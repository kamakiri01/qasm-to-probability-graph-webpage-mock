/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./lib/app.js":
/*!********************!*\
  !*** ./lib/app.js ***!
  \********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\n\nfunction _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = \"function\" == typeof Symbol ? Symbol : {}, n = r.iterator || \"@@iterator\", o = r.toStringTag || \"@@toStringTag\"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, \"_invoke\", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError(\"Generator is already running\"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = \"next\"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError(\"iterator result is not an object\"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i[\"return\"]) && t.call(i), c < 2 && (u = TypeError(\"The iterator does not provide a '\" + o + \"' method\"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, \"GeneratorFunction\")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, \"constructor\", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = \"GeneratorFunction\", _regeneratorDefine2(GeneratorFunctionPrototype, o, \"GeneratorFunction\"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, \"Generator\"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, \"toString\", function () { return \"[object Generator]\"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }\nfunction _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, \"\", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o(\"next\", 0), o(\"throw\", 1), o(\"return\", 2)); }, _regeneratorDefine2(e, r, n, t); }\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar qasm = __webpack_require__(/*! qasm-ts */ \"./node_modules/qasm-ts/dist/main.js\");\nvar chart_js_1 = __webpack_require__(/*! chart.js */ \"./node_modules/chart.js/dist/chart.cjs\");\nvar qulacsExec_1 = __webpack_require__(/*! ./qulacsExec */ \"./lib/qulacsExec.js\");\n// Chart.jsの必要なコンポーネントを登録\nchart_js_1.Chart.register(chart_js_1.CategoryScale, chart_js_1.LinearScale, chart_js_1.BarElement, chart_js_1.BarController, chart_js_1.Title, chart_js_1.Tooltip, chart_js_1.Legend);\n// ファイルの内容を保存する変数\nvar currentFile = null;\nvar currentFileContent = '';\nvar quantumChart = null;\n// DOM要素の取得\nvar dropZone = document.getElementById('dropZone');\nvar fileInput = document.getElementById('fileInput');\nvar fileInfo = document.getElementById('fileInfo');\nvar fileName = document.getElementById('fileName');\nvar fileContent = document.getElementById('fileContent');\nvar executeBtn = document.getElementById('executeBtn');\nvar resultArea = document.getElementById('resultArea');\nvar errorArea = document.getElementById('errorArea');\nvar graphContainer = document.getElementById('graphContainer');\nvar resultChart = document.getElementById('resultChart');\n// ドラッグ＆ドロップイベントのセットアップ\ndropZone.addEventListener('dragover', handleDragOver);\ndropZone.addEventListener('drop', handleDrop);\ndropZone.addEventListener('dragenter', handleDragEnter);\ndropZone.addEventListener('dragleave', handleDragLeave);\n// ファイル選択イベント\nfileInput.addEventListener('change', handleFileSelect);\nexecuteBtn.addEventListener(\"click\", executeQuantumCircuit);\nfunction handleDragOver(e) {\n  e.preventDefault();\n}\nfunction handleDragEnter(e) {\n  e.preventDefault();\n  dropZone.classList.add('dragover');\n}\nfunction handleDragLeave(e) {\n  e.preventDefault();\n  dropZone.classList.remove('dragover');\n}\nfunction handleDrop(e) {\n  e.preventDefault();\n  dropZone.classList.remove('dragover');\n  var files = e.dataTransfer.files;\n  if (files.length > 0) {\n    handleFile(files[0]);\n  }\n}\nfunction handleFileSelect(e) {\n  var files = e.target.files;\n  if (files.length > 0) {\n    handleFile(files[0]);\n  }\n}\nfunction handleFile(file) {\n  // ファイルの拡張子チェック\n  if (!file.name.toLowerCase().endsWith('.qasm')) {\n    showError('QASMファイル (.qasm) を選択してください。');\n    return;\n  }\n  currentFile = file;\n  // ファイル読み込み\n  var reader = new FileReader();\n  reader.onload = function (e) {\n    currentFileContent = e.target.result;\n    showFileInfo();\n    hideError();\n  };\n  reader.onerror = function () {\n    showError('ファイルの読み込み中にエラーが発生しました。');\n  };\n  reader.readAsText(file);\n}\nfunction showFileInfo() {\n  fileName.textContent = \"\".concat(currentFile.name, \" (\").concat(currentFile.size, \" bytes)\");\n  // ファイル内容を表示\n  if (fileContent) {\n    fileContent.textContent = currentFileContent;\n  }\n  fileInfo.style.display = 'block';\n  executeBtn.disabled = false;\n}\nfunction showError(message) {\n  errorArea.innerHTML = \"<div class=\\\"error\\\">\".concat(message, \"</div>\");\n  errorArea.style.display = 'block';\n}\nfunction hideError() {\n  errorArea.style.display = 'none';\n}\nfunction executeQuantumCircuit() {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator().m(function _callee() {\n    var qasmParseCircuit, result;\n    return _regenerator().w(function (_context) {\n      while (1) switch (_context.n) {\n        case 0:\n          try {\n            hideError();\n            executeBtn.disabled = true;\n            executeBtn.textContent = '実行中...';\n            // QASMファイルのパース（qasm-ts使用）\n            qasmParseCircuit = qasm.parseString(currentFileContent, 3);\n            console.log(\"qasmParseCircuit\", qasmParseCircuit);\n            result = (0, qulacsExec_1.qulacsExec)(qasmParseCircuit);\n            displayResults(result);\n          } catch (error) {\n            showError(\"\\u5B9F\\u884C\\u4E2D\\u306B\\u30A8\\u30E9\\u30FC\\u304C\\u767A\\u751F\\u3057\\u307E\\u3057\\u305F: \".concat(error.message));\n          } finally {\n            executeBtn.disabled = false;\n            executeBtn.textContent = '量子回路を実行';\n          }\n        case 1:\n          return _context.a(2);\n      }\n    }, _callee);\n  }));\n}\n// 結果をグラフで表示する関数\nfunction displayResults(results) {\n  // 状態ベクトルの正規化\n  var mags = results.map(function (r) {\n    return Object.assign(Object.assign({}, r), {\n      magnitude: Math.sqrt(r.real * r.real + r.imag * r.imag)\n    });\n  });\n  var totalMagnitude = Math.sqrt(mags.reduce(function (sum, state) {\n    return sum + state.magnitude * state.magnitude;\n  }, 0));\n  mags.forEach(function (state) {\n    state.real /= totalMagnitude;\n    state.imag /= totalMagnitude;\n    state.magnitude /= totalMagnitude;\n    state.probability = state.magnitude * state.magnitude;\n  });\n  resultArea.style.display = 'block';\n  // Chart.jsを使用した確率分布のグラフ\n  var ctx = resultChart.getContext('2d');\n  // 既存のチャートがあれば破棄\n  if (quantumChart) {\n    quantumChart.destroy();\n    quantumChart = null;\n  }\n  var labels = mags.map(function (_, index) {\n    return \"|\".concat(index.toString(2).padStart(Math.log2(mags.length), '0'), \"\\u27E9\");\n  });\n  var probabilities = mags.map(function (state) {\n    return state.probability;\n  });\n  quantumChart = new chart_js_1.Chart(ctx, {\n    type: 'bar',\n    data: {\n      labels: labels,\n      datasets: [{\n        label: '確率',\n        data: probabilities,\n        backgroundColor: 'rgba(54, 162, 235, 0.8)',\n        borderColor: 'rgba(54, 162, 235, 1)',\n        borderWidth: 1\n      }]\n    },\n    options: {\n      responsive: true,\n      maintainAspectRatio: false,\n      scales: {\n        y: {\n          beginAtZero: true,\n          max: 1,\n          title: {\n            display: true,\n            text: '確率'\n          }\n        },\n        x: {\n          title: {\n            display: true,\n            text: '量子状態'\n          }\n        }\n      },\n      plugins: {\n        title: {\n          display: true,\n          text: '量子状態の確率分布'\n        },\n        legend: {\n          display: true\n        }\n      }\n    }\n  });\n}\n// 初期化\ndocument.addEventListener('DOMContentLoaded', function () {\n  console.log('QASM量子回路シミュレーターが初期化されました');\n});\n\n//# sourceURL=webpack://qasm-quantum-simulator/./lib/app.js?\n}");

/***/ }),

/***/ "./lib/qulacsExec.js":
/*!***************************!*\
  !*** ./lib/qulacsExec.js ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\n\nfunction _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = \"function\" == typeof Symbol ? Symbol : {}, n = r.iterator || \"@@iterator\", o = r.toStringTag || \"@@toStringTag\"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, \"_invoke\", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError(\"Generator is already running\"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = \"next\"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError(\"iterator result is not an object\"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i[\"return\"]) && t.call(i), c < 2 && (u = TypeError(\"The iterator does not provide a '\" + o + \"' method\"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, \"GeneratorFunction\")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, \"constructor\", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = \"GeneratorFunction\", _regeneratorDefine2(GeneratorFunctionPrototype, o, \"GeneratorFunction\"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, \"Generator\"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, \"toString\", function () { return \"[object Generator]\"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }\nfunction _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, \"\", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o(\"next\", 0), o(\"throw\", 1), o(\"return\", 2)); }, _regeneratorDefine2(e, r, n, t); }\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.qulacsExec = qulacsExec;\nvar qulacs_wasm_1 = __webpack_require__(/*! qulacs-wasm */ \"./node_modules/qulacs-wasm/lib/bundle/index.js\");\nvar ast_1 = __webpack_require__(/*! qasm-ts/dist/qasm3/ast */ \"./node_modules/qasm-ts/dist/qasm3/ast.js\");\nvar q;\n(0, qulacs_wasm_1.initQulacs)().then(function () {\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regenerator().m(function _callee() {\n    return _regenerator().w(function (_context) {\n      while (1) switch (_context.n) {\n        case 0:\n          _context.n = 1;\n          return Promise.resolve().then(function () {\n            return __webpack_require__(/*! qulacs-wasm */ \"./node_modules/qulacs-wasm/lib/bundle/index.js\");\n          });\n        case 1:\n          q = _context.v;\n        case 2:\n          return _context.a(2);\n      }\n    }, _callee);\n  }));\n});\n// X/Y/Z/H/CNOTのみ対応している\nfunction qulacsExec(parsedCircuit) {\n  var count;\n  var gates = [];\n  parsedCircuit.forEach(function (e) {\n    if (e instanceof ast_1.QuantumDeclaration) {\n      var size = e.size;\n      count = Number(size.value);\n    } else if (e instanceof ast_1.QuantumGateCall) {\n      gates.push(e);\n    }\n  });\n  var state = new q.QuantumState(count);\n  state.set_zero_state();\n  var circuit = new q.QuantumCircuit(count);\n  gates.forEach(function (g) {\n    var value0 = g.qubits[0].subscript.value;\n    value0 = Number(value0);\n    switch (g.quantumGateName.name) {\n      case \"x\":\n        circuit.add_X_gate(value0);\n        break;\n      case \"y\":\n        circuit.add_Y_gate(value0);\n        break;\n      case \"z\":\n        circuit.add_Z_gate(value0);\n        break;\n      case \"h\":\n        circuit.add_H_gate(value0);\n        break;\n      case \"cx\":\n        var value1 = g.qubits[1].subscript.value;\n        circuit.add_CNOT_gate(value0, Number(value1));\n        break;\n      default:\n      // do nothing\n    }\n  });\n  circuit.update_quantum_state(state);\n  return state.get_vector();\n}\n\n//# sourceURL=webpack://qasm-quantum-simulator/./lib/qulacsExec.js?\n}");

/***/ }),

/***/ "./node_modules/@kurkle/color/dist/color.cjs":
/*!***************************************************!*\
  !*** ./node_modules/@kurkle/color/dist/color.cjs ***!
  \***************************************************/
/***/ (function(module) {

eval("{/*!\n * @kurkle/color v0.3.4\n * https://github.com/kurkle/color#readme\n * (c) 2024 Jukka Kurkela\n * Released under the MIT License\n */\n(function (global, factory) {\n true ? module.exports = factory() :\n0;\n})(this, (function () { 'use strict';\n\nfunction round(v) {\n  return v + 0.5 | 0;\n}\nconst lim = (v, l, h) => Math.max(Math.min(v, h), l);\nfunction p2b(v) {\n  return lim(round(v * 2.55), 0, 255);\n}\nfunction b2p(v) {\n  return lim(round(v / 2.55), 0, 100);\n}\nfunction n2b(v) {\n  return lim(round(v * 255), 0, 255);\n}\nfunction b2n(v) {\n  return lim(round(v / 2.55) / 100, 0, 1);\n}\nfunction n2p(v) {\n  return lim(round(v * 100), 0, 100);\n}\n\nconst map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};\nconst hex = [...'0123456789ABCDEF'];\nconst h1 = b => hex[b & 0xF];\nconst h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\nconst eq = b => ((b & 0xF0) >> 4) === (b & 0xF);\nconst isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\nfunction hexParse(str) {\n  var len = str.length;\n  var ret;\n  if (str[0] === '#') {\n    if (len === 4 || len === 5) {\n      ret = {\n        r: 255 & map$1[str[1]] * 17,\n        g: 255 & map$1[str[2]] * 17,\n        b: 255 & map$1[str[3]] * 17,\n        a: len === 5 ? map$1[str[4]] * 17 : 255\n      };\n    } else if (len === 7 || len === 9) {\n      ret = {\n        r: map$1[str[1]] << 4 | map$1[str[2]],\n        g: map$1[str[3]] << 4 | map$1[str[4]],\n        b: map$1[str[5]] << 4 | map$1[str[6]],\n        a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255\n      };\n    }\n  }\n  return ret;\n}\nconst alpha = (a, f) => a < 255 ? f(a) : '';\nfunction hexString(v) {\n  var f = isShort(v) ? h1 : h2;\n  return v\n    ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)\n    : undefined;\n}\n\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction hsl2rgbn(h, s, l) {\n  const a = s * Math.min(l, 1 - l);\n  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n  return [f(0), f(8), f(4)];\n}\nfunction hsv2rgbn(h, s, v) {\n  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n  return [f(5), f(3), f(1)];\n}\nfunction hwb2rgbn(h, w, b) {\n  const rgb = hsl2rgbn(h, 1, 0.5);\n  let i;\n  if (w + b > 1) {\n    i = 1 / (w + b);\n    w *= i;\n    b *= i;\n  }\n  for (i = 0; i < 3; i++) {\n    rgb[i] *= 1 - w - b;\n    rgb[i] += w;\n  }\n  return rgb;\n}\nfunction hueValue(r, g, b, d, max) {\n  if (r === max) {\n    return ((g - b) / d) + (g < b ? 6 : 0);\n  }\n  if (g === max) {\n    return (b - r) / d + 2;\n  }\n  return (r - g) / d + 4;\n}\nfunction rgb2hsl(v) {\n  const range = 255;\n  const r = v.r / range;\n  const g = v.g / range;\n  const b = v.b / range;\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const l = (max + min) / 2;\n  let h, s, d;\n  if (max !== min) {\n    d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    h = hueValue(r, g, b, d, max);\n    h = h * 60 + 0.5;\n  }\n  return [h | 0, s || 0, l];\n}\nfunction calln(f, a, b, c) {\n  return (\n    Array.isArray(a)\n      ? f(a[0], a[1], a[2])\n      : f(a, b, c)\n  ).map(n2b);\n}\nfunction hsl2rgb(h, s, l) {\n  return calln(hsl2rgbn, h, s, l);\n}\nfunction hwb2rgb(h, w, b) {\n  return calln(hwb2rgbn, h, w, b);\n}\nfunction hsv2rgb(h, s, v) {\n  return calln(hsv2rgbn, h, s, v);\n}\nfunction hue(h) {\n  return (h % 360 + 360) % 360;\n}\nfunction hueParse(str) {\n  const m = HUE_RE.exec(str);\n  let a = 255;\n  let v;\n  if (!m) {\n    return;\n  }\n  if (m[5] !== v) {\n    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n  }\n  const h = hue(+m[2]);\n  const p1 = +m[3] / 100;\n  const p2 = +m[4] / 100;\n  if (m[1] === 'hwb') {\n    v = hwb2rgb(h, p1, p2);\n  } else if (m[1] === 'hsv') {\n    v = hsv2rgb(h, p1, p2);\n  } else {\n    v = hsl2rgb(h, p1, p2);\n  }\n  return {\n    r: v[0],\n    g: v[1],\n    b: v[2],\n    a: a\n  };\n}\nfunction rotate(v, deg) {\n  var h = rgb2hsl(v);\n  h[0] = hue(h[0] + deg);\n  h = hsl2rgb(h);\n  v.r = h[0];\n  v.g = h[1];\n  v.b = h[2];\n}\nfunction hslString(v) {\n  if (!v) {\n    return;\n  }\n  const a = rgb2hsl(v);\n  const h = a[0];\n  const s = n2p(a[1]);\n  const l = n2p(a[2]);\n  return v.a < 255\n    ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`\n    : `hsl(${h}, ${s}%, ${l}%)`;\n}\n\nconst map = {\n\tx: 'dark',\n\tZ: 'light',\n\tY: 're',\n\tX: 'blu',\n\tW: 'gr',\n\tV: 'medium',\n\tU: 'slate',\n\tA: 'ee',\n\tT: 'ol',\n\tS: 'or',\n\tB: 'ra',\n\tC: 'lateg',\n\tD: 'ights',\n\tR: 'in',\n\tQ: 'turquois',\n\tE: 'hi',\n\tP: 'ro',\n\tO: 'al',\n\tN: 'le',\n\tM: 'de',\n\tL: 'yello',\n\tF: 'en',\n\tK: 'ch',\n\tG: 'arks',\n\tH: 'ea',\n\tI: 'ightg',\n\tJ: 'wh'\n};\nconst names$1 = {\n\tOiceXe: 'f0f8ff',\n\tantiquewEte: 'faebd7',\n\taqua: 'ffff',\n\taquamarRe: '7fffd4',\n\tazuY: 'f0ffff',\n\tbeige: 'f5f5dc',\n\tbisque: 'ffe4c4',\n\tblack: '0',\n\tblanKedOmond: 'ffebcd',\n\tXe: 'ff',\n\tXeviTet: '8a2be2',\n\tbPwn: 'a52a2a',\n\tburlywood: 'deb887',\n\tcaMtXe: '5f9ea0',\n\tKartYuse: '7fff00',\n\tKocTate: 'd2691e',\n\tcSO: 'ff7f50',\n\tcSnflowerXe: '6495ed',\n\tcSnsilk: 'fff8dc',\n\tcrimson: 'dc143c',\n\tcyan: 'ffff',\n\txXe: '8b',\n\txcyan: '8b8b',\n\txgTMnPd: 'b8860b',\n\txWay: 'a9a9a9',\n\txgYF: '6400',\n\txgYy: 'a9a9a9',\n\txkhaki: 'bdb76b',\n\txmagFta: '8b008b',\n\txTivegYF: '556b2f',\n\txSange: 'ff8c00',\n\txScEd: '9932cc',\n\txYd: '8b0000',\n\txsOmon: 'e9967a',\n\txsHgYF: '8fbc8f',\n\txUXe: '483d8b',\n\txUWay: '2f4f4f',\n\txUgYy: '2f4f4f',\n\txQe: 'ced1',\n\txviTet: '9400d3',\n\tdAppRk: 'ff1493',\n\tdApskyXe: 'bfff',\n\tdimWay: '696969',\n\tdimgYy: '696969',\n\tdodgerXe: '1e90ff',\n\tfiYbrick: 'b22222',\n\tflSOwEte: 'fffaf0',\n\tfoYstWAn: '228b22',\n\tfuKsia: 'ff00ff',\n\tgaRsbSo: 'dcdcdc',\n\tghostwEte: 'f8f8ff',\n\tgTd: 'ffd700',\n\tgTMnPd: 'daa520',\n\tWay: '808080',\n\tgYF: '8000',\n\tgYFLw: 'adff2f',\n\tgYy: '808080',\n\thoneyMw: 'f0fff0',\n\thotpRk: 'ff69b4',\n\tRdianYd: 'cd5c5c',\n\tRdigo: '4b0082',\n\tivSy: 'fffff0',\n\tkhaki: 'f0e68c',\n\tlavFMr: 'e6e6fa',\n\tlavFMrXsh: 'fff0f5',\n\tlawngYF: '7cfc00',\n\tNmoncEffon: 'fffacd',\n\tZXe: 'add8e6',\n\tZcSO: 'f08080',\n\tZcyan: 'e0ffff',\n\tZgTMnPdLw: 'fafad2',\n\tZWay: 'd3d3d3',\n\tZgYF: '90ee90',\n\tZgYy: 'd3d3d3',\n\tZpRk: 'ffb6c1',\n\tZsOmon: 'ffa07a',\n\tZsHgYF: '20b2aa',\n\tZskyXe: '87cefa',\n\tZUWay: '778899',\n\tZUgYy: '778899',\n\tZstAlXe: 'b0c4de',\n\tZLw: 'ffffe0',\n\tlime: 'ff00',\n\tlimegYF: '32cd32',\n\tlRF: 'faf0e6',\n\tmagFta: 'ff00ff',\n\tmaPon: '800000',\n\tVaquamarRe: '66cdaa',\n\tVXe: 'cd',\n\tVScEd: 'ba55d3',\n\tVpurpN: '9370db',\n\tVsHgYF: '3cb371',\n\tVUXe: '7b68ee',\n\tVsprRggYF: 'fa9a',\n\tVQe: '48d1cc',\n\tVviTetYd: 'c71585',\n\tmidnightXe: '191970',\n\tmRtcYam: 'f5fffa',\n\tmistyPse: 'ffe4e1',\n\tmoccasR: 'ffe4b5',\n\tnavajowEte: 'ffdead',\n\tnavy: '80',\n\tTdlace: 'fdf5e6',\n\tTive: '808000',\n\tTivedBb: '6b8e23',\n\tSange: 'ffa500',\n\tSangeYd: 'ff4500',\n\tScEd: 'da70d6',\n\tpOegTMnPd: 'eee8aa',\n\tpOegYF: '98fb98',\n\tpOeQe: 'afeeee',\n\tpOeviTetYd: 'db7093',\n\tpapayawEp: 'ffefd5',\n\tpHKpuff: 'ffdab9',\n\tperu: 'cd853f',\n\tpRk: 'ffc0cb',\n\tplum: 'dda0dd',\n\tpowMrXe: 'b0e0e6',\n\tpurpN: '800080',\n\tYbeccapurpN: '663399',\n\tYd: 'ff0000',\n\tPsybrown: 'bc8f8f',\n\tPyOXe: '4169e1',\n\tsaddNbPwn: '8b4513',\n\tsOmon: 'fa8072',\n\tsandybPwn: 'f4a460',\n\tsHgYF: '2e8b57',\n\tsHshell: 'fff5ee',\n\tsiFna: 'a0522d',\n\tsilver: 'c0c0c0',\n\tskyXe: '87ceeb',\n\tUXe: '6a5acd',\n\tUWay: '708090',\n\tUgYy: '708090',\n\tsnow: 'fffafa',\n\tsprRggYF: 'ff7f',\n\tstAlXe: '4682b4',\n\ttan: 'd2b48c',\n\tteO: '8080',\n\ttEstN: 'd8bfd8',\n\ttomato: 'ff6347',\n\tQe: '40e0d0',\n\tviTet: 'ee82ee',\n\tJHt: 'f5deb3',\n\twEte: 'ffffff',\n\twEtesmoke: 'f5f5f5',\n\tLw: 'ffff00',\n\tLwgYF: '9acd32'\n};\nfunction unpack() {\n  const unpacked = {};\n  const keys = Object.keys(names$1);\n  const tkeys = Object.keys(map);\n  let i, j, k, ok, nk;\n  for (i = 0; i < keys.length; i++) {\n    ok = nk = keys[i];\n    for (j = 0; j < tkeys.length; j++) {\n      k = tkeys[j];\n      nk = nk.replace(k, map[k]);\n    }\n    k = parseInt(names$1[ok], 16);\n    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\n  }\n  return unpacked;\n}\n\nlet names;\nfunction nameParse(str) {\n  if (!names) {\n    names = unpack();\n    names.transparent = [0, 0, 0, 0];\n  }\n  const a = names[str.toLowerCase()];\n  return a && {\n    r: a[0],\n    g: a[1],\n    b: a[2],\n    a: a.length === 4 ? a[3] : 255\n  };\n}\n\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction rgbParse(str) {\n  const m = RGB_RE.exec(str);\n  let a = 255;\n  let r, g, b;\n  if (!m) {\n    return;\n  }\n  if (m[7] !== r) {\n    const v = +m[7];\n    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);\n  }\n  r = +m[1];\n  g = +m[3];\n  b = +m[5];\n  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));\n  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));\n  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n}\nfunction rgbString(v) {\n  return v && (\n    v.a < 255\n      ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`\n      : `rgb(${v.r}, ${v.g}, ${v.b})`\n  );\n}\n\nconst to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;\nconst from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\nfunction interpolate(rgb1, rgb2, t) {\n  const r = from(b2n(rgb1.r));\n  const g = from(b2n(rgb1.g));\n  const b = from(b2n(rgb1.b));\n  return {\n    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),\n    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),\n    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),\n    a: rgb1.a + t * (rgb2.a - rgb1.a)\n  };\n}\n\nfunction modHSL(v, i, ratio) {\n  if (v) {\n    let tmp = rgb2hsl(v);\n    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n    tmp = hsl2rgb(tmp);\n    v.r = tmp[0];\n    v.g = tmp[1];\n    v.b = tmp[2];\n  }\n}\nfunction clone(v, proto) {\n  return v ? Object.assign(proto || {}, v) : v;\n}\nfunction fromObject(input) {\n  var v = {r: 0, g: 0, b: 0, a: 255};\n  if (Array.isArray(input)) {\n    if (input.length >= 3) {\n      v = {r: input[0], g: input[1], b: input[2], a: 255};\n      if (input.length > 3) {\n        v.a = n2b(input[3]);\n      }\n    }\n  } else {\n    v = clone(input, {r: 0, g: 0, b: 0, a: 1});\n    v.a = n2b(v.a);\n  }\n  return v;\n}\nfunction functionParse(str) {\n  if (str.charAt(0) === 'r') {\n    return rgbParse(str);\n  }\n  return hueParse(str);\n}\nclass Color {\n  constructor(input) {\n    if (input instanceof Color) {\n      return input;\n    }\n    const type = typeof input;\n    let v;\n    if (type === 'object') {\n      v = fromObject(input);\n    } else if (type === 'string') {\n      v = hexParse(input) || nameParse(input) || functionParse(input);\n    }\n    this._rgb = v;\n    this._valid = !!v;\n  }\n  get valid() {\n    return this._valid;\n  }\n  get rgb() {\n    var v = clone(this._rgb);\n    if (v) {\n      v.a = b2n(v.a);\n    }\n    return v;\n  }\n  set rgb(obj) {\n    this._rgb = fromObject(obj);\n  }\n  rgbString() {\n    return this._valid ? rgbString(this._rgb) : undefined;\n  }\n  hexString() {\n    return this._valid ? hexString(this._rgb) : undefined;\n  }\n  hslString() {\n    return this._valid ? hslString(this._rgb) : undefined;\n  }\n  mix(color, weight) {\n    if (color) {\n      const c1 = this.rgb;\n      const c2 = color.rgb;\n      let w2;\n      const p = weight === w2 ? 0.5 : weight;\n      const w = 2 * p - 1;\n      const a = c1.a - c2.a;\n      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n      w2 = 1 - w1;\n      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\n      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\n      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\n      c1.a = p * c1.a + (1 - p) * c2.a;\n      this.rgb = c1;\n    }\n    return this;\n  }\n  interpolate(color, t) {\n    if (color) {\n      this._rgb = interpolate(this._rgb, color._rgb, t);\n    }\n    return this;\n  }\n  clone() {\n    return new Color(this.rgb);\n  }\n  alpha(a) {\n    this._rgb.a = n2b(a);\n    return this;\n  }\n  clearer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 - ratio;\n    return this;\n  }\n  greyscale() {\n    const rgb = this._rgb;\n    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n    rgb.r = rgb.g = rgb.b = val;\n    return this;\n  }\n  opaquer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 + ratio;\n    return this;\n  }\n  negate() {\n    const v = this._rgb;\n    v.r = 255 - v.r;\n    v.g = 255 - v.g;\n    v.b = 255 - v.b;\n    return this;\n  }\n  lighten(ratio) {\n    modHSL(this._rgb, 2, ratio);\n    return this;\n  }\n  darken(ratio) {\n    modHSL(this._rgb, 2, -ratio);\n    return this;\n  }\n  saturate(ratio) {\n    modHSL(this._rgb, 1, ratio);\n    return this;\n  }\n  desaturate(ratio) {\n    modHSL(this._rgb, 1, -ratio);\n    return this;\n  }\n  rotate(deg) {\n    rotate(this._rgb, deg);\n    return this;\n  }\n}\n\nfunction index_esm(input) {\n  return new Color(input);\n}\n\nvar color = /*#__PURE__*/Object.freeze({\n__proto__: null,\nColor: Color,\nb2n: b2n,\nb2p: b2p,\ndefault: index_esm,\nhexParse: hexParse,\nhexString: hexString,\nhsl2rgb: hsl2rgb,\nhslString: hslString,\nhsv2rgb: hsv2rgb,\nhueParse: hueParse,\nhwb2rgb: hwb2rgb,\nlim: lim,\nn2b: n2b,\nn2p: n2p,\nnameParse: nameParse,\np2b: p2b,\nrgb2hsl: rgb2hsl,\nrgbParse: rgbParse,\nrgbString: rgbString,\nrotate: rotate,\nround: round\n});\n\nvar index = Object.assign(index_esm, color);\n\nreturn index;\n\n}));\n\n\n//# sourceURL=webpack://qasm-quantum-simulator/./node_modules/@kurkle/color/dist/color.cjs?\n}");

/***/ }),

/***/ "./node_modules/chart.js/dist/chart.cjs":
/*!**********************************************!*\
  !*** ./node_modules/chart.js/dist/chart.cjs ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{/*!\n * Chart.js v4.5.0\n * https://www.chartjs.org\n * (c) 2025 Chart.js Contributors\n * Released under the MIT License\n */\n\n\nvar helpers_dataset = __webpack_require__(/*! ./chunks/helpers.dataset.cjs */ \"./node_modules/chart.js/dist/chunks/helpers.dataset.cjs\");\n__webpack_require__(/*! @kurkle/color */ \"./node_modules/@kurkle/color/dist/color.cjs\");\n\nclass Animator {\n    constructor(){\n        this._request = null;\n        this._charts = new Map();\n        this._running = false;\n        this._lastDate = undefined;\n    }\n _notify(chart, anims, date, type) {\n        const callbacks = anims.listeners[type];\n        const numSteps = anims.duration;\n        callbacks.forEach((fn)=>fn({\n                chart,\n                initial: anims.initial,\n                numSteps,\n                currentStep: Math.min(date - anims.start, numSteps)\n            }));\n    }\n _refresh() {\n        if (this._request) {\n            return;\n        }\n        this._running = true;\n        this._request = helpers_dataset.requestAnimFrame.call(window, ()=>{\n            this._update();\n            this._request = null;\n            if (this._running) {\n                this._refresh();\n            }\n        });\n    }\n _update(date = Date.now()) {\n        let remaining = 0;\n        this._charts.forEach((anims, chart)=>{\n            if (!anims.running || !anims.items.length) {\n                return;\n            }\n            const items = anims.items;\n            let i = items.length - 1;\n            let draw = false;\n            let item;\n            for(; i >= 0; --i){\n                item = items[i];\n                if (item._active) {\n                    if (item._total > anims.duration) {\n                        anims.duration = item._total;\n                    }\n                    item.tick(date);\n                    draw = true;\n                } else {\n                    items[i] = items[items.length - 1];\n                    items.pop();\n                }\n            }\n            if (draw) {\n                chart.draw();\n                this._notify(chart, anims, date, 'progress');\n            }\n            if (!items.length) {\n                anims.running = false;\n                this._notify(chart, anims, date, 'complete');\n                anims.initial = false;\n            }\n            remaining += items.length;\n        });\n        this._lastDate = date;\n        if (remaining === 0) {\n            this._running = false;\n        }\n    }\n _getAnims(chart) {\n        const charts = this._charts;\n        let anims = charts.get(chart);\n        if (!anims) {\n            anims = {\n                running: false,\n                initial: true,\n                items: [],\n                listeners: {\n                    complete: [],\n                    progress: []\n                }\n            };\n            charts.set(chart, anims);\n        }\n        return anims;\n    }\n listen(chart, event, cb) {\n        this._getAnims(chart).listeners[event].push(cb);\n    }\n add(chart, items) {\n        if (!items || !items.length) {\n            return;\n        }\n        this._getAnims(chart).items.push(...items);\n    }\n has(chart) {\n        return this._getAnims(chart).items.length > 0;\n    }\n start(chart) {\n        const anims = this._charts.get(chart);\n        if (!anims) {\n            return;\n        }\n        anims.running = true;\n        anims.start = Date.now();\n        anims.duration = anims.items.reduce((acc, cur)=>Math.max(acc, cur._duration), 0);\n        this._refresh();\n    }\n    running(chart) {\n        if (!this._running) {\n            return false;\n        }\n        const anims = this._charts.get(chart);\n        if (!anims || !anims.running || !anims.items.length) {\n            return false;\n        }\n        return true;\n    }\n stop(chart) {\n        const anims = this._charts.get(chart);\n        if (!anims || !anims.items.length) {\n            return;\n        }\n        const items = anims.items;\n        let i = items.length - 1;\n        for(; i >= 0; --i){\n            items[i].cancel();\n        }\n        anims.items = [];\n        this._notify(chart, anims, Date.now(), 'complete');\n    }\n remove(chart) {\n        return this._charts.delete(chart);\n    }\n}\nvar animator = /* #__PURE__ */ new Animator();\n\nconst transparent = 'transparent';\nconst interpolators = {\n    boolean (from, to, factor) {\n        return factor > 0.5 ? to : from;\n    },\n color (from, to, factor) {\n        const c0 = helpers_dataset.color(from || transparent);\n        const c1 = c0.valid && helpers_dataset.color(to || transparent);\n        return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;\n    },\n    number (from, to, factor) {\n        return from + (to - from) * factor;\n    }\n};\nclass Animation {\n    constructor(cfg, target, prop, to){\n        const currentValue = target[prop];\n        to = helpers_dataset.resolve([\n            cfg.to,\n            to,\n            currentValue,\n            cfg.from\n        ]);\n        const from = helpers_dataset.resolve([\n            cfg.from,\n            currentValue,\n            to\n        ]);\n        this._active = true;\n        this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n        this._easing = helpers_dataset.effects[cfg.easing] || helpers_dataset.effects.linear;\n        this._start = Math.floor(Date.now() + (cfg.delay || 0));\n        this._duration = this._total = Math.floor(cfg.duration);\n        this._loop = !!cfg.loop;\n        this._target = target;\n        this._prop = prop;\n        this._from = from;\n        this._to = to;\n        this._promises = undefined;\n    }\n    active() {\n        return this._active;\n    }\n    update(cfg, to, date) {\n        if (this._active) {\n            this._notify(false);\n            const currentValue = this._target[this._prop];\n            const elapsed = date - this._start;\n            const remain = this._duration - elapsed;\n            this._start = date;\n            this._duration = Math.floor(Math.max(remain, cfg.duration));\n            this._total += elapsed;\n            this._loop = !!cfg.loop;\n            this._to = helpers_dataset.resolve([\n                cfg.to,\n                to,\n                currentValue,\n                cfg.from\n            ]);\n            this._from = helpers_dataset.resolve([\n                cfg.from,\n                currentValue,\n                to\n            ]);\n        }\n    }\n    cancel() {\n        if (this._active) {\n            this.tick(Date.now());\n            this._active = false;\n            this._notify(false);\n        }\n    }\n    tick(date) {\n        const elapsed = date - this._start;\n        const duration = this._duration;\n        const prop = this._prop;\n        const from = this._from;\n        const loop = this._loop;\n        const to = this._to;\n        let factor;\n        this._active = from !== to && (loop || elapsed < duration);\n        if (!this._active) {\n            this._target[prop] = to;\n            this._notify(true);\n            return;\n        }\n        if (elapsed < 0) {\n            this._target[prop] = from;\n            return;\n        }\n        factor = elapsed / duration % 2;\n        factor = loop && factor > 1 ? 2 - factor : factor;\n        factor = this._easing(Math.min(1, Math.max(0, factor)));\n        this._target[prop] = this._fn(from, to, factor);\n    }\n    wait() {\n        const promises = this._promises || (this._promises = []);\n        return new Promise((res, rej)=>{\n            promises.push({\n                res,\n                rej\n            });\n        });\n    }\n    _notify(resolved) {\n        const method = resolved ? 'res' : 'rej';\n        const promises = this._promises || [];\n        for(let i = 0; i < promises.length; i++){\n            promises[i][method]();\n        }\n    }\n}\n\nclass Animations {\n    constructor(chart, config){\n        this._chart = chart;\n        this._properties = new Map();\n        this.configure(config);\n    }\n    configure(config) {\n        if (!helpers_dataset.isObject(config)) {\n            return;\n        }\n        const animationOptions = Object.keys(helpers_dataset.defaults.animation);\n        const animatedProps = this._properties;\n        Object.getOwnPropertyNames(config).forEach((key)=>{\n            const cfg = config[key];\n            if (!helpers_dataset.isObject(cfg)) {\n                return;\n            }\n            const resolved = {};\n            for (const option of animationOptions){\n                resolved[option] = cfg[option];\n            }\n            (helpers_dataset.isArray(cfg.properties) && cfg.properties || [\n                key\n            ]).forEach((prop)=>{\n                if (prop === key || !animatedProps.has(prop)) {\n                    animatedProps.set(prop, resolved);\n                }\n            });\n        });\n    }\n _animateOptions(target, values) {\n        const newOptions = values.options;\n        const options = resolveTargetOptions(target, newOptions);\n        if (!options) {\n            return [];\n        }\n        const animations = this._createAnimations(options, newOptions);\n        if (newOptions.$shared) {\n            awaitAll(target.options.$animations, newOptions).then(()=>{\n                target.options = newOptions;\n            }, ()=>{\n            });\n        }\n        return animations;\n    }\n _createAnimations(target, values) {\n        const animatedProps = this._properties;\n        const animations = [];\n        const running = target.$animations || (target.$animations = {});\n        const props = Object.keys(values);\n        const date = Date.now();\n        let i;\n        for(i = props.length - 1; i >= 0; --i){\n            const prop = props[i];\n            if (prop.charAt(0) === '$') {\n                continue;\n            }\n            if (prop === 'options') {\n                animations.push(...this._animateOptions(target, values));\n                continue;\n            }\n            const value = values[prop];\n            let animation = running[prop];\n            const cfg = animatedProps.get(prop);\n            if (animation) {\n                if (cfg && animation.active()) {\n                    animation.update(cfg, value, date);\n                    continue;\n                } else {\n                    animation.cancel();\n                }\n            }\n            if (!cfg || !cfg.duration) {\n                target[prop] = value;\n                continue;\n            }\n            running[prop] = animation = new Animation(cfg, target, prop, value);\n            animations.push(animation);\n        }\n        return animations;\n    }\n update(target, values) {\n        if (this._properties.size === 0) {\n            Object.assign(target, values);\n            return;\n        }\n        const animations = this._createAnimations(target, values);\n        if (animations.length) {\n            animator.add(this._chart, animations);\n            return true;\n        }\n    }\n}\nfunction awaitAll(animations, properties) {\n    const running = [];\n    const keys = Object.keys(properties);\n    for(let i = 0; i < keys.length; i++){\n        const anim = animations[keys[i]];\n        if (anim && anim.active()) {\n            running.push(anim.wait());\n        }\n    }\n    return Promise.all(running);\n}\nfunction resolveTargetOptions(target, newOptions) {\n    if (!newOptions) {\n        return;\n    }\n    let options = target.options;\n    if (!options) {\n        target.options = newOptions;\n        return;\n    }\n    if (options.$shared) {\n        target.options = options = Object.assign({}, options, {\n            $shared: false,\n            $animations: {}\n        });\n    }\n    return options;\n}\n\nfunction scaleClip(scale, allowedOverflow) {\n    const opts = scale && scale.options || {};\n    const reverse = opts.reverse;\n    const min = opts.min === undefined ? allowedOverflow : 0;\n    const max = opts.max === undefined ? allowedOverflow : 0;\n    return {\n        start: reverse ? max : min,\n        end: reverse ? min : max\n    };\n}\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n    if (allowedOverflow === false) {\n        return false;\n    }\n    const x = scaleClip(xScale, allowedOverflow);\n    const y = scaleClip(yScale, allowedOverflow);\n    return {\n        top: y.end,\n        right: x.end,\n        bottom: y.start,\n        left: x.start\n    };\n}\nfunction toClip(value) {\n    let t, r, b, l;\n    if (helpers_dataset.isObject(value)) {\n        t = value.top;\n        r = value.right;\n        b = value.bottom;\n        l = value.left;\n    } else {\n        t = r = b = l = value;\n    }\n    return {\n        top: t,\n        right: r,\n        bottom: b,\n        left: l,\n        disabled: value === false\n    };\n}\nfunction getSortedDatasetIndices(chart, filterVisible) {\n    const keys = [];\n    const metasets = chart._getSortedDatasetMetas(filterVisible);\n    let i, ilen;\n    for(i = 0, ilen = metasets.length; i < ilen; ++i){\n        keys.push(metasets[i].index);\n    }\n    return keys;\n}\nfunction applyStack(stack, value, dsIndex, options = {}) {\n    const keys = stack.keys;\n    const singleMode = options.mode === 'single';\n    let i, ilen, datasetIndex, otherValue;\n    if (value === null) {\n        return;\n    }\n    let found = false;\n    for(i = 0, ilen = keys.length; i < ilen; ++i){\n        datasetIndex = +keys[i];\n        if (datasetIndex === dsIndex) {\n            found = true;\n            if (options.all) {\n                continue;\n            }\n            break;\n        }\n        otherValue = stack.values[datasetIndex];\n        if (helpers_dataset.isNumberFinite(otherValue) && (singleMode || value === 0 || helpers_dataset.sign(value) === helpers_dataset.sign(otherValue))) {\n            value += otherValue;\n        }\n    }\n    if (!found && !options.all) {\n        return 0;\n    }\n    return value;\n}\nfunction convertObjectDataToArray(data, meta) {\n    const { iScale , vScale  } = meta;\n    const iAxisKey = iScale.axis === 'x' ? 'x' : 'y';\n    const vAxisKey = vScale.axis === 'x' ? 'x' : 'y';\n    const keys = Object.keys(data);\n    const adata = new Array(keys.length);\n    let i, ilen, key;\n    for(i = 0, ilen = keys.length; i < ilen; ++i){\n        key = keys[i];\n        adata[i] = {\n            [iAxisKey]: key,\n            [vAxisKey]: data[key]\n        };\n    }\n    return adata;\n}\nfunction isStacked(scale, meta) {\n    const stacked = scale && scale.options.stacked;\n    return stacked || stacked === undefined && meta.stack !== undefined;\n}\nfunction getStackKey(indexScale, valueScale, meta) {\n    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n}\nfunction getUserBounds(scale) {\n    const { min , max , minDefined , maxDefined  } = scale.getUserBounds();\n    return {\n        min: minDefined ? min : Number.NEGATIVE_INFINITY,\n        max: maxDefined ? max : Number.POSITIVE_INFINITY\n    };\n}\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n    const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n    return subStack[indexValue] || (subStack[indexValue] = {});\n}\nfunction getLastIndexInStack(stack, vScale, positive, type) {\n    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()){\n        const value = stack[meta.index];\n        if (positive && value > 0 || !positive && value < 0) {\n            return meta.index;\n        }\n    }\n    return null;\n}\nfunction updateStacks(controller, parsed) {\n    const { chart , _cachedMeta: meta  } = controller;\n    const stacks = chart._stacks || (chart._stacks = {});\n    const { iScale , vScale , index: datasetIndex  } = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const key = getStackKey(iScale, vScale, meta);\n    const ilen = parsed.length;\n    let stack;\n    for(let i = 0; i < ilen; ++i){\n        const item = parsed[i];\n        const { [iAxis]: index , [vAxis]: value  } = item;\n        const itemStacks = item._stacks || (item._stacks = {});\n        stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n        stack[datasetIndex] = value;\n        stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n        stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n        const visualValues = stack._visualValues || (stack._visualValues = {});\n        visualValues[datasetIndex] = value;\n    }\n}\nfunction getFirstScaleId(chart, axis) {\n    const scales = chart.scales;\n    return Object.keys(scales).filter((key)=>scales[key].axis === axis).shift();\n}\nfunction createDatasetContext(parent, index) {\n    return helpers_dataset.createContext(parent, {\n        active: false,\n        dataset: undefined,\n        datasetIndex: index,\n        index,\n        mode: 'default',\n        type: 'dataset'\n    });\n}\nfunction createDataContext(parent, index, element) {\n    return helpers_dataset.createContext(parent, {\n        active: false,\n        dataIndex: index,\n        parsed: undefined,\n        raw: undefined,\n        element,\n        index,\n        mode: 'default',\n        type: 'data'\n    });\n}\nfunction clearStacks(meta, items) {\n    const datasetIndex = meta.controller.index;\n    const axis = meta.vScale && meta.vScale.axis;\n    if (!axis) {\n        return;\n    }\n    items = items || meta._parsed;\n    for (const parsed of items){\n        const stacks = parsed._stacks;\n        if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n            return;\n        }\n        delete stacks[axis][datasetIndex];\n        if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) {\n            delete stacks[axis]._visualValues[datasetIndex];\n        }\n    }\n}\nconst isDirectUpdateMode = (mode)=>mode === 'reset' || mode === 'none';\nconst cloneIfNotShared = (cached, shared)=>shared ? cached : Object.assign({}, cached);\nconst createStack = (canStack, meta, chart)=>canStack && !meta.hidden && meta._stacked && {\n        keys: getSortedDatasetIndices(chart, true),\n        values: null\n    };\nclass DatasetController {\n static defaults = {};\n static datasetElementType = null;\n static dataElementType = null;\n constructor(chart, datasetIndex){\n        this.chart = chart;\n        this._ctx = chart.ctx;\n        this.index = datasetIndex;\n        this._cachedDataOpts = {};\n        this._cachedMeta = this.getMeta();\n        this._type = this._cachedMeta.type;\n        this.options = undefined;\n         this._parsing = false;\n        this._data = undefined;\n        this._objectData = undefined;\n        this._sharedOptions = undefined;\n        this._drawStart = undefined;\n        this._drawCount = undefined;\n        this.enableOptionSharing = false;\n        this.supportsDecimation = false;\n        this.$context = undefined;\n        this._syncList = [];\n        this.datasetElementType = new.target.datasetElementType;\n        this.dataElementType = new.target.dataElementType;\n        this.initialize();\n    }\n    initialize() {\n        const meta = this._cachedMeta;\n        this.configure();\n        this.linkScales();\n        meta._stacked = isStacked(meta.vScale, meta);\n        this.addElements();\n        if (this.options.fill && !this.chart.isPluginEnabled('filler')) {\n            console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\");\n        }\n    }\n    updateIndex(datasetIndex) {\n        if (this.index !== datasetIndex) {\n            clearStacks(this._cachedMeta);\n        }\n        this.index = datasetIndex;\n    }\n    linkScales() {\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const dataset = this.getDataset();\n        const chooseId = (axis, x, y, r)=>axis === 'x' ? x : axis === 'r' ? r : y;\n        const xid = meta.xAxisID = helpers_dataset.valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));\n        const yid = meta.yAxisID = helpers_dataset.valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));\n        const rid = meta.rAxisID = helpers_dataset.valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));\n        const indexAxis = meta.indexAxis;\n        const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n        const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n        meta.xScale = this.getScaleForId(xid);\n        meta.yScale = this.getScaleForId(yid);\n        meta.rScale = this.getScaleForId(rid);\n        meta.iScale = this.getScaleForId(iid);\n        meta.vScale = this.getScaleForId(vid);\n    }\n    getDataset() {\n        return this.chart.data.datasets[this.index];\n    }\n    getMeta() {\n        return this.chart.getDatasetMeta(this.index);\n    }\n getScaleForId(scaleID) {\n        return this.chart.scales[scaleID];\n    }\n _getOtherScale(scale) {\n        const meta = this._cachedMeta;\n        return scale === meta.iScale ? meta.vScale : meta.iScale;\n    }\n    reset() {\n        this._update('reset');\n    }\n _destroy() {\n        const meta = this._cachedMeta;\n        if (this._data) {\n            helpers_dataset.unlistenArrayEvents(this._data, this);\n        }\n        if (meta._stacked) {\n            clearStacks(meta);\n        }\n    }\n _dataCheck() {\n        const dataset = this.getDataset();\n        const data = dataset.data || (dataset.data = []);\n        const _data = this._data;\n        if (helpers_dataset.isObject(data)) {\n            const meta = this._cachedMeta;\n            this._data = convertObjectDataToArray(data, meta);\n        } else if (_data !== data) {\n            if (_data) {\n                helpers_dataset.unlistenArrayEvents(_data, this);\n                const meta = this._cachedMeta;\n                clearStacks(meta);\n                meta._parsed = [];\n            }\n            if (data && Object.isExtensible(data)) {\n                helpers_dataset.listenArrayEvents(data, this);\n            }\n            this._syncList = [];\n            this._data = data;\n        }\n    }\n    addElements() {\n        const meta = this._cachedMeta;\n        this._dataCheck();\n        if (this.datasetElementType) {\n            meta.dataset = new this.datasetElementType();\n        }\n    }\n    buildOrUpdateElements(resetNewElements) {\n        const meta = this._cachedMeta;\n        const dataset = this.getDataset();\n        let stackChanged = false;\n        this._dataCheck();\n        const oldStacked = meta._stacked;\n        meta._stacked = isStacked(meta.vScale, meta);\n        if (meta.stack !== dataset.stack) {\n            stackChanged = true;\n            clearStacks(meta);\n            meta.stack = dataset.stack;\n        }\n        this._resyncElements(resetNewElements);\n        if (stackChanged || oldStacked !== meta._stacked) {\n            updateStacks(this, meta._parsed);\n            meta._stacked = isStacked(meta.vScale, meta);\n        }\n    }\n configure() {\n        const config = this.chart.config;\n        const scopeKeys = config.datasetScopeKeys(this._type);\n        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n        this.options = config.createResolver(scopes, this.getContext());\n        this._parsing = this.options.parsing;\n        this._cachedDataOpts = {};\n    }\n parse(start, count) {\n        const { _cachedMeta: meta , _data: data  } = this;\n        const { iScale , _stacked  } = meta;\n        const iAxis = iScale.axis;\n        let sorted = start === 0 && count === data.length ? true : meta._sorted;\n        let prev = start > 0 && meta._parsed[start - 1];\n        let i, cur, parsed;\n        if (this._parsing === false) {\n            meta._parsed = data;\n            meta._sorted = true;\n            parsed = data;\n        } else {\n            if (helpers_dataset.isArray(data[start])) {\n                parsed = this.parseArrayData(meta, data, start, count);\n            } else if (helpers_dataset.isObject(data[start])) {\n                parsed = this.parseObjectData(meta, data, start, count);\n            } else {\n                parsed = this.parsePrimitiveData(meta, data, start, count);\n            }\n            const isNotInOrderComparedToPrev = ()=>cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];\n            for(i = 0; i < count; ++i){\n                meta._parsed[i + start] = cur = parsed[i];\n                if (sorted) {\n                    if (isNotInOrderComparedToPrev()) {\n                        sorted = false;\n                    }\n                    prev = cur;\n                }\n            }\n            meta._sorted = sorted;\n        }\n        if (_stacked) {\n            updateStacks(this, parsed);\n        }\n    }\n parsePrimitiveData(meta, data, start, count) {\n        const { iScale , vScale  } = meta;\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const labels = iScale.getLabels();\n        const singleScale = iScale === vScale;\n        const parsed = new Array(count);\n        let i, ilen, index;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            parsed[i] = {\n                [iAxis]: singleScale || iScale.parse(labels[index], index),\n                [vAxis]: vScale.parse(data[index], index)\n            };\n        }\n        return parsed;\n    }\n parseArrayData(meta, data, start, count) {\n        const { xScale , yScale  } = meta;\n        const parsed = new Array(count);\n        let i, ilen, index, item;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            item = data[index];\n            parsed[i] = {\n                x: xScale.parse(item[0], index),\n                y: yScale.parse(item[1], index)\n            };\n        }\n        return parsed;\n    }\n parseObjectData(meta, data, start, count) {\n        const { xScale , yScale  } = meta;\n        const { xAxisKey ='x' , yAxisKey ='y'  } = this._parsing;\n        const parsed = new Array(count);\n        let i, ilen, index, item;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            item = data[index];\n            parsed[i] = {\n                x: xScale.parse(helpers_dataset.resolveObjectKey(item, xAxisKey), index),\n                y: yScale.parse(helpers_dataset.resolveObjectKey(item, yAxisKey), index)\n            };\n        }\n        return parsed;\n    }\n getParsed(index) {\n        return this._cachedMeta._parsed[index];\n    }\n getDataElement(index) {\n        return this._cachedMeta.data[index];\n    }\n applyStack(scale, parsed, mode) {\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const value = parsed[scale.axis];\n        const stack = {\n            keys: getSortedDatasetIndices(chart, true),\n            values: parsed._stacks[scale.axis]._visualValues\n        };\n        return applyStack(stack, value, meta.index, {\n            mode\n        });\n    }\n updateRangeFromParsed(range, scale, parsed, stack) {\n        const parsedValue = parsed[scale.axis];\n        let value = parsedValue === null ? NaN : parsedValue;\n        const values = stack && parsed._stacks[scale.axis];\n        if (stack && values) {\n            stack.values = values;\n            value = applyStack(stack, parsedValue, this._cachedMeta.index);\n        }\n        range.min = Math.min(range.min, value);\n        range.max = Math.max(range.max, value);\n    }\n getMinMax(scale, canStack) {\n        const meta = this._cachedMeta;\n        const _parsed = meta._parsed;\n        const sorted = meta._sorted && scale === meta.iScale;\n        const ilen = _parsed.length;\n        const otherScale = this._getOtherScale(scale);\n        const stack = createStack(canStack, meta, this.chart);\n        const range = {\n            min: Number.POSITIVE_INFINITY,\n            max: Number.NEGATIVE_INFINITY\n        };\n        const { min: otherMin , max: otherMax  } = getUserBounds(otherScale);\n        let i, parsed;\n        function _skip() {\n            parsed = _parsed[i];\n            const otherValue = parsed[otherScale.axis];\n            return !helpers_dataset.isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n        }\n        for(i = 0; i < ilen; ++i){\n            if (_skip()) {\n                continue;\n            }\n            this.updateRangeFromParsed(range, scale, parsed, stack);\n            if (sorted) {\n                break;\n            }\n        }\n        if (sorted) {\n            for(i = ilen - 1; i >= 0; --i){\n                if (_skip()) {\n                    continue;\n                }\n                this.updateRangeFromParsed(range, scale, parsed, stack);\n                break;\n            }\n        }\n        return range;\n    }\n    getAllParsedValues(scale) {\n        const parsed = this._cachedMeta._parsed;\n        const values = [];\n        let i, ilen, value;\n        for(i = 0, ilen = parsed.length; i < ilen; ++i){\n            value = parsed[i][scale.axis];\n            if (helpers_dataset.isNumberFinite(value)) {\n                values.push(value);\n            }\n        }\n        return values;\n    }\n getMaxOverflow() {\n        return false;\n    }\n getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const iScale = meta.iScale;\n        const vScale = meta.vScale;\n        const parsed = this.getParsed(index);\n        return {\n            label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\n            value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\n        };\n    }\n _update(mode) {\n        const meta = this._cachedMeta;\n        this.update(mode || 'default');\n        meta._clip = toClip(helpers_dataset.valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n    }\n update(mode) {}\n    draw() {\n        const ctx = this._ctx;\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const elements = meta.data || [];\n        const area = chart.chartArea;\n        const active = [];\n        const start = this._drawStart || 0;\n        const count = this._drawCount || elements.length - start;\n        const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n        let i;\n        if (meta.dataset) {\n            meta.dataset.draw(ctx, area, start, count);\n        }\n        for(i = start; i < start + count; ++i){\n            const element = elements[i];\n            if (element.hidden) {\n                continue;\n            }\n            if (element.active && drawActiveElementsOnTop) {\n                active.push(element);\n            } else {\n                element.draw(ctx, area);\n            }\n        }\n        for(i = 0; i < active.length; ++i){\n            active[i].draw(ctx, area);\n        }\n    }\n getStyle(index, active) {\n        const mode = active ? 'active' : 'default';\n        return index === undefined && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);\n    }\n getContext(index, active, mode) {\n        const dataset = this.getDataset();\n        let context;\n        if (index >= 0 && index < this._cachedMeta.data.length) {\n            const element = this._cachedMeta.data[index];\n            context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));\n            context.parsed = this.getParsed(index);\n            context.raw = dataset.data[index];\n            context.index = context.dataIndex = index;\n        } else {\n            context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n            context.dataset = dataset;\n            context.index = context.datasetIndex = this.index;\n        }\n        context.active = !!active;\n        context.mode = mode;\n        return context;\n    }\n resolveDatasetElementOptions(mode) {\n        return this._resolveElementOptions(this.datasetElementType.id, mode);\n    }\n resolveDataElementOptions(index, mode) {\n        return this._resolveElementOptions(this.dataElementType.id, mode, index);\n    }\n _resolveElementOptions(elementType, mode = 'default', index) {\n        const active = mode === 'active';\n        const cache = this._cachedDataOpts;\n        const cacheKey = elementType + '-' + mode;\n        const cached = cache[cacheKey];\n        const sharing = this.enableOptionSharing && helpers_dataset.defined(index);\n        if (cached) {\n            return cloneIfNotShared(cached, sharing);\n        }\n        const config = this.chart.config;\n        const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n        const prefixes = active ? [\n            `${elementType}Hover`,\n            'hover',\n            elementType,\n            ''\n        ] : [\n            elementType,\n            ''\n        ];\n        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n        const names = Object.keys(helpers_dataset.defaults.elements[elementType]);\n        const context = ()=>this.getContext(index, active, mode);\n        const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n        if (values.$shared) {\n            values.$shared = sharing;\n            cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n        }\n        return values;\n    }\n _resolveAnimations(index, transition, active) {\n        const chart = this.chart;\n        const cache = this._cachedDataOpts;\n        const cacheKey = `animation-${transition}`;\n        const cached = cache[cacheKey];\n        if (cached) {\n            return cached;\n        }\n        let options;\n        if (chart.options.animation !== false) {\n            const config = this.chart.config;\n            const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n            options = config.createResolver(scopes, this.getContext(index, active, transition));\n        }\n        const animations = new Animations(chart, options && options.animations);\n        if (options && options._cacheable) {\n            cache[cacheKey] = Object.freeze(animations);\n        }\n        return animations;\n    }\n getSharedOptions(options) {\n        if (!options.$shared) {\n            return;\n        }\n        return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n    }\n includeOptions(mode, sharedOptions) {\n        return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n    }\n _getSharedOptions(start, mode) {\n        const firstOpts = this.resolveDataElementOptions(start, mode);\n        const previouslySharedOptions = this._sharedOptions;\n        const sharedOptions = this.getSharedOptions(firstOpts);\n        const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;\n        this.updateSharedOptions(sharedOptions, mode, firstOpts);\n        return {\n            sharedOptions,\n            includeOptions\n        };\n    }\n updateElement(element, index, properties, mode) {\n        if (isDirectUpdateMode(mode)) {\n            Object.assign(element, properties);\n        } else {\n            this._resolveAnimations(index, mode).update(element, properties);\n        }\n    }\n updateSharedOptions(sharedOptions, mode, newOptions) {\n        if (sharedOptions && !isDirectUpdateMode(mode)) {\n            this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n        }\n    }\n _setStyle(element, index, mode, active) {\n        element.active = active;\n        const options = this.getStyle(index, active);\n        this._resolveAnimations(index, mode, active).update(element, {\n            options: !active && this.getSharedOptions(options) || options\n        });\n    }\n    removeHoverStyle(element, datasetIndex, index) {\n        this._setStyle(element, index, 'active', false);\n    }\n    setHoverStyle(element, datasetIndex, index) {\n        this._setStyle(element, index, 'active', true);\n    }\n _removeDatasetHoverStyle() {\n        const element = this._cachedMeta.dataset;\n        if (element) {\n            this._setStyle(element, undefined, 'active', false);\n        }\n    }\n _setDatasetHoverStyle() {\n        const element = this._cachedMeta.dataset;\n        if (element) {\n            this._setStyle(element, undefined, 'active', true);\n        }\n    }\n _resyncElements(resetNewElements) {\n        const data = this._data;\n        const elements = this._cachedMeta.data;\n        for (const [method, arg1, arg2] of this._syncList){\n            this[method](arg1, arg2);\n        }\n        this._syncList = [];\n        const numMeta = elements.length;\n        const numData = data.length;\n        const count = Math.min(numData, numMeta);\n        if (count) {\n            this.parse(0, count);\n        }\n        if (numData > numMeta) {\n            this._insertElements(numMeta, numData - numMeta, resetNewElements);\n        } else if (numData < numMeta) {\n            this._removeElements(numData, numMeta - numData);\n        }\n    }\n _insertElements(start, count, resetNewElements = true) {\n        const meta = this._cachedMeta;\n        const data = meta.data;\n        const end = start + count;\n        let i;\n        const move = (arr)=>{\n            arr.length += count;\n            for(i = arr.length - 1; i >= end; i--){\n                arr[i] = arr[i - count];\n            }\n        };\n        move(data);\n        for(i = start; i < end; ++i){\n            data[i] = new this.dataElementType();\n        }\n        if (this._parsing) {\n            move(meta._parsed);\n        }\n        this.parse(start, count);\n        if (resetNewElements) {\n            this.updateElements(data, start, count, 'reset');\n        }\n    }\n    updateElements(element, start, count, mode) {}\n _removeElements(start, count) {\n        const meta = this._cachedMeta;\n        if (this._parsing) {\n            const removed = meta._parsed.splice(start, count);\n            if (meta._stacked) {\n                clearStacks(meta, removed);\n            }\n        }\n        meta.data.splice(start, count);\n    }\n _sync(args) {\n        if (this._parsing) {\n            this._syncList.push(args);\n        } else {\n            const [method, arg1, arg2] = args;\n            this[method](arg1, arg2);\n        }\n        this.chart._dataChanges.push([\n            this.index,\n            ...args\n        ]);\n    }\n    _onDataPush() {\n        const count = arguments.length;\n        this._sync([\n            '_insertElements',\n            this.getDataset().data.length - count,\n            count\n        ]);\n    }\n    _onDataPop() {\n        this._sync([\n            '_removeElements',\n            this._cachedMeta.data.length - 1,\n            1\n        ]);\n    }\n    _onDataShift() {\n        this._sync([\n            '_removeElements',\n            0,\n            1\n        ]);\n    }\n    _onDataSplice(start, count) {\n        if (count) {\n            this._sync([\n                '_removeElements',\n                start,\n                count\n            ]);\n        }\n        const newCount = arguments.length - 2;\n        if (newCount) {\n            this._sync([\n                '_insertElements',\n                start,\n                newCount\n            ]);\n        }\n    }\n    _onDataUnshift() {\n        this._sync([\n            '_insertElements',\n            0,\n            arguments.length\n        ]);\n    }\n}\n\nfunction getAllScaleValues(scale, type) {\n    if (!scale._cache.$bar) {\n        const visibleMetas = scale.getMatchingVisibleMetas(type);\n        let values = [];\n        for(let i = 0, ilen = visibleMetas.length; i < ilen; i++){\n            values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n        }\n        scale._cache.$bar = helpers_dataset._arrayUnique(values.sort((a, b)=>a - b));\n    }\n    return scale._cache.$bar;\n}\n function computeMinSampleSize(meta) {\n    const scale = meta.iScale;\n    const values = getAllScaleValues(scale, meta.type);\n    let min = scale._length;\n    let i, ilen, curr, prev;\n    const updateMinAndPrev = ()=>{\n        if (curr === 32767 || curr === -32768) {\n            return;\n        }\n        if (helpers_dataset.defined(prev)) {\n            min = Math.min(min, Math.abs(curr - prev) || min);\n        }\n        prev = curr;\n    };\n    for(i = 0, ilen = values.length; i < ilen; ++i){\n        curr = scale.getPixelForValue(values[i]);\n        updateMinAndPrev();\n    }\n    prev = undefined;\n    for(i = 0, ilen = scale.ticks.length; i < ilen; ++i){\n        curr = scale.getPixelForTick(i);\n        updateMinAndPrev();\n    }\n    return min;\n}\n function computeFitCategoryTraits(index, ruler, options, stackCount) {\n    const thickness = options.barThickness;\n    let size, ratio;\n    if (helpers_dataset.isNullOrUndef(thickness)) {\n        size = ruler.min * options.categoryPercentage;\n        ratio = options.barPercentage;\n    } else {\n        size = thickness * stackCount;\n        ratio = 1;\n    }\n    return {\n        chunk: size / stackCount,\n        ratio,\n        start: ruler.pixels[index] - size / 2\n    };\n}\n function computeFlexCategoryTraits(index, ruler, options, stackCount) {\n    const pixels = ruler.pixels;\n    const curr = pixels[index];\n    let prev = index > 0 ? pixels[index - 1] : null;\n    let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n    const percent = options.categoryPercentage;\n    if (prev === null) {\n        prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n    }\n    if (next === null) {\n        next = curr + curr - prev;\n    }\n    const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n    const size = Math.abs(next - prev) / 2 * percent;\n    return {\n        chunk: size / stackCount,\n        ratio: options.barPercentage,\n        start\n    };\n}\nfunction parseFloatBar(entry, item, vScale, i) {\n    const startValue = vScale.parse(entry[0], i);\n    const endValue = vScale.parse(entry[1], i);\n    const min = Math.min(startValue, endValue);\n    const max = Math.max(startValue, endValue);\n    let barStart = min;\n    let barEnd = max;\n    if (Math.abs(min) > Math.abs(max)) {\n        barStart = max;\n        barEnd = min;\n    }\n    item[vScale.axis] = barEnd;\n    item._custom = {\n        barStart,\n        barEnd,\n        start: startValue,\n        end: endValue,\n        min,\n        max\n    };\n}\nfunction parseValue(entry, item, vScale, i) {\n    if (helpers_dataset.isArray(entry)) {\n        parseFloatBar(entry, item, vScale, i);\n    } else {\n        item[vScale.axis] = vScale.parse(entry, i);\n    }\n    return item;\n}\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = [];\n    let i, ilen, item, entry;\n    for(i = start, ilen = start + count; i < ilen; ++i){\n        entry = data[i];\n        item = {};\n        item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n        parsed.push(parseValue(entry, item, vScale, i));\n    }\n    return parsed;\n}\nfunction isFloatBar(custom) {\n    return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\nfunction barSign(size, vScale, actualBase) {\n    if (size !== 0) {\n        return helpers_dataset.sign(size);\n    }\n    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\nfunction borderProps(properties) {\n    let reverse, start, end, top, bottom;\n    if (properties.horizontal) {\n        reverse = properties.base > properties.x;\n        start = 'left';\n        end = 'right';\n    } else {\n        reverse = properties.base < properties.y;\n        start = 'bottom';\n        end = 'top';\n    }\n    if (reverse) {\n        top = 'end';\n        bottom = 'start';\n    } else {\n        top = 'start';\n        bottom = 'end';\n    }\n    return {\n        start,\n        end,\n        reverse,\n        top,\n        bottom\n    };\n}\nfunction setBorderSkipped(properties, options, stack, index) {\n    let edge = options.borderSkipped;\n    const res = {};\n    if (!edge) {\n        properties.borderSkipped = res;\n        return;\n    }\n    if (edge === true) {\n        properties.borderSkipped = {\n            top: true,\n            right: true,\n            bottom: true,\n            left: true\n        };\n        return;\n    }\n    const { start , end , reverse , top , bottom  } = borderProps(properties);\n    if (edge === 'middle' && stack) {\n        properties.enableBorderRadius = true;\n        if ((stack._top || 0) === index) {\n            edge = top;\n        } else if ((stack._bottom || 0) === index) {\n            edge = bottom;\n        } else {\n            res[parseEdge(bottom, start, end, reverse)] = true;\n            edge = top;\n        }\n    }\n    res[parseEdge(edge, start, end, reverse)] = true;\n    properties.borderSkipped = res;\n}\nfunction parseEdge(edge, a, b, reverse) {\n    if (reverse) {\n        edge = swap(edge, a, b);\n        edge = startEnd(edge, b, a);\n    } else {\n        edge = startEnd(edge, a, b);\n    }\n    return edge;\n}\nfunction swap(orig, v1, v2) {\n    return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\nfunction startEnd(v, start, end) {\n    return v === 'start' ? start : v === 'end' ? end : v;\n}\nfunction setInflateAmount(properties, { inflateAmount  }, ratio) {\n    properties.inflateAmount = inflateAmount === 'auto' ? ratio === 1 ? 0.33 : 0 : inflateAmount;\n}\nclass BarController extends DatasetController {\n    static id = 'bar';\n static defaults = {\n        datasetElementType: false,\n        dataElementType: 'bar',\n        categoryPercentage: 0.8,\n        barPercentage: 0.9,\n        grouped: true,\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'x',\n                    'y',\n                    'base',\n                    'width',\n                    'height'\n                ]\n            }\n        }\n    };\n static overrides = {\n        scales: {\n            _index_: {\n                type: 'category',\n                offset: true,\n                grid: {\n                    offset: true\n                }\n            },\n            _value_: {\n                type: 'linear',\n                beginAtZero: true\n            }\n        }\n    };\n parsePrimitiveData(meta, data, start, count) {\n        return parseArrayOrPrimitive(meta, data, start, count);\n    }\n parseArrayData(meta, data, start, count) {\n        return parseArrayOrPrimitive(meta, data, start, count);\n    }\n parseObjectData(meta, data, start, count) {\n        const { iScale , vScale  } = meta;\n        const { xAxisKey ='x' , yAxisKey ='y'  } = this._parsing;\n        const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\n        const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\n        const parsed = [];\n        let i, ilen, item, obj;\n        for(i = start, ilen = start + count; i < ilen; ++i){\n            obj = data[i];\n            item = {};\n            item[iScale.axis] = iScale.parse(helpers_dataset.resolveObjectKey(obj, iAxisKey), i);\n            parsed.push(parseValue(helpers_dataset.resolveObjectKey(obj, vAxisKey), item, vScale, i));\n        }\n        return parsed;\n    }\n updateRangeFromParsed(range, scale, parsed, stack) {\n        super.updateRangeFromParsed(range, scale, parsed, stack);\n        const custom = parsed._custom;\n        if (custom && scale === this._cachedMeta.vScale) {\n            range.min = Math.min(range.min, custom.min);\n            range.max = Math.max(range.max, custom.max);\n        }\n    }\n getMaxOverflow() {\n        return 0;\n    }\n getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const { iScale , vScale  } = meta;\n        const parsed = this.getParsed(index);\n        const custom = parsed._custom;\n        const value = isFloatBar(custom) ? '[' + custom.start + ', ' + custom.end + ']' : '' + vScale.getLabelForValue(parsed[vScale.axis]);\n        return {\n            label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\n            value\n        };\n    }\n    initialize() {\n        this.enableOptionSharing = true;\n        super.initialize();\n        const meta = this._cachedMeta;\n        meta.stack = this.getDataset().stack;\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        this.updateElements(meta.data, 0, meta.data.length, mode);\n    }\n    updateElements(bars, start, count, mode) {\n        const reset = mode === 'reset';\n        const { index , _cachedMeta: { vScale  }  } = this;\n        const base = vScale.getBasePixel();\n        const horizontal = vScale.isHorizontal();\n        const ruler = this._getRuler();\n        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);\n        for(let i = start; i < start + count; i++){\n            const parsed = this.getParsed(i);\n            const vpixels = reset || helpers_dataset.isNullOrUndef(parsed[vScale.axis]) ? {\n                base,\n                head: base\n            } : this._calculateBarValuePixels(i);\n            const ipixels = this._calculateBarIndexPixels(i, ruler);\n            const stack = (parsed._stacks || {})[vScale.axis];\n            const properties = {\n                horizontal,\n                base: vpixels.base,\n                enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,\n                x: horizontal ? vpixels.head : ipixels.center,\n                y: horizontal ? ipixels.center : vpixels.head,\n                height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n                width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n            };\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\n            }\n            const options = properties.options || bars[i].options;\n            setBorderSkipped(properties, options, stack, index);\n            setInflateAmount(properties, options, ruler.ratio);\n            this.updateElement(bars[i], i, properties, mode);\n        }\n    }\n _getStacks(last, dataIndex) {\n        const { iScale  } = this._cachedMeta;\n        const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta)=>meta.controller.options.grouped);\n        const stacked = iScale.options.stacked;\n        const stacks = [];\n        const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);\n        const iScaleValue = currentParsed && currentParsed[iScale.axis];\n        const skipNull = (meta)=>{\n            const parsed = meta._parsed.find((item)=>item[iScale.axis] === iScaleValue);\n            const val = parsed && parsed[meta.vScale.axis];\n            if (helpers_dataset.isNullOrUndef(val) || isNaN(val)) {\n                return true;\n            }\n        };\n        for (const meta of metasets){\n            if (dataIndex !== undefined && skipNull(meta)) {\n                continue;\n            }\n            if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === undefined && meta.stack === undefined) {\n                stacks.push(meta.stack);\n            }\n            if (meta.index === last) {\n                break;\n            }\n        }\n        if (!stacks.length) {\n            stacks.push(undefined);\n        }\n        return stacks;\n    }\n _getStackCount(index) {\n        return this._getStacks(undefined, index).length;\n    }\n    _getAxisCount() {\n        return this._getAxis().length;\n    }\n    getFirstScaleIdForIndexAxis() {\n        const scales = this.chart.scales;\n        const indexScaleId = this.chart.options.indexAxis;\n        return Object.keys(scales).filter((key)=>scales[key].axis === indexScaleId).shift();\n    }\n    _getAxis() {\n        const axis = {};\n        const firstScaleAxisId = this.getFirstScaleIdForIndexAxis();\n        for (const dataset of this.chart.data.datasets){\n            axis[helpers_dataset.valueOrDefault(this.chart.options.indexAxis === 'x' ? dataset.xAxisID : dataset.yAxisID, firstScaleAxisId)] = true;\n        }\n        return Object.keys(axis);\n    }\n _getStackIndex(datasetIndex, name, dataIndex) {\n        const stacks = this._getStacks(datasetIndex, dataIndex);\n        const index = name !== undefined ? stacks.indexOf(name) : -1;\n        return index === -1 ? stacks.length - 1 : index;\n    }\n _getRuler() {\n        const opts = this.options;\n        const meta = this._cachedMeta;\n        const iScale = meta.iScale;\n        const pixels = [];\n        let i, ilen;\n        for(i = 0, ilen = meta.data.length; i < ilen; ++i){\n            pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n        }\n        const barThickness = opts.barThickness;\n        const min = barThickness || computeMinSampleSize(meta);\n        return {\n            min,\n            pixels,\n            start: iScale._startPixel,\n            end: iScale._endPixel,\n            stackCount: this._getStackCount(),\n            scale: iScale,\n            grouped: opts.grouped,\n            ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n        };\n    }\n _calculateBarValuePixels(index) {\n        const { _cachedMeta: { vScale , _stacked , index: datasetIndex  } , options: { base: baseValue , minBarLength  }  } = this;\n        const actualBase = baseValue || 0;\n        const parsed = this.getParsed(index);\n        const custom = parsed._custom;\n        const floating = isFloatBar(custom);\n        let value = parsed[vScale.axis];\n        let start = 0;\n        let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n        let head, size;\n        if (length !== value) {\n            start = length - value;\n            length = value;\n        }\n        if (floating) {\n            value = custom.barStart;\n            length = custom.barEnd - custom.barStart;\n            if (value !== 0 && helpers_dataset.sign(value) !== helpers_dataset.sign(custom.barEnd)) {\n                start = 0;\n            }\n            start += value;\n        }\n        const startValue = !helpers_dataset.isNullOrUndef(baseValue) && !floating ? baseValue : start;\n        let base = vScale.getPixelForValue(startValue);\n        if (this.chart.getDataVisibility(index)) {\n            head = vScale.getPixelForValue(start + length);\n        } else {\n            head = base;\n        }\n        size = head - base;\n        if (Math.abs(size) < minBarLength) {\n            size = barSign(size, vScale, actualBase) * minBarLength;\n            if (value === actualBase) {\n                base -= size / 2;\n            }\n            const startPixel = vScale.getPixelForDecimal(0);\n            const endPixel = vScale.getPixelForDecimal(1);\n            const min = Math.min(startPixel, endPixel);\n            const max = Math.max(startPixel, endPixel);\n            base = Math.max(Math.min(base, max), min);\n            head = base + size;\n            if (_stacked && !floating) {\n                parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);\n            }\n        }\n        if (base === vScale.getPixelForValue(actualBase)) {\n            const halfGrid = helpers_dataset.sign(size) * vScale.getLineWidthForValue(actualBase) / 2;\n            base += halfGrid;\n            size -= halfGrid;\n        }\n        return {\n            size,\n            base,\n            head,\n            center: head + size / 2\n        };\n    }\n _calculateBarIndexPixels(index, ruler) {\n        const scale = ruler.scale;\n        const options = this.options;\n        const skipNull = options.skipNull;\n        const maxBarThickness = helpers_dataset.valueOrDefault(options.maxBarThickness, Infinity);\n        let center, size;\n        const axisCount = this._getAxisCount();\n        if (ruler.grouped) {\n            const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\n            const range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options, stackCount * axisCount) : computeFitCategoryTraits(index, ruler, options, stackCount * axisCount);\n            const axisID = this.chart.options.indexAxis === 'x' ? this.getDataset().xAxisID : this.getDataset().yAxisID;\n            const axisNumber = this._getAxis().indexOf(helpers_dataset.valueOrDefault(axisID, this.getFirstScaleIdForIndexAxis()));\n            const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined) + axisNumber;\n            center = range.start + range.chunk * stackIndex + range.chunk / 2;\n            size = Math.min(maxBarThickness, range.chunk * range.ratio);\n        } else {\n            center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\n            size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n        }\n        return {\n            base: center - size / 2,\n            head: center + size / 2,\n            center,\n            size\n        };\n    }\n    draw() {\n        const meta = this._cachedMeta;\n        const vScale = meta.vScale;\n        const rects = meta.data;\n        const ilen = rects.length;\n        let i = 0;\n        for(; i < ilen; ++i){\n            if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) {\n                rects[i].draw(this._ctx);\n            }\n        }\n    }\n}\n\nclass BubbleController extends DatasetController {\n    static id = 'bubble';\n static defaults = {\n        datasetElementType: false,\n        dataElementType: 'point',\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'x',\n                    'y',\n                    'borderWidth',\n                    'radius'\n                ]\n            }\n        }\n    };\n static overrides = {\n        scales: {\n            x: {\n                type: 'linear'\n            },\n            y: {\n                type: 'linear'\n            }\n        }\n    };\n    initialize() {\n        this.enableOptionSharing = true;\n        super.initialize();\n    }\n parsePrimitiveData(meta, data, start, count) {\n        const parsed = super.parsePrimitiveData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n        }\n        return parsed;\n    }\n parseArrayData(meta, data, start, count) {\n        const parsed = super.parseArrayData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            const item = data[start + i];\n            parsed[i]._custom = helpers_dataset.valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);\n        }\n        return parsed;\n    }\n parseObjectData(meta, data, start, count) {\n        const parsed = super.parseObjectData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            const item = data[start + i];\n            parsed[i]._custom = helpers_dataset.valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n        }\n        return parsed;\n    }\n getMaxOverflow() {\n        const data = this._cachedMeta.data;\n        let max = 0;\n        for(let i = data.length - 1; i >= 0; --i){\n            max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n        }\n        return max > 0 && max;\n    }\n getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const labels = this.chart.data.labels || [];\n        const { xScale , yScale  } = meta;\n        const parsed = this.getParsed(index);\n        const x = xScale.getLabelForValue(parsed.x);\n        const y = yScale.getLabelForValue(parsed.y);\n        const r = parsed._custom;\n        return {\n            label: labels[index] || '',\n            value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\n        };\n    }\n    update(mode) {\n        const points = this._cachedMeta.data;\n        this.updateElements(points, 0, points.length, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === 'reset';\n        const { iScale , vScale  } = this._cachedMeta;\n        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        for(let i = start; i < start + count; i++){\n            const point = points[i];\n            const parsed = !reset && this.getParsed(i);\n            const properties = {};\n            const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n            const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel);\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n                if (reset) {\n                    properties.options.radius = 0;\n                }\n            }\n            this.updateElement(point, i, properties, mode);\n        }\n    }\n resolveDataElementOptions(index, mode) {\n        const parsed = this.getParsed(index);\n        let values = super.resolveDataElementOptions(index, mode);\n        if (values.$shared) {\n            values = Object.assign({}, values, {\n                $shared: false\n            });\n        }\n        const radius = values.radius;\n        if (mode !== 'active') {\n            values.radius = 0;\n        }\n        values.radius += helpers_dataset.valueOrDefault(parsed && parsed._custom, radius);\n        return values;\n    }\n}\n\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n    let ratioX = 1;\n    let ratioY = 1;\n    let offsetX = 0;\n    let offsetY = 0;\n    if (circumference < helpers_dataset.TAU) {\n        const startAngle = rotation;\n        const endAngle = startAngle + circumference;\n        const startX = Math.cos(startAngle);\n        const startY = Math.sin(startAngle);\n        const endX = Math.cos(endAngle);\n        const endY = Math.sin(endAngle);\n        const calcMax = (angle, a, b)=>helpers_dataset._angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n        const calcMin = (angle, a, b)=>helpers_dataset._angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n        const maxX = calcMax(0, startX, endX);\n        const maxY = calcMax(helpers_dataset.HALF_PI, startY, endY);\n        const minX = calcMin(helpers_dataset.PI, startX, endX);\n        const minY = calcMin(helpers_dataset.PI + helpers_dataset.HALF_PI, startY, endY);\n        ratioX = (maxX - minX) / 2;\n        ratioY = (maxY - minY) / 2;\n        offsetX = -(maxX + minX) / 2;\n        offsetY = -(maxY + minY) / 2;\n    }\n    return {\n        ratioX,\n        ratioY,\n        offsetX,\n        offsetY\n    };\n}\nclass DoughnutController extends DatasetController {\n    static id = 'doughnut';\n static defaults = {\n        datasetElementType: false,\n        dataElementType: 'arc',\n        animation: {\n            animateRotate: true,\n            animateScale: false\n        },\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'circumference',\n                    'endAngle',\n                    'innerRadius',\n                    'outerRadius',\n                    'startAngle',\n                    'x',\n                    'y',\n                    'offset',\n                    'borderWidth',\n                    'spacing'\n                ]\n            }\n        },\n        cutout: '50%',\n        rotation: 0,\n        circumference: 360,\n        radius: '100%',\n        spacing: 0,\n        indexAxis: 'r'\n    };\n    static descriptors = {\n        _scriptable: (name)=>name !== 'spacing',\n        _indexable: (name)=>name !== 'spacing' && !name.startsWith('borderDash') && !name.startsWith('hoverBorderDash')\n    };\n static overrides = {\n        aspectRatio: 1,\n        plugins: {\n            legend: {\n                labels: {\n                    generateLabels (chart) {\n                        const data = chart.data;\n                        if (data.labels.length && data.datasets.length) {\n                            const { labels: { pointStyle , color  }  } = chart.legend.options;\n                            return data.labels.map((label, i)=>{\n                                const meta = chart.getDatasetMeta(0);\n                                const style = meta.controller.getStyle(i);\n                                return {\n                                    text: label,\n                                    fillStyle: style.backgroundColor,\n                                    strokeStyle: style.borderColor,\n                                    fontColor: color,\n                                    lineWidth: style.borderWidth,\n                                    pointStyle: pointStyle,\n                                    hidden: !chart.getDataVisibility(i),\n                                    index: i\n                                };\n                            });\n                        }\n                        return [];\n                    }\n                },\n                onClick (e, legendItem, legend) {\n                    legend.chart.toggleDataVisibility(legendItem.index);\n                    legend.chart.update();\n                }\n            }\n        }\n    };\n    constructor(chart, datasetIndex){\n        super(chart, datasetIndex);\n        this.enableOptionSharing = true;\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n        this.offsetX = undefined;\n        this.offsetY = undefined;\n    }\n    linkScales() {}\n parse(start, count) {\n        const data = this.getDataset().data;\n        const meta = this._cachedMeta;\n        if (this._parsing === false) {\n            meta._parsed = data;\n        } else {\n            let getter = (i)=>+data[i];\n            if (helpers_dataset.isObject(data[start])) {\n                const { key ='value'  } = this._parsing;\n                getter = (i)=>+helpers_dataset.resolveObjectKey(data[i], key);\n            }\n            let i, ilen;\n            for(i = start, ilen = start + count; i < ilen; ++i){\n                meta._parsed[i] = getter(i);\n            }\n        }\n    }\n _getRotation() {\n        return helpers_dataset.toRadians(this.options.rotation - 90);\n    }\n _getCircumference() {\n        return helpers_dataset.toRadians(this.options.circumference);\n    }\n _getRotationExtents() {\n        let min = helpers_dataset.TAU;\n        let max = -helpers_dataset.TAU;\n        for(let i = 0; i < this.chart.data.datasets.length; ++i){\n            if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {\n                const controller = this.chart.getDatasetMeta(i).controller;\n                const rotation = controller._getRotation();\n                const circumference = controller._getCircumference();\n                min = Math.min(min, rotation);\n                max = Math.max(max, rotation + circumference);\n            }\n        }\n        return {\n            rotation: min,\n            circumference: max - min\n        };\n    }\n update(mode) {\n        const chart = this.chart;\n        const { chartArea  } = chart;\n        const meta = this._cachedMeta;\n        const arcs = meta.data;\n        const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n        const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n        const cutout = Math.min(helpers_dataset.toPercentage(this.options.cutout, maxSize), 1);\n        const chartWeight = this._getRingWeight(this.index);\n        const { circumference , rotation  } = this._getRotationExtents();\n        const { ratioX , ratioY , offsetX , offsetY  } = getRatioAndOffset(rotation, circumference, cutout);\n        const maxWidth = (chartArea.width - spacing) / ratioX;\n        const maxHeight = (chartArea.height - spacing) / ratioY;\n        const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n        const outerRadius = helpers_dataset.toDimension(this.options.radius, maxRadius);\n        const innerRadius = Math.max(outerRadius * cutout, 0);\n        const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n        this.offsetX = offsetX * outerRadius;\n        this.offsetY = offsetY * outerRadius;\n        meta.total = this.calculateTotal();\n        this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n        this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n        this.updateElements(arcs, 0, arcs.length, mode);\n    }\n _circumference(i, reset) {\n        const opts = this.options;\n        const meta = this._cachedMeta;\n        const circumference = this._getCircumference();\n        if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n            return 0;\n        }\n        return this.calculateCircumference(meta._parsed[i] * circumference / helpers_dataset.TAU);\n    }\n    updateElements(arcs, start, count, mode) {\n        const reset = mode === 'reset';\n        const chart = this.chart;\n        const chartArea = chart.chartArea;\n        const opts = chart.options;\n        const animationOpts = opts.animation;\n        const centerX = (chartArea.left + chartArea.right) / 2;\n        const centerY = (chartArea.top + chartArea.bottom) / 2;\n        const animateScale = reset && animationOpts.animateScale;\n        const innerRadius = animateScale ? 0 : this.innerRadius;\n        const outerRadius = animateScale ? 0 : this.outerRadius;\n        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);\n        let startAngle = this._getRotation();\n        let i;\n        for(i = 0; i < start; ++i){\n            startAngle += this._circumference(i, reset);\n        }\n        for(i = start; i < start + count; ++i){\n            const circumference = this._circumference(i, reset);\n            const arc = arcs[i];\n            const properties = {\n                x: centerX + this.offsetX,\n                y: centerY + this.offsetY,\n                startAngle,\n                endAngle: startAngle + circumference,\n                circumference,\n                outerRadius,\n                innerRadius\n            };\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);\n            }\n            startAngle += circumference;\n            this.updateElement(arc, i, properties, mode);\n        }\n    }\n    calculateTotal() {\n        const meta = this._cachedMeta;\n        const metaData = meta.data;\n        let total = 0;\n        let i;\n        for(i = 0; i < metaData.length; i++){\n            const value = meta._parsed[i];\n            if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n                total += Math.abs(value);\n            }\n        }\n        return total;\n    }\n    calculateCircumference(value) {\n        const total = this._cachedMeta.total;\n        if (total > 0 && !isNaN(value)) {\n            return helpers_dataset.TAU * (Math.abs(value) / total);\n        }\n        return 0;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const chart = this.chart;\n        const labels = chart.data.labels || [];\n        const value = helpers_dataset.formatNumber(meta._parsed[index], chart.options.locale);\n        return {\n            label: labels[index] || '',\n            value\n        };\n    }\n    getMaxBorderWidth(arcs) {\n        let max = 0;\n        const chart = this.chart;\n        let i, ilen, meta, controller, options;\n        if (!arcs) {\n            for(i = 0, ilen = chart.data.datasets.length; i < ilen; ++i){\n                if (chart.isDatasetVisible(i)) {\n                    meta = chart.getDatasetMeta(i);\n                    arcs = meta.data;\n                    controller = meta.controller;\n                    break;\n                }\n            }\n        }\n        if (!arcs) {\n            return 0;\n        }\n        for(i = 0, ilen = arcs.length; i < ilen; ++i){\n            options = controller.resolveDataElementOptions(i);\n            if (options.borderAlign !== 'inner') {\n                max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n            }\n        }\n        return max;\n    }\n    getMaxOffset(arcs) {\n        let max = 0;\n        for(let i = 0, ilen = arcs.length; i < ilen; ++i){\n            const options = this.resolveDataElementOptions(i);\n            max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n        }\n        return max;\n    }\n _getRingWeightOffset(datasetIndex) {\n        let ringWeightOffset = 0;\n        for(let i = 0; i < datasetIndex; ++i){\n            if (this.chart.isDatasetVisible(i)) {\n                ringWeightOffset += this._getRingWeight(i);\n            }\n        }\n        return ringWeightOffset;\n    }\n _getRingWeight(datasetIndex) {\n        return Math.max(helpers_dataset.valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n    }\n _getVisibleDatasetWeightTotal() {\n        return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n    }\n}\n\nclass LineController extends DatasetController {\n    static id = 'line';\n static defaults = {\n        datasetElementType: 'line',\n        dataElementType: 'point',\n        showLine: true,\n        spanGaps: false\n    };\n static overrides = {\n        scales: {\n            _index_: {\n                type: 'category'\n            },\n            _value_: {\n                type: 'linear'\n            }\n        }\n    };\n    initialize() {\n        this.enableOptionSharing = true;\n        this.supportsDecimation = true;\n        super.initialize();\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const { dataset: line , data: points = [] , _dataset  } = meta;\n        const animationsDisabled = this.chart._animationsDisabled;\n        let { start , count  } = helpers_dataset._getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n        this._drawStart = start;\n        this._drawCount = count;\n        if (helpers_dataset._scaleRangesChanged(meta)) {\n            start = 0;\n            count = points.length;\n        }\n        line._chart = this.chart;\n        line._datasetIndex = this.index;\n        line._decimated = !!_dataset._decimated;\n        line.points = points;\n        const options = this.resolveDatasetElementOptions(mode);\n        if (!this.options.showLine) {\n            options.borderWidth = 0;\n        }\n        options.segment = this.options.segment;\n        this.updateElement(line, undefined, {\n            animated: !animationsDisabled,\n            options\n        }, mode);\n        this.updateElements(points, start, count, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === 'reset';\n        const { iScale , vScale , _stacked , _dataset  } = this._cachedMeta;\n        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const { spanGaps , segment  } = this.options;\n        const maxGapLength = helpers_dataset.isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n        const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n        const end = start + count;\n        const pointsCount = points.length;\n        let prevParsed = start > 0 && this.getParsed(start - 1);\n        for(let i = 0; i < pointsCount; ++i){\n            const point = points[i];\n            const properties = directUpdate ? point : {};\n            if (i < start || i >= end) {\n                properties.skip = true;\n                continue;\n            }\n            const parsed = this.getParsed(i);\n            const nullData = helpers_dataset.isNullOrUndef(parsed[vAxis]);\n            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\n            if (segment) {\n                properties.parsed = parsed;\n                properties.raw = _dataset.data[i];\n            }\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n            }\n            if (!directUpdate) {\n                this.updateElement(point, i, properties, mode);\n            }\n            prevParsed = parsed;\n        }\n    }\n getMaxOverflow() {\n        const meta = this._cachedMeta;\n        const dataset = meta.dataset;\n        const border = dataset.options && dataset.options.borderWidth || 0;\n        const data = meta.data || [];\n        if (!data.length) {\n            return border;\n        }\n        const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n        return Math.max(border, firstPoint, lastPoint) / 2;\n    }\n    draw() {\n        const meta = this._cachedMeta;\n        meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n        super.draw();\n    }\n}\n\nclass PolarAreaController extends DatasetController {\n    static id = 'polarArea';\n static defaults = {\n        dataElementType: 'arc',\n        animation: {\n            animateRotate: true,\n            animateScale: true\n        },\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'x',\n                    'y',\n                    'startAngle',\n                    'endAngle',\n                    'innerRadius',\n                    'outerRadius'\n                ]\n            }\n        },\n        indexAxis: 'r',\n        startAngle: 0\n    };\n static overrides = {\n        aspectRatio: 1,\n        plugins: {\n            legend: {\n                labels: {\n                    generateLabels (chart) {\n                        const data = chart.data;\n                        if (data.labels.length && data.datasets.length) {\n                            const { labels: { pointStyle , color  }  } = chart.legend.options;\n                            return data.labels.map((label, i)=>{\n                                const meta = chart.getDatasetMeta(0);\n                                const style = meta.controller.getStyle(i);\n                                return {\n                                    text: label,\n                                    fillStyle: style.backgroundColor,\n                                    strokeStyle: style.borderColor,\n                                    fontColor: color,\n                                    lineWidth: style.borderWidth,\n                                    pointStyle: pointStyle,\n                                    hidden: !chart.getDataVisibility(i),\n                                    index: i\n                                };\n                            });\n                        }\n                        return [];\n                    }\n                },\n                onClick (e, legendItem, legend) {\n                    legend.chart.toggleDataVisibility(legendItem.index);\n                    legend.chart.update();\n                }\n            }\n        },\n        scales: {\n            r: {\n                type: 'radialLinear',\n                angleLines: {\n                    display: false\n                },\n                beginAtZero: true,\n                grid: {\n                    circular: true\n                },\n                pointLabels: {\n                    display: false\n                },\n                startAngle: 0\n            }\n        }\n    };\n    constructor(chart, datasetIndex){\n        super(chart, datasetIndex);\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const chart = this.chart;\n        const labels = chart.data.labels || [];\n        const value = helpers_dataset.formatNumber(meta._parsed[index].r, chart.options.locale);\n        return {\n            label: labels[index] || '',\n            value\n        };\n    }\n    parseObjectData(meta, data, start, count) {\n        return helpers_dataset._parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n    }\n    update(mode) {\n        const arcs = this._cachedMeta.data;\n        this._updateRadius();\n        this.updateElements(arcs, 0, arcs.length, mode);\n    }\n getMinMax() {\n        const meta = this._cachedMeta;\n        const range = {\n            min: Number.POSITIVE_INFINITY,\n            max: Number.NEGATIVE_INFINITY\n        };\n        meta.data.forEach((element, index)=>{\n            const parsed = this.getParsed(index).r;\n            if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\n                if (parsed < range.min) {\n                    range.min = parsed;\n                }\n                if (parsed > range.max) {\n                    range.max = parsed;\n                }\n            }\n        });\n        return range;\n    }\n _updateRadius() {\n        const chart = this.chart;\n        const chartArea = chart.chartArea;\n        const opts = chart.options;\n        const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n        const outerRadius = Math.max(minSize / 2, 0);\n        const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);\n        const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n        this.outerRadius = outerRadius - radiusLength * this.index;\n        this.innerRadius = this.outerRadius - radiusLength;\n    }\n    updateElements(arcs, start, count, mode) {\n        const reset = mode === 'reset';\n        const chart = this.chart;\n        const opts = chart.options;\n        const animationOpts = opts.animation;\n        const scale = this._cachedMeta.rScale;\n        const centerX = scale.xCenter;\n        const centerY = scale.yCenter;\n        const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * helpers_dataset.PI;\n        let angle = datasetStartAngle;\n        let i;\n        const defaultAngle = 360 / this.countVisibleElements();\n        for(i = 0; i < start; ++i){\n            angle += this._computeAngle(i, mode, defaultAngle);\n        }\n        for(i = start; i < start + count; i++){\n            const arc = arcs[i];\n            let startAngle = angle;\n            let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n            let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\n            angle = endAngle;\n            if (reset) {\n                if (animationOpts.animateScale) {\n                    outerRadius = 0;\n                }\n                if (animationOpts.animateRotate) {\n                    startAngle = endAngle = datasetStartAngle;\n                }\n            }\n            const properties = {\n                x: centerX,\n                y: centerY,\n                innerRadius: 0,\n                outerRadius,\n                startAngle,\n                endAngle,\n                options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)\n            };\n            this.updateElement(arc, i, properties, mode);\n        }\n    }\n    countVisibleElements() {\n        const meta = this._cachedMeta;\n        let count = 0;\n        meta.data.forEach((element, index)=>{\n            if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\n                count++;\n            }\n        });\n        return count;\n    }\n _computeAngle(index, mode, defaultAngle) {\n        return this.chart.getDataVisibility(index) ? helpers_dataset.toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;\n    }\n}\n\nclass PieController extends DoughnutController {\n    static id = 'pie';\n static defaults = {\n        cutout: 0,\n        rotation: 0,\n        circumference: 360,\n        radius: '100%'\n    };\n}\n\nclass RadarController extends DatasetController {\n    static id = 'radar';\n static defaults = {\n        datasetElementType: 'line',\n        dataElementType: 'point',\n        indexAxis: 'r',\n        showLine: true,\n        elements: {\n            line: {\n                fill: 'start'\n            }\n        }\n    };\n static overrides = {\n        aspectRatio: 1,\n        scales: {\n            r: {\n                type: 'radialLinear'\n            }\n        }\n    };\n getLabelAndValue(index) {\n        const vScale = this._cachedMeta.vScale;\n        const parsed = this.getParsed(index);\n        return {\n            label: vScale.getLabels()[index],\n            value: '' + vScale.getLabelForValue(parsed[vScale.axis])\n        };\n    }\n    parseObjectData(meta, data, start, count) {\n        return helpers_dataset._parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const line = meta.dataset;\n        const points = meta.data || [];\n        const labels = meta.iScale.getLabels();\n        line.points = points;\n        if (mode !== 'resize') {\n            const options = this.resolveDatasetElementOptions(mode);\n            if (!this.options.showLine) {\n                options.borderWidth = 0;\n            }\n            const properties = {\n                _loop: true,\n                _fullLoop: labels.length === points.length,\n                options\n            };\n            this.updateElement(line, undefined, properties, mode);\n        }\n        this.updateElements(points, 0, points.length, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const scale = this._cachedMeta.rScale;\n        const reset = mode === 'reset';\n        for(let i = start; i < start + count; i++){\n            const point = points[i];\n            const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n            const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\n            const x = reset ? scale.xCenter : pointPosition.x;\n            const y = reset ? scale.yCenter : pointPosition.y;\n            const properties = {\n                x,\n                y,\n                angle: pointPosition.angle,\n                skip: isNaN(x) || isNaN(y),\n                options\n            };\n            this.updateElement(point, i, properties, mode);\n        }\n    }\n}\n\nclass ScatterController extends DatasetController {\n    static id = 'scatter';\n static defaults = {\n        datasetElementType: false,\n        dataElementType: 'point',\n        showLine: false,\n        fill: false\n    };\n static overrides = {\n        interaction: {\n            mode: 'point'\n        },\n        scales: {\n            x: {\n                type: 'linear'\n            },\n            y: {\n                type: 'linear'\n            }\n        }\n    };\n getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const labels = this.chart.data.labels || [];\n        const { xScale , yScale  } = meta;\n        const parsed = this.getParsed(index);\n        const x = xScale.getLabelForValue(parsed.x);\n        const y = yScale.getLabelForValue(parsed.y);\n        return {\n            label: labels[index] || '',\n            value: '(' + x + ', ' + y + ')'\n        };\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const { data: points = []  } = meta;\n        const animationsDisabled = this.chart._animationsDisabled;\n        let { start , count  } = helpers_dataset._getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n        this._drawStart = start;\n        this._drawCount = count;\n        if (helpers_dataset._scaleRangesChanged(meta)) {\n            start = 0;\n            count = points.length;\n        }\n        if (this.options.showLine) {\n            if (!this.datasetElementType) {\n                this.addElements();\n            }\n            const { dataset: line , _dataset  } = meta;\n            line._chart = this.chart;\n            line._datasetIndex = this.index;\n            line._decimated = !!_dataset._decimated;\n            line.points = points;\n            const options = this.resolveDatasetElementOptions(mode);\n            options.segment = this.options.segment;\n            this.updateElement(line, undefined, {\n                animated: !animationsDisabled,\n                options\n            }, mode);\n        } else if (this.datasetElementType) {\n            delete meta.dataset;\n            this.datasetElementType = false;\n        }\n        this.updateElements(points, start, count, mode);\n    }\n    addElements() {\n        const { showLine  } = this.options;\n        if (!this.datasetElementType && showLine) {\n            this.datasetElementType = this.chart.registry.getElement('line');\n        }\n        super.addElements();\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === 'reset';\n        const { iScale , vScale , _stacked , _dataset  } = this._cachedMeta;\n        const firstOpts = this.resolveDataElementOptions(start, mode);\n        const sharedOptions = this.getSharedOptions(firstOpts);\n        const includeOptions = this.includeOptions(mode, sharedOptions);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const { spanGaps , segment  } = this.options;\n        const maxGapLength = helpers_dataset.isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n        const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n        let prevParsed = start > 0 && this.getParsed(start - 1);\n        for(let i = start; i < start + count; ++i){\n            const point = points[i];\n            const parsed = this.getParsed(i);\n            const properties = directUpdate ? point : {};\n            const nullData = helpers_dataset.isNullOrUndef(parsed[vAxis]);\n            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\n            if (segment) {\n                properties.parsed = parsed;\n                properties.raw = _dataset.data[i];\n            }\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n            }\n            if (!directUpdate) {\n                this.updateElement(point, i, properties, mode);\n            }\n            prevParsed = parsed;\n        }\n        this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    }\n getMaxOverflow() {\n        const meta = this._cachedMeta;\n        const data = meta.data || [];\n        if (!this.options.showLine) {\n            let max = 0;\n            for(let i = data.length - 1; i >= 0; --i){\n                max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n            }\n            return max > 0 && max;\n        }\n        const dataset = meta.dataset;\n        const border = dataset.options && dataset.options.borderWidth || 0;\n        if (!data.length) {\n            return border;\n        }\n        const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n        return Math.max(border, firstPoint, lastPoint) / 2;\n    }\n}\n\nvar controllers = /*#__PURE__*/Object.freeze({\n__proto__: null,\nBarController: BarController,\nBubbleController: BubbleController,\nDoughnutController: DoughnutController,\nLineController: LineController,\nPieController: PieController,\nPolarAreaController: PolarAreaController,\nRadarController: RadarController,\nScatterController: ScatterController\n});\n\n/**\n * @namespace Chart._adapters\n * @since 2.8.0\n * @private\n */ function abstract() {\n    throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\n}\n/**\n * Date adapter (current used by the time scale)\n * @namespace Chart._adapters._date\n * @memberof Chart._adapters\n * @private\n */ class DateAdapterBase {\n    /**\n   * Override default date adapter methods.\n   * Accepts type parameter to define options type.\n   * @example\n   * Chart._adapters._date.override<{myAdapterOption: string}>({\n   *   init() {\n   *     console.log(this.options.myAdapterOption);\n   *   }\n   * })\n   */ static override(members) {\n        Object.assign(DateAdapterBase.prototype, members);\n    }\n    options;\n    constructor(options){\n        this.options = options || {};\n    }\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    init() {}\n    formats() {\n        return abstract();\n    }\n    parse() {\n        return abstract();\n    }\n    format() {\n        return abstract();\n    }\n    add() {\n        return abstract();\n    }\n    diff() {\n        return abstract();\n    }\n    startOf() {\n        return abstract();\n    }\n    endOf() {\n        return abstract();\n    }\n}\nvar adapters = {\n    _date: DateAdapterBase\n};\n\nfunction binarySearch(metaset, axis, value, intersect) {\n    const { controller , data , _sorted  } = metaset;\n    const iScale = controller._cachedMeta.iScale;\n    const spanGaps = metaset.dataset ? metaset.dataset.options ? metaset.dataset.options.spanGaps : null : null;\n    if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {\n        const lookupMethod = iScale._reversePixels ? helpers_dataset._rlookupByKey : helpers_dataset._lookupByKey;\n        if (!intersect) {\n            const result = lookupMethod(data, axis, value);\n            if (spanGaps) {\n                const { vScale  } = controller._cachedMeta;\n                const { _parsed  } = metaset;\n                const distanceToDefinedLo = _parsed.slice(0, result.lo + 1).reverse().findIndex((point)=>!helpers_dataset.isNullOrUndef(point[vScale.axis]));\n                result.lo -= Math.max(0, distanceToDefinedLo);\n                const distanceToDefinedHi = _parsed.slice(result.hi).findIndex((point)=>!helpers_dataset.isNullOrUndef(point[vScale.axis]));\n                result.hi += Math.max(0, distanceToDefinedHi);\n            }\n            return result;\n        } else if (controller._sharedOptions) {\n            const el = data[0];\n            const range = typeof el.getRange === 'function' && el.getRange(axis);\n            if (range) {\n                const start = lookupMethod(data, axis, value - range);\n                const end = lookupMethod(data, axis, value + range);\n                return {\n                    lo: start.lo,\n                    hi: end.hi\n                };\n            }\n        }\n    }\n    return {\n        lo: 0,\n        hi: data.length - 1\n    };\n}\n function evaluateInteractionItems(chart, axis, position, handler, intersect) {\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const value = position[axis];\n    for(let i = 0, ilen = metasets.length; i < ilen; ++i){\n        const { index , data  } = metasets[i];\n        const { lo , hi  } = binarySearch(metasets[i], axis, value, intersect);\n        for(let j = lo; j <= hi; ++j){\n            const element = data[j];\n            if (!element.skip) {\n                handler(element, index, j);\n            }\n        }\n    }\n}\n function getDistanceMetricForAxis(axis) {\n    const useX = axis.indexOf('x') !== -1;\n    const useY = axis.indexOf('y') !== -1;\n    return function(pt1, pt2) {\n        const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n        const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n    };\n}\n function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\n    const items = [];\n    if (!includeInvisible && !chart.isPointInArea(position)) {\n        return items;\n    }\n    const evaluationFunc = function(element, datasetIndex, index) {\n        if (!includeInvisible && !helpers_dataset._isPointInArea(element, chart.chartArea, 0)) {\n            return;\n        }\n        if (element.inRange(position.x, position.y, useFinalPosition)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    };\n    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\n    return items;\n}\n function getNearestRadialItems(chart, position, axis, useFinalPosition) {\n    let items = [];\n    function evaluationFunc(element, datasetIndex, index) {\n        const { startAngle , endAngle  } = element.getProps([\n            'startAngle',\n            'endAngle'\n        ], useFinalPosition);\n        const { angle  } = helpers_dataset.getAngleFromPoint(element, {\n            x: position.x,\n            y: position.y\n        });\n        if (helpers_dataset._angleBetween(angle, startAngle, endAngle)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    }\n    evaluateInteractionItems(chart, axis, position, evaluationFunc);\n    return items;\n}\n function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n    let items = [];\n    const distanceMetric = getDistanceMetricForAxis(axis);\n    let minDistance = Number.POSITIVE_INFINITY;\n    function evaluationFunc(element, datasetIndex, index) {\n        const inRange = element.inRange(position.x, position.y, useFinalPosition);\n        if (intersect && !inRange) {\n            return;\n        }\n        const center = element.getCenterPoint(useFinalPosition);\n        const pointInArea = !!includeInvisible || chart.isPointInArea(center);\n        if (!pointInArea && !inRange) {\n            return;\n        }\n        const distance = distanceMetric(position, center);\n        if (distance < minDistance) {\n            items = [\n                {\n                    element,\n                    datasetIndex,\n                    index\n                }\n            ];\n            minDistance = distance;\n        } else if (distance === minDistance) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    }\n    evaluateInteractionItems(chart, axis, position, evaluationFunc);\n    return items;\n}\n function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n    if (!includeInvisible && !chart.isPointInArea(position)) {\n        return [];\n    }\n    return axis === 'r' && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\n}\n function getAxisItems(chart, position, axis, intersect, useFinalPosition) {\n    const items = [];\n    const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\n    let intersectsItem = false;\n    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index)=>{\n        if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n            intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\n        }\n    });\n    if (intersect && !intersectsItem) {\n        return [];\n    }\n    return items;\n}\n var Interaction = {\n    evaluateInteractionItems,\n    modes: {\n index (chart, e, options, useFinalPosition) {\n            const position = helpers_dataset.getRelativePosition(e, chart);\n            const axis = options.axis || 'x';\n            const includeInvisible = options.includeInvisible || false;\n            const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n            const elements = [];\n            if (!items.length) {\n                return [];\n            }\n            chart.getSortedVisibleDatasetMetas().forEach((meta)=>{\n                const index = items[0].index;\n                const element = meta.data[index];\n                if (element && !element.skip) {\n                    elements.push({\n                        element,\n                        datasetIndex: meta.index,\n                        index\n                    });\n                }\n            });\n            return elements;\n        },\n dataset (chart, e, options, useFinalPosition) {\n            const position = helpers_dataset.getRelativePosition(e, chart);\n            const axis = options.axis || 'xy';\n            const includeInvisible = options.includeInvisible || false;\n            let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n            if (items.length > 0) {\n                const datasetIndex = items[0].datasetIndex;\n                const data = chart.getDatasetMeta(datasetIndex).data;\n                items = [];\n                for(let i = 0; i < data.length; ++i){\n                    items.push({\n                        element: data[i],\n                        datasetIndex,\n                        index: i\n                    });\n                }\n            }\n            return items;\n        },\n point (chart, e, options, useFinalPosition) {\n            const position = helpers_dataset.getRelativePosition(e, chart);\n            const axis = options.axis || 'xy';\n            const includeInvisible = options.includeInvisible || false;\n            return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\n        },\n nearest (chart, e, options, useFinalPosition) {\n            const position = helpers_dataset.getRelativePosition(e, chart);\n            const axis = options.axis || 'xy';\n            const includeInvisible = options.includeInvisible || false;\n            return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\n        },\n x (chart, e, options, useFinalPosition) {\n            const position = helpers_dataset.getRelativePosition(e, chart);\n            return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);\n        },\n y (chart, e, options, useFinalPosition) {\n            const position = helpers_dataset.getRelativePosition(e, chart);\n            return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);\n        }\n    }\n};\n\nconst STATIC_POSITIONS = [\n    'left',\n    'top',\n    'right',\n    'bottom'\n];\nfunction filterByPosition(array, position) {\n    return array.filter((v)=>v.pos === position);\n}\nfunction filterDynamicPositionByAxis(array, axis) {\n    return array.filter((v)=>STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\nfunction sortByWeight(array, reverse) {\n    return array.sort((a, b)=>{\n        const v0 = reverse ? b : a;\n        const v1 = reverse ? a : b;\n        return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;\n    });\n}\nfunction wrapBoxes(boxes) {\n    const layoutBoxes = [];\n    let i, ilen, box, pos, stack, stackWeight;\n    for(i = 0, ilen = (boxes || []).length; i < ilen; ++i){\n        box = boxes[i];\n        ({ position: pos , options: { stack , stackWeight =1  }  } = box);\n        layoutBoxes.push({\n            index: i,\n            box,\n            pos,\n            horizontal: box.isHorizontal(),\n            weight: box.weight,\n            stack: stack && pos + stack,\n            stackWeight\n        });\n    }\n    return layoutBoxes;\n}\nfunction buildStacks(layouts) {\n    const stacks = {};\n    for (const wrap of layouts){\n        const { stack , pos , stackWeight  } = wrap;\n        if (!stack || !STATIC_POSITIONS.includes(pos)) {\n            continue;\n        }\n        const _stack = stacks[stack] || (stacks[stack] = {\n            count: 0,\n            placed: 0,\n            weight: 0,\n            size: 0\n        });\n        _stack.count++;\n        _stack.weight += stackWeight;\n    }\n    return stacks;\n}\n function setLayoutDims(layouts, params) {\n    const stacks = buildStacks(layouts);\n    const { vBoxMaxWidth , hBoxMaxHeight  } = params;\n    let i, ilen, layout;\n    for(i = 0, ilen = layouts.length; i < ilen; ++i){\n        layout = layouts[i];\n        const { fullSize  } = layout.box;\n        const stack = stacks[layout.stack];\n        const factor = stack && layout.stackWeight / stack.weight;\n        if (layout.horizontal) {\n            layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n            layout.height = hBoxMaxHeight;\n        } else {\n            layout.width = vBoxMaxWidth;\n            layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n        }\n    }\n    return stacks;\n}\nfunction buildLayoutBoxes(boxes) {\n    const layoutBoxes = wrapBoxes(boxes);\n    const fullSize = sortByWeight(layoutBoxes.filter((wrap)=>wrap.box.fullSize), true);\n    const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\n    const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\n    const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\n    const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\n    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\n    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\n    return {\n        fullSize,\n        leftAndTop: left.concat(top),\n        rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n        chartArea: filterByPosition(layoutBoxes, 'chartArea'),\n        vertical: left.concat(right).concat(centerVertical),\n        horizontal: top.concat(bottom).concat(centerHorizontal)\n    };\n}\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\nfunction updateMaxPadding(maxPadding, boxPadding) {\n    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\nfunction updateDims(chartArea, params, layout, stacks) {\n    const { pos , box  } = layout;\n    const maxPadding = chartArea.maxPadding;\n    if (!helpers_dataset.isObject(pos)) {\n        if (layout.size) {\n            chartArea[pos] -= layout.size;\n        }\n        const stack = stacks[layout.stack] || {\n            size: 0,\n            count: 1\n        };\n        stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n        layout.size = stack.size / stack.count;\n        chartArea[pos] += layout.size;\n    }\n    if (box.getPadding) {\n        updateMaxPadding(maxPadding, box.getPadding());\n    }\n    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\n    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\n    const widthChanged = newWidth !== chartArea.w;\n    const heightChanged = newHeight !== chartArea.h;\n    chartArea.w = newWidth;\n    chartArea.h = newHeight;\n    return layout.horizontal ? {\n        same: widthChanged,\n        other: heightChanged\n    } : {\n        same: heightChanged,\n        other: widthChanged\n    };\n}\nfunction handleMaxPadding(chartArea) {\n    const maxPadding = chartArea.maxPadding;\n    function updatePos(pos) {\n        const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n        chartArea[pos] += change;\n        return change;\n    }\n    chartArea.y += updatePos('top');\n    chartArea.x += updatePos('left');\n    updatePos('right');\n    updatePos('bottom');\n}\nfunction getMargins(horizontal, chartArea) {\n    const maxPadding = chartArea.maxPadding;\n    function marginForPositions(positions) {\n        const margin = {\n            left: 0,\n            top: 0,\n            right: 0,\n            bottom: 0\n        };\n        positions.forEach((pos)=>{\n            margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n        });\n        return margin;\n    }\n    return horizontal ? marginForPositions([\n        'left',\n        'right'\n    ]) : marginForPositions([\n        'top',\n        'bottom'\n    ]);\n}\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n    const refitBoxes = [];\n    let i, ilen, layout, box, refit, changed;\n    for(i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i){\n        layout = boxes[i];\n        box = layout.box;\n        box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));\n        const { same , other  } = updateDims(chartArea, params, layout, stacks);\n        refit |= same && refitBoxes.length;\n        changed = changed || other;\n        if (!box.fullSize) {\n            refitBoxes.push(layout);\n        }\n    }\n    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\nfunction setBoxDims(box, left, top, width, height) {\n    box.top = top;\n    box.left = left;\n    box.right = left + width;\n    box.bottom = top + height;\n    box.width = width;\n    box.height = height;\n}\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n    const userPadding = params.padding;\n    let { x , y  } = chartArea;\n    for (const layout of boxes){\n        const box = layout.box;\n        const stack = stacks[layout.stack] || {\n            count: 1,\n            placed: 0,\n            weight: 1\n        };\n        const weight = layout.stackWeight / stack.weight || 1;\n        if (layout.horizontal) {\n            const width = chartArea.w * weight;\n            const height = stack.size || box.height;\n            if (helpers_dataset.defined(stack.start)) {\n                y = stack.start;\n            }\n            if (box.fullSize) {\n                setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n            } else {\n                setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n            }\n            stack.start = y;\n            stack.placed += width;\n            y = box.bottom;\n        } else {\n            const height = chartArea.h * weight;\n            const width = stack.size || box.width;\n            if (helpers_dataset.defined(stack.start)) {\n                x = stack.start;\n            }\n            if (box.fullSize) {\n                setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n            } else {\n                setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n            }\n            stack.start = x;\n            stack.placed += height;\n            x = box.right;\n        }\n    }\n    chartArea.x = x;\n    chartArea.y = y;\n}\nvar layouts = {\n addBox (chart, item) {\n        if (!chart.boxes) {\n            chart.boxes = [];\n        }\n        item.fullSize = item.fullSize || false;\n        item.position = item.position || 'top';\n        item.weight = item.weight || 0;\n        item._layers = item._layers || function() {\n            return [\n                {\n                    z: 0,\n                    draw (chartArea) {\n                        item.draw(chartArea);\n                    }\n                }\n            ];\n        };\n        chart.boxes.push(item);\n    },\n removeBox (chart, layoutItem) {\n        const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n        if (index !== -1) {\n            chart.boxes.splice(index, 1);\n        }\n    },\n configure (chart, item, options) {\n        item.fullSize = options.fullSize;\n        item.position = options.position;\n        item.weight = options.weight;\n    },\n update (chart, width, height, minPadding) {\n        if (!chart) {\n            return;\n        }\n        const padding = helpers_dataset.toPadding(chart.options.layout.padding);\n        const availableWidth = Math.max(width - padding.width, 0);\n        const availableHeight = Math.max(height - padding.height, 0);\n        const boxes = buildLayoutBoxes(chart.boxes);\n        const verticalBoxes = boxes.vertical;\n        const horizontalBoxes = boxes.horizontal;\n        helpers_dataset.each(chart.boxes, (box)=>{\n            if (typeof box.beforeLayout === 'function') {\n                box.beforeLayout();\n            }\n        });\n        const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap)=>wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n        const params = Object.freeze({\n            outerWidth: width,\n            outerHeight: height,\n            padding,\n            availableWidth,\n            availableHeight,\n            vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n            hBoxMaxHeight: availableHeight / 2\n        });\n        const maxPadding = Object.assign({}, padding);\n        updateMaxPadding(maxPadding, helpers_dataset.toPadding(minPadding));\n        const chartArea = Object.assign({\n            maxPadding,\n            w: availableWidth,\n            h: availableHeight,\n            x: padding.left,\n            y: padding.top\n        }, padding);\n        const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n        fitBoxes(boxes.fullSize, chartArea, params, stacks);\n        fitBoxes(verticalBoxes, chartArea, params, stacks);\n        if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n            fitBoxes(verticalBoxes, chartArea, params, stacks);\n        }\n        handleMaxPadding(chartArea);\n        placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n        chartArea.x += chartArea.w;\n        chartArea.y += chartArea.h;\n        placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n        chart.chartArea = {\n            left: chartArea.left,\n            top: chartArea.top,\n            right: chartArea.left + chartArea.w,\n            bottom: chartArea.top + chartArea.h,\n            height: chartArea.h,\n            width: chartArea.w\n        };\n        helpers_dataset.each(boxes.chartArea, (layout)=>{\n            const box = layout.box;\n            Object.assign(box, chart.chartArea);\n            box.update(chartArea.w, chartArea.h, {\n                left: 0,\n                top: 0,\n                right: 0,\n                bottom: 0\n            });\n        });\n    }\n};\n\nclass BasePlatform {\n acquireContext(canvas, aspectRatio) {}\n releaseContext(context) {\n        return false;\n    }\n addEventListener(chart, type, listener) {}\n removeEventListener(chart, type, listener) {}\n getDevicePixelRatio() {\n        return 1;\n    }\n getMaximumSize(element, width, height, aspectRatio) {\n        width = Math.max(0, width || element.width);\n        height = height || element.height;\n        return {\n            width,\n            height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n        };\n    }\n isAttached(canvas) {\n        return true;\n    }\n updateConfig(config) {\n    }\n}\n\nclass BasicPlatform extends BasePlatform {\n    acquireContext(item) {\n        return item && item.getContext && item.getContext('2d') || null;\n    }\n    updateConfig(config) {\n        config.options.animation = false;\n    }\n}\n\nconst EXPANDO_KEY = '$chartjs';\n const EVENT_TYPES = {\n    touchstart: 'mousedown',\n    touchmove: 'mousemove',\n    touchend: 'mouseup',\n    pointerenter: 'mouseenter',\n    pointerdown: 'mousedown',\n    pointermove: 'mousemove',\n    pointerup: 'mouseup',\n    pointerleave: 'mouseout',\n    pointerout: 'mouseout'\n};\nconst isNullOrEmpty = (value)=>value === null || value === '';\n function initCanvas(canvas, aspectRatio) {\n    const style = canvas.style;\n    const renderHeight = canvas.getAttribute('height');\n    const renderWidth = canvas.getAttribute('width');\n    canvas[EXPANDO_KEY] = {\n        initial: {\n            height: renderHeight,\n            width: renderWidth,\n            style: {\n                display: style.display,\n                height: style.height,\n                width: style.width\n            }\n        }\n    };\n    style.display = style.display || 'block';\n    style.boxSizing = style.boxSizing || 'border-box';\n    if (isNullOrEmpty(renderWidth)) {\n        const displayWidth = helpers_dataset.readUsedSize(canvas, 'width');\n        if (displayWidth !== undefined) {\n            canvas.width = displayWidth;\n        }\n    }\n    if (isNullOrEmpty(renderHeight)) {\n        if (canvas.style.height === '') {\n            canvas.height = canvas.width / (aspectRatio || 2);\n        } else {\n            const displayHeight = helpers_dataset.readUsedSize(canvas, 'height');\n            if (displayHeight !== undefined) {\n                canvas.height = displayHeight;\n            }\n        }\n    }\n    return canvas;\n}\nconst eventListenerOptions = helpers_dataset.supportsEventListenerOptions ? {\n    passive: true\n} : false;\nfunction addListener(node, type, listener) {\n    if (node) {\n        node.addEventListener(type, listener, eventListenerOptions);\n    }\n}\nfunction removeListener(chart, type, listener) {\n    if (chart && chart.canvas) {\n        chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n    }\n}\nfunction fromNativeEvent(event, chart) {\n    const type = EVENT_TYPES[event.type] || event.type;\n    const { x , y  } = helpers_dataset.getRelativePosition(event, chart);\n    return {\n        type,\n        chart,\n        native: event,\n        x: x !== undefined ? x : null,\n        y: y !== undefined ? y : null\n    };\n}\nfunction nodeListContains(nodeList, canvas) {\n    for (const node of nodeList){\n        if (node === canvas || node.contains(canvas)) {\n            return true;\n        }\n    }\n}\nfunction createAttachObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const observer = new MutationObserver((entries)=>{\n        let trigger = false;\n        for (const entry of entries){\n            trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n            trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n        }\n        if (trigger) {\n            listener();\n        }\n    });\n    observer.observe(document, {\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nfunction createDetachObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const observer = new MutationObserver((entries)=>{\n        let trigger = false;\n        for (const entry of entries){\n            trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n            trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n        }\n        if (trigger) {\n            listener();\n        }\n    });\n    observer.observe(document, {\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\nfunction onWindowResize() {\n    const dpr = window.devicePixelRatio;\n    if (dpr === oldDevicePixelRatio) {\n        return;\n    }\n    oldDevicePixelRatio = dpr;\n    drpListeningCharts.forEach((resize, chart)=>{\n        if (chart.currentDevicePixelRatio !== dpr) {\n            resize();\n        }\n    });\n}\nfunction listenDevicePixelRatioChanges(chart, resize) {\n    if (!drpListeningCharts.size) {\n        window.addEventListener('resize', onWindowResize);\n    }\n    drpListeningCharts.set(chart, resize);\n}\nfunction unlistenDevicePixelRatioChanges(chart) {\n    drpListeningCharts.delete(chart);\n    if (!drpListeningCharts.size) {\n        window.removeEventListener('resize', onWindowResize);\n    }\n}\nfunction createResizeObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const container = canvas && helpers_dataset._getParentNode(canvas);\n    if (!container) {\n        return;\n    }\n    const resize = helpers_dataset.throttled((width, height)=>{\n        const w = container.clientWidth;\n        listener(width, height);\n        if (w < container.clientWidth) {\n            listener();\n        }\n    }, window);\n    const observer = new ResizeObserver((entries)=>{\n        const entry = entries[0];\n        const width = entry.contentRect.width;\n        const height = entry.contentRect.height;\n        if (width === 0 && height === 0) {\n            return;\n        }\n        resize(width, height);\n    });\n    observer.observe(container);\n    listenDevicePixelRatioChanges(chart, resize);\n    return observer;\n}\nfunction releaseObserver(chart, type, observer) {\n    if (observer) {\n        observer.disconnect();\n    }\n    if (type === 'resize') {\n        unlistenDevicePixelRatioChanges(chart);\n    }\n}\nfunction createProxyAndListen(chart, type, listener) {\n    const canvas = chart.canvas;\n    const proxy = helpers_dataset.throttled((event)=>{\n        if (chart.ctx !== null) {\n            listener(fromNativeEvent(event, chart));\n        }\n    }, chart);\n    addListener(canvas, type, proxy);\n    return proxy;\n}\n class DomPlatform extends BasePlatform {\n acquireContext(canvas, aspectRatio) {\n        const context = canvas && canvas.getContext && canvas.getContext('2d');\n        if (context && context.canvas === canvas) {\n            initCanvas(canvas, aspectRatio);\n            return context;\n        }\n        return null;\n    }\n releaseContext(context) {\n        const canvas = context.canvas;\n        if (!canvas[EXPANDO_KEY]) {\n            return false;\n        }\n        const initial = canvas[EXPANDO_KEY].initial;\n        [\n            'height',\n            'width'\n        ].forEach((prop)=>{\n            const value = initial[prop];\n            if (helpers_dataset.isNullOrUndef(value)) {\n                canvas.removeAttribute(prop);\n            } else {\n                canvas.setAttribute(prop, value);\n            }\n        });\n        const style = initial.style || {};\n        Object.keys(style).forEach((key)=>{\n            canvas.style[key] = style[key];\n        });\n        canvas.width = canvas.width;\n        delete canvas[EXPANDO_KEY];\n        return true;\n    }\n addEventListener(chart, type, listener) {\n        this.removeEventListener(chart, type);\n        const proxies = chart.$proxies || (chart.$proxies = {});\n        const handlers = {\n            attach: createAttachObserver,\n            detach: createDetachObserver,\n            resize: createResizeObserver\n        };\n        const handler = handlers[type] || createProxyAndListen;\n        proxies[type] = handler(chart, type, listener);\n    }\n removeEventListener(chart, type) {\n        const proxies = chart.$proxies || (chart.$proxies = {});\n        const proxy = proxies[type];\n        if (!proxy) {\n            return;\n        }\n        const handlers = {\n            attach: releaseObserver,\n            detach: releaseObserver,\n            resize: releaseObserver\n        };\n        const handler = handlers[type] || removeListener;\n        handler(chart, type, proxy);\n        proxies[type] = undefined;\n    }\n    getDevicePixelRatio() {\n        return window.devicePixelRatio;\n    }\n getMaximumSize(canvas, width, height, aspectRatio) {\n        return helpers_dataset.getMaximumSize(canvas, width, height, aspectRatio);\n    }\n isAttached(canvas) {\n        const container = canvas && helpers_dataset._getParentNode(canvas);\n        return !!(container && container.isConnected);\n    }\n}\n\nfunction _detectPlatform(canvas) {\n    if (!helpers_dataset._isDomSupported() || typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {\n        return BasicPlatform;\n    }\n    return DomPlatform;\n}\n\nclass Element {\n    static defaults = {};\n    static defaultRoutes = undefined;\n    x;\n    y;\n    active = false;\n    options;\n    $animations;\n    tooltipPosition(useFinalPosition) {\n        const { x , y  } = this.getProps([\n            'x',\n            'y'\n        ], useFinalPosition);\n        return {\n            x,\n            y\n        };\n    }\n    hasValue() {\n        return helpers_dataset.isNumber(this.x) && helpers_dataset.isNumber(this.y);\n    }\n    getProps(props, final) {\n        const anims = this.$animations;\n        if (!final || !anims) {\n            // let's not create an object, if not needed\n            return this;\n        }\n        const ret = {};\n        props.forEach((prop)=>{\n            ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];\n        });\n        return ret;\n    }\n}\n\nfunction autoSkip(scale, ticks) {\n    const tickOpts = scale.options.ticks;\n    const determinedMaxTicks = determineMaxTicks(scale);\n    const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);\n    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n    const numMajorIndices = majorIndices.length;\n    const first = majorIndices[0];\n    const last = majorIndices[numMajorIndices - 1];\n    const newTicks = [];\n    if (numMajorIndices > ticksLimit) {\n        skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n        return newTicks;\n    }\n    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n    if (numMajorIndices > 0) {\n        let i, ilen;\n        const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n        skip(ticks, newTicks, spacing, helpers_dataset.isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n        for(i = 0, ilen = numMajorIndices - 1; i < ilen; i++){\n            skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n        }\n        skip(ticks, newTicks, spacing, last, helpers_dataset.isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n        return newTicks;\n    }\n    skip(ticks, newTicks, spacing);\n    return newTicks;\n}\nfunction determineMaxTicks(scale) {\n    const offset = scale.options.offset;\n    const tickLength = scale._tickSize();\n    const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n    const maxChart = scale._maxLength / tickLength;\n    return Math.floor(Math.min(maxScale, maxChart));\n}\n function calculateSpacing(majorIndices, ticks, ticksLimit) {\n    const evenMajorSpacing = getEvenSpacing(majorIndices);\n    const spacing = ticks.length / ticksLimit;\n    if (!evenMajorSpacing) {\n        return Math.max(spacing, 1);\n    }\n    const factors = helpers_dataset._factorize(evenMajorSpacing);\n    for(let i = 0, ilen = factors.length - 1; i < ilen; i++){\n        const factor = factors[i];\n        if (factor > spacing) {\n            return factor;\n        }\n    }\n    return Math.max(spacing, 1);\n}\n function getMajorIndices(ticks) {\n    const result = [];\n    let i, ilen;\n    for(i = 0, ilen = ticks.length; i < ilen; i++){\n        if (ticks[i].major) {\n            result.push(i);\n        }\n    }\n    return result;\n}\n function skipMajors(ticks, newTicks, majorIndices, spacing) {\n    let count = 0;\n    let next = majorIndices[0];\n    let i;\n    spacing = Math.ceil(spacing);\n    for(i = 0; i < ticks.length; i++){\n        if (i === next) {\n            newTicks.push(ticks[i]);\n            count++;\n            next = majorIndices[count * spacing];\n        }\n    }\n}\n function skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n    const start = helpers_dataset.valueOrDefault(majorStart, 0);\n    const end = Math.min(helpers_dataset.valueOrDefault(majorEnd, ticks.length), ticks.length);\n    let count = 0;\n    let length, i, next;\n    spacing = Math.ceil(spacing);\n    if (majorEnd) {\n        length = majorEnd - majorStart;\n        spacing = length / Math.floor(length / spacing);\n    }\n    next = start;\n    while(next < 0){\n        count++;\n        next = Math.round(start + count * spacing);\n    }\n    for(i = Math.max(start, 0); i < end; i++){\n        if (i === next) {\n            newTicks.push(ticks[i]);\n            count++;\n            next = Math.round(start + count * spacing);\n        }\n    }\n}\n function getEvenSpacing(arr) {\n    const len = arr.length;\n    let i, diff;\n    if (len < 2) {\n        return false;\n    }\n    for(diff = arr[0], i = 1; i < len; ++i){\n        if (arr[i] - arr[i - 1] !== diff) {\n            return false;\n        }\n    }\n    return diff;\n}\n\nconst reverseAlign = (align)=>align === 'left' ? 'right' : align === 'right' ? 'left' : align;\nconst offsetFromEdge = (scale, edge, offset)=>edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\nconst getTicksLimit = (ticksLength, maxTicksLimit)=>Math.min(maxTicksLimit || ticksLength, ticksLength);\n function sample(arr, numItems) {\n    const result = [];\n    const increment = arr.length / numItems;\n    const len = arr.length;\n    let i = 0;\n    for(; i < len; i += increment){\n        result.push(arr[Math.floor(i)]);\n    }\n    return result;\n}\n function getPixelForGridLine(scale, index, offsetGridLines) {\n    const length = scale.ticks.length;\n    const validIndex = Math.min(index, length - 1);\n    const start = scale._startPixel;\n    const end = scale._endPixel;\n    const epsilon = 1e-6;\n    let lineValue = scale.getPixelForTick(validIndex);\n    let offset;\n    if (offsetGridLines) {\n        if (length === 1) {\n            offset = Math.max(lineValue - start, end - lineValue);\n        } else if (index === 0) {\n            offset = (scale.getPixelForTick(1) - lineValue) / 2;\n        } else {\n            offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n        }\n        lineValue += validIndex < index ? offset : -offset;\n        if (lineValue < start - epsilon || lineValue > end + epsilon) {\n            return;\n        }\n    }\n    return lineValue;\n}\n function garbageCollect(caches, length) {\n    helpers_dataset.each(caches, (cache)=>{\n        const gc = cache.gc;\n        const gcLen = gc.length / 2;\n        let i;\n        if (gcLen > length) {\n            for(i = 0; i < gcLen; ++i){\n                delete cache.data[gc[i]];\n            }\n            gc.splice(0, gcLen);\n        }\n    });\n}\n function getTickMarkLength(options) {\n    return options.drawTicks ? options.tickLength : 0;\n}\n function getTitleHeight(options, fallback) {\n    if (!options.display) {\n        return 0;\n    }\n    const font = helpers_dataset.toFont(options.font, fallback);\n    const padding = helpers_dataset.toPadding(options.padding);\n    const lines = helpers_dataset.isArray(options.text) ? options.text.length : 1;\n    return lines * font.lineHeight + padding.height;\n}\nfunction createScaleContext(parent, scale) {\n    return helpers_dataset.createContext(parent, {\n        scale,\n        type: 'scale'\n    });\n}\nfunction createTickContext(parent, index, tick) {\n    return helpers_dataset.createContext(parent, {\n        tick,\n        index,\n        type: 'tick'\n    });\n}\nfunction titleAlign(align, position, reverse) {\n     let ret = helpers_dataset._toLeftRightCenter(align);\n    if (reverse && position !== 'right' || !reverse && position === 'right') {\n        ret = reverseAlign(ret);\n    }\n    return ret;\n}\nfunction titleArgs(scale, offset, position, align) {\n    const { top , left , bottom , right , chart  } = scale;\n    const { chartArea , scales  } = chart;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n    const height = bottom - top;\n    const width = right - left;\n    if (scale.isHorizontal()) {\n        titleX = helpers_dataset._alignStartEnd(align, left, right);\n        if (helpers_dataset.isObject(position)) {\n            const positionAxisID = Object.keys(position)[0];\n            const value = position[positionAxisID];\n            titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n        } else if (position === 'center') {\n            titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n        } else {\n            titleY = offsetFromEdge(scale, position, offset);\n        }\n        maxWidth = right - left;\n    } else {\n        if (helpers_dataset.isObject(position)) {\n            const positionAxisID = Object.keys(position)[0];\n            const value = position[positionAxisID];\n            titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n        } else if (position === 'center') {\n            titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n        } else {\n            titleX = offsetFromEdge(scale, position, offset);\n        }\n        titleY = helpers_dataset._alignStartEnd(align, bottom, top);\n        rotation = position === 'left' ? -helpers_dataset.HALF_PI : helpers_dataset.HALF_PI;\n    }\n    return {\n        titleX,\n        titleY,\n        maxWidth,\n        rotation\n    };\n}\nclass Scale extends Element {\n    constructor(cfg){\n        super();\n         this.id = cfg.id;\n         this.type = cfg.type;\n         this.options = undefined;\n         this.ctx = cfg.ctx;\n         this.chart = cfg.chart;\n         this.top = undefined;\n         this.bottom = undefined;\n         this.left = undefined;\n         this.right = undefined;\n         this.width = undefined;\n         this.height = undefined;\n        this._margins = {\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n        };\n         this.maxWidth = undefined;\n         this.maxHeight = undefined;\n         this.paddingTop = undefined;\n         this.paddingBottom = undefined;\n         this.paddingLeft = undefined;\n         this.paddingRight = undefined;\n         this.axis = undefined;\n         this.labelRotation = undefined;\n        this.min = undefined;\n        this.max = undefined;\n        this._range = undefined;\n         this.ticks = [];\n         this._gridLineItems = null;\n         this._labelItems = null;\n         this._labelSizes = null;\n        this._length = 0;\n        this._maxLength = 0;\n        this._longestTextCache = {};\n         this._startPixel = undefined;\n         this._endPixel = undefined;\n        this._reversePixels = false;\n        this._userMax = undefined;\n        this._userMin = undefined;\n        this._suggestedMax = undefined;\n        this._suggestedMin = undefined;\n        this._ticksLength = 0;\n        this._borderValue = 0;\n        this._cache = {};\n        this._dataLimitsCached = false;\n        this.$context = undefined;\n    }\n init(options) {\n        this.options = options.setContext(this.getContext());\n        this.axis = options.axis;\n        this._userMin = this.parse(options.min);\n        this._userMax = this.parse(options.max);\n        this._suggestedMin = this.parse(options.suggestedMin);\n        this._suggestedMax = this.parse(options.suggestedMax);\n    }\n parse(raw, index) {\n        return raw;\n    }\n getUserBounds() {\n        let { _userMin , _userMax , _suggestedMin , _suggestedMax  } = this;\n        _userMin = helpers_dataset.finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\n        _userMax = helpers_dataset.finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\n        _suggestedMin = helpers_dataset.finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\n        _suggestedMax = helpers_dataset.finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\n        return {\n            min: helpers_dataset.finiteOrDefault(_userMin, _suggestedMin),\n            max: helpers_dataset.finiteOrDefault(_userMax, _suggestedMax),\n            minDefined: helpers_dataset.isNumberFinite(_userMin),\n            maxDefined: helpers_dataset.isNumberFinite(_userMax)\n        };\n    }\n getMinMax(canStack) {\n        let { min , max , minDefined , maxDefined  } = this.getUserBounds();\n        let range;\n        if (minDefined && maxDefined) {\n            return {\n                min,\n                max\n            };\n        }\n        const metas = this.getMatchingVisibleMetas();\n        for(let i = 0, ilen = metas.length; i < ilen; ++i){\n            range = metas[i].controller.getMinMax(this, canStack);\n            if (!minDefined) {\n                min = Math.min(min, range.min);\n            }\n            if (!maxDefined) {\n                max = Math.max(max, range.max);\n            }\n        }\n        min = maxDefined && min > max ? max : min;\n        max = minDefined && min > max ? min : max;\n        return {\n            min: helpers_dataset.finiteOrDefault(min, helpers_dataset.finiteOrDefault(max, min)),\n            max: helpers_dataset.finiteOrDefault(max, helpers_dataset.finiteOrDefault(min, max))\n        };\n    }\n getPadding() {\n        return {\n            left: this.paddingLeft || 0,\n            top: this.paddingTop || 0,\n            right: this.paddingRight || 0,\n            bottom: this.paddingBottom || 0\n        };\n    }\n getTicks() {\n        return this.ticks;\n    }\n getLabels() {\n        const data = this.chart.data;\n        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n    }\n getLabelItems(chartArea = this.chart.chartArea) {\n        const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n        return items;\n    }\n    beforeLayout() {\n        this._cache = {};\n        this._dataLimitsCached = false;\n    }\n    beforeUpdate() {\n        helpers_dataset.callback(this.options.beforeUpdate, [\n            this\n        ]);\n    }\n update(maxWidth, maxHeight, margins) {\n        const { beginAtZero , grace , ticks: tickOpts  } = this.options;\n        const sampleSize = tickOpts.sampleSize;\n        this.beforeUpdate();\n        this.maxWidth = maxWidth;\n        this.maxHeight = maxHeight;\n        this._margins = margins = Object.assign({\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n        }, margins);\n        this.ticks = null;\n        this._labelSizes = null;\n        this._gridLineItems = null;\n        this._labelItems = null;\n        this.beforeSetDimensions();\n        this.setDimensions();\n        this.afterSetDimensions();\n        this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;\n        if (!this._dataLimitsCached) {\n            this.beforeDataLimits();\n            this.determineDataLimits();\n            this.afterDataLimits();\n            this._range = helpers_dataset._addGrace(this, grace, beginAtZero);\n            this._dataLimitsCached = true;\n        }\n        this.beforeBuildTicks();\n        this.ticks = this.buildTicks() || [];\n        this.afterBuildTicks();\n        const samplingEnabled = sampleSize < this.ticks.length;\n        this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n        this.configure();\n        this.beforeCalculateLabelRotation();\n        this.calculateLabelRotation();\n        this.afterCalculateLabelRotation();\n        if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\n            this.ticks = autoSkip(this, this.ticks);\n            this._labelSizes = null;\n            this.afterAutoSkip();\n        }\n        if (samplingEnabled) {\n            this._convertTicksToLabels(this.ticks);\n        }\n        this.beforeFit();\n        this.fit();\n        this.afterFit();\n        this.afterUpdate();\n    }\n configure() {\n        let reversePixels = this.options.reverse;\n        let startPixel, endPixel;\n        if (this.isHorizontal()) {\n            startPixel = this.left;\n            endPixel = this.right;\n        } else {\n            startPixel = this.top;\n            endPixel = this.bottom;\n            reversePixels = !reversePixels;\n        }\n        this._startPixel = startPixel;\n        this._endPixel = endPixel;\n        this._reversePixels = reversePixels;\n        this._length = endPixel - startPixel;\n        this._alignToPixels = this.options.alignToPixels;\n    }\n    afterUpdate() {\n        helpers_dataset.callback(this.options.afterUpdate, [\n            this\n        ]);\n    }\n    beforeSetDimensions() {\n        helpers_dataset.callback(this.options.beforeSetDimensions, [\n            this\n        ]);\n    }\n    setDimensions() {\n        if (this.isHorizontal()) {\n            this.width = this.maxWidth;\n            this.left = 0;\n            this.right = this.width;\n        } else {\n            this.height = this.maxHeight;\n            this.top = 0;\n            this.bottom = this.height;\n        }\n        this.paddingLeft = 0;\n        this.paddingTop = 0;\n        this.paddingRight = 0;\n        this.paddingBottom = 0;\n    }\n    afterSetDimensions() {\n        helpers_dataset.callback(this.options.afterSetDimensions, [\n            this\n        ]);\n    }\n    _callHooks(name) {\n        this.chart.notifyPlugins(name, this.getContext());\n        helpers_dataset.callback(this.options[name], [\n            this\n        ]);\n    }\n    beforeDataLimits() {\n        this._callHooks('beforeDataLimits');\n    }\n    determineDataLimits() {}\n    afterDataLimits() {\n        this._callHooks('afterDataLimits');\n    }\n    beforeBuildTicks() {\n        this._callHooks('beforeBuildTicks');\n    }\n buildTicks() {\n        return [];\n    }\n    afterBuildTicks() {\n        this._callHooks('afterBuildTicks');\n    }\n    beforeTickToLabelConversion() {\n        helpers_dataset.callback(this.options.beforeTickToLabelConversion, [\n            this\n        ]);\n    }\n generateTickLabels(ticks) {\n        const tickOpts = this.options.ticks;\n        let i, ilen, tick;\n        for(i = 0, ilen = ticks.length; i < ilen; i++){\n            tick = ticks[i];\n            tick.label = helpers_dataset.callback(tickOpts.callback, [\n                tick.value,\n                i,\n                ticks\n            ], this);\n        }\n    }\n    afterTickToLabelConversion() {\n        helpers_dataset.callback(this.options.afterTickToLabelConversion, [\n            this\n        ]);\n    }\n    beforeCalculateLabelRotation() {\n        helpers_dataset.callback(this.options.beforeCalculateLabelRotation, [\n            this\n        ]);\n    }\n    calculateLabelRotation() {\n        const options = this.options;\n        const tickOpts = options.ticks;\n        const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);\n        const minRotation = tickOpts.minRotation || 0;\n        const maxRotation = tickOpts.maxRotation;\n        let labelRotation = minRotation;\n        let tickWidth, maxHeight, maxLabelDiagonal;\n        if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n            this.labelRotation = minRotation;\n            return;\n        }\n        const labelSizes = this._getLabelSizes();\n        const maxLabelWidth = labelSizes.widest.width;\n        const maxLabelHeight = labelSizes.highest.height;\n        const maxWidth = helpers_dataset._limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n        tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n        if (maxLabelWidth + 6 > tickWidth) {\n            tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n            maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n            maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n            labelRotation = helpers_dataset.toDegrees(Math.min(Math.asin(helpers_dataset._limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(helpers_dataset._limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(helpers_dataset._limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));\n            labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n        }\n        this.labelRotation = labelRotation;\n    }\n    afterCalculateLabelRotation() {\n        helpers_dataset.callback(this.options.afterCalculateLabelRotation, [\n            this\n        ]);\n    }\n    afterAutoSkip() {}\n    beforeFit() {\n        helpers_dataset.callback(this.options.beforeFit, [\n            this\n        ]);\n    }\n    fit() {\n        const minSize = {\n            width: 0,\n            height: 0\n        };\n        const { chart , options: { ticks: tickOpts , title: titleOpts , grid: gridOpts  }  } = this;\n        const display = this._isVisible();\n        const isHorizontal = this.isHorizontal();\n        if (display) {\n            const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n            if (isHorizontal) {\n                minSize.width = this.maxWidth;\n                minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n            } else {\n                minSize.height = this.maxHeight;\n                minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n            }\n            if (tickOpts.display && this.ticks.length) {\n                const { first , last , widest , highest  } = this._getLabelSizes();\n                const tickPadding = tickOpts.padding * 2;\n                const angleRadians = helpers_dataset.toRadians(this.labelRotation);\n                const cos = Math.cos(angleRadians);\n                const sin = Math.sin(angleRadians);\n                if (isHorizontal) {\n                    const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n                    minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n                } else {\n                    const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n                    minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n                }\n                this._calculatePadding(first, last, sin, cos);\n            }\n        }\n        this._handleMargins();\n        if (isHorizontal) {\n            this.width = this._length = chart.width - this._margins.left - this._margins.right;\n            this.height = minSize.height;\n        } else {\n            this.width = minSize.width;\n            this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n        }\n    }\n    _calculatePadding(first, last, sin, cos) {\n        const { ticks: { align , padding  } , position  } = this.options;\n        const isRotated = this.labelRotation !== 0;\n        const labelsBelowTicks = position !== 'top' && this.axis === 'x';\n        if (this.isHorizontal()) {\n            const offsetLeft = this.getPixelForTick(0) - this.left;\n            const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n            let paddingLeft = 0;\n            let paddingRight = 0;\n            if (isRotated) {\n                if (labelsBelowTicks) {\n                    paddingLeft = cos * first.width;\n                    paddingRight = sin * last.height;\n                } else {\n                    paddingLeft = sin * first.height;\n                    paddingRight = cos * last.width;\n                }\n            } else if (align === 'start') {\n                paddingRight = last.width;\n            } else if (align === 'end') {\n                paddingLeft = first.width;\n            } else if (align !== 'inner') {\n                paddingLeft = first.width / 2;\n                paddingRight = last.width / 2;\n            }\n            this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n            this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n        } else {\n            let paddingTop = last.height / 2;\n            let paddingBottom = first.height / 2;\n            if (align === 'start') {\n                paddingTop = 0;\n                paddingBottom = first.height;\n            } else if (align === 'end') {\n                paddingTop = last.height;\n                paddingBottom = 0;\n            }\n            this.paddingTop = paddingTop + padding;\n            this.paddingBottom = paddingBottom + padding;\n        }\n    }\n _handleMargins() {\n        if (this._margins) {\n            this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n            this._margins.top = Math.max(this.paddingTop, this._margins.top);\n            this._margins.right = Math.max(this.paddingRight, this._margins.right);\n            this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n        }\n    }\n    afterFit() {\n        helpers_dataset.callback(this.options.afterFit, [\n            this\n        ]);\n    }\n isHorizontal() {\n        const { axis , position  } = this.options;\n        return position === 'top' || position === 'bottom' || axis === 'x';\n    }\n isFullSize() {\n        return this.options.fullSize;\n    }\n _convertTicksToLabels(ticks) {\n        this.beforeTickToLabelConversion();\n        this.generateTickLabels(ticks);\n        let i, ilen;\n        for(i = 0, ilen = ticks.length; i < ilen; i++){\n            if (helpers_dataset.isNullOrUndef(ticks[i].label)) {\n                ticks.splice(i, 1);\n                ilen--;\n                i--;\n            }\n        }\n        this.afterTickToLabelConversion();\n    }\n _getLabelSizes() {\n        let labelSizes = this._labelSizes;\n        if (!labelSizes) {\n            const sampleSize = this.options.ticks.sampleSize;\n            let ticks = this.ticks;\n            if (sampleSize < ticks.length) {\n                ticks = sample(ticks, sampleSize);\n            }\n            this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);\n        }\n        return labelSizes;\n    }\n _computeLabelSizes(ticks, length, maxTicksLimit) {\n        const { ctx , _longestTextCache: caches  } = this;\n        const widths = [];\n        const heights = [];\n        const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));\n        let widestLabelSize = 0;\n        let highestLabelSize = 0;\n        let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n        for(i = 0; i < length; i += increment){\n            label = ticks[i].label;\n            tickFont = this._resolveTickFontOptions(i);\n            ctx.font = fontString = tickFont.string;\n            cache = caches[fontString] = caches[fontString] || {\n                data: {},\n                gc: []\n            };\n            lineHeight = tickFont.lineHeight;\n            width = height = 0;\n            if (!helpers_dataset.isNullOrUndef(label) && !helpers_dataset.isArray(label)) {\n                width = helpers_dataset._measureText(ctx, cache.data, cache.gc, width, label);\n                height = lineHeight;\n            } else if (helpers_dataset.isArray(label)) {\n                for(j = 0, jlen = label.length; j < jlen; ++j){\n                    nestedLabel =  label[j];\n                    if (!helpers_dataset.isNullOrUndef(nestedLabel) && !helpers_dataset.isArray(nestedLabel)) {\n                        width = helpers_dataset._measureText(ctx, cache.data, cache.gc, width, nestedLabel);\n                        height += lineHeight;\n                    }\n                }\n            }\n            widths.push(width);\n            heights.push(height);\n            widestLabelSize = Math.max(width, widestLabelSize);\n            highestLabelSize = Math.max(height, highestLabelSize);\n        }\n        garbageCollect(caches, length);\n        const widest = widths.indexOf(widestLabelSize);\n        const highest = heights.indexOf(highestLabelSize);\n        const valueAt = (idx)=>({\n                width: widths[idx] || 0,\n                height: heights[idx] || 0\n            });\n        return {\n            first: valueAt(0),\n            last: valueAt(length - 1),\n            widest: valueAt(widest),\n            highest: valueAt(highest),\n            widths,\n            heights\n        };\n    }\n getLabelForValue(value) {\n        return value;\n    }\n getPixelForValue(value, index) {\n        return NaN;\n    }\n getValueForPixel(pixel) {}\n getPixelForTick(index) {\n        const ticks = this.ticks;\n        if (index < 0 || index > ticks.length - 1) {\n            return null;\n        }\n        return this.getPixelForValue(ticks[index].value);\n    }\n getPixelForDecimal(decimal) {\n        if (this._reversePixels) {\n            decimal = 1 - decimal;\n        }\n        const pixel = this._startPixel + decimal * this._length;\n        return helpers_dataset._int16Range(this._alignToPixels ? helpers_dataset._alignPixel(this.chart, pixel, 0) : pixel);\n    }\n getDecimalForPixel(pixel) {\n        const decimal = (pixel - this._startPixel) / this._length;\n        return this._reversePixels ? 1 - decimal : decimal;\n    }\n getBasePixel() {\n        return this.getPixelForValue(this.getBaseValue());\n    }\n getBaseValue() {\n        const { min , max  } = this;\n        return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;\n    }\n getContext(index) {\n        const ticks = this.ticks || [];\n        if (index >= 0 && index < ticks.length) {\n            const tick = ticks[index];\n            return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));\n        }\n        return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));\n    }\n _tickSize() {\n        const optionTicks = this.options.ticks;\n        const rot = helpers_dataset.toRadians(this.labelRotation);\n        const cos = Math.abs(Math.cos(rot));\n        const sin = Math.abs(Math.sin(rot));\n        const labelSizes = this._getLabelSizes();\n        const padding = optionTicks.autoSkipPadding || 0;\n        const w = labelSizes ? labelSizes.widest.width + padding : 0;\n        const h = labelSizes ? labelSizes.highest.height + padding : 0;\n        return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;\n    }\n _isVisible() {\n        const display = this.options.display;\n        if (display !== 'auto') {\n            return !!display;\n        }\n        return this.getMatchingVisibleMetas().length > 0;\n    }\n _computeGridLineItems(chartArea) {\n        const axis = this.axis;\n        const chart = this.chart;\n        const options = this.options;\n        const { grid , position , border  } = options;\n        const offset = grid.offset;\n        const isHorizontal = this.isHorizontal();\n        const ticks = this.ticks;\n        const ticksLength = ticks.length + (offset ? 1 : 0);\n        const tl = getTickMarkLength(grid);\n        const items = [];\n        const borderOpts = border.setContext(this.getContext());\n        const axisWidth = borderOpts.display ? borderOpts.width : 0;\n        const axisHalfWidth = axisWidth / 2;\n        const alignBorderValue = function(pixel) {\n            return helpers_dataset._alignPixel(chart, pixel, axisWidth);\n        };\n        let borderValue, i, lineValue, alignedLineValue;\n        let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n        if (position === 'top') {\n            borderValue = alignBorderValue(this.bottom);\n            ty1 = this.bottom - tl;\n            ty2 = borderValue - axisHalfWidth;\n            y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n            y2 = chartArea.bottom;\n        } else if (position === 'bottom') {\n            borderValue = alignBorderValue(this.top);\n            y1 = chartArea.top;\n            y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n            ty1 = borderValue + axisHalfWidth;\n            ty2 = this.top + tl;\n        } else if (position === 'left') {\n            borderValue = alignBorderValue(this.right);\n            tx1 = this.right - tl;\n            tx2 = borderValue - axisHalfWidth;\n            x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n            x2 = chartArea.right;\n        } else if (position === 'right') {\n            borderValue = alignBorderValue(this.left);\n            x1 = chartArea.left;\n            x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n            tx1 = borderValue + axisHalfWidth;\n            tx2 = this.left + tl;\n        } else if (axis === 'x') {\n            if (position === 'center') {\n                borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n            } else if (helpers_dataset.isObject(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n            }\n            y1 = chartArea.top;\n            y2 = chartArea.bottom;\n            ty1 = borderValue + axisHalfWidth;\n            ty2 = ty1 + tl;\n        } else if (axis === 'y') {\n            if (position === 'center') {\n                borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n            } else if (helpers_dataset.isObject(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n            }\n            tx1 = borderValue - axisHalfWidth;\n            tx2 = tx1 - tl;\n            x1 = chartArea.left;\n            x2 = chartArea.right;\n        }\n        const limit = helpers_dataset.valueOrDefault(options.ticks.maxTicksLimit, ticksLength);\n        const step = Math.max(1, Math.ceil(ticksLength / limit));\n        for(i = 0; i < ticksLength; i += step){\n            const context = this.getContext(i);\n            const optsAtIndex = grid.setContext(context);\n            const optsAtIndexBorder = border.setContext(context);\n            const lineWidth = optsAtIndex.lineWidth;\n            const lineColor = optsAtIndex.color;\n            const borderDash = optsAtIndexBorder.dash || [];\n            const borderDashOffset = optsAtIndexBorder.dashOffset;\n            const tickWidth = optsAtIndex.tickWidth;\n            const tickColor = optsAtIndex.tickColor;\n            const tickBorderDash = optsAtIndex.tickBorderDash || [];\n            const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n            lineValue = getPixelForGridLine(this, i, offset);\n            if (lineValue === undefined) {\n                continue;\n            }\n            alignedLineValue = helpers_dataset._alignPixel(chart, lineValue, lineWidth);\n            if (isHorizontal) {\n                tx1 = tx2 = x1 = x2 = alignedLineValue;\n            } else {\n                ty1 = ty2 = y1 = y2 = alignedLineValue;\n            }\n            items.push({\n                tx1,\n                ty1,\n                tx2,\n                ty2,\n                x1,\n                y1,\n                x2,\n                y2,\n                width: lineWidth,\n                color: lineColor,\n                borderDash,\n                borderDashOffset,\n                tickWidth,\n                tickColor,\n                tickBorderDash,\n                tickBorderDashOffset\n            });\n        }\n        this._ticksLength = ticksLength;\n        this._borderValue = borderValue;\n        return items;\n    }\n _computeLabelItems(chartArea) {\n        const axis = this.axis;\n        const options = this.options;\n        const { position , ticks: optionTicks  } = options;\n        const isHorizontal = this.isHorizontal();\n        const ticks = this.ticks;\n        const { align , crossAlign , padding , mirror  } = optionTicks;\n        const tl = getTickMarkLength(options.grid);\n        const tickAndPadding = tl + padding;\n        const hTickAndPadding = mirror ? -padding : tickAndPadding;\n        const rotation = -helpers_dataset.toRadians(this.labelRotation);\n        const items = [];\n        let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n        let textBaseline = 'middle';\n        if (position === 'top') {\n            y = this.bottom - hTickAndPadding;\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (position === 'bottom') {\n            y = this.top + hTickAndPadding;\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (position === 'left') {\n            const ret = this._getYAxisLabelAlignment(tl);\n            textAlign = ret.textAlign;\n            x = ret.x;\n        } else if (position === 'right') {\n            const ret = this._getYAxisLabelAlignment(tl);\n            textAlign = ret.textAlign;\n            x = ret.x;\n        } else if (axis === 'x') {\n            if (position === 'center') {\n                y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;\n            } else if (helpers_dataset.isObject(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n            }\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (axis === 'y') {\n            if (position === 'center') {\n                x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;\n            } else if (helpers_dataset.isObject(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                x = this.chart.scales[positionAxisID].getPixelForValue(value);\n            }\n            textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n        }\n        if (axis === 'y') {\n            if (align === 'start') {\n                textBaseline = 'top';\n            } else if (align === 'end') {\n                textBaseline = 'bottom';\n            }\n        }\n        const labelSizes = this._getLabelSizes();\n        for(i = 0, ilen = ticks.length; i < ilen; ++i){\n            tick = ticks[i];\n            label = tick.label;\n            const optsAtIndex = optionTicks.setContext(this.getContext(i));\n            pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n            font = this._resolveTickFontOptions(i);\n            lineHeight = font.lineHeight;\n            lineCount = helpers_dataset.isArray(label) ? label.length : 1;\n            const halfCount = lineCount / 2;\n            const color = optsAtIndex.color;\n            const strokeColor = optsAtIndex.textStrokeColor;\n            const strokeWidth = optsAtIndex.textStrokeWidth;\n            let tickTextAlign = textAlign;\n            if (isHorizontal) {\n                x = pixel;\n                if (textAlign === 'inner') {\n                    if (i === ilen - 1) {\n                        tickTextAlign = !this.options.reverse ? 'right' : 'left';\n                    } else if (i === 0) {\n                        tickTextAlign = !this.options.reverse ? 'left' : 'right';\n                    } else {\n                        tickTextAlign = 'center';\n                    }\n                }\n                if (position === 'top') {\n                    if (crossAlign === 'near' || rotation !== 0) {\n                        textOffset = -lineCount * lineHeight + lineHeight / 2;\n                    } else if (crossAlign === 'center') {\n                        textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n                    } else {\n                        textOffset = -labelSizes.highest.height + lineHeight / 2;\n                    }\n                } else {\n                    if (crossAlign === 'near' || rotation !== 0) {\n                        textOffset = lineHeight / 2;\n                    } else if (crossAlign === 'center') {\n                        textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n                    } else {\n                        textOffset = labelSizes.highest.height - lineCount * lineHeight;\n                    }\n                }\n                if (mirror) {\n                    textOffset *= -1;\n                }\n                if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {\n                    x += lineHeight / 2 * Math.sin(rotation);\n                }\n            } else {\n                y = pixel;\n                textOffset = (1 - lineCount) * lineHeight / 2;\n            }\n            let backdrop;\n            if (optsAtIndex.showLabelBackdrop) {\n                const labelPadding = helpers_dataset.toPadding(optsAtIndex.backdropPadding);\n                const height = labelSizes.heights[i];\n                const width = labelSizes.widths[i];\n                let top = textOffset - labelPadding.top;\n                let left = 0 - labelPadding.left;\n                switch(textBaseline){\n                    case 'middle':\n                        top -= height / 2;\n                        break;\n                    case 'bottom':\n                        top -= height;\n                        break;\n                }\n                switch(textAlign){\n                    case 'center':\n                        left -= width / 2;\n                        break;\n                    case 'right':\n                        left -= width;\n                        break;\n                    case 'inner':\n                        if (i === ilen - 1) {\n                            left -= width;\n                        } else if (i > 0) {\n                            left -= width / 2;\n                        }\n                        break;\n                }\n                backdrop = {\n                    left,\n                    top,\n                    width: width + labelPadding.width,\n                    height: height + labelPadding.height,\n                    color: optsAtIndex.backdropColor\n                };\n            }\n            items.push({\n                label,\n                font,\n                textOffset,\n                options: {\n                    rotation,\n                    color,\n                    strokeColor,\n                    strokeWidth,\n                    textAlign: tickTextAlign,\n                    textBaseline,\n                    translation: [\n                        x,\n                        y\n                    ],\n                    backdrop\n                }\n            });\n        }\n        return items;\n    }\n    _getXAxisLabelAlignment() {\n        const { position , ticks  } = this.options;\n        const rotation = -helpers_dataset.toRadians(this.labelRotation);\n        if (rotation) {\n            return position === 'top' ? 'left' : 'right';\n        }\n        let align = 'center';\n        if (ticks.align === 'start') {\n            align = 'left';\n        } else if (ticks.align === 'end') {\n            align = 'right';\n        } else if (ticks.align === 'inner') {\n            align = 'inner';\n        }\n        return align;\n    }\n    _getYAxisLabelAlignment(tl) {\n        const { position , ticks: { crossAlign , mirror , padding  }  } = this.options;\n        const labelSizes = this._getLabelSizes();\n        const tickAndPadding = tl + padding;\n        const widest = labelSizes.widest.width;\n        let textAlign;\n        let x;\n        if (position === 'left') {\n            if (mirror) {\n                x = this.right + padding;\n                if (crossAlign === 'near') {\n                    textAlign = 'left';\n                } else if (crossAlign === 'center') {\n                    textAlign = 'center';\n                    x += widest / 2;\n                } else {\n                    textAlign = 'right';\n                    x += widest;\n                }\n            } else {\n                x = this.right - tickAndPadding;\n                if (crossAlign === 'near') {\n                    textAlign = 'right';\n                } else if (crossAlign === 'center') {\n                    textAlign = 'center';\n                    x -= widest / 2;\n                } else {\n                    textAlign = 'left';\n                    x = this.left;\n                }\n            }\n        } else if (position === 'right') {\n            if (mirror) {\n                x = this.left + padding;\n                if (crossAlign === 'near') {\n                    textAlign = 'right';\n                } else if (crossAlign === 'center') {\n                    textAlign = 'center';\n                    x -= widest / 2;\n                } else {\n                    textAlign = 'left';\n                    x -= widest;\n                }\n            } else {\n                x = this.left + tickAndPadding;\n                if (crossAlign === 'near') {\n                    textAlign = 'left';\n                } else if (crossAlign === 'center') {\n                    textAlign = 'center';\n                    x += widest / 2;\n                } else {\n                    textAlign = 'right';\n                    x = this.right;\n                }\n            }\n        } else {\n            textAlign = 'right';\n        }\n        return {\n            textAlign,\n            x\n        };\n    }\n _computeLabelArea() {\n        if (this.options.ticks.mirror) {\n            return;\n        }\n        const chart = this.chart;\n        const position = this.options.position;\n        if (position === 'left' || position === 'right') {\n            return {\n                top: 0,\n                left: this.left,\n                bottom: chart.height,\n                right: this.right\n            };\n        }\n        if (position === 'top' || position === 'bottom') {\n            return {\n                top: this.top,\n                left: 0,\n                bottom: this.bottom,\n                right: chart.width\n            };\n        }\n    }\n drawBackground() {\n        const { ctx , options: { backgroundColor  } , left , top , width , height  } = this;\n        if (backgroundColor) {\n            ctx.save();\n            ctx.fillStyle = backgroundColor;\n            ctx.fillRect(left, top, width, height);\n            ctx.restore();\n        }\n    }\n    getLineWidthForValue(value) {\n        const grid = this.options.grid;\n        if (!this._isVisible() || !grid.display) {\n            return 0;\n        }\n        const ticks = this.ticks;\n        const index = ticks.findIndex((t)=>t.value === value);\n        if (index >= 0) {\n            const opts = grid.setContext(this.getContext(index));\n            return opts.lineWidth;\n        }\n        return 0;\n    }\n drawGrid(chartArea) {\n        const grid = this.options.grid;\n        const ctx = this.ctx;\n        const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n        let i, ilen;\n        const drawLine = (p1, p2, style)=>{\n            if (!style.width || !style.color) {\n                return;\n            }\n            ctx.save();\n            ctx.lineWidth = style.width;\n            ctx.strokeStyle = style.color;\n            ctx.setLineDash(style.borderDash || []);\n            ctx.lineDashOffset = style.borderDashOffset;\n            ctx.beginPath();\n            ctx.moveTo(p1.x, p1.y);\n            ctx.lineTo(p2.x, p2.y);\n            ctx.stroke();\n            ctx.restore();\n        };\n        if (grid.display) {\n            for(i = 0, ilen = items.length; i < ilen; ++i){\n                const item = items[i];\n                if (grid.drawOnChartArea) {\n                    drawLine({\n                        x: item.x1,\n                        y: item.y1\n                    }, {\n                        x: item.x2,\n                        y: item.y2\n                    }, item);\n                }\n                if (grid.drawTicks) {\n                    drawLine({\n                        x: item.tx1,\n                        y: item.ty1\n                    }, {\n                        x: item.tx2,\n                        y: item.ty2\n                    }, {\n                        color: item.tickColor,\n                        width: item.tickWidth,\n                        borderDash: item.tickBorderDash,\n                        borderDashOffset: item.tickBorderDashOffset\n                    });\n                }\n            }\n        }\n    }\n drawBorder() {\n        const { chart , ctx , options: { border , grid  }  } = this;\n        const borderOpts = border.setContext(this.getContext());\n        const axisWidth = border.display ? borderOpts.width : 0;\n        if (!axisWidth) {\n            return;\n        }\n        const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n        const borderValue = this._borderValue;\n        let x1, x2, y1, y2;\n        if (this.isHorizontal()) {\n            x1 = helpers_dataset._alignPixel(chart, this.left, axisWidth) - axisWidth / 2;\n            x2 = helpers_dataset._alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n            y1 = y2 = borderValue;\n        } else {\n            y1 = helpers_dataset._alignPixel(chart, this.top, axisWidth) - axisWidth / 2;\n            y2 = helpers_dataset._alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n            x1 = x2 = borderValue;\n        }\n        ctx.save();\n        ctx.lineWidth = borderOpts.width;\n        ctx.strokeStyle = borderOpts.color;\n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y2);\n        ctx.stroke();\n        ctx.restore();\n    }\n drawLabels(chartArea) {\n        const optionTicks = this.options.ticks;\n        if (!optionTicks.display) {\n            return;\n        }\n        const ctx = this.ctx;\n        const area = this._computeLabelArea();\n        if (area) {\n            helpers_dataset.clipArea(ctx, area);\n        }\n        const items = this.getLabelItems(chartArea);\n        for (const item of items){\n            const renderTextOptions = item.options;\n            const tickFont = item.font;\n            const label = item.label;\n            const y = item.textOffset;\n            helpers_dataset.renderText(ctx, label, 0, y, tickFont, renderTextOptions);\n        }\n        if (area) {\n            helpers_dataset.unclipArea(ctx);\n        }\n    }\n drawTitle() {\n        const { ctx , options: { position , title , reverse  }  } = this;\n        if (!title.display) {\n            return;\n        }\n        const font = helpers_dataset.toFont(title.font);\n        const padding = helpers_dataset.toPadding(title.padding);\n        const align = title.align;\n        let offset = font.lineHeight / 2;\n        if (position === 'bottom' || position === 'center' || helpers_dataset.isObject(position)) {\n            offset += padding.bottom;\n            if (helpers_dataset.isArray(title.text)) {\n                offset += font.lineHeight * (title.text.length - 1);\n            }\n        } else {\n            offset += padding.top;\n        }\n        const { titleX , titleY , maxWidth , rotation  } = titleArgs(this, offset, position, align);\n        helpers_dataset.renderText(ctx, title.text, 0, 0, font, {\n            color: title.color,\n            maxWidth,\n            rotation,\n            textAlign: titleAlign(align, position, reverse),\n            textBaseline: 'middle',\n            translation: [\n                titleX,\n                titleY\n            ]\n        });\n    }\n    draw(chartArea) {\n        if (!this._isVisible()) {\n            return;\n        }\n        this.drawBackground();\n        this.drawGrid(chartArea);\n        this.drawBorder();\n        this.drawTitle();\n        this.drawLabels(chartArea);\n    }\n _layers() {\n        const opts = this.options;\n        const tz = opts.ticks && opts.ticks.z || 0;\n        const gz = helpers_dataset.valueOrDefault(opts.grid && opts.grid.z, -1);\n        const bz = helpers_dataset.valueOrDefault(opts.border && opts.border.z, 0);\n        if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\n            return [\n                {\n                    z: tz,\n                    draw: (chartArea)=>{\n                        this.draw(chartArea);\n                    }\n                }\n            ];\n        }\n        return [\n            {\n                z: gz,\n                draw: (chartArea)=>{\n                    this.drawBackground();\n                    this.drawGrid(chartArea);\n                    this.drawTitle();\n                }\n            },\n            {\n                z: bz,\n                draw: ()=>{\n                    this.drawBorder();\n                }\n            },\n            {\n                z: tz,\n                draw: (chartArea)=>{\n                    this.drawLabels(chartArea);\n                }\n            }\n        ];\n    }\n getMatchingVisibleMetas(type) {\n        const metas = this.chart.getSortedVisibleDatasetMetas();\n        const axisID = this.axis + 'AxisID';\n        const result = [];\n        let i, ilen;\n        for(i = 0, ilen = metas.length; i < ilen; ++i){\n            const meta = metas[i];\n            if (meta[axisID] === this.id && (!type || meta.type === type)) {\n                result.push(meta);\n            }\n        }\n        return result;\n    }\n _resolveTickFontOptions(index) {\n        const opts = this.options.ticks.setContext(this.getContext(index));\n        return helpers_dataset.toFont(opts.font);\n    }\n _maxDigits() {\n        const fontSize = this._resolveTickFontOptions(0).lineHeight;\n        return (this.isHorizontal() ? this.width : this.height) / fontSize;\n    }\n}\n\nclass TypedRegistry {\n    constructor(type, scope, override){\n        this.type = type;\n        this.scope = scope;\n        this.override = override;\n        this.items = Object.create(null);\n    }\n    isForType(type) {\n        return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n    }\n register(item) {\n        const proto = Object.getPrototypeOf(item);\n        let parentScope;\n        if (isIChartComponent(proto)) {\n            parentScope = this.register(proto);\n        }\n        const items = this.items;\n        const id = item.id;\n        const scope = this.scope + '.' + id;\n        if (!id) {\n            throw new Error('class does not have id: ' + item);\n        }\n        if (id in items) {\n            return scope;\n        }\n        items[id] = item;\n        registerDefaults(item, scope, parentScope);\n        if (this.override) {\n            helpers_dataset.defaults.override(item.id, item.overrides);\n        }\n        return scope;\n    }\n get(id) {\n        return this.items[id];\n    }\n unregister(item) {\n        const items = this.items;\n        const id = item.id;\n        const scope = this.scope;\n        if (id in items) {\n            delete items[id];\n        }\n        if (scope && id in helpers_dataset.defaults[scope]) {\n            delete helpers_dataset.defaults[scope][id];\n            if (this.override) {\n                delete helpers_dataset.overrides[id];\n            }\n        }\n    }\n}\nfunction registerDefaults(item, scope, parentScope) {\n    const itemDefaults = helpers_dataset.merge(Object.create(null), [\n        parentScope ? helpers_dataset.defaults.get(parentScope) : {},\n        helpers_dataset.defaults.get(scope),\n        item.defaults\n    ]);\n    helpers_dataset.defaults.set(scope, itemDefaults);\n    if (item.defaultRoutes) {\n        routeDefaults(scope, item.defaultRoutes);\n    }\n    if (item.descriptors) {\n        helpers_dataset.defaults.describe(scope, item.descriptors);\n    }\n}\nfunction routeDefaults(scope, routes) {\n    Object.keys(routes).forEach((property)=>{\n        const propertyParts = property.split('.');\n        const sourceName = propertyParts.pop();\n        const sourceScope = [\n            scope\n        ].concat(propertyParts).join('.');\n        const parts = routes[property].split('.');\n        const targetName = parts.pop();\n        const targetScope = parts.join('.');\n        helpers_dataset.defaults.route(sourceScope, sourceName, targetScope, targetName);\n    });\n}\nfunction isIChartComponent(proto) {\n    return 'id' in proto && 'defaults' in proto;\n}\n\nclass Registry {\n    constructor(){\n        this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\n        this.elements = new TypedRegistry(Element, 'elements');\n        this.plugins = new TypedRegistry(Object, 'plugins');\n        this.scales = new TypedRegistry(Scale, 'scales');\n        this._typedRegistries = [\n            this.controllers,\n            this.scales,\n            this.elements\n        ];\n    }\n add(...args) {\n        this._each('register', args);\n    }\n    remove(...args) {\n        this._each('unregister', args);\n    }\n addControllers(...args) {\n        this._each('register', args, this.controllers);\n    }\n addElements(...args) {\n        this._each('register', args, this.elements);\n    }\n addPlugins(...args) {\n        this._each('register', args, this.plugins);\n    }\n addScales(...args) {\n        this._each('register', args, this.scales);\n    }\n getController(id) {\n        return this._get(id, this.controllers, 'controller');\n    }\n getElement(id) {\n        return this._get(id, this.elements, 'element');\n    }\n getPlugin(id) {\n        return this._get(id, this.plugins, 'plugin');\n    }\n getScale(id) {\n        return this._get(id, this.scales, 'scale');\n    }\n removeControllers(...args) {\n        this._each('unregister', args, this.controllers);\n    }\n removeElements(...args) {\n        this._each('unregister', args, this.elements);\n    }\n removePlugins(...args) {\n        this._each('unregister', args, this.plugins);\n    }\n removeScales(...args) {\n        this._each('unregister', args, this.scales);\n    }\n _each(method, args, typedRegistry) {\n        [\n            ...args\n        ].forEach((arg)=>{\n            const reg = typedRegistry || this._getRegistryForType(arg);\n            if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {\n                this._exec(method, reg, arg);\n            } else {\n                helpers_dataset.each(arg, (item)=>{\n                    const itemReg = typedRegistry || this._getRegistryForType(item);\n                    this._exec(method, itemReg, item);\n                });\n            }\n        });\n    }\n _exec(method, registry, component) {\n        const camelMethod = helpers_dataset._capitalize(method);\n        helpers_dataset.callback(component['before' + camelMethod], [], component);\n        registry[method](component);\n        helpers_dataset.callback(component['after' + camelMethod], [], component);\n    }\n _getRegistryForType(type) {\n        for(let i = 0; i < this._typedRegistries.length; i++){\n            const reg = this._typedRegistries[i];\n            if (reg.isForType(type)) {\n                return reg;\n            }\n        }\n        return this.plugins;\n    }\n _get(id, typedRegistry, type) {\n        const item = typedRegistry.get(id);\n        if (item === undefined) {\n            throw new Error('\"' + id + '\" is not a registered ' + type + '.');\n        }\n        return item;\n    }\n}\nvar registry = /* #__PURE__ */ new Registry();\n\nclass PluginService {\n    constructor(){\n        this._init = [];\n    }\n notify(chart, hook, args, filter) {\n        if (hook === 'beforeInit') {\n            this._init = this._createDescriptors(chart, true);\n            this._notify(this._init, chart, 'install');\n        }\n        const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n        const result = this._notify(descriptors, chart, hook, args);\n        if (hook === 'afterDestroy') {\n            this._notify(descriptors, chart, 'stop');\n            this._notify(this._init, chart, 'uninstall');\n        }\n        return result;\n    }\n _notify(descriptors, chart, hook, args) {\n        args = args || {};\n        for (const descriptor of descriptors){\n            const plugin = descriptor.plugin;\n            const method = plugin[hook];\n            const params = [\n                chart,\n                args,\n                descriptor.options\n            ];\n            if (helpers_dataset.callback(method, params, plugin) === false && args.cancelable) {\n                return false;\n            }\n        }\n        return true;\n    }\n    invalidate() {\n        if (!helpers_dataset.isNullOrUndef(this._cache)) {\n            this._oldCache = this._cache;\n            this._cache = undefined;\n        }\n    }\n _descriptors(chart) {\n        if (this._cache) {\n            return this._cache;\n        }\n        const descriptors = this._cache = this._createDescriptors(chart);\n        this._notifyStateChanges(chart);\n        return descriptors;\n    }\n    _createDescriptors(chart, all) {\n        const config = chart && chart.config;\n        const options = helpers_dataset.valueOrDefault(config.options && config.options.plugins, {});\n        const plugins = allPlugins(config);\n        return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n    }\n _notifyStateChanges(chart) {\n        const previousDescriptors = this._oldCache || [];\n        const descriptors = this._cache;\n        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.plugin.id === y.plugin.id));\n        this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\n        this._notify(diff(descriptors, previousDescriptors), chart, 'start');\n    }\n}\n function allPlugins(config) {\n    const localIds = {};\n    const plugins = [];\n    const keys = Object.keys(registry.plugins.items);\n    for(let i = 0; i < keys.length; i++){\n        plugins.push(registry.getPlugin(keys[i]));\n    }\n    const local = config.plugins || [];\n    for(let i = 0; i < local.length; i++){\n        const plugin = local[i];\n        if (plugins.indexOf(plugin) === -1) {\n            plugins.push(plugin);\n            localIds[plugin.id] = true;\n        }\n    }\n    return {\n        plugins,\n        localIds\n    };\n}\nfunction getOpts(options, all) {\n    if (!all && options === false) {\n        return null;\n    }\n    if (options === true) {\n        return {};\n    }\n    return options;\n}\nfunction createDescriptors(chart, { plugins , localIds  }, options, all) {\n    const result = [];\n    const context = chart.getContext();\n    for (const plugin of plugins){\n        const id = plugin.id;\n        const opts = getOpts(options[id], all);\n        if (opts === null) {\n            continue;\n        }\n        result.push({\n            plugin,\n            options: pluginOpts(chart.config, {\n                plugin,\n                local: localIds[id]\n            }, opts, context)\n        });\n    }\n    return result;\n}\nfunction pluginOpts(config, { plugin , local  }, opts, context) {\n    const keys = config.pluginScopeKeys(plugin);\n    const scopes = config.getOptionScopes(opts, keys);\n    if (local && plugin.defaults) {\n        scopes.push(plugin.defaults);\n    }\n    return config.createResolver(scopes, context, [\n        ''\n    ], {\n        scriptable: false,\n        indexable: false,\n        allKeys: true\n    });\n}\n\nfunction getIndexAxis(type, options) {\n    const datasetDefaults = helpers_dataset.defaults.datasets[type] || {};\n    const datasetOptions = (options.datasets || {})[type] || {};\n    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\n}\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n    let axis = id;\n    if (id === '_index_') {\n        axis = indexAxis;\n    } else if (id === '_value_') {\n        axis = indexAxis === 'x' ? 'y' : 'x';\n    }\n    return axis;\n}\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n    return axis === indexAxis ? '_index_' : '_value_';\n}\nfunction idMatchesAxis(id) {\n    if (id === 'x' || id === 'y' || id === 'r') {\n        return id;\n    }\n}\nfunction axisFromPosition(position) {\n    if (position === 'top' || position === 'bottom') {\n        return 'x';\n    }\n    if (position === 'left' || position === 'right') {\n        return 'y';\n    }\n}\nfunction determineAxis(id, ...scaleOptions) {\n    if (idMatchesAxis(id)) {\n        return id;\n    }\n    for (const opts of scaleOptions){\n        const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());\n        if (axis) {\n            return axis;\n        }\n    }\n    throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);\n}\nfunction getAxisFromDataset(id, axis, dataset) {\n    if (dataset[axis + 'AxisID'] === id) {\n        return {\n            axis\n        };\n    }\n}\nfunction retrieveAxisFromDatasets(id, config) {\n    if (config.data && config.data.datasets) {\n        const boundDs = config.data.datasets.filter((d)=>d.xAxisID === id || d.yAxisID === id);\n        if (boundDs.length) {\n            return getAxisFromDataset(id, 'x', boundDs[0]) || getAxisFromDataset(id, 'y', boundDs[0]);\n        }\n    }\n    return {};\n}\nfunction mergeScaleConfig(config, options) {\n    const chartDefaults = helpers_dataset.overrides[config.type] || {\n        scales: {}\n    };\n    const configScales = options.scales || {};\n    const chartIndexAxis = getIndexAxis(config.type, options);\n    const scales = Object.create(null);\n    Object.keys(configScales).forEach((id)=>{\n        const scaleConf = configScales[id];\n        if (!helpers_dataset.isObject(scaleConf)) {\n            return console.error(`Invalid scale configuration for scale: ${id}`);\n        }\n        if (scaleConf._proxy) {\n            return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\n        }\n        const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), helpers_dataset.defaults.scales[scaleConf.type]);\n        const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n        const defaultScaleOptions = chartDefaults.scales || {};\n        scales[id] = helpers_dataset.mergeIf(Object.create(null), [\n            {\n                axis\n            },\n            scaleConf,\n            defaultScaleOptions[axis],\n            defaultScaleOptions[defaultId]\n        ]);\n    });\n    config.data.datasets.forEach((dataset)=>{\n        const type = dataset.type || config.type;\n        const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n        const datasetDefaults = helpers_dataset.overrides[type] || {};\n        const defaultScaleOptions = datasetDefaults.scales || {};\n        Object.keys(defaultScaleOptions).forEach((defaultID)=>{\n            const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n            const id = dataset[axis + 'AxisID'] || axis;\n            scales[id] = scales[id] || Object.create(null);\n            helpers_dataset.mergeIf(scales[id], [\n                {\n                    axis\n                },\n                configScales[id],\n                defaultScaleOptions[defaultID]\n            ]);\n        });\n    });\n    Object.keys(scales).forEach((key)=>{\n        const scale = scales[key];\n        helpers_dataset.mergeIf(scale, [\n            helpers_dataset.defaults.scales[scale.type],\n            helpers_dataset.defaults.scale\n        ]);\n    });\n    return scales;\n}\nfunction initOptions(config) {\n    const options = config.options || (config.options = {});\n    options.plugins = helpers_dataset.valueOrDefault(options.plugins, {});\n    options.scales = mergeScaleConfig(config, options);\n}\nfunction initData(data) {\n    data = data || {};\n    data.datasets = data.datasets || [];\n    data.labels = data.labels || [];\n    return data;\n}\nfunction initConfig(config) {\n    config = config || {};\n    config.data = initData(config.data);\n    initOptions(config);\n    return config;\n}\nconst keyCache = new Map();\nconst keysCached = new Set();\nfunction cachedKeys(cacheKey, generate) {\n    let keys = keyCache.get(cacheKey);\n    if (!keys) {\n        keys = generate();\n        keyCache.set(cacheKey, keys);\n        keysCached.add(keys);\n    }\n    return keys;\n}\nconst addIfFound = (set, obj, key)=>{\n    const opts = helpers_dataset.resolveObjectKey(obj, key);\n    if (opts !== undefined) {\n        set.add(opts);\n    }\n};\nclass Config {\n    constructor(config){\n        this._config = initConfig(config);\n        this._scopeCache = new Map();\n        this._resolverCache = new Map();\n    }\n    get platform() {\n        return this._config.platform;\n    }\n    get type() {\n        return this._config.type;\n    }\n    set type(type) {\n        this._config.type = type;\n    }\n    get data() {\n        return this._config.data;\n    }\n    set data(data) {\n        this._config.data = initData(data);\n    }\n    get options() {\n        return this._config.options;\n    }\n    set options(options) {\n        this._config.options = options;\n    }\n    get plugins() {\n        return this._config.plugins;\n    }\n    update() {\n        const config = this._config;\n        this.clearCache();\n        initOptions(config);\n    }\n    clearCache() {\n        this._scopeCache.clear();\n        this._resolverCache.clear();\n    }\n datasetScopeKeys(datasetType) {\n        return cachedKeys(datasetType, ()=>[\n                [\n                    `datasets.${datasetType}`,\n                    ''\n                ]\n            ]);\n    }\n datasetAnimationScopeKeys(datasetType, transition) {\n        return cachedKeys(`${datasetType}.transition.${transition}`, ()=>[\n                [\n                    `datasets.${datasetType}.transitions.${transition}`,\n                    `transitions.${transition}`\n                ],\n                [\n                    `datasets.${datasetType}`,\n                    ''\n                ]\n            ]);\n    }\n datasetElementScopeKeys(datasetType, elementType) {\n        return cachedKeys(`${datasetType}-${elementType}`, ()=>[\n                [\n                    `datasets.${datasetType}.elements.${elementType}`,\n                    `datasets.${datasetType}`,\n                    `elements.${elementType}`,\n                    ''\n                ]\n            ]);\n    }\n pluginScopeKeys(plugin) {\n        const id = plugin.id;\n        const type = this.type;\n        return cachedKeys(`${type}-plugin-${id}`, ()=>[\n                [\n                    `plugins.${id}`,\n                    ...plugin.additionalOptionScopes || []\n                ]\n            ]);\n    }\n _cachedScopes(mainScope, resetCache) {\n        const _scopeCache = this._scopeCache;\n        let cache = _scopeCache.get(mainScope);\n        if (!cache || resetCache) {\n            cache = new Map();\n            _scopeCache.set(mainScope, cache);\n        }\n        return cache;\n    }\n getOptionScopes(mainScope, keyLists, resetCache) {\n        const { options , type  } = this;\n        const cache = this._cachedScopes(mainScope, resetCache);\n        const cached = cache.get(keyLists);\n        if (cached) {\n            return cached;\n        }\n        const scopes = new Set();\n        keyLists.forEach((keys)=>{\n            if (mainScope) {\n                scopes.add(mainScope);\n                keys.forEach((key)=>addIfFound(scopes, mainScope, key));\n            }\n            keys.forEach((key)=>addIfFound(scopes, options, key));\n            keys.forEach((key)=>addIfFound(scopes, helpers_dataset.overrides[type] || {}, key));\n            keys.forEach((key)=>addIfFound(scopes, helpers_dataset.defaults, key));\n            keys.forEach((key)=>addIfFound(scopes, helpers_dataset.descriptors, key));\n        });\n        const array = Array.from(scopes);\n        if (array.length === 0) {\n            array.push(Object.create(null));\n        }\n        if (keysCached.has(keyLists)) {\n            cache.set(keyLists, array);\n        }\n        return array;\n    }\n chartOptionScopes() {\n        const { options , type  } = this;\n        return [\n            options,\n            helpers_dataset.overrides[type] || {},\n            helpers_dataset.defaults.datasets[type] || {},\n            {\n                type\n            },\n            helpers_dataset.defaults,\n            helpers_dataset.descriptors\n        ];\n    }\n resolveNamedOptions(scopes, names, context, prefixes = [\n        ''\n    ]) {\n        const result = {\n            $shared: true\n        };\n        const { resolver , subPrefixes  } = getResolver(this._resolverCache, scopes, prefixes);\n        let options = resolver;\n        if (needContext(resolver, names)) {\n            result.$shared = false;\n            context = helpers_dataset.isFunction(context) ? context() : context;\n            const subResolver = this.createResolver(scopes, context, subPrefixes);\n            options = helpers_dataset._attachContext(resolver, context, subResolver);\n        }\n        for (const prop of names){\n            result[prop] = options[prop];\n        }\n        return result;\n    }\n createResolver(scopes, context, prefixes = [\n        ''\n    ], descriptorDefaults) {\n        const { resolver  } = getResolver(this._resolverCache, scopes, prefixes);\n        return helpers_dataset.isObject(context) ? helpers_dataset._attachContext(resolver, context, undefined, descriptorDefaults) : resolver;\n    }\n}\nfunction getResolver(resolverCache, scopes, prefixes) {\n    let cache = resolverCache.get(scopes);\n    if (!cache) {\n        cache = new Map();\n        resolverCache.set(scopes, cache);\n    }\n    const cacheKey = prefixes.join();\n    let cached = cache.get(cacheKey);\n    if (!cached) {\n        const resolver = helpers_dataset._createResolver(scopes, prefixes);\n        cached = {\n            resolver,\n            subPrefixes: prefixes.filter((p)=>!p.toLowerCase().includes('hover'))\n        };\n        cache.set(cacheKey, cached);\n    }\n    return cached;\n}\nconst hasFunction = (value)=>helpers_dataset.isObject(value) && Object.getOwnPropertyNames(value).some((key)=>helpers_dataset.isFunction(value[key]));\nfunction needContext(proxy, names) {\n    const { isScriptable , isIndexable  } = helpers_dataset._descriptors(proxy);\n    for (const prop of names){\n        const scriptable = isScriptable(prop);\n        const indexable = isIndexable(prop);\n        const value = (indexable || scriptable) && proxy[prop];\n        if (scriptable && (helpers_dataset.isFunction(value) || hasFunction(value)) || indexable && helpers_dataset.isArray(value)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvar version = \"4.5.0\";\n\nconst KNOWN_POSITIONS = [\n    'top',\n    'bottom',\n    'left',\n    'right',\n    'chartArea'\n];\nfunction positionIsHorizontal(position, axis) {\n    return position === 'top' || position === 'bottom' || KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x';\n}\nfunction compare2Level(l1, l2) {\n    return function(a, b) {\n        return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];\n    };\n}\nfunction onAnimationsComplete(context) {\n    const chart = context.chart;\n    const animationOptions = chart.options.animation;\n    chart.notifyPlugins('afterRender');\n    helpers_dataset.callback(animationOptions && animationOptions.onComplete, [\n        context\n    ], chart);\n}\nfunction onAnimationProgress(context) {\n    const chart = context.chart;\n    const animationOptions = chart.options.animation;\n    helpers_dataset.callback(animationOptions && animationOptions.onProgress, [\n        context\n    ], chart);\n}\n function getCanvas(item) {\n    if (helpers_dataset._isDomSupported() && typeof item === 'string') {\n        item = document.getElementById(item);\n    } else if (item && item.length) {\n        item = item[0];\n    }\n    if (item && item.canvas) {\n        item = item.canvas;\n    }\n    return item;\n}\nconst instances = {};\nconst getChart = (key)=>{\n    const canvas = getCanvas(key);\n    return Object.values(instances).filter((c)=>c.canvas === canvas).pop();\n};\nfunction moveNumericKeys(obj, start, move) {\n    const keys = Object.keys(obj);\n    for (const key of keys){\n        const intKey = +key;\n        if (intKey >= start) {\n            const value = obj[key];\n            delete obj[key];\n            if (move > 0 || intKey > start) {\n                obj[intKey + move] = value;\n            }\n        }\n    }\n}\n function determineLastEvent(e, lastEvent, inChartArea, isClick) {\n    if (!inChartArea || e.type === 'mouseout') {\n        return null;\n    }\n    if (isClick) {\n        return lastEvent;\n    }\n    return e;\n}\nclass Chart {\n    static defaults = helpers_dataset.defaults;\n    static instances = instances;\n    static overrides = helpers_dataset.overrides;\n    static registry = registry;\n    static version = version;\n    static getChart = getChart;\n    static register(...items) {\n        registry.add(...items);\n        invalidatePlugins();\n    }\n    static unregister(...items) {\n        registry.remove(...items);\n        invalidatePlugins();\n    }\n    constructor(item, userConfig){\n        const config = this.config = new Config(userConfig);\n        const initialCanvas = getCanvas(item);\n        const existingChart = getChart(initialCanvas);\n        if (existingChart) {\n            throw new Error('Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' + ' must be destroyed before the canvas with ID \\'' + existingChart.canvas.id + '\\' can be reused.');\n        }\n        const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n        this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n        this.platform.updateConfig(config);\n        const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n        const canvas = context && context.canvas;\n        const height = canvas && canvas.height;\n        const width = canvas && canvas.width;\n        this.id = helpers_dataset.uid();\n        this.ctx = context;\n        this.canvas = canvas;\n        this.width = width;\n        this.height = height;\n        this._options = options;\n        this._aspectRatio = this.aspectRatio;\n        this._layers = [];\n        this._metasets = [];\n        this._stacks = undefined;\n        this.boxes = [];\n        this.currentDevicePixelRatio = undefined;\n        this.chartArea = undefined;\n        this._active = [];\n        this._lastEvent = undefined;\n        this._listeners = {};\n         this._responsiveListeners = undefined;\n        this._sortedMetasets = [];\n        this.scales = {};\n        this._plugins = new PluginService();\n        this.$proxies = {};\n        this._hiddenIndices = {};\n        this.attached = false;\n        this._animationsDisabled = undefined;\n        this.$context = undefined;\n        this._doResize = helpers_dataset.debounce((mode)=>this.update(mode), options.resizeDelay || 0);\n        this._dataChanges = [];\n        instances[this.id] = this;\n        if (!context || !canvas) {\n            console.error(\"Failed to create chart: can't acquire context from the given item\");\n            return;\n        }\n        animator.listen(this, 'complete', onAnimationsComplete);\n        animator.listen(this, 'progress', onAnimationProgress);\n        this._initialize();\n        if (this.attached) {\n            this.update();\n        }\n    }\n    get aspectRatio() {\n        const { options: { aspectRatio , maintainAspectRatio  } , width , height , _aspectRatio  } = this;\n        if (!helpers_dataset.isNullOrUndef(aspectRatio)) {\n            return aspectRatio;\n        }\n        if (maintainAspectRatio && _aspectRatio) {\n            return _aspectRatio;\n        }\n        return height ? width / height : null;\n    }\n    get data() {\n        return this.config.data;\n    }\n    set data(data) {\n        this.config.data = data;\n    }\n    get options() {\n        return this._options;\n    }\n    set options(options) {\n        this.config.options = options;\n    }\n    get registry() {\n        return registry;\n    }\n _initialize() {\n        this.notifyPlugins('beforeInit');\n        if (this.options.responsive) {\n            this.resize();\n        } else {\n            helpers_dataset.retinaScale(this, this.options.devicePixelRatio);\n        }\n        this.bindEvents();\n        this.notifyPlugins('afterInit');\n        return this;\n    }\n    clear() {\n        helpers_dataset.clearCanvas(this.canvas, this.ctx);\n        return this;\n    }\n    stop() {\n        animator.stop(this);\n        return this;\n    }\n resize(width, height) {\n        if (!animator.running(this)) {\n            this._resize(width, height);\n        } else {\n            this._resizeBeforeDraw = {\n                width,\n                height\n            };\n        }\n    }\n    _resize(width, height) {\n        const options = this.options;\n        const canvas = this.canvas;\n        const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n        const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n        const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n        const mode = this.width ? 'resize' : 'attach';\n        this.width = newSize.width;\n        this.height = newSize.height;\n        this._aspectRatio = this.aspectRatio;\n        if (!helpers_dataset.retinaScale(this, newRatio, true)) {\n            return;\n        }\n        this.notifyPlugins('resize', {\n            size: newSize\n        });\n        helpers_dataset.callback(options.onResize, [\n            this,\n            newSize\n        ], this);\n        if (this.attached) {\n            if (this._doResize(mode)) {\n                this.render();\n            }\n        }\n    }\n    ensureScalesHaveIDs() {\n        const options = this.options;\n        const scalesOptions = options.scales || {};\n        helpers_dataset.each(scalesOptions, (axisOptions, axisID)=>{\n            axisOptions.id = axisID;\n        });\n    }\n buildOrUpdateScales() {\n        const options = this.options;\n        const scaleOpts = options.scales;\n        const scales = this.scales;\n        const updated = Object.keys(scales).reduce((obj, id)=>{\n            obj[id] = false;\n            return obj;\n        }, {});\n        let items = [];\n        if (scaleOpts) {\n            items = items.concat(Object.keys(scaleOpts).map((id)=>{\n                const scaleOptions = scaleOpts[id];\n                const axis = determineAxis(id, scaleOptions);\n                const isRadial = axis === 'r';\n                const isHorizontal = axis === 'x';\n                return {\n                    options: scaleOptions,\n                    dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\n                    dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\n                };\n            }));\n        }\n        helpers_dataset.each(items, (item)=>{\n            const scaleOptions = item.options;\n            const id = scaleOptions.id;\n            const axis = determineAxis(id, scaleOptions);\n            const scaleType = helpers_dataset.valueOrDefault(scaleOptions.type, item.dtype);\n            if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n                scaleOptions.position = item.dposition;\n            }\n            updated[id] = true;\n            let scale = null;\n            if (id in scales && scales[id].type === scaleType) {\n                scale = scales[id];\n            } else {\n                const scaleClass = registry.getScale(scaleType);\n                scale = new scaleClass({\n                    id,\n                    type: scaleType,\n                    ctx: this.ctx,\n                    chart: this\n                });\n                scales[scale.id] = scale;\n            }\n            scale.init(scaleOptions, options);\n        });\n        helpers_dataset.each(updated, (hasUpdated, id)=>{\n            if (!hasUpdated) {\n                delete scales[id];\n            }\n        });\n        helpers_dataset.each(scales, (scale)=>{\n            layouts.configure(this, scale, scale.options);\n            layouts.addBox(this, scale);\n        });\n    }\n _updateMetasets() {\n        const metasets = this._metasets;\n        const numData = this.data.datasets.length;\n        const numMeta = metasets.length;\n        metasets.sort((a, b)=>a.index - b.index);\n        if (numMeta > numData) {\n            for(let i = numData; i < numMeta; ++i){\n                this._destroyDatasetMeta(i);\n            }\n            metasets.splice(numData, numMeta - numData);\n        }\n        this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\n    }\n _removeUnreferencedMetasets() {\n        const { _metasets: metasets , data: { datasets  }  } = this;\n        if (metasets.length > datasets.length) {\n            delete this._stacks;\n        }\n        metasets.forEach((meta, index)=>{\n            if (datasets.filter((x)=>x === meta._dataset).length === 0) {\n                this._destroyDatasetMeta(index);\n            }\n        });\n    }\n    buildOrUpdateControllers() {\n        const newControllers = [];\n        const datasets = this.data.datasets;\n        let i, ilen;\n        this._removeUnreferencedMetasets();\n        for(i = 0, ilen = datasets.length; i < ilen; i++){\n            const dataset = datasets[i];\n            let meta = this.getDatasetMeta(i);\n            const type = dataset.type || this.config.type;\n            if (meta.type && meta.type !== type) {\n                this._destroyDatasetMeta(i);\n                meta = this.getDatasetMeta(i);\n            }\n            meta.type = type;\n            meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n            meta.order = dataset.order || 0;\n            meta.index = i;\n            meta.label = '' + dataset.label;\n            meta.visible = this.isDatasetVisible(i);\n            if (meta.controller) {\n                meta.controller.updateIndex(i);\n                meta.controller.linkScales();\n            } else {\n                const ControllerClass = registry.getController(type);\n                const { datasetElementType , dataElementType  } = helpers_dataset.defaults.datasets[type];\n                Object.assign(ControllerClass, {\n                    dataElementType: registry.getElement(dataElementType),\n                    datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n                });\n                meta.controller = new ControllerClass(this, i);\n                newControllers.push(meta.controller);\n            }\n        }\n        this._updateMetasets();\n        return newControllers;\n    }\n _resetElements() {\n        helpers_dataset.each(this.data.datasets, (dataset, datasetIndex)=>{\n            this.getDatasetMeta(datasetIndex).controller.reset();\n        }, this);\n    }\n reset() {\n        this._resetElements();\n        this.notifyPlugins('reset');\n    }\n    update(mode) {\n        const config = this.config;\n        config.update();\n        const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n        const animsDisabled = this._animationsDisabled = !options.animation;\n        this._updateScales();\n        this._checkEventBindings();\n        this._updateHiddenIndices();\n        this._plugins.invalidate();\n        if (this.notifyPlugins('beforeUpdate', {\n            mode,\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const newControllers = this.buildOrUpdateControllers();\n        this.notifyPlugins('beforeElementsUpdate');\n        let minPadding = 0;\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; i++){\n            const { controller  } = this.getDatasetMeta(i);\n            const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n            controller.buildOrUpdateElements(reset);\n            minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n        }\n        minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n        this._updateLayout(minPadding);\n        if (!animsDisabled) {\n            helpers_dataset.each(newControllers, (controller)=>{\n                controller.reset();\n            });\n        }\n        this._updateDatasets(mode);\n        this.notifyPlugins('afterUpdate', {\n            mode\n        });\n        this._layers.sort(compare2Level('z', '_idx'));\n        const { _active , _lastEvent  } = this;\n        if (_lastEvent) {\n            this._eventHandler(_lastEvent, true);\n        } else if (_active.length) {\n            this._updateHoverStyles(_active, _active, true);\n        }\n        this.render();\n    }\n _updateScales() {\n        helpers_dataset.each(this.scales, (scale)=>{\n            layouts.removeBox(this, scale);\n        });\n        this.ensureScalesHaveIDs();\n        this.buildOrUpdateScales();\n    }\n _checkEventBindings() {\n        const options = this.options;\n        const existingEvents = new Set(Object.keys(this._listeners));\n        const newEvents = new Set(options.events);\n        if (!helpers_dataset.setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n            this.unbindEvents();\n            this.bindEvents();\n        }\n    }\n _updateHiddenIndices() {\n        const { _hiddenIndices  } = this;\n        const changes = this._getUniformDataChanges() || [];\n        for (const { method , start , count  } of changes){\n            const move = method === '_removeElements' ? -count : count;\n            moveNumericKeys(_hiddenIndices, start, move);\n        }\n    }\n _getUniformDataChanges() {\n        const _dataChanges = this._dataChanges;\n        if (!_dataChanges || !_dataChanges.length) {\n            return;\n        }\n        this._dataChanges = [];\n        const datasetCount = this.data.datasets.length;\n        const makeSet = (idx)=>new Set(_dataChanges.filter((c)=>c[0] === idx).map((c, i)=>i + ',' + c.splice(1).join(',')));\n        const changeSet = makeSet(0);\n        for(let i = 1; i < datasetCount; i++){\n            if (!helpers_dataset.setsEqual(changeSet, makeSet(i))) {\n                return;\n            }\n        }\n        return Array.from(changeSet).map((c)=>c.split(',')).map((a)=>({\n                method: a[1],\n                start: +a[2],\n                count: +a[3]\n            }));\n    }\n _updateLayout(minPadding) {\n        if (this.notifyPlugins('beforeLayout', {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        layouts.update(this, this.width, this.height, minPadding);\n        const area = this.chartArea;\n        const noArea = area.width <= 0 || area.height <= 0;\n        this._layers = [];\n        helpers_dataset.each(this.boxes, (box)=>{\n            if (noArea && box.position === 'chartArea') {\n                return;\n            }\n            if (box.configure) {\n                box.configure();\n            }\n            this._layers.push(...box._layers());\n        }, this);\n        this._layers.forEach((item, index)=>{\n            item._idx = index;\n        });\n        this.notifyPlugins('afterLayout');\n    }\n _updateDatasets(mode) {\n        if (this.notifyPlugins('beforeDatasetsUpdate', {\n            mode,\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this.getDatasetMeta(i).controller.configure();\n        }\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this._updateDataset(i, helpers_dataset.isFunction(mode) ? mode({\n                datasetIndex: i\n            }) : mode);\n        }\n        this.notifyPlugins('afterDatasetsUpdate', {\n            mode\n        });\n    }\n _updateDataset(index, mode) {\n        const meta = this.getDatasetMeta(index);\n        const args = {\n            meta,\n            index,\n            mode,\n            cancelable: true\n        };\n        if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {\n            return;\n        }\n        meta.controller._update(mode);\n        args.cancelable = false;\n        this.notifyPlugins('afterDatasetUpdate', args);\n    }\n    render() {\n        if (this.notifyPlugins('beforeRender', {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        if (animator.has(this)) {\n            if (this.attached && !animator.running(this)) {\n                animator.start(this);\n            }\n        } else {\n            this.draw();\n            onAnimationsComplete({\n                chart: this\n            });\n        }\n    }\n    draw() {\n        let i;\n        if (this._resizeBeforeDraw) {\n            const { width , height  } = this._resizeBeforeDraw;\n            this._resizeBeforeDraw = null;\n            this._resize(width, height);\n        }\n        this.clear();\n        if (this.width <= 0 || this.height <= 0) {\n            return;\n        }\n        if (this.notifyPlugins('beforeDraw', {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const layers = this._layers;\n        for(i = 0; i < layers.length && layers[i].z <= 0; ++i){\n            layers[i].draw(this.chartArea);\n        }\n        this._drawDatasets();\n        for(; i < layers.length; ++i){\n            layers[i].draw(this.chartArea);\n        }\n        this.notifyPlugins('afterDraw');\n    }\n _getSortedDatasetMetas(filterVisible) {\n        const metasets = this._sortedMetasets;\n        const result = [];\n        let i, ilen;\n        for(i = 0, ilen = metasets.length; i < ilen; ++i){\n            const meta = metasets[i];\n            if (!filterVisible || meta.visible) {\n                result.push(meta);\n            }\n        }\n        return result;\n    }\n getSortedVisibleDatasetMetas() {\n        return this._getSortedDatasetMetas(true);\n    }\n _drawDatasets() {\n        if (this.notifyPlugins('beforeDatasetsDraw', {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const metasets = this.getSortedVisibleDatasetMetas();\n        for(let i = metasets.length - 1; i >= 0; --i){\n            this._drawDataset(metasets[i]);\n        }\n        this.notifyPlugins('afterDatasetsDraw');\n    }\n _drawDataset(meta) {\n        const ctx = this.ctx;\n        const args = {\n            meta,\n            index: meta.index,\n            cancelable: true\n        };\n        const clip = helpers_dataset.getDatasetClipArea(this, meta);\n        if (this.notifyPlugins('beforeDatasetDraw', args) === false) {\n            return;\n        }\n        if (clip) {\n            helpers_dataset.clipArea(ctx, clip);\n        }\n        meta.controller.draw();\n        if (clip) {\n            helpers_dataset.unclipArea(ctx);\n        }\n        args.cancelable = false;\n        this.notifyPlugins('afterDatasetDraw', args);\n    }\n isPointInArea(point) {\n        return helpers_dataset._isPointInArea(point, this.chartArea, this._minPadding);\n    }\n    getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n        const method = Interaction.modes[mode];\n        if (typeof method === 'function') {\n            return method(this, e, options, useFinalPosition);\n        }\n        return [];\n    }\n    getDatasetMeta(datasetIndex) {\n        const dataset = this.data.datasets[datasetIndex];\n        const metasets = this._metasets;\n        let meta = metasets.filter((x)=>x && x._dataset === dataset).pop();\n        if (!meta) {\n            meta = {\n                type: null,\n                data: [],\n                dataset: null,\n                controller: null,\n                hidden: null,\n                xAxisID: null,\n                yAxisID: null,\n                order: dataset && dataset.order || 0,\n                index: datasetIndex,\n                _dataset: dataset,\n                _parsed: [],\n                _sorted: false\n            };\n            metasets.push(meta);\n        }\n        return meta;\n    }\n    getContext() {\n        return this.$context || (this.$context = helpers_dataset.createContext(null, {\n            chart: this,\n            type: 'chart'\n        }));\n    }\n    getVisibleDatasetCount() {\n        return this.getSortedVisibleDatasetMetas().length;\n    }\n    isDatasetVisible(datasetIndex) {\n        const dataset = this.data.datasets[datasetIndex];\n        if (!dataset) {\n            return false;\n        }\n        const meta = this.getDatasetMeta(datasetIndex);\n        return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\n    }\n    setDatasetVisibility(datasetIndex, visible) {\n        const meta = this.getDatasetMeta(datasetIndex);\n        meta.hidden = !visible;\n    }\n    toggleDataVisibility(index) {\n        this._hiddenIndices[index] = !this._hiddenIndices[index];\n    }\n    getDataVisibility(index) {\n        return !this._hiddenIndices[index];\n    }\n _updateVisibility(datasetIndex, dataIndex, visible) {\n        const mode = visible ? 'show' : 'hide';\n        const meta = this.getDatasetMeta(datasetIndex);\n        const anims = meta.controller._resolveAnimations(undefined, mode);\n        if (helpers_dataset.defined(dataIndex)) {\n            meta.data[dataIndex].hidden = !visible;\n            this.update();\n        } else {\n            this.setDatasetVisibility(datasetIndex, visible);\n            anims.update(meta, {\n                visible\n            });\n            this.update((ctx)=>ctx.datasetIndex === datasetIndex ? mode : undefined);\n        }\n    }\n    hide(datasetIndex, dataIndex) {\n        this._updateVisibility(datasetIndex, dataIndex, false);\n    }\n    show(datasetIndex, dataIndex) {\n        this._updateVisibility(datasetIndex, dataIndex, true);\n    }\n _destroyDatasetMeta(datasetIndex) {\n        const meta = this._metasets[datasetIndex];\n        if (meta && meta.controller) {\n            meta.controller._destroy();\n        }\n        delete this._metasets[datasetIndex];\n    }\n    _stop() {\n        let i, ilen;\n        this.stop();\n        animator.remove(this);\n        for(i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this._destroyDatasetMeta(i);\n        }\n    }\n    destroy() {\n        this.notifyPlugins('beforeDestroy');\n        const { canvas , ctx  } = this;\n        this._stop();\n        this.config.clearCache();\n        if (canvas) {\n            this.unbindEvents();\n            helpers_dataset.clearCanvas(canvas, ctx);\n            this.platform.releaseContext(ctx);\n            this.canvas = null;\n            this.ctx = null;\n        }\n        delete instances[this.id];\n        this.notifyPlugins('afterDestroy');\n    }\n    toBase64Image(...args) {\n        return this.canvas.toDataURL(...args);\n    }\n bindEvents() {\n        this.bindUserEvents();\n        if (this.options.responsive) {\n            this.bindResponsiveEvents();\n        } else {\n            this.attached = true;\n        }\n    }\n bindUserEvents() {\n        const listeners = this._listeners;\n        const platform = this.platform;\n        const _add = (type, listener)=>{\n            platform.addEventListener(this, type, listener);\n            listeners[type] = listener;\n        };\n        const listener = (e, x, y)=>{\n            e.offsetX = x;\n            e.offsetY = y;\n            this._eventHandler(e);\n        };\n        helpers_dataset.each(this.options.events, (type)=>_add(type, listener));\n    }\n bindResponsiveEvents() {\n        if (!this._responsiveListeners) {\n            this._responsiveListeners = {};\n        }\n        const listeners = this._responsiveListeners;\n        const platform = this.platform;\n        const _add = (type, listener)=>{\n            platform.addEventListener(this, type, listener);\n            listeners[type] = listener;\n        };\n        const _remove = (type, listener)=>{\n            if (listeners[type]) {\n                platform.removeEventListener(this, type, listener);\n                delete listeners[type];\n            }\n        };\n        const listener = (width, height)=>{\n            if (this.canvas) {\n                this.resize(width, height);\n            }\n        };\n        let detached;\n        const attached = ()=>{\n            _remove('attach', attached);\n            this.attached = true;\n            this.resize();\n            _add('resize', listener);\n            _add('detach', detached);\n        };\n        detached = ()=>{\n            this.attached = false;\n            _remove('resize', listener);\n            this._stop();\n            this._resize(0, 0);\n            _add('attach', attached);\n        };\n        if (platform.isAttached(this.canvas)) {\n            attached();\n        } else {\n            detached();\n        }\n    }\n unbindEvents() {\n        helpers_dataset.each(this._listeners, (listener, type)=>{\n            this.platform.removeEventListener(this, type, listener);\n        });\n        this._listeners = {};\n        helpers_dataset.each(this._responsiveListeners, (listener, type)=>{\n            this.platform.removeEventListener(this, type, listener);\n        });\n        this._responsiveListeners = undefined;\n    }\n    updateHoverStyle(items, mode, enabled) {\n        const prefix = enabled ? 'set' : 'remove';\n        let meta, item, i, ilen;\n        if (mode === 'dataset') {\n            meta = this.getDatasetMeta(items[0].datasetIndex);\n            meta.controller['_' + prefix + 'DatasetHoverStyle']();\n        }\n        for(i = 0, ilen = items.length; i < ilen; ++i){\n            item = items[i];\n            const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n            if (controller) {\n                controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\n            }\n        }\n    }\n getActiveElements() {\n        return this._active || [];\n    }\n setActiveElements(activeElements) {\n        const lastActive = this._active || [];\n        const active = activeElements.map(({ datasetIndex , index  })=>{\n            const meta = this.getDatasetMeta(datasetIndex);\n            if (!meta) {\n                throw new Error('No dataset found at index ' + datasetIndex);\n            }\n            return {\n                datasetIndex,\n                element: meta.data[index],\n                index\n            };\n        });\n        const changed = !helpers_dataset._elementsEqual(active, lastActive);\n        if (changed) {\n            this._active = active;\n            this._lastEvent = null;\n            this._updateHoverStyles(active, lastActive);\n        }\n    }\n notifyPlugins(hook, args, filter) {\n        return this._plugins.notify(this, hook, args, filter);\n    }\n isPluginEnabled(pluginId) {\n        return this._plugins._cache.filter((p)=>p.plugin.id === pluginId).length === 1;\n    }\n _updateHoverStyles(active, lastActive, replay) {\n        const hoverOptions = this.options.hover;\n        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.datasetIndex === y.datasetIndex && x.index === y.index));\n        const deactivated = diff(lastActive, active);\n        const activated = replay ? active : diff(active, lastActive);\n        if (deactivated.length) {\n            this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n        }\n        if (activated.length && hoverOptions.mode) {\n            this.updateHoverStyle(activated, hoverOptions.mode, true);\n        }\n    }\n _eventHandler(e, replay) {\n        const args = {\n            event: e,\n            replay,\n            cancelable: true,\n            inChartArea: this.isPointInArea(e)\n        };\n        const eventFilter = (plugin)=>(plugin.options.events || this.options.events).includes(e.native.type);\n        if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {\n            return;\n        }\n        const changed = this._handleEvent(e, replay, args.inChartArea);\n        args.cancelable = false;\n        this.notifyPlugins('afterEvent', args, eventFilter);\n        if (changed || args.changed) {\n            this.render();\n        }\n        return this;\n    }\n _handleEvent(e, replay, inChartArea) {\n        const { _active: lastActive = [] , options  } = this;\n        const useFinalPosition = replay;\n        const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\n        const isClick = helpers_dataset._isClickEvent(e);\n        const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\n        if (inChartArea) {\n            this._lastEvent = null;\n            helpers_dataset.callback(options.onHover, [\n                e,\n                active,\n                this\n            ], this);\n            if (isClick) {\n                helpers_dataset.callback(options.onClick, [\n                    e,\n                    active,\n                    this\n                ], this);\n            }\n        }\n        const changed = !helpers_dataset._elementsEqual(active, lastActive);\n        if (changed || replay) {\n            this._active = active;\n            this._updateHoverStyles(active, lastActive, replay);\n        }\n        this._lastEvent = lastEvent;\n        return changed;\n    }\n _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\n        if (e.type === 'mouseout') {\n            return [];\n        }\n        if (!inChartArea) {\n            return lastActive;\n        }\n        const hoverOptions = this.options.hover;\n        return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n    }\n}\nfunction invalidatePlugins() {\n    return helpers_dataset.each(Chart.instances, (chart)=>chart._plugins.invalidate());\n}\n\nfunction clipSelf(ctx, element, endAngle) {\n    const { startAngle , x , y , outerRadius , innerRadius , options  } = element;\n    const { borderWidth , borderJoinStyle  } = options;\n    const outerAngleClip = Math.min(borderWidth / outerRadius, helpers_dataset._normalizeAngle(startAngle - endAngle));\n    ctx.beginPath();\n    ctx.arc(x, y, outerRadius - borderWidth / 2, startAngle + outerAngleClip / 2, endAngle - outerAngleClip / 2);\n    if (innerRadius > 0) {\n        const innerAngleClip = Math.min(borderWidth / innerRadius, helpers_dataset._normalizeAngle(startAngle - endAngle));\n        ctx.arc(x, y, innerRadius + borderWidth / 2, endAngle - innerAngleClip / 2, startAngle + innerAngleClip / 2, true);\n    } else {\n        const clipWidth = Math.min(borderWidth / 2, outerRadius * helpers_dataset._normalizeAngle(startAngle - endAngle));\n        if (borderJoinStyle === 'round') {\n            ctx.arc(x, y, clipWidth, endAngle - helpers_dataset.PI / 2, startAngle + helpers_dataset.PI / 2, true);\n        } else if (borderJoinStyle === 'bevel') {\n            const r = 2 * clipWidth * clipWidth;\n            const endX = -r * Math.cos(endAngle + helpers_dataset.PI / 2) + x;\n            const endY = -r * Math.sin(endAngle + helpers_dataset.PI / 2) + y;\n            const startX = r * Math.cos(startAngle + helpers_dataset.PI / 2) + x;\n            const startY = r * Math.sin(startAngle + helpers_dataset.PI / 2) + y;\n            ctx.lineTo(endX, endY);\n            ctx.lineTo(startX, startY);\n        }\n    }\n    ctx.closePath();\n    ctx.moveTo(0, 0);\n    ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    ctx.clip('evenodd');\n}\nfunction clipArc(ctx, element, endAngle) {\n    const { startAngle , pixelMargin , x , y , outerRadius , innerRadius  } = element;\n    let angleMargin = pixelMargin / outerRadius;\n    // Draw an inner border by clipping the arc and drawing a double-width border\n    // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders\n    ctx.beginPath();\n    ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n    if (innerRadius > pixelMargin) {\n        angleMargin = pixelMargin / innerRadius;\n        ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n    } else {\n        ctx.arc(x, y, pixelMargin, endAngle + helpers_dataset.HALF_PI, startAngle - helpers_dataset.HALF_PI);\n    }\n    ctx.closePath();\n    ctx.clip();\n}\nfunction toRadiusCorners(value) {\n    return helpers_dataset._readValueToProps(value, [\n        'outerStart',\n        'outerEnd',\n        'innerStart',\n        'innerEnd'\n    ]);\n}\n/**\n * Parse border radius from the provided options\n */ function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {\n    const o = toRadiusCorners(arc.options.borderRadius);\n    const halfThickness = (outerRadius - innerRadius) / 2;\n    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n    // Outer limits are complicated. We want to compute the available angular distance at\n    // a radius of outerRadius - borderRadius because for small angular distances, this term limits.\n    // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.\n    //\n    // If the borderRadius is large, that value can become negative.\n    // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius\n    // we know that the thickness term will dominate and compute the limits at that point\n    const computeOuterLimit = (val)=>{\n        const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n        return helpers_dataset._limitValue(val, 0, Math.min(halfThickness, outerArcLimit));\n    };\n    return {\n        outerStart: computeOuterLimit(o.outerStart),\n        outerEnd: computeOuterLimit(o.outerEnd),\n        innerStart: helpers_dataset._limitValue(o.innerStart, 0, innerLimit),\n        innerEnd: helpers_dataset._limitValue(o.innerEnd, 0, innerLimit)\n    };\n}\n/**\n * Convert (r, 𝜃) to (x, y)\n */ function rThetaToXY(r, theta, x, y) {\n    return {\n        x: x + r * Math.cos(theta),\n        y: y + r * Math.sin(theta)\n    };\n}\n/**\n * Path the arc, respecting border radius by separating into left and right halves.\n *\n *   Start      End\n *\n *    1--->a--->2    Outer\n *   /           \\\n *   8           3\n *   |           |\n *   |           |\n *   7           4\n *   \\           /\n *    6<---b<---5    Inner\n */ function pathArc(ctx, element, offset, spacing, end, circular) {\n    const { x , y , startAngle: start , pixelMargin , innerRadius: innerR  } = element;\n    const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n    const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n    let spacingOffset = 0;\n    const alpha = end - start;\n    if (spacing) {\n        // When spacing is present, it is the same for all items\n        // So we adjust the start and end angle of the arc such that\n        // the distance is the same as it would be without the spacing\n        const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n        const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n        const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n        const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;\n        spacingOffset = (alpha - adjustedAngle) / 2;\n    }\n    const beta = Math.max(0.001, alpha * outerRadius - offset / helpers_dataset.PI) / outerRadius;\n    const angleOffset = (alpha - beta) / 2;\n    const startAngle = start + angleOffset + spacingOffset;\n    const endAngle = end - angleOffset - spacingOffset;\n    const { outerStart , outerEnd , innerStart , innerEnd  } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);\n    const outerStartAdjustedRadius = outerRadius - outerStart;\n    const outerEndAdjustedRadius = outerRadius - outerEnd;\n    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n    const innerStartAdjustedRadius = innerRadius + innerStart;\n    const innerEndAdjustedRadius = innerRadius + innerEnd;\n    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n    ctx.beginPath();\n    if (circular) {\n        // The first arc segments from point 1 to point a to point 2\n        const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;\n        ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);\n        ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);\n        // The corner segment from point 2 to point 3\n        if (outerEnd > 0) {\n            const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + helpers_dataset.HALF_PI);\n        }\n        // The line from point 3 to point 4\n        const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n        ctx.lineTo(p4.x, p4.y);\n        // The corner segment from point 4 to point 5\n        if (innerEnd > 0) {\n            const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + helpers_dataset.HALF_PI, innerEndAdjustedAngle + Math.PI);\n        }\n        // The inner arc from point 5 to point b to point 6\n        const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;\n        ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);\n        ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);\n        // The corner segment from point 6 to point 7\n        if (innerStart > 0) {\n            const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - helpers_dataset.HALF_PI);\n        }\n        // The line from point 7 to point 8\n        const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n        ctx.lineTo(p8.x, p8.y);\n        // The corner segment from point 8 to point 1\n        if (outerStart > 0) {\n            const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - helpers_dataset.HALF_PI, outerStartAdjustedAngle);\n        }\n    } else {\n        ctx.moveTo(x, y);\n        const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\n        const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\n        ctx.lineTo(outerStartX, outerStartY);\n        const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\n        const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\n        ctx.lineTo(outerEndX, outerEndY);\n    }\n    ctx.closePath();\n}\nfunction drawArc(ctx, element, offset, spacing, circular) {\n    const { fullCircles , startAngle , circumference  } = element;\n    let endAngle = element.endAngle;\n    if (fullCircles) {\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\n        for(let i = 0; i < fullCircles; ++i){\n            ctx.fill();\n        }\n        if (!isNaN(circumference)) {\n            endAngle = startAngle + (circumference % helpers_dataset.TAU || helpers_dataset.TAU);\n        }\n    }\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    ctx.fill();\n    return endAngle;\n}\nfunction drawBorder(ctx, element, offset, spacing, circular) {\n    const { fullCircles , startAngle , circumference , options  } = element;\n    const { borderWidth , borderJoinStyle , borderDash , borderDashOffset , borderRadius  } = options;\n    const inner = options.borderAlign === 'inner';\n    if (!borderWidth) {\n        return;\n    }\n    ctx.setLineDash(borderDash || []);\n    ctx.lineDashOffset = borderDashOffset;\n    if (inner) {\n        ctx.lineWidth = borderWidth * 2;\n        ctx.lineJoin = borderJoinStyle || 'round';\n    } else {\n        ctx.lineWidth = borderWidth;\n        ctx.lineJoin = borderJoinStyle || 'bevel';\n    }\n    let endAngle = element.endAngle;\n    if (fullCircles) {\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\n        for(let i = 0; i < fullCircles; ++i){\n            ctx.stroke();\n        }\n        if (!isNaN(circumference)) {\n            endAngle = startAngle + (circumference % helpers_dataset.TAU || helpers_dataset.TAU);\n        }\n    }\n    if (inner) {\n        clipArc(ctx, element, endAngle);\n    }\n    if (options.selfJoin && endAngle - startAngle >= helpers_dataset.PI && borderRadius === 0 && borderJoinStyle !== 'miter') {\n        clipSelf(ctx, element, endAngle);\n    }\n    if (!fullCircles) {\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\n        ctx.stroke();\n    }\n}\nclass ArcElement extends Element {\n    static id = 'arc';\n    static defaults = {\n        borderAlign: 'center',\n        borderColor: '#fff',\n        borderDash: [],\n        borderDashOffset: 0,\n        borderJoinStyle: undefined,\n        borderRadius: 0,\n        borderWidth: 2,\n        offset: 0,\n        spacing: 0,\n        angle: undefined,\n        circular: true,\n        selfJoin: false\n    };\n    static defaultRoutes = {\n        backgroundColor: 'backgroundColor'\n    };\n    static descriptors = {\n        _scriptable: true,\n        _indexable: (name)=>name !== 'borderDash'\n    };\n    circumference;\n    endAngle;\n    fullCircles;\n    innerRadius;\n    outerRadius;\n    pixelMargin;\n    startAngle;\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.circumference = undefined;\n        this.startAngle = undefined;\n        this.endAngle = undefined;\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n        this.pixelMargin = 0;\n        this.fullCircles = 0;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    inRange(chartX, chartY, useFinalPosition) {\n        const point = this.getProps([\n            'x',\n            'y'\n        ], useFinalPosition);\n        const { angle , distance  } = helpers_dataset.getAngleFromPoint(point, {\n            x: chartX,\n            y: chartY\n        });\n        const { startAngle , endAngle , innerRadius , outerRadius , circumference  } = this.getProps([\n            'startAngle',\n            'endAngle',\n            'innerRadius',\n            'outerRadius',\n            'circumference'\n        ], useFinalPosition);\n        const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;\n        const _circumference = helpers_dataset.valueOrDefault(circumference, endAngle - startAngle);\n        const nonZeroBetween = helpers_dataset._angleBetween(angle, startAngle, endAngle) && startAngle !== endAngle;\n        const betweenAngles = _circumference >= helpers_dataset.TAU || nonZeroBetween;\n        const withinRadius = helpers_dataset._isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n        return betweenAngles && withinRadius;\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x , y , startAngle , endAngle , innerRadius , outerRadius  } = this.getProps([\n            'x',\n            'y',\n            'startAngle',\n            'endAngle',\n            'innerRadius',\n            'outerRadius'\n        ], useFinalPosition);\n        const { offset , spacing  } = this.options;\n        const halfAngle = (startAngle + endAngle) / 2;\n        const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n        return {\n            x: x + Math.cos(halfAngle) * halfRadius,\n            y: y + Math.sin(halfAngle) * halfRadius\n        };\n    }\n    tooltipPosition(useFinalPosition) {\n        return this.getCenterPoint(useFinalPosition);\n    }\n    draw(ctx) {\n        const { options , circumference  } = this;\n        const offset = (options.offset || 0) / 4;\n        const spacing = (options.spacing || 0) / 2;\n        const circular = options.circular;\n        this.pixelMargin = options.borderAlign === 'inner' ? 0.33 : 0;\n        this.fullCircles = circumference > helpers_dataset.TAU ? Math.floor(circumference / helpers_dataset.TAU) : 0;\n        if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n            return;\n        }\n        ctx.save();\n        const halfAngle = (this.startAngle + this.endAngle) / 2;\n        ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);\n        const fix = 1 - Math.sin(Math.min(helpers_dataset.PI, circumference || 0));\n        const radiusOffset = offset * fix;\n        ctx.fillStyle = options.backgroundColor;\n        ctx.strokeStyle = options.borderColor;\n        drawArc(ctx, this, radiusOffset, spacing, circular);\n        drawBorder(ctx, this, radiusOffset, spacing, circular);\n        ctx.restore();\n    }\n}\n\nfunction setStyle(ctx, options, style = options) {\n    ctx.lineCap = helpers_dataset.valueOrDefault(style.borderCapStyle, options.borderCapStyle);\n    ctx.setLineDash(helpers_dataset.valueOrDefault(style.borderDash, options.borderDash));\n    ctx.lineDashOffset = helpers_dataset.valueOrDefault(style.borderDashOffset, options.borderDashOffset);\n    ctx.lineJoin = helpers_dataset.valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);\n    ctx.lineWidth = helpers_dataset.valueOrDefault(style.borderWidth, options.borderWidth);\n    ctx.strokeStyle = helpers_dataset.valueOrDefault(style.borderColor, options.borderColor);\n}\nfunction lineTo(ctx, previous, target) {\n    ctx.lineTo(target.x, target.y);\n}\n function getLineMethod(options) {\n    if (options.stepped) {\n        return helpers_dataset._steppedLineTo;\n    }\n    if (options.tension || options.cubicInterpolationMode === 'monotone') {\n        return helpers_dataset._bezierCurveTo;\n    }\n    return lineTo;\n}\nfunction pathVars(points, segment, params = {}) {\n    const count = points.length;\n    const { start: paramsStart = 0 , end: paramsEnd = count - 1  } = params;\n    const { start: segmentStart , end: segmentEnd  } = segment;\n    const start = Math.max(paramsStart, segmentStart);\n    const end = Math.min(paramsEnd, segmentEnd);\n    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n    return {\n        count,\n        start,\n        loop: segment.loop,\n        ilen: end < start && !outside ? count + end - start : end - start\n    };\n}\n function pathSegment(ctx, line, segment, params) {\n    const { points , options  } = line;\n    const { count , start , loop , ilen  } = pathVars(points, segment, params);\n    const lineMethod = getLineMethod(options);\n    let { move =true , reverse  } = params || {};\n    let i, point, prev;\n    for(i = 0; i <= ilen; ++i){\n        point = points[(start + (reverse ? ilen - i : i)) % count];\n        if (point.skip) {\n            continue;\n        } else if (move) {\n            ctx.moveTo(point.x, point.y);\n            move = false;\n        } else {\n            lineMethod(ctx, prev, point, reverse, options.stepped);\n        }\n        prev = point;\n    }\n    if (loop) {\n        point = points[(start + (reverse ? ilen : 0)) % count];\n        lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n    return !!loop;\n}\n function fastPathSegment(ctx, line, segment, params) {\n    const points = line.points;\n    const { count , start , ilen  } = pathVars(points, segment, params);\n    const { move =true , reverse  } = params || {};\n    let avgX = 0;\n    let countX = 0;\n    let i, point, prevX, minY, maxY, lastY;\n    const pointIndex = (index)=>(start + (reverse ? ilen - index : index)) % count;\n    const drawX = ()=>{\n        if (minY !== maxY) {\n            ctx.lineTo(avgX, maxY);\n            ctx.lineTo(avgX, minY);\n            ctx.lineTo(avgX, lastY);\n        }\n    };\n    if (move) {\n        point = points[pointIndex(0)];\n        ctx.moveTo(point.x, point.y);\n    }\n    for(i = 0; i <= ilen; ++i){\n        point = points[pointIndex(i)];\n        if (point.skip) {\n            continue;\n        }\n        const x = point.x;\n        const y = point.y;\n        const truncX = x | 0;\n        if (truncX === prevX) {\n            if (y < minY) {\n                minY = y;\n            } else if (y > maxY) {\n                maxY = y;\n            }\n            avgX = (countX * avgX + x) / ++countX;\n        } else {\n            drawX();\n            ctx.lineTo(x, y);\n            prevX = truncX;\n            countX = 0;\n            minY = maxY = y;\n        }\n        lastY = y;\n    }\n    drawX();\n}\n function _getSegmentMethod(line) {\n    const opts = line.options;\n    const borderDash = opts.borderDash && opts.borderDash.length;\n    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\n    return useFastPath ? fastPathSegment : pathSegment;\n}\n function _getInterpolationMethod(options) {\n    if (options.stepped) {\n        return helpers_dataset._steppedInterpolation;\n    }\n    if (options.tension || options.cubicInterpolationMode === 'monotone') {\n        return helpers_dataset._bezierInterpolation;\n    }\n    return helpers_dataset._pointInLine;\n}\nfunction strokePathWithCache(ctx, line, start, count) {\n    let path = line._path;\n    if (!path) {\n        path = line._path = new Path2D();\n        if (line.path(path, start, count)) {\n            path.closePath();\n        }\n    }\n    setStyle(ctx, line.options);\n    ctx.stroke(path);\n}\nfunction strokePathDirect(ctx, line, start, count) {\n    const { segments , options  } = line;\n    const segmentMethod = _getSegmentMethod(line);\n    for (const segment of segments){\n        setStyle(ctx, options, segment.style);\n        ctx.beginPath();\n        if (segmentMethod(ctx, line, segment, {\n            start,\n            end: start + count - 1\n        })) {\n            ctx.closePath();\n        }\n        ctx.stroke();\n    }\n}\nconst usePath2D = typeof Path2D === 'function';\nfunction draw(ctx, line, start, count) {\n    if (usePath2D && !line.options.segment) {\n        strokePathWithCache(ctx, line, start, count);\n    } else {\n        strokePathDirect(ctx, line, start, count);\n    }\n}\nclass LineElement extends Element {\n    static id = 'line';\n static defaults = {\n        borderCapStyle: 'butt',\n        borderDash: [],\n        borderDashOffset: 0,\n        borderJoinStyle: 'miter',\n        borderWidth: 3,\n        capBezierPoints: true,\n        cubicInterpolationMode: 'default',\n        fill: false,\n        spanGaps: false,\n        stepped: false,\n        tension: 0\n    };\n static defaultRoutes = {\n        backgroundColor: 'backgroundColor',\n        borderColor: 'borderColor'\n    };\n    static descriptors = {\n        _scriptable: true,\n        _indexable: (name)=>name !== 'borderDash' && name !== 'fill'\n    };\n    constructor(cfg){\n        super();\n        this.animated = true;\n        this.options = undefined;\n        this._chart = undefined;\n        this._loop = undefined;\n        this._fullLoop = undefined;\n        this._path = undefined;\n        this._points = undefined;\n        this._segments = undefined;\n        this._decimated = false;\n        this._pointsUpdated = false;\n        this._datasetIndex = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    updateControlPoints(chartArea, indexAxis) {\n        const options = this.options;\n        if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {\n            const loop = options.spanGaps ? this._loop : this._fullLoop;\n            helpers_dataset._updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);\n            this._pointsUpdated = true;\n        }\n    }\n    set points(points) {\n        this._points = points;\n        delete this._segments;\n        delete this._path;\n        this._pointsUpdated = false;\n    }\n    get points() {\n        return this._points;\n    }\n    get segments() {\n        return this._segments || (this._segments = helpers_dataset._computeSegments(this, this.options.segment));\n    }\n first() {\n        const segments = this.segments;\n        const points = this.points;\n        return segments.length && points[segments[0].start];\n    }\n last() {\n        const segments = this.segments;\n        const points = this.points;\n        const count = segments.length;\n        return count && points[segments[count - 1].end];\n    }\n interpolate(point, property) {\n        const options = this.options;\n        const value = point[property];\n        const points = this.points;\n        const segments = helpers_dataset._boundSegments(this, {\n            property,\n            start: value,\n            end: value\n        });\n        if (!segments.length) {\n            return;\n        }\n        const result = [];\n        const _interpolate = _getInterpolationMethod(options);\n        let i, ilen;\n        for(i = 0, ilen = segments.length; i < ilen; ++i){\n            const { start , end  } = segments[i];\n            const p1 = points[start];\n            const p2 = points[end];\n            if (p1 === p2) {\n                result.push(p1);\n                continue;\n            }\n            const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n            const interpolated = _interpolate(p1, p2, t, options.stepped);\n            interpolated[property] = point[property];\n            result.push(interpolated);\n        }\n        return result.length === 1 ? result[0] : result;\n    }\n pathSegment(ctx, segment, params) {\n        const segmentMethod = _getSegmentMethod(this);\n        return segmentMethod(ctx, this, segment, params);\n    }\n path(ctx, start, count) {\n        const segments = this.segments;\n        const segmentMethod = _getSegmentMethod(this);\n        let loop = this._loop;\n        start = start || 0;\n        count = count || this.points.length - start;\n        for (const segment of segments){\n            loop &= segmentMethod(ctx, this, segment, {\n                start,\n                end: start + count - 1\n            });\n        }\n        return !!loop;\n    }\n draw(ctx, chartArea, start, count) {\n        const options = this.options || {};\n        const points = this.points || [];\n        if (points.length && options.borderWidth) {\n            ctx.save();\n            draw(ctx, this, start, count);\n            ctx.restore();\n        }\n        if (this.animated) {\n            this._pointsUpdated = false;\n            this._path = undefined;\n        }\n    }\n}\n\nfunction inRange$1(el, pos, axis, useFinalPosition) {\n    const options = el.options;\n    const { [axis]: value  } = el.getProps([\n        axis\n    ], useFinalPosition);\n    return Math.abs(pos - value) < options.radius + options.hitRadius;\n}\nclass PointElement extends Element {\n    static id = 'point';\n    parsed;\n    skip;\n    stop;\n    /**\n   * @type {any}\n   */ static defaults = {\n        borderWidth: 1,\n        hitRadius: 1,\n        hoverBorderWidth: 1,\n        hoverRadius: 4,\n        pointStyle: 'circle',\n        radius: 3,\n        rotation: 0\n    };\n    /**\n   * @type {any}\n   */ static defaultRoutes = {\n        backgroundColor: 'backgroundColor',\n        borderColor: 'borderColor'\n    };\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.parsed = undefined;\n        this.skip = undefined;\n        this.stop = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    inRange(mouseX, mouseY, useFinalPosition) {\n        const options = this.options;\n        const { x , y  } = this.getProps([\n            'x',\n            'y'\n        ], useFinalPosition);\n        return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);\n    }\n    inXRange(mouseX, useFinalPosition) {\n        return inRange$1(this, mouseX, 'x', useFinalPosition);\n    }\n    inYRange(mouseY, useFinalPosition) {\n        return inRange$1(this, mouseY, 'y', useFinalPosition);\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x , y  } = this.getProps([\n            'x',\n            'y'\n        ], useFinalPosition);\n        return {\n            x,\n            y\n        };\n    }\n    size(options) {\n        options = options || this.options || {};\n        let radius = options.radius || 0;\n        radius = Math.max(radius, radius && options.hoverRadius || 0);\n        const borderWidth = radius && options.borderWidth || 0;\n        return (radius + borderWidth) * 2;\n    }\n    draw(ctx, area) {\n        const options = this.options;\n        if (this.skip || options.radius < 0.1 || !helpers_dataset._isPointInArea(this, area, this.size(options) / 2)) {\n            return;\n        }\n        ctx.strokeStyle = options.borderColor;\n        ctx.lineWidth = options.borderWidth;\n        ctx.fillStyle = options.backgroundColor;\n        helpers_dataset.drawPoint(ctx, options, this.x, this.y);\n    }\n    getRange() {\n        const options = this.options || {};\n        // @ts-expect-error Fallbacks should never be hit in practice\n        return options.radius + options.hitRadius;\n    }\n}\n\nfunction getBarBounds(bar, useFinalPosition) {\n    const { x , y , base , width , height  } =  bar.getProps([\n        'x',\n        'y',\n        'base',\n        'width',\n        'height'\n    ], useFinalPosition);\n    let left, right, top, bottom, half;\n    if (bar.horizontal) {\n        half = height / 2;\n        left = Math.min(x, base);\n        right = Math.max(x, base);\n        top = y - half;\n        bottom = y + half;\n    } else {\n        half = width / 2;\n        left = x - half;\n        right = x + half;\n        top = Math.min(y, base);\n        bottom = Math.max(y, base);\n    }\n    return {\n        left,\n        top,\n        right,\n        bottom\n    };\n}\nfunction skipOrLimit(skip, value, min, max) {\n    return skip ? 0 : helpers_dataset._limitValue(value, min, max);\n}\nfunction parseBorderWidth(bar, maxW, maxH) {\n    const value = bar.options.borderWidth;\n    const skip = bar.borderSkipped;\n    const o = helpers_dataset.toTRBL(value);\n    return {\n        t: skipOrLimit(skip.top, o.top, 0, maxH),\n        r: skipOrLimit(skip.right, o.right, 0, maxW),\n        b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n        l: skipOrLimit(skip.left, o.left, 0, maxW)\n    };\n}\nfunction parseBorderRadius(bar, maxW, maxH) {\n    const { enableBorderRadius  } = bar.getProps([\n        'enableBorderRadius'\n    ]);\n    const value = bar.options.borderRadius;\n    const o = helpers_dataset.toTRBLCorners(value);\n    const maxR = Math.min(maxW, maxH);\n    const skip = bar.borderSkipped;\n    const enableBorder = enableBorderRadius || helpers_dataset.isObject(value);\n    return {\n        topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n        topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n        bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n        bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n    };\n}\nfunction boundingRects(bar) {\n    const bounds = getBarBounds(bar);\n    const width = bounds.right - bounds.left;\n    const height = bounds.bottom - bounds.top;\n    const border = parseBorderWidth(bar, width / 2, height / 2);\n    const radius = parseBorderRadius(bar, width / 2, height / 2);\n    return {\n        outer: {\n            x: bounds.left,\n            y: bounds.top,\n            w: width,\n            h: height,\n            radius\n        },\n        inner: {\n            x: bounds.left + border.l,\n            y: bounds.top + border.t,\n            w: width - border.l - border.r,\n            h: height - border.t - border.b,\n            radius: {\n                topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n                topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n                bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n                bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))\n            }\n        }\n    };\n}\nfunction inRange(bar, x, y, useFinalPosition) {\n    const skipX = x === null;\n    const skipY = y === null;\n    const skipBoth = skipX && skipY;\n    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n    return bounds && (skipX || helpers_dataset._isBetween(x, bounds.left, bounds.right)) && (skipY || helpers_dataset._isBetween(y, bounds.top, bounds.bottom));\n}\nfunction hasRadius(radius) {\n    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\n function addNormalRectPath(ctx, rect) {\n    ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\nfunction inflateRect(rect, amount, refRect = {}) {\n    const x = rect.x !== refRect.x ? -amount : 0;\n    const y = rect.y !== refRect.y ? -amount : 0;\n    const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n    const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n    return {\n        x: rect.x + x,\n        y: rect.y + y,\n        w: rect.w + w,\n        h: rect.h + h,\n        radius: rect.radius\n    };\n}\nclass BarElement extends Element {\n    static id = 'bar';\n static defaults = {\n        borderSkipped: 'start',\n        borderWidth: 0,\n        borderRadius: 0,\n        inflateAmount: 'auto',\n        pointStyle: undefined\n    };\n static defaultRoutes = {\n        backgroundColor: 'backgroundColor',\n        borderColor: 'borderColor'\n    };\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.horizontal = undefined;\n        this.base = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this.inflateAmount = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    draw(ctx) {\n        const { inflateAmount , options: { borderColor , backgroundColor  }  } = this;\n        const { inner , outer  } = boundingRects(this);\n        const addRectPath = hasRadius(outer.radius) ? helpers_dataset.addRoundedRectPath : addNormalRectPath;\n        ctx.save();\n        if (outer.w !== inner.w || outer.h !== inner.h) {\n            ctx.beginPath();\n            addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n            ctx.clip();\n            addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n            ctx.fillStyle = borderColor;\n            ctx.fill('evenodd');\n        }\n        ctx.beginPath();\n        addRectPath(ctx, inflateRect(inner, inflateAmount));\n        ctx.fillStyle = backgroundColor;\n        ctx.fill();\n        ctx.restore();\n    }\n    inRange(mouseX, mouseY, useFinalPosition) {\n        return inRange(this, mouseX, mouseY, useFinalPosition);\n    }\n    inXRange(mouseX, useFinalPosition) {\n        return inRange(this, mouseX, null, useFinalPosition);\n    }\n    inYRange(mouseY, useFinalPosition) {\n        return inRange(this, null, mouseY, useFinalPosition);\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x , y , base , horizontal  } =  this.getProps([\n            'x',\n            'y',\n            'base',\n            'horizontal'\n        ], useFinalPosition);\n        return {\n            x: horizontal ? (x + base) / 2 : x,\n            y: horizontal ? y : (y + base) / 2\n        };\n    }\n    getRange(axis) {\n        return axis === 'x' ? this.width / 2 : this.height / 2;\n    }\n}\n\nvar elements = /*#__PURE__*/Object.freeze({\n__proto__: null,\nArcElement: ArcElement,\nBarElement: BarElement,\nLineElement: LineElement,\nPointElement: PointElement\n});\n\nconst BORDER_COLORS = [\n    'rgb(54, 162, 235)',\n    'rgb(255, 99, 132)',\n    'rgb(255, 159, 64)',\n    'rgb(255, 205, 86)',\n    'rgb(75, 192, 192)',\n    'rgb(153, 102, 255)',\n    'rgb(201, 203, 207)' // grey\n];\n// Border colors with 50% transparency\nconst BACKGROUND_COLORS = /* #__PURE__ */ BORDER_COLORS.map((color)=>color.replace('rgb(', 'rgba(').replace(')', ', 0.5)'));\nfunction getBorderColor(i) {\n    return BORDER_COLORS[i % BORDER_COLORS.length];\n}\nfunction getBackgroundColor(i) {\n    return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];\n}\nfunction colorizeDefaultDataset(dataset, i) {\n    dataset.borderColor = getBorderColor(i);\n    dataset.backgroundColor = getBackgroundColor(i);\n    return ++i;\n}\nfunction colorizeDoughnutDataset(dataset, i) {\n    dataset.backgroundColor = dataset.data.map(()=>getBorderColor(i++));\n    return i;\n}\nfunction colorizePolarAreaDataset(dataset, i) {\n    dataset.backgroundColor = dataset.data.map(()=>getBackgroundColor(i++));\n    return i;\n}\nfunction getColorizer(chart) {\n    let i = 0;\n    return (dataset, datasetIndex)=>{\n        const controller = chart.getDatasetMeta(datasetIndex).controller;\n        if (controller instanceof DoughnutController) {\n            i = colorizeDoughnutDataset(dataset, i);\n        } else if (controller instanceof PolarAreaController) {\n            i = colorizePolarAreaDataset(dataset, i);\n        } else if (controller) {\n            i = colorizeDefaultDataset(dataset, i);\n        }\n    };\n}\nfunction containsColorsDefinitions(descriptors) {\n    let k;\n    for(k in descriptors){\n        if (descriptors[k].borderColor || descriptors[k].backgroundColor) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction containsColorsDefinition(descriptor) {\n    return descriptor && (descriptor.borderColor || descriptor.backgroundColor);\n}\nfunction containsDefaultColorsDefenitions() {\n    return helpers_dataset.defaults.borderColor !== 'rgba(0,0,0,0.1)' || helpers_dataset.defaults.backgroundColor !== 'rgba(0,0,0,0.1)';\n}\nvar plugin_colors = {\n    id: 'colors',\n    defaults: {\n        enabled: true,\n        forceOverride: false\n    },\n    beforeLayout (chart, _args, options) {\n        if (!options.enabled) {\n            return;\n        }\n        const { data: { datasets  } , options: chartOptions  } = chart.config;\n        const { elements  } = chartOptions;\n        const containsColorDefenition = containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements && containsColorsDefinitions(elements) || containsDefaultColorsDefenitions();\n        if (!options.forceOverride && containsColorDefenition) {\n            return;\n        }\n        const colorizer = getColorizer(chart);\n        datasets.forEach(colorizer);\n    }\n};\n\nfunction lttbDecimation(data, start, count, availableWidth, options) {\n const samples = options.samples || availableWidth;\n    if (samples >= count) {\n        return data.slice(start, start + count);\n    }\n    const decimated = [];\n    const bucketWidth = (count - 2) / (samples - 2);\n    let sampledIndex = 0;\n    const endIndex = start + count - 1;\n    let a = start;\n    let i, maxAreaPoint, maxArea, area, nextA;\n    decimated[sampledIndex++] = data[a];\n    for(i = 0; i < samples - 2; i++){\n        let avgX = 0;\n        let avgY = 0;\n        let j;\n        const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\n        const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\n        const avgRangeLength = avgRangeEnd - avgRangeStart;\n        for(j = avgRangeStart; j < avgRangeEnd; j++){\n            avgX += data[j].x;\n            avgY += data[j].y;\n        }\n        avgX /= avgRangeLength;\n        avgY /= avgRangeLength;\n        const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\n        const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\n        const { x: pointAx , y: pointAy  } = data[a];\n        maxArea = area = -1;\n        for(j = rangeOffs; j < rangeTo; j++){\n            area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));\n            if (area > maxArea) {\n                maxArea = area;\n                maxAreaPoint = data[j];\n                nextA = j;\n            }\n        }\n        decimated[sampledIndex++] = maxAreaPoint;\n        a = nextA;\n    }\n    decimated[sampledIndex++] = data[endIndex];\n    return decimated;\n}\nfunction minMaxDecimation(data, start, count, availableWidth) {\n    let avgX = 0;\n    let countX = 0;\n    let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\n    const decimated = [];\n    const endIndex = start + count - 1;\n    const xMin = data[start].x;\n    const xMax = data[endIndex].x;\n    const dx = xMax - xMin;\n    for(i = start; i < start + count; ++i){\n        point = data[i];\n        x = (point.x - xMin) / dx * availableWidth;\n        y = point.y;\n        const truncX = x | 0;\n        if (truncX === prevX) {\n            if (y < minY) {\n                minY = y;\n                minIndex = i;\n            } else if (y > maxY) {\n                maxY = y;\n                maxIndex = i;\n            }\n            avgX = (countX * avgX + point.x) / ++countX;\n        } else {\n            const lastIndex = i - 1;\n            if (!helpers_dataset.isNullOrUndef(minIndex) && !helpers_dataset.isNullOrUndef(maxIndex)) {\n                const intermediateIndex1 = Math.min(minIndex, maxIndex);\n                const intermediateIndex2 = Math.max(minIndex, maxIndex);\n                if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\n                    decimated.push({\n                        ...data[intermediateIndex1],\n                        x: avgX\n                    });\n                }\n                if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\n                    decimated.push({\n                        ...data[intermediateIndex2],\n                        x: avgX\n                    });\n                }\n            }\n            if (i > 0 && lastIndex !== startIndex) {\n                decimated.push(data[lastIndex]);\n            }\n            decimated.push(point);\n            prevX = truncX;\n            countX = 0;\n            minY = maxY = y;\n            minIndex = maxIndex = startIndex = i;\n        }\n    }\n    return decimated;\n}\nfunction cleanDecimatedDataset(dataset) {\n    if (dataset._decimated) {\n        const data = dataset._data;\n        delete dataset._decimated;\n        delete dataset._data;\n        Object.defineProperty(dataset, 'data', {\n            configurable: true,\n            enumerable: true,\n            writable: true,\n            value: data\n        });\n    }\n}\nfunction cleanDecimatedData(chart) {\n    chart.data.datasets.forEach((dataset)=>{\n        cleanDecimatedDataset(dataset);\n    });\n}\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\n    const pointCount = points.length;\n    let start = 0;\n    let count;\n    const { iScale  } = meta;\n    const { min , max , minDefined , maxDefined  } = iScale.getUserBounds();\n    if (minDefined) {\n        start = helpers_dataset._limitValue(helpers_dataset._lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);\n    }\n    if (maxDefined) {\n        count = helpers_dataset._limitValue(helpers_dataset._lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;\n    } else {\n        count = pointCount - start;\n    }\n    return {\n        start,\n        count\n    };\n}\nvar plugin_decimation = {\n    id: 'decimation',\n    defaults: {\n        algorithm: 'min-max',\n        enabled: false\n    },\n    beforeElementsUpdate: (chart, args, options)=>{\n        if (!options.enabled) {\n            cleanDecimatedData(chart);\n            return;\n        }\n        const availableWidth = chart.width;\n        chart.data.datasets.forEach((dataset, datasetIndex)=>{\n            const { _data , indexAxis  } = dataset;\n            const meta = chart.getDatasetMeta(datasetIndex);\n            const data = _data || dataset.data;\n            if (helpers_dataset.resolve([\n                indexAxis,\n                chart.options.indexAxis\n            ]) === 'y') {\n                return;\n            }\n            if (!meta.controller.supportsDecimation) {\n                return;\n            }\n            const xAxis = chart.scales[meta.xAxisID];\n            if (xAxis.type !== 'linear' && xAxis.type !== 'time') {\n                return;\n            }\n            if (chart.options.parsing) {\n                return;\n            }\n            let { start , count  } = getStartAndCountOfVisiblePointsSimplified(meta, data);\n            const threshold = options.threshold || 4 * availableWidth;\n            if (count <= threshold) {\n                cleanDecimatedDataset(dataset);\n                return;\n            }\n            if (helpers_dataset.isNullOrUndef(_data)) {\n                dataset._data = data;\n                delete dataset.data;\n                Object.defineProperty(dataset, 'data', {\n                    configurable: true,\n                    enumerable: true,\n                    get: function() {\n                        return this._decimated;\n                    },\n                    set: function(d) {\n                        this._data = d;\n                    }\n                });\n            }\n            let decimated;\n            switch(options.algorithm){\n                case 'lttb':\n                    decimated = lttbDecimation(data, start, count, availableWidth, options);\n                    break;\n                case 'min-max':\n                    decimated = minMaxDecimation(data, start, count, availableWidth);\n                    break;\n                default:\n                    throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\n            }\n            dataset._decimated = decimated;\n        });\n    },\n    destroy (chart) {\n        cleanDecimatedData(chart);\n    }\n};\n\nfunction _segments(line, target, property) {\n    const segments = line.segments;\n    const points = line.points;\n    const tpoints = target.points;\n    const parts = [];\n    for (const segment of segments){\n        let { start , end  } = segment;\n        end = _findSegmentEnd(start, end, points);\n        const bounds = _getBounds(property, points[start], points[end], segment.loop);\n        if (!target.segments) {\n            parts.push({\n                source: segment,\n                target: bounds,\n                start: points[start],\n                end: points[end]\n            });\n            continue;\n        }\n        const targetSegments = helpers_dataset._boundSegments(target, bounds);\n        for (const tgt of targetSegments){\n            const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n            const fillSources = helpers_dataset._boundSegment(segment, points, subBounds);\n            for (const fillSource of fillSources){\n                parts.push({\n                    source: fillSource,\n                    target: tgt,\n                    start: {\n                        [property]: _getEdge(bounds, subBounds, 'start', Math.max)\n                    },\n                    end: {\n                        [property]: _getEdge(bounds, subBounds, 'end', Math.min)\n                    }\n                });\n            }\n        }\n    }\n    return parts;\n}\nfunction _getBounds(property, first, last, loop) {\n    if (loop) {\n        return;\n    }\n    let start = first[property];\n    let end = last[property];\n    if (property === 'angle') {\n        start = helpers_dataset._normalizeAngle(start);\n        end = helpers_dataset._normalizeAngle(end);\n    }\n    return {\n        property,\n        start,\n        end\n    };\n}\nfunction _pointsFromSegments(boundary, line) {\n    const { x =null , y =null  } = boundary || {};\n    const linePoints = line.points;\n    const points = [];\n    line.segments.forEach(({ start , end  })=>{\n        end = _findSegmentEnd(start, end, linePoints);\n        const first = linePoints[start];\n        const last = linePoints[end];\n        if (y !== null) {\n            points.push({\n                x: first.x,\n                y\n            });\n            points.push({\n                x: last.x,\n                y\n            });\n        } else if (x !== null) {\n            points.push({\n                x,\n                y: first.y\n            });\n            points.push({\n                x,\n                y: last.y\n            });\n        }\n    });\n    return points;\n}\nfunction _findSegmentEnd(start, end, points) {\n    for(; end > start; end--){\n        const point = points[end];\n        if (!isNaN(point.x) && !isNaN(point.y)) {\n            break;\n        }\n    }\n    return end;\n}\nfunction _getEdge(a, b, prop, fn) {\n    if (a && b) {\n        return fn(a[prop], b[prop]);\n    }\n    return a ? a[prop] : b ? b[prop] : 0;\n}\n\nfunction _createBoundaryLine(boundary, line) {\n    let points = [];\n    let _loop = false;\n    if (helpers_dataset.isArray(boundary)) {\n        _loop = true;\n        points = boundary;\n    } else {\n        points = _pointsFromSegments(boundary, line);\n    }\n    return points.length ? new LineElement({\n        points,\n        options: {\n            tension: 0\n        },\n        _loop,\n        _fullLoop: _loop\n    }) : null;\n}\nfunction _shouldApplyFill(source) {\n    return source && source.fill !== false;\n}\n\nfunction _resolveTarget(sources, index, propagate) {\n    const source = sources[index];\n    let fill = source.fill;\n    const visited = [\n        index\n    ];\n    let target;\n    if (!propagate) {\n        return fill;\n    }\n    while(fill !== false && visited.indexOf(fill) === -1){\n        if (!helpers_dataset.isNumberFinite(fill)) {\n            return fill;\n        }\n        target = sources[fill];\n        if (!target) {\n            return false;\n        }\n        if (target.visible) {\n            return fill;\n        }\n        visited.push(fill);\n        fill = target.fill;\n    }\n    return false;\n}\n function _decodeFill(line, index, count) {\n     const fill = parseFillOption(line);\n    if (helpers_dataset.isObject(fill)) {\n        return isNaN(fill.value) ? false : fill;\n    }\n    let target = parseFloat(fill);\n    if (helpers_dataset.isNumberFinite(target) && Math.floor(target) === target) {\n        return decodeTargetIndex(fill[0], index, target, count);\n    }\n    return [\n        'origin',\n        'start',\n        'end',\n        'stack',\n        'shape'\n    ].indexOf(fill) >= 0 && fill;\n}\nfunction decodeTargetIndex(firstCh, index, target, count) {\n    if (firstCh === '-' || firstCh === '+') {\n        target = index + target;\n    }\n    if (target === index || target < 0 || target >= count) {\n        return false;\n    }\n    return target;\n}\n function _getTargetPixel(fill, scale) {\n    let pixel = null;\n    if (fill === 'start') {\n        pixel = scale.bottom;\n    } else if (fill === 'end') {\n        pixel = scale.top;\n    } else if (helpers_dataset.isObject(fill)) {\n        pixel = scale.getPixelForValue(fill.value);\n    } else if (scale.getBasePixel) {\n        pixel = scale.getBasePixel();\n    }\n    return pixel;\n}\n function _getTargetValue(fill, scale, startValue) {\n    let value;\n    if (fill === 'start') {\n        value = startValue;\n    } else if (fill === 'end') {\n        value = scale.options.reverse ? scale.min : scale.max;\n    } else if (helpers_dataset.isObject(fill)) {\n        value = fill.value;\n    } else {\n        value = scale.getBaseValue();\n    }\n    return value;\n}\n function parseFillOption(line) {\n    const options = line.options;\n    const fillOption = options.fill;\n    let fill = helpers_dataset.valueOrDefault(fillOption && fillOption.target, fillOption);\n    if (fill === undefined) {\n        fill = !!options.backgroundColor;\n    }\n    if (fill === false || fill === null) {\n        return false;\n    }\n    if (fill === true) {\n        return 'origin';\n    }\n    return fill;\n}\n\nfunction _buildStackLine(source) {\n    const { scale , index , line  } = source;\n    const points = [];\n    const segments = line.segments;\n    const sourcePoints = line.points;\n    const linesBelow = getLinesBelow(scale, index);\n    linesBelow.push(_createBoundaryLine({\n        x: null,\n        y: scale.bottom\n    }, line));\n    for(let i = 0; i < segments.length; i++){\n        const segment = segments[i];\n        for(let j = segment.start; j <= segment.end; j++){\n            addPointsBelow(points, sourcePoints[j], linesBelow);\n        }\n    }\n    return new LineElement({\n        points,\n        options: {}\n    });\n}\n function getLinesBelow(scale, index) {\n    const below = [];\n    const metas = scale.getMatchingVisibleMetas('line');\n    for(let i = 0; i < metas.length; i++){\n        const meta = metas[i];\n        if (meta.index === index) {\n            break;\n        }\n        if (!meta.hidden) {\n            below.unshift(meta.dataset);\n        }\n    }\n    return below;\n}\n function addPointsBelow(points, sourcePoint, linesBelow) {\n    const postponed = [];\n    for(let j = 0; j < linesBelow.length; j++){\n        const line = linesBelow[j];\n        const { first , last , point  } = findPoint(line, sourcePoint, 'x');\n        if (!point || first && last) {\n            continue;\n        }\n        if (first) {\n            postponed.unshift(point);\n        } else {\n            points.push(point);\n            if (!last) {\n                break;\n            }\n        }\n    }\n    points.push(...postponed);\n}\n function findPoint(line, sourcePoint, property) {\n    const point = line.interpolate(sourcePoint, property);\n    if (!point) {\n        return {};\n    }\n    const pointValue = point[property];\n    const segments = line.segments;\n    const linePoints = line.points;\n    let first = false;\n    let last = false;\n    for(let i = 0; i < segments.length; i++){\n        const segment = segments[i];\n        const firstValue = linePoints[segment.start][property];\n        const lastValue = linePoints[segment.end][property];\n        if (helpers_dataset._isBetween(pointValue, firstValue, lastValue)) {\n            first = pointValue === firstValue;\n            last = pointValue === lastValue;\n            break;\n        }\n    }\n    return {\n        first,\n        last,\n        point\n    };\n}\n\nclass simpleArc {\n    constructor(opts){\n        this.x = opts.x;\n        this.y = opts.y;\n        this.radius = opts.radius;\n    }\n    pathSegment(ctx, bounds, opts) {\n        const { x , y , radius  } = this;\n        bounds = bounds || {\n            start: 0,\n            end: helpers_dataset.TAU\n        };\n        ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n        return !opts.bounds;\n    }\n    interpolate(point) {\n        const { x , y , radius  } = this;\n        const angle = point.angle;\n        return {\n            x: x + Math.cos(angle) * radius,\n            y: y + Math.sin(angle) * radius,\n            angle\n        };\n    }\n}\n\nfunction _getTarget(source) {\n    const { chart , fill , line  } = source;\n    if (helpers_dataset.isNumberFinite(fill)) {\n        return getLineByIndex(chart, fill);\n    }\n    if (fill === 'stack') {\n        return _buildStackLine(source);\n    }\n    if (fill === 'shape') {\n        return true;\n    }\n    const boundary = computeBoundary(source);\n    if (boundary instanceof simpleArc) {\n        return boundary;\n    }\n    return _createBoundaryLine(boundary, line);\n}\n function getLineByIndex(chart, index) {\n    const meta = chart.getDatasetMeta(index);\n    const visible = meta && chart.isDatasetVisible(index);\n    return visible ? meta.dataset : null;\n}\nfunction computeBoundary(source) {\n    const scale = source.scale || {};\n    if (scale.getPointPositionForValue) {\n        return computeCircularBoundary(source);\n    }\n    return computeLinearBoundary(source);\n}\nfunction computeLinearBoundary(source) {\n    const { scale ={} , fill  } = source;\n    const pixel = _getTargetPixel(fill, scale);\n    if (helpers_dataset.isNumberFinite(pixel)) {\n        const horizontal = scale.isHorizontal();\n        return {\n            x: horizontal ? pixel : null,\n            y: horizontal ? null : pixel\n        };\n    }\n    return null;\n}\nfunction computeCircularBoundary(source) {\n    const { scale , fill  } = source;\n    const options = scale.options;\n    const length = scale.getLabels().length;\n    const start = options.reverse ? scale.max : scale.min;\n    const value = _getTargetValue(fill, scale, start);\n    const target = [];\n    if (options.grid.circular) {\n        const center = scale.getPointPositionForValue(0, start);\n        return new simpleArc({\n            x: center.x,\n            y: center.y,\n            radius: scale.getDistanceFromCenterForValue(value)\n        });\n    }\n    for(let i = 0; i < length; ++i){\n        target.push(scale.getPointPositionForValue(i, value));\n    }\n    return target;\n}\n\nfunction _drawfill(ctx, source, area) {\n    const target = _getTarget(source);\n    const { chart , index , line , scale , axis  } = source;\n    const lineOpts = line.options;\n    const fillOption = lineOpts.fill;\n    const color = lineOpts.backgroundColor;\n    const { above =color , below =color  } = fillOption || {};\n    const meta = chart.getDatasetMeta(index);\n    const clip = helpers_dataset.getDatasetClipArea(chart, meta);\n    if (target && line.points.length) {\n        helpers_dataset.clipArea(ctx, area);\n        doFill(ctx, {\n            line,\n            target,\n            above,\n            below,\n            area,\n            scale,\n            axis,\n            clip\n        });\n        helpers_dataset.unclipArea(ctx);\n    }\n}\nfunction doFill(ctx, cfg) {\n    const { line , target , above , below , area , scale , clip  } = cfg;\n    const property = line._loop ? 'angle' : cfg.axis;\n    ctx.save();\n    let fillColor = below;\n    if (below !== above) {\n        if (property === 'x') {\n            clipVertical(ctx, target, area.top);\n            fill(ctx, {\n                line,\n                target,\n                color: above,\n                scale,\n                property,\n                clip\n            });\n            ctx.restore();\n            ctx.save();\n            clipVertical(ctx, target, area.bottom);\n        } else if (property === 'y') {\n            clipHorizontal(ctx, target, area.left);\n            fill(ctx, {\n                line,\n                target,\n                color: below,\n                scale,\n                property,\n                clip\n            });\n            ctx.restore();\n            ctx.save();\n            clipHorizontal(ctx, target, area.right);\n            fillColor = above;\n        }\n    }\n    fill(ctx, {\n        line,\n        target,\n        color: fillColor,\n        scale,\n        property,\n        clip\n    });\n    ctx.restore();\n}\nfunction clipVertical(ctx, target, clipY) {\n    const { segments , points  } = target;\n    let first = true;\n    let lineLoop = false;\n    ctx.beginPath();\n    for (const segment of segments){\n        const { start , end  } = segment;\n        const firstPoint = points[start];\n        const lastPoint = points[_findSegmentEnd(start, end, points)];\n        if (first) {\n            ctx.moveTo(firstPoint.x, firstPoint.y);\n            first = false;\n        } else {\n            ctx.lineTo(firstPoint.x, clipY);\n            ctx.lineTo(firstPoint.x, firstPoint.y);\n        }\n        lineLoop = !!target.pathSegment(ctx, segment, {\n            move: lineLoop\n        });\n        if (lineLoop) {\n            ctx.closePath();\n        } else {\n            ctx.lineTo(lastPoint.x, clipY);\n        }\n    }\n    ctx.lineTo(target.first().x, clipY);\n    ctx.closePath();\n    ctx.clip();\n}\nfunction clipHorizontal(ctx, target, clipX) {\n    const { segments , points  } = target;\n    let first = true;\n    let lineLoop = false;\n    ctx.beginPath();\n    for (const segment of segments){\n        const { start , end  } = segment;\n        const firstPoint = points[start];\n        const lastPoint = points[_findSegmentEnd(start, end, points)];\n        if (first) {\n            ctx.moveTo(firstPoint.x, firstPoint.y);\n            first = false;\n        } else {\n            ctx.lineTo(clipX, firstPoint.y);\n            ctx.lineTo(firstPoint.x, firstPoint.y);\n        }\n        lineLoop = !!target.pathSegment(ctx, segment, {\n            move: lineLoop\n        });\n        if (lineLoop) {\n            ctx.closePath();\n        } else {\n            ctx.lineTo(clipX, lastPoint.y);\n        }\n    }\n    ctx.lineTo(clipX, target.first().y);\n    ctx.closePath();\n    ctx.clip();\n}\nfunction fill(ctx, cfg) {\n    const { line , target , property , color , scale , clip  } = cfg;\n    const segments = _segments(line, target, property);\n    for (const { source: src , target: tgt , start , end  } of segments){\n        const { style: { backgroundColor =color  } = {}  } = src;\n        const notShape = target !== true;\n        ctx.save();\n        ctx.fillStyle = backgroundColor;\n        clipBounds(ctx, scale, clip, notShape && _getBounds(property, start, end));\n        ctx.beginPath();\n        const lineLoop = !!line.pathSegment(ctx, src);\n        let loop;\n        if (notShape) {\n            if (lineLoop) {\n                ctx.closePath();\n            } else {\n                interpolatedLineTo(ctx, target, end, property);\n            }\n            const targetLoop = !!target.pathSegment(ctx, tgt, {\n                move: lineLoop,\n                reverse: true\n            });\n            loop = lineLoop && targetLoop;\n            if (!loop) {\n                interpolatedLineTo(ctx, target, start, property);\n            }\n        }\n        ctx.closePath();\n        ctx.fill(loop ? 'evenodd' : 'nonzero');\n        ctx.restore();\n    }\n}\nfunction clipBounds(ctx, scale, clip, bounds) {\n    const chartArea = scale.chart.chartArea;\n    const { property , start , end  } = bounds || {};\n    if (property === 'x' || property === 'y') {\n        let left, top, right, bottom;\n        if (property === 'x') {\n            left = start;\n            top = chartArea.top;\n            right = end;\n            bottom = chartArea.bottom;\n        } else {\n            left = chartArea.left;\n            top = start;\n            right = chartArea.right;\n            bottom = end;\n        }\n        ctx.beginPath();\n        if (clip) {\n            left = Math.max(left, clip.left);\n            right = Math.min(right, clip.right);\n            top = Math.max(top, clip.top);\n            bottom = Math.min(bottom, clip.bottom);\n        }\n        ctx.rect(left, top, right - left, bottom - top);\n        ctx.clip();\n    }\n}\nfunction interpolatedLineTo(ctx, target, point, property) {\n    const interpolatedPoint = target.interpolate(point, property);\n    if (interpolatedPoint) {\n        ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n    }\n}\n\nvar index = {\n    id: 'filler',\n    afterDatasetsUpdate (chart, _args, options) {\n        const count = (chart.data.datasets || []).length;\n        const sources = [];\n        let meta, i, line, source;\n        for(i = 0; i < count; ++i){\n            meta = chart.getDatasetMeta(i);\n            line = meta.dataset;\n            source = null;\n            if (line && line.options && line instanceof LineElement) {\n                source = {\n                    visible: chart.isDatasetVisible(i),\n                    index: i,\n                    fill: _decodeFill(line, i, count),\n                    chart,\n                    axis: meta.controller.options.indexAxis,\n                    scale: meta.vScale,\n                    line\n                };\n            }\n            meta.$filler = source;\n            sources.push(source);\n        }\n        for(i = 0; i < count; ++i){\n            source = sources[i];\n            if (!source || source.fill === false) {\n                continue;\n            }\n            source.fill = _resolveTarget(sources, i, options.propagate);\n        }\n    },\n    beforeDraw (chart, _args, options) {\n        const draw = options.drawTime === 'beforeDraw';\n        const metasets = chart.getSortedVisibleDatasetMetas();\n        const area = chart.chartArea;\n        for(let i = metasets.length - 1; i >= 0; --i){\n            const source = metasets[i].$filler;\n            if (!source) {\n                continue;\n            }\n            source.line.updateControlPoints(area, source.axis);\n            if (draw && source.fill) {\n                _drawfill(chart.ctx, source, area);\n            }\n        }\n    },\n    beforeDatasetsDraw (chart, _args, options) {\n        if (options.drawTime !== 'beforeDatasetsDraw') {\n            return;\n        }\n        const metasets = chart.getSortedVisibleDatasetMetas();\n        for(let i = metasets.length - 1; i >= 0; --i){\n            const source = metasets[i].$filler;\n            if (_shouldApplyFill(source)) {\n                _drawfill(chart.ctx, source, chart.chartArea);\n            }\n        }\n    },\n    beforeDatasetDraw (chart, args, options) {\n        const source = args.meta.$filler;\n        if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {\n            return;\n        }\n        _drawfill(chart.ctx, source, chart.chartArea);\n    },\n    defaults: {\n        propagate: true,\n        drawTime: 'beforeDatasetDraw'\n    }\n};\n\nconst getBoxSize = (labelOpts, fontSize)=>{\n    let { boxHeight =fontSize , boxWidth =fontSize  } = labelOpts;\n    if (labelOpts.usePointStyle) {\n        boxHeight = Math.min(boxHeight, fontSize);\n        boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\n    }\n    return {\n        boxWidth,\n        boxHeight,\n        itemHeight: Math.max(fontSize, boxHeight)\n    };\n};\nconst itemsEqual = (a, b)=>a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\nclass Legend extends Element {\n constructor(config){\n        super();\n        this._added = false;\n        this.legendHitBoxes = [];\n this._hoveredItem = null;\n        this.doughnutMode = false;\n        this.chart = config.chart;\n        this.options = config.options;\n        this.ctx = config.ctx;\n        this.legendItems = undefined;\n        this.columnSizes = undefined;\n        this.lineWidths = undefined;\n        this.maxHeight = undefined;\n        this.maxWidth = undefined;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.height = undefined;\n        this.width = undefined;\n        this._margins = undefined;\n        this.position = undefined;\n        this.weight = undefined;\n        this.fullSize = undefined;\n    }\n    update(maxWidth, maxHeight, margins) {\n        this.maxWidth = maxWidth;\n        this.maxHeight = maxHeight;\n        this._margins = margins;\n        this.setDimensions();\n        this.buildLabels();\n        this.fit();\n    }\n    setDimensions() {\n        if (this.isHorizontal()) {\n            this.width = this.maxWidth;\n            this.left = this._margins.left;\n            this.right = this.width;\n        } else {\n            this.height = this.maxHeight;\n            this.top = this._margins.top;\n            this.bottom = this.height;\n        }\n    }\n    buildLabels() {\n        const labelOpts = this.options.labels || {};\n        let legendItems = helpers_dataset.callback(labelOpts.generateLabels, [\n            this.chart\n        ], this) || [];\n        if (labelOpts.filter) {\n            legendItems = legendItems.filter((item)=>labelOpts.filter(item, this.chart.data));\n        }\n        if (labelOpts.sort) {\n            legendItems = legendItems.sort((a, b)=>labelOpts.sort(a, b, this.chart.data));\n        }\n        if (this.options.reverse) {\n            legendItems.reverse();\n        }\n        this.legendItems = legendItems;\n    }\n    fit() {\n        const { options , ctx  } = this;\n        if (!options.display) {\n            this.width = this.height = 0;\n            return;\n        }\n        const labelOpts = options.labels;\n        const labelFont = helpers_dataset.toFont(labelOpts.font);\n        const fontSize = labelFont.size;\n        const titleHeight = this._computeTitleHeight();\n        const { boxWidth , itemHeight  } = getBoxSize(labelOpts, fontSize);\n        let width, height;\n        ctx.font = labelFont.string;\n        if (this.isHorizontal()) {\n            width = this.maxWidth;\n            height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n        } else {\n            height = this.maxHeight;\n            width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;\n        }\n        this.width = Math.min(width, options.maxWidth || this.maxWidth);\n        this.height = Math.min(height, options.maxHeight || this.maxHeight);\n    }\n _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n        const { ctx , maxWidth , options: { labels: { padding  }  }  } = this;\n        const hitboxes = this.legendHitBoxes = [];\n        const lineWidths = this.lineWidths = [\n            0\n        ];\n        const lineHeight = itemHeight + padding;\n        let totalHeight = titleHeight;\n        ctx.textAlign = 'left';\n        ctx.textBaseline = 'middle';\n        let row = -1;\n        let top = -lineHeight;\n        this.legendItems.forEach((legendItem, i)=>{\n            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n            if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n                totalHeight += lineHeight;\n                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n                top += lineHeight;\n                row++;\n            }\n            hitboxes[i] = {\n                left: 0,\n                top,\n                row,\n                width: itemWidth,\n                height: itemHeight\n            };\n            lineWidths[lineWidths.length - 1] += itemWidth + padding;\n        });\n        return totalHeight;\n    }\n    _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {\n        const { ctx , maxHeight , options: { labels: { padding  }  }  } = this;\n        const hitboxes = this.legendHitBoxes = [];\n        const columnSizes = this.columnSizes = [];\n        const heightLimit = maxHeight - titleHeight;\n        let totalWidth = padding;\n        let currentColWidth = 0;\n        let currentColHeight = 0;\n        let left = 0;\n        let col = 0;\n        this.legendItems.forEach((legendItem, i)=>{\n            const { itemWidth , itemHeight  } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);\n            if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n                totalWidth += currentColWidth + padding;\n                columnSizes.push({\n                    width: currentColWidth,\n                    height: currentColHeight\n                });\n                left += currentColWidth + padding;\n                col++;\n                currentColWidth = currentColHeight = 0;\n            }\n            hitboxes[i] = {\n                left,\n                top: currentColHeight,\n                col,\n                width: itemWidth,\n                height: itemHeight\n            };\n            currentColWidth = Math.max(currentColWidth, itemWidth);\n            currentColHeight += itemHeight + padding;\n        });\n        totalWidth += currentColWidth;\n        columnSizes.push({\n            width: currentColWidth,\n            height: currentColHeight\n        });\n        return totalWidth;\n    }\n    adjustHitBoxes() {\n        if (!this.options.display) {\n            return;\n        }\n        const titleHeight = this._computeTitleHeight();\n        const { legendHitBoxes: hitboxes , options: { align , labels: { padding  } , rtl  }  } = this;\n        const rtlHelper = helpers_dataset.getRtlAdapter(rtl, this.left, this.width);\n        if (this.isHorizontal()) {\n            let row = 0;\n            let left = helpers_dataset._alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n            for (const hitbox of hitboxes){\n                if (row !== hitbox.row) {\n                    row = hitbox.row;\n                    left = helpers_dataset._alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n                }\n                hitbox.top += this.top + titleHeight + padding;\n                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n                left += hitbox.width + padding;\n            }\n        } else {\n            let col = 0;\n            let top = helpers_dataset._alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n            for (const hitbox of hitboxes){\n                if (hitbox.col !== col) {\n                    col = hitbox.col;\n                    top = helpers_dataset._alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n                }\n                hitbox.top = top;\n                hitbox.left += this.left + padding;\n                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n                top += hitbox.height + padding;\n            }\n        }\n    }\n    isHorizontal() {\n        return this.options.position === 'top' || this.options.position === 'bottom';\n    }\n    draw() {\n        if (this.options.display) {\n            const ctx = this.ctx;\n            helpers_dataset.clipArea(ctx, this);\n            this._draw();\n            helpers_dataset.unclipArea(ctx);\n        }\n    }\n _draw() {\n        const { options: opts , columnSizes , lineWidths , ctx  } = this;\n        const { align , labels: labelOpts  } = opts;\n        const defaultColor = helpers_dataset.defaults.color;\n        const rtlHelper = helpers_dataset.getRtlAdapter(opts.rtl, this.left, this.width);\n        const labelFont = helpers_dataset.toFont(labelOpts.font);\n        const { padding  } = labelOpts;\n        const fontSize = labelFont.size;\n        const halfFontSize = fontSize / 2;\n        let cursor;\n        this.drawTitle();\n        ctx.textAlign = rtlHelper.textAlign('left');\n        ctx.textBaseline = 'middle';\n        ctx.lineWidth = 0.5;\n        ctx.font = labelFont.string;\n        const { boxWidth , boxHeight , itemHeight  } = getBoxSize(labelOpts, fontSize);\n        const drawLegendBox = function(x, y, legendItem) {\n            if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n                return;\n            }\n            ctx.save();\n            const lineWidth = helpers_dataset.valueOrDefault(legendItem.lineWidth, 1);\n            ctx.fillStyle = helpers_dataset.valueOrDefault(legendItem.fillStyle, defaultColor);\n            ctx.lineCap = helpers_dataset.valueOrDefault(legendItem.lineCap, 'butt');\n            ctx.lineDashOffset = helpers_dataset.valueOrDefault(legendItem.lineDashOffset, 0);\n            ctx.lineJoin = helpers_dataset.valueOrDefault(legendItem.lineJoin, 'miter');\n            ctx.lineWidth = lineWidth;\n            ctx.strokeStyle = helpers_dataset.valueOrDefault(legendItem.strokeStyle, defaultColor);\n            ctx.setLineDash(helpers_dataset.valueOrDefault(legendItem.lineDash, []));\n            if (labelOpts.usePointStyle) {\n                const drawOptions = {\n                    radius: boxHeight * Math.SQRT2 / 2,\n                    pointStyle: legendItem.pointStyle,\n                    rotation: legendItem.rotation,\n                    borderWidth: lineWidth\n                };\n                const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n                const centerY = y + halfFontSize;\n                helpers_dataset.drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\n            } else {\n                const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n                const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n                const borderRadius = helpers_dataset.toTRBLCorners(legendItem.borderRadius);\n                ctx.beginPath();\n                if (Object.values(borderRadius).some((v)=>v !== 0)) {\n                    helpers_dataset.addRoundedRectPath(ctx, {\n                        x: xBoxLeft,\n                        y: yBoxTop,\n                        w: boxWidth,\n                        h: boxHeight,\n                        radius: borderRadius\n                    });\n                } else {\n                    ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n                }\n                ctx.fill();\n                if (lineWidth !== 0) {\n                    ctx.stroke();\n                }\n            }\n            ctx.restore();\n        };\n        const fillText = function(x, y, legendItem) {\n            helpers_dataset.renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {\n                strikethrough: legendItem.hidden,\n                textAlign: rtlHelper.textAlign(legendItem.textAlign)\n            });\n        };\n        const isHorizontal = this.isHorizontal();\n        const titleHeight = this._computeTitleHeight();\n        if (isHorizontal) {\n            cursor = {\n                x: helpers_dataset._alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),\n                y: this.top + padding + titleHeight,\n                line: 0\n            };\n        } else {\n            cursor = {\n                x: this.left + padding,\n                y: helpers_dataset._alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n                line: 0\n            };\n        }\n        helpers_dataset.overrideTextDirection(this.ctx, opts.textDirection);\n        const lineHeight = itemHeight + padding;\n        this.legendItems.forEach((legendItem, i)=>{\n            ctx.strokeStyle = legendItem.fontColor;\n            ctx.fillStyle = legendItem.fontColor;\n            const textWidth = ctx.measureText(legendItem.text).width;\n            const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n            const width = boxWidth + halfFontSize + textWidth;\n            let x = cursor.x;\n            let y = cursor.y;\n            rtlHelper.setWidth(this.width);\n            if (isHorizontal) {\n                if (i > 0 && x + width + padding > this.right) {\n                    y = cursor.y += lineHeight;\n                    cursor.line++;\n                    x = cursor.x = helpers_dataset._alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);\n                }\n            } else if (i > 0 && y + lineHeight > this.bottom) {\n                x = cursor.x = x + columnSizes[cursor.line].width + padding;\n                cursor.line++;\n                y = cursor.y = helpers_dataset._alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n            }\n            const realX = rtlHelper.x(x);\n            drawLegendBox(realX, y, legendItem);\n            x = helpers_dataset._textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n            fillText(rtlHelper.x(x), y, legendItem);\n            if (isHorizontal) {\n                cursor.x += width + padding;\n            } else if (typeof legendItem.text !== 'string') {\n                const fontLineHeight = labelFont.lineHeight;\n                cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;\n            } else {\n                cursor.y += lineHeight;\n            }\n        });\n        helpers_dataset.restoreTextDirection(this.ctx, opts.textDirection);\n    }\n drawTitle() {\n        const opts = this.options;\n        const titleOpts = opts.title;\n        const titleFont = helpers_dataset.toFont(titleOpts.font);\n        const titlePadding = helpers_dataset.toPadding(titleOpts.padding);\n        if (!titleOpts.display) {\n            return;\n        }\n        const rtlHelper = helpers_dataset.getRtlAdapter(opts.rtl, this.left, this.width);\n        const ctx = this.ctx;\n        const position = titleOpts.position;\n        const halfFontSize = titleFont.size / 2;\n        const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n        let y;\n        let left = this.left;\n        let maxWidth = this.width;\n        if (this.isHorizontal()) {\n            maxWidth = Math.max(...this.lineWidths);\n            y = this.top + topPaddingPlusHalfFontSize;\n            left = helpers_dataset._alignStartEnd(opts.align, left, this.right - maxWidth);\n        } else {\n            const maxHeight = this.columnSizes.reduce((acc, size)=>Math.max(acc, size.height), 0);\n            y = topPaddingPlusHalfFontSize + helpers_dataset._alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n        }\n        const x = helpers_dataset._alignStartEnd(position, left, left + maxWidth);\n        ctx.textAlign = rtlHelper.textAlign(helpers_dataset._toLeftRightCenter(position));\n        ctx.textBaseline = 'middle';\n        ctx.strokeStyle = titleOpts.color;\n        ctx.fillStyle = titleOpts.color;\n        ctx.font = titleFont.string;\n        helpers_dataset.renderText(ctx, titleOpts.text, x, y, titleFont);\n    }\n _computeTitleHeight() {\n        const titleOpts = this.options.title;\n        const titleFont = helpers_dataset.toFont(titleOpts.font);\n        const titlePadding = helpers_dataset.toPadding(titleOpts.padding);\n        return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n    }\n _getLegendItemAt(x, y) {\n        let i, hitBox, lh;\n        if (helpers_dataset._isBetween(x, this.left, this.right) && helpers_dataset._isBetween(y, this.top, this.bottom)) {\n            lh = this.legendHitBoxes;\n            for(i = 0; i < lh.length; ++i){\n                hitBox = lh[i];\n                if (helpers_dataset._isBetween(x, hitBox.left, hitBox.left + hitBox.width) && helpers_dataset._isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {\n                    return this.legendItems[i];\n                }\n            }\n        }\n        return null;\n    }\n handleEvent(e) {\n        const opts = this.options;\n        if (!isListened(e.type, opts)) {\n            return;\n        }\n        const hoveredItem = this._getLegendItemAt(e.x, e.y);\n        if (e.type === 'mousemove' || e.type === 'mouseout') {\n            const previous = this._hoveredItem;\n            const sameItem = itemsEqual(previous, hoveredItem);\n            if (previous && !sameItem) {\n                helpers_dataset.callback(opts.onLeave, [\n                    e,\n                    previous,\n                    this\n                ], this);\n            }\n            this._hoveredItem = hoveredItem;\n            if (hoveredItem && !sameItem) {\n                helpers_dataset.callback(opts.onHover, [\n                    e,\n                    hoveredItem,\n                    this\n                ], this);\n            }\n        } else if (hoveredItem) {\n            helpers_dataset.callback(opts.onClick, [\n                e,\n                hoveredItem,\n                this\n            ], this);\n        }\n    }\n}\nfunction calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {\n    const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);\n    const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);\n    return {\n        itemWidth,\n        itemHeight\n    };\n}\nfunction calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {\n    let legendItemText = legendItem.text;\n    if (legendItemText && typeof legendItemText !== 'string') {\n        legendItemText = legendItemText.reduce((a, b)=>a.length > b.length ? a : b);\n    }\n    return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;\n}\nfunction calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {\n    let itemHeight = _itemHeight;\n    if (typeof legendItem.text !== 'string') {\n        itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);\n    }\n    return itemHeight;\n}\nfunction calculateLegendItemHeight(legendItem, fontLineHeight) {\n    const labelHeight = legendItem.text ? legendItem.text.length : 0;\n    return fontLineHeight * labelHeight;\n}\nfunction isListened(type, opts) {\n    if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {\n        return true;\n    }\n    if (opts.onClick && (type === 'click' || type === 'mouseup')) {\n        return true;\n    }\n    return false;\n}\nvar plugin_legend = {\n    id: 'legend',\n _element: Legend,\n    start (chart, _args, options) {\n        const legend = chart.legend = new Legend({\n            ctx: chart.ctx,\n            options,\n            chart\n        });\n        layouts.configure(chart, legend, options);\n        layouts.addBox(chart, legend);\n    },\n    stop (chart) {\n        layouts.removeBox(chart, chart.legend);\n        delete chart.legend;\n    },\n    beforeUpdate (chart, _args, options) {\n        const legend = chart.legend;\n        layouts.configure(chart, legend, options);\n        legend.options = options;\n    },\n    afterUpdate (chart) {\n        const legend = chart.legend;\n        legend.buildLabels();\n        legend.adjustHitBoxes();\n    },\n    afterEvent (chart, args) {\n        if (!args.replay) {\n            chart.legend.handleEvent(args.event);\n        }\n    },\n    defaults: {\n        display: true,\n        position: 'top',\n        align: 'center',\n        fullSize: true,\n        reverse: false,\n        weight: 1000,\n        onClick (e, legendItem, legend) {\n            const index = legendItem.datasetIndex;\n            const ci = legend.chart;\n            if (ci.isDatasetVisible(index)) {\n                ci.hide(index);\n                legendItem.hidden = true;\n            } else {\n                ci.show(index);\n                legendItem.hidden = false;\n            }\n        },\n        onHover: null,\n        onLeave: null,\n        labels: {\n            color: (ctx)=>ctx.chart.options.color,\n            boxWidth: 40,\n            padding: 10,\n            generateLabels (chart) {\n                const datasets = chart.data.datasets;\n                const { labels: { usePointStyle , pointStyle , textAlign , color , useBorderRadius , borderRadius  }  } = chart.legend.options;\n                return chart._getSortedDatasetMetas().map((meta)=>{\n                    const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n                    const borderWidth = helpers_dataset.toPadding(style.borderWidth);\n                    return {\n                        text: datasets[meta.index].label,\n                        fillStyle: style.backgroundColor,\n                        fontColor: color,\n                        hidden: !meta.visible,\n                        lineCap: style.borderCapStyle,\n                        lineDash: style.borderDash,\n                        lineDashOffset: style.borderDashOffset,\n                        lineJoin: style.borderJoinStyle,\n                        lineWidth: (borderWidth.width + borderWidth.height) / 4,\n                        strokeStyle: style.borderColor,\n                        pointStyle: pointStyle || style.pointStyle,\n                        rotation: style.rotation,\n                        textAlign: textAlign || style.textAlign,\n                        borderRadius: useBorderRadius && (borderRadius || style.borderRadius),\n                        datasetIndex: meta.index\n                    };\n                }, this);\n            }\n        },\n        title: {\n            color: (ctx)=>ctx.chart.options.color,\n            display: false,\n            position: 'center',\n            text: ''\n        }\n    },\n    descriptors: {\n        _scriptable: (name)=>!name.startsWith('on'),\n        labels: {\n            _scriptable: (name)=>![\n                    'generateLabels',\n                    'filter',\n                    'sort'\n                ].includes(name)\n        }\n    }\n};\n\nclass Title extends Element {\n constructor(config){\n        super();\n        this.chart = config.chart;\n        this.options = config.options;\n        this.ctx = config.ctx;\n        this._padding = undefined;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this.position = undefined;\n        this.weight = undefined;\n        this.fullSize = undefined;\n    }\n    update(maxWidth, maxHeight) {\n        const opts = this.options;\n        this.left = 0;\n        this.top = 0;\n        if (!opts.display) {\n            this.width = this.height = this.right = this.bottom = 0;\n            return;\n        }\n        this.width = this.right = maxWidth;\n        this.height = this.bottom = maxHeight;\n        const lineCount = helpers_dataset.isArray(opts.text) ? opts.text.length : 1;\n        this._padding = helpers_dataset.toPadding(opts.padding);\n        const textSize = lineCount * helpers_dataset.toFont(opts.font).lineHeight + this._padding.height;\n        if (this.isHorizontal()) {\n            this.height = textSize;\n        } else {\n            this.width = textSize;\n        }\n    }\n    isHorizontal() {\n        const pos = this.options.position;\n        return pos === 'top' || pos === 'bottom';\n    }\n    _drawArgs(offset) {\n        const { top , left , bottom , right , options  } = this;\n        const align = options.align;\n        let rotation = 0;\n        let maxWidth, titleX, titleY;\n        if (this.isHorizontal()) {\n            titleX = helpers_dataset._alignStartEnd(align, left, right);\n            titleY = top + offset;\n            maxWidth = right - left;\n        } else {\n            if (options.position === 'left') {\n                titleX = left + offset;\n                titleY = helpers_dataset._alignStartEnd(align, bottom, top);\n                rotation = helpers_dataset.PI * -0.5;\n            } else {\n                titleX = right - offset;\n                titleY = helpers_dataset._alignStartEnd(align, top, bottom);\n                rotation = helpers_dataset.PI * 0.5;\n            }\n            maxWidth = bottom - top;\n        }\n        return {\n            titleX,\n            titleY,\n            maxWidth,\n            rotation\n        };\n    }\n    draw() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        if (!opts.display) {\n            return;\n        }\n        const fontOpts = helpers_dataset.toFont(opts.font);\n        const lineHeight = fontOpts.lineHeight;\n        const offset = lineHeight / 2 + this._padding.top;\n        const { titleX , titleY , maxWidth , rotation  } = this._drawArgs(offset);\n        helpers_dataset.renderText(ctx, opts.text, 0, 0, fontOpts, {\n            color: opts.color,\n            maxWidth,\n            rotation,\n            textAlign: helpers_dataset._toLeftRightCenter(opts.align),\n            textBaseline: 'middle',\n            translation: [\n                titleX,\n                titleY\n            ]\n        });\n    }\n}\nfunction createTitle(chart, titleOpts) {\n    const title = new Title({\n        ctx: chart.ctx,\n        options: titleOpts,\n        chart\n    });\n    layouts.configure(chart, title, titleOpts);\n    layouts.addBox(chart, title);\n    chart.titleBlock = title;\n}\nvar plugin_title = {\n    id: 'title',\n _element: Title,\n    start (chart, _args, options) {\n        createTitle(chart, options);\n    },\n    stop (chart) {\n        const titleBlock = chart.titleBlock;\n        layouts.removeBox(chart, titleBlock);\n        delete chart.titleBlock;\n    },\n    beforeUpdate (chart, _args, options) {\n        const title = chart.titleBlock;\n        layouts.configure(chart, title, options);\n        title.options = options;\n    },\n    defaults: {\n        align: 'center',\n        display: false,\n        font: {\n            weight: 'bold'\n        },\n        fullSize: true,\n        padding: 10,\n        position: 'top',\n        text: '',\n        weight: 2000\n    },\n    defaultRoutes: {\n        color: 'color'\n    },\n    descriptors: {\n        _scriptable: true,\n        _indexable: false\n    }\n};\n\nconst map = new WeakMap();\nvar plugin_subtitle = {\n    id: 'subtitle',\n    start (chart, _args, options) {\n        const title = new Title({\n            ctx: chart.ctx,\n            options,\n            chart\n        });\n        layouts.configure(chart, title, options);\n        layouts.addBox(chart, title);\n        map.set(chart, title);\n    },\n    stop (chart) {\n        layouts.removeBox(chart, map.get(chart));\n        map.delete(chart);\n    },\n    beforeUpdate (chart, _args, options) {\n        const title = map.get(chart);\n        layouts.configure(chart, title, options);\n        title.options = options;\n    },\n    defaults: {\n        align: 'center',\n        display: false,\n        font: {\n            weight: 'normal'\n        },\n        fullSize: true,\n        padding: 0,\n        position: 'top',\n        text: '',\n        weight: 1500\n    },\n    defaultRoutes: {\n        color: 'color'\n    },\n    descriptors: {\n        _scriptable: true,\n        _indexable: false\n    }\n};\n\nconst positioners = {\n average (items) {\n        if (!items.length) {\n            return false;\n        }\n        let i, len;\n        let xSet = new Set();\n        let y = 0;\n        let count = 0;\n        for(i = 0, len = items.length; i < len; ++i){\n            const el = items[i].element;\n            if (el && el.hasValue()) {\n                const pos = el.tooltipPosition();\n                xSet.add(pos.x);\n                y += pos.y;\n                ++count;\n            }\n        }\n        if (count === 0 || xSet.size === 0) {\n            return false;\n        }\n        const xAverage = [\n            ...xSet\n        ].reduce((a, b)=>a + b) / xSet.size;\n        return {\n            x: xAverage,\n            y: y / count\n        };\n    },\n nearest (items, eventPosition) {\n        if (!items.length) {\n            return false;\n        }\n        let x = eventPosition.x;\n        let y = eventPosition.y;\n        let minDistance = Number.POSITIVE_INFINITY;\n        let i, len, nearestElement;\n        for(i = 0, len = items.length; i < len; ++i){\n            const el = items[i].element;\n            if (el && el.hasValue()) {\n                const center = el.getCenterPoint();\n                const d = helpers_dataset.distanceBetweenPoints(eventPosition, center);\n                if (d < minDistance) {\n                    minDistance = d;\n                    nearestElement = el;\n                }\n            }\n        }\n        if (nearestElement) {\n            const tp = nearestElement.tooltipPosition();\n            x = tp.x;\n            y = tp.y;\n        }\n        return {\n            x,\n            y\n        };\n    }\n};\nfunction pushOrConcat(base, toPush) {\n    if (toPush) {\n        if (helpers_dataset.isArray(toPush)) {\n            Array.prototype.push.apply(base, toPush);\n        } else {\n            base.push(toPush);\n        }\n    }\n    return base;\n}\n function splitNewlines(str) {\n    if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n        return str.split('\\n');\n    }\n    return str;\n}\n function createTooltipItem(chart, item) {\n    const { element , datasetIndex , index  } = item;\n    const controller = chart.getDatasetMeta(datasetIndex).controller;\n    const { label , value  } = controller.getLabelAndValue(index);\n    return {\n        chart,\n        label,\n        parsed: controller.getParsed(index),\n        raw: chart.data.datasets[datasetIndex].data[index],\n        formattedValue: value,\n        dataset: controller.getDataset(),\n        dataIndex: index,\n        datasetIndex,\n        element\n    };\n}\n function getTooltipSize(tooltip, options) {\n    const ctx = tooltip.chart.ctx;\n    const { body , footer , title  } = tooltip;\n    const { boxWidth , boxHeight  } = options;\n    const bodyFont = helpers_dataset.toFont(options.bodyFont);\n    const titleFont = helpers_dataset.toFont(options.titleFont);\n    const footerFont = helpers_dataset.toFont(options.footerFont);\n    const titleLineCount = title.length;\n    const footerLineCount = footer.length;\n    const bodyLineItemCount = body.length;\n    const padding = helpers_dataset.toPadding(options.padding);\n    let height = padding.height;\n    let width = 0;\n    let combinedBodyLength = body.reduce((count, bodyItem)=>count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n    if (titleLineCount) {\n        height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;\n    }\n    if (combinedBodyLength) {\n        const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n        height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;\n    }\n    if (footerLineCount) {\n        height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;\n    }\n    let widthPadding = 0;\n    const maxLineWidth = function(line) {\n        width = Math.max(width, ctx.measureText(line).width + widthPadding);\n    };\n    ctx.save();\n    ctx.font = titleFont.string;\n    helpers_dataset.each(tooltip.title, maxLineWidth);\n    ctx.font = bodyFont.string;\n    helpers_dataset.each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;\n    helpers_dataset.each(body, (bodyItem)=>{\n        helpers_dataset.each(bodyItem.before, maxLineWidth);\n        helpers_dataset.each(bodyItem.lines, maxLineWidth);\n        helpers_dataset.each(bodyItem.after, maxLineWidth);\n    });\n    widthPadding = 0;\n    ctx.font = footerFont.string;\n    helpers_dataset.each(tooltip.footer, maxLineWidth);\n    ctx.restore();\n    width += padding.width;\n    return {\n        width,\n        height\n    };\n}\nfunction determineYAlign(chart, size) {\n    const { y , height  } = size;\n    if (y < height / 2) {\n        return 'top';\n    } else if (y > chart.height - height / 2) {\n        return 'bottom';\n    }\n    return 'center';\n}\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n    const { x , width  } = size;\n    const caret = options.caretSize + options.caretPadding;\n    if (xAlign === 'left' && x + width + caret > chart.width) {\n        return true;\n    }\n    if (xAlign === 'right' && x - width - caret < 0) {\n        return true;\n    }\n}\nfunction determineXAlign(chart, options, size, yAlign) {\n    const { x , width  } = size;\n    const { width: chartWidth , chartArea: { left , right  }  } = chart;\n    let xAlign = 'center';\n    if (yAlign === 'center') {\n        xAlign = x <= (left + right) / 2 ? 'left' : 'right';\n    } else if (x <= width / 2) {\n        xAlign = 'left';\n    } else if (x >= chartWidth - width / 2) {\n        xAlign = 'right';\n    }\n    if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n        xAlign = 'center';\n    }\n    return xAlign;\n}\n function determineAlignment(chart, options, size) {\n    const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\n    return {\n        xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\n        yAlign\n    };\n}\nfunction alignX(size, xAlign) {\n    let { x , width  } = size;\n    if (xAlign === 'right') {\n        x -= width;\n    } else if (xAlign === 'center') {\n        x -= width / 2;\n    }\n    return x;\n}\nfunction alignY(size, yAlign, paddingAndSize) {\n    let { y , height  } = size;\n    if (yAlign === 'top') {\n        y += paddingAndSize;\n    } else if (yAlign === 'bottom') {\n        y -= height + paddingAndSize;\n    } else {\n        y -= height / 2;\n    }\n    return y;\n}\n function getBackgroundPoint(options, size, alignment, chart) {\n    const { caretSize , caretPadding , cornerRadius  } = options;\n    const { xAlign , yAlign  } = alignment;\n    const paddingAndSize = caretSize + caretPadding;\n    const { topLeft , topRight , bottomLeft , bottomRight  } = helpers_dataset.toTRBLCorners(cornerRadius);\n    let x = alignX(size, xAlign);\n    const y = alignY(size, yAlign, paddingAndSize);\n    if (yAlign === 'center') {\n        if (xAlign === 'left') {\n            x += paddingAndSize;\n        } else if (xAlign === 'right') {\n            x -= paddingAndSize;\n        }\n    } else if (xAlign === 'left') {\n        x -= Math.max(topLeft, bottomLeft) + caretSize;\n    } else if (xAlign === 'right') {\n        x += Math.max(topRight, bottomRight) + caretSize;\n    }\n    return {\n        x: helpers_dataset._limitValue(x, 0, chart.width - size.width),\n        y: helpers_dataset._limitValue(y, 0, chart.height - size.height)\n    };\n}\nfunction getAlignedX(tooltip, align, options) {\n    const padding = helpers_dataset.toPadding(options.padding);\n    return align === 'center' ? tooltip.x + tooltip.width / 2 : align === 'right' ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;\n}\n function getBeforeAfterBodyLines(callback) {\n    return pushOrConcat([], splitNewlines(callback));\n}\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n    return helpers_dataset.createContext(parent, {\n        tooltip,\n        tooltipItems,\n        type: 'tooltip'\n    });\n}\nfunction overrideCallbacks(callbacks, context) {\n    const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n    return override ? callbacks.override(override) : callbacks;\n}\nconst defaultCallbacks = {\n    beforeTitle: helpers_dataset.noop,\n    title (tooltipItems) {\n        if (tooltipItems.length > 0) {\n            const item = tooltipItems[0];\n            const labels = item.chart.data.labels;\n            const labelCount = labels ? labels.length : 0;\n            if (this && this.options && this.options.mode === 'dataset') {\n                return item.dataset.label || '';\n            } else if (item.label) {\n                return item.label;\n            } else if (labelCount > 0 && item.dataIndex < labelCount) {\n                return labels[item.dataIndex];\n            }\n        }\n        return '';\n    },\n    afterTitle: helpers_dataset.noop,\n    beforeBody: helpers_dataset.noop,\n    beforeLabel: helpers_dataset.noop,\n    label (tooltipItem) {\n        if (this && this.options && this.options.mode === 'dataset') {\n            return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\n        }\n        let label = tooltipItem.dataset.label || '';\n        if (label) {\n            label += ': ';\n        }\n        const value = tooltipItem.formattedValue;\n        if (!helpers_dataset.isNullOrUndef(value)) {\n            label += value;\n        }\n        return label;\n    },\n    labelColor (tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n            borderColor: options.borderColor,\n            backgroundColor: options.backgroundColor,\n            borderWidth: options.borderWidth,\n            borderDash: options.borderDash,\n            borderDashOffset: options.borderDashOffset,\n            borderRadius: 0\n        };\n    },\n    labelTextColor () {\n        return this.options.bodyColor;\n    },\n    labelPointStyle (tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n            pointStyle: options.pointStyle,\n            rotation: options.rotation\n        };\n    },\n    afterLabel: helpers_dataset.noop,\n    afterBody: helpers_dataset.noop,\n    beforeFooter: helpers_dataset.noop,\n    footer: helpers_dataset.noop,\n    afterFooter: helpers_dataset.noop\n};\n function invokeCallbackWithFallback(callbacks, name, ctx, arg) {\n    const result = callbacks[name].call(ctx, arg);\n    if (typeof result === 'undefined') {\n        return defaultCallbacks[name].call(ctx, arg);\n    }\n    return result;\n}\nclass Tooltip extends Element {\n static positioners = positioners;\n    constructor(config){\n        super();\n        this.opacity = 0;\n        this._active = [];\n        this._eventPosition = undefined;\n        this._size = undefined;\n        this._cachedAnimations = undefined;\n        this._tooltipItems = [];\n        this.$animations = undefined;\n        this.$context = undefined;\n        this.chart = config.chart;\n        this.options = config.options;\n        this.dataPoints = undefined;\n        this.title = undefined;\n        this.beforeBody = undefined;\n        this.body = undefined;\n        this.afterBody = undefined;\n        this.footer = undefined;\n        this.xAlign = undefined;\n        this.yAlign = undefined;\n        this.x = undefined;\n        this.y = undefined;\n        this.height = undefined;\n        this.width = undefined;\n        this.caretX = undefined;\n        this.caretY = undefined;\n        this.labelColors = undefined;\n        this.labelPointStyles = undefined;\n        this.labelTextColors = undefined;\n    }\n    initialize(options) {\n        this.options = options;\n        this._cachedAnimations = undefined;\n        this.$context = undefined;\n    }\n _resolveAnimations() {\n        const cached = this._cachedAnimations;\n        if (cached) {\n            return cached;\n        }\n        const chart = this.chart;\n        const options = this.options.setContext(this.getContext());\n        const opts = options.enabled && chart.options.animation && options.animations;\n        const animations = new Animations(this.chart, opts);\n        if (opts._cacheable) {\n            this._cachedAnimations = Object.freeze(animations);\n        }\n        return animations;\n    }\n getContext() {\n        return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\n    }\n    getTitle(context, options) {\n        const { callbacks  } = options;\n        const beforeTitle = invokeCallbackWithFallback(callbacks, 'beforeTitle', this, context);\n        const title = invokeCallbackWithFallback(callbacks, 'title', this, context);\n        const afterTitle = invokeCallbackWithFallback(callbacks, 'afterTitle', this, context);\n        let lines = [];\n        lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n        lines = pushOrConcat(lines, splitNewlines(title));\n        lines = pushOrConcat(lines, splitNewlines(afterTitle));\n        return lines;\n    }\n    getBeforeBody(tooltipItems, options) {\n        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'beforeBody', this, tooltipItems));\n    }\n    getBody(tooltipItems, options) {\n        const { callbacks  } = options;\n        const bodyItems = [];\n        helpers_dataset.each(tooltipItems, (context)=>{\n            const bodyItem = {\n                before: [],\n                lines: [],\n                after: []\n            };\n            const scoped = overrideCallbacks(callbacks, context);\n            pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, 'beforeLabel', this, context)));\n            pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, 'label', this, context));\n            pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, 'afterLabel', this, context)));\n            bodyItems.push(bodyItem);\n        });\n        return bodyItems;\n    }\n    getAfterBody(tooltipItems, options) {\n        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'afterBody', this, tooltipItems));\n    }\n    getFooter(tooltipItems, options) {\n        const { callbacks  } = options;\n        const beforeFooter = invokeCallbackWithFallback(callbacks, 'beforeFooter', this, tooltipItems);\n        const footer = invokeCallbackWithFallback(callbacks, 'footer', this, tooltipItems);\n        const afterFooter = invokeCallbackWithFallback(callbacks, 'afterFooter', this, tooltipItems);\n        let lines = [];\n        lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n        lines = pushOrConcat(lines, splitNewlines(footer));\n        lines = pushOrConcat(lines, splitNewlines(afterFooter));\n        return lines;\n    }\n _createItems(options) {\n        const active = this._active;\n        const data = this.chart.data;\n        const labelColors = [];\n        const labelPointStyles = [];\n        const labelTextColors = [];\n        let tooltipItems = [];\n        let i, len;\n        for(i = 0, len = active.length; i < len; ++i){\n            tooltipItems.push(createTooltipItem(this.chart, active[i]));\n        }\n        if (options.filter) {\n            tooltipItems = tooltipItems.filter((element, index, array)=>options.filter(element, index, array, data));\n        }\n        if (options.itemSort) {\n            tooltipItems = tooltipItems.sort((a, b)=>options.itemSort(a, b, data));\n        }\n        helpers_dataset.each(tooltipItems, (context)=>{\n            const scoped = overrideCallbacks(options.callbacks, context);\n            labelColors.push(invokeCallbackWithFallback(scoped, 'labelColor', this, context));\n            labelPointStyles.push(invokeCallbackWithFallback(scoped, 'labelPointStyle', this, context));\n            labelTextColors.push(invokeCallbackWithFallback(scoped, 'labelTextColor', this, context));\n        });\n        this.labelColors = labelColors;\n        this.labelPointStyles = labelPointStyles;\n        this.labelTextColors = labelTextColors;\n        this.dataPoints = tooltipItems;\n        return tooltipItems;\n    }\n    update(changed, replay) {\n        const options = this.options.setContext(this.getContext());\n        const active = this._active;\n        let properties;\n        let tooltipItems = [];\n        if (!active.length) {\n            if (this.opacity !== 0) {\n                properties = {\n                    opacity: 0\n                };\n            }\n        } else {\n            const position = positioners[options.position].call(this, active, this._eventPosition);\n            tooltipItems = this._createItems(options);\n            this.title = this.getTitle(tooltipItems, options);\n            this.beforeBody = this.getBeforeBody(tooltipItems, options);\n            this.body = this.getBody(tooltipItems, options);\n            this.afterBody = this.getAfterBody(tooltipItems, options);\n            this.footer = this.getFooter(tooltipItems, options);\n            const size = this._size = getTooltipSize(this, options);\n            const positionAndSize = Object.assign({}, position, size);\n            const alignment = determineAlignment(this.chart, options, positionAndSize);\n            const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\n            this.xAlign = alignment.xAlign;\n            this.yAlign = alignment.yAlign;\n            properties = {\n                opacity: 1,\n                x: backgroundPoint.x,\n                y: backgroundPoint.y,\n                width: size.width,\n                height: size.height,\n                caretX: position.x,\n                caretY: position.y\n            };\n        }\n        this._tooltipItems = tooltipItems;\n        this.$context = undefined;\n        if (properties) {\n            this._resolveAnimations().update(this, properties);\n        }\n        if (changed && options.external) {\n            options.external.call(this, {\n                chart: this.chart,\n                tooltip: this,\n                replay\n            });\n        }\n    }\n    drawCaret(tooltipPoint, ctx, size, options) {\n        const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n        ctx.lineTo(caretPosition.x1, caretPosition.y1);\n        ctx.lineTo(caretPosition.x2, caretPosition.y2);\n        ctx.lineTo(caretPosition.x3, caretPosition.y3);\n    }\n    getCaretPosition(tooltipPoint, size, options) {\n        const { xAlign , yAlign  } = this;\n        const { caretSize , cornerRadius  } = options;\n        const { topLeft , topRight , bottomLeft , bottomRight  } = helpers_dataset.toTRBLCorners(cornerRadius);\n        const { x: ptX , y: ptY  } = tooltipPoint;\n        const { width , height  } = size;\n        let x1, x2, x3, y1, y2, y3;\n        if (yAlign === 'center') {\n            y2 = ptY + height / 2;\n            if (xAlign === 'left') {\n                x1 = ptX;\n                x2 = x1 - caretSize;\n                y1 = y2 + caretSize;\n                y3 = y2 - caretSize;\n            } else {\n                x1 = ptX + width;\n                x2 = x1 + caretSize;\n                y1 = y2 - caretSize;\n                y3 = y2 + caretSize;\n            }\n            x3 = x1;\n        } else {\n            if (xAlign === 'left') {\n                x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;\n            } else if (xAlign === 'right') {\n                x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n            } else {\n                x2 = this.caretX;\n            }\n            if (yAlign === 'top') {\n                y1 = ptY;\n                y2 = y1 - caretSize;\n                x1 = x2 - caretSize;\n                x3 = x2 + caretSize;\n            } else {\n                y1 = ptY + height;\n                y2 = y1 + caretSize;\n                x1 = x2 + caretSize;\n                x3 = x2 - caretSize;\n            }\n            y3 = y1;\n        }\n        return {\n            x1,\n            x2,\n            x3,\n            y1,\n            y2,\n            y3\n        };\n    }\n    drawTitle(pt, ctx, options) {\n        const title = this.title;\n        const length = title.length;\n        let titleFont, titleSpacing, i;\n        if (length) {\n            const rtlHelper = helpers_dataset.getRtlAdapter(options.rtl, this.x, this.width);\n            pt.x = getAlignedX(this, options.titleAlign, options);\n            ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n            ctx.textBaseline = 'middle';\n            titleFont = helpers_dataset.toFont(options.titleFont);\n            titleSpacing = options.titleSpacing;\n            ctx.fillStyle = options.titleColor;\n            ctx.font = titleFont.string;\n            for(i = 0; i < length; ++i){\n                ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n                pt.y += titleFont.lineHeight + titleSpacing;\n                if (i + 1 === length) {\n                    pt.y += options.titleMarginBottom - titleSpacing;\n                }\n            }\n        }\n    }\n _drawColorBox(ctx, pt, i, rtlHelper, options) {\n        const labelColor = this.labelColors[i];\n        const labelPointStyle = this.labelPointStyles[i];\n        const { boxHeight , boxWidth  } = options;\n        const bodyFont = helpers_dataset.toFont(options.bodyFont);\n        const colorX = getAlignedX(this, 'left', options);\n        const rtlColorX = rtlHelper.x(colorX);\n        const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n        const colorY = pt.y + yOffSet;\n        if (options.usePointStyle) {\n            const drawOptions = {\n                radius: Math.min(boxWidth, boxHeight) / 2,\n                pointStyle: labelPointStyle.pointStyle,\n                rotation: labelPointStyle.rotation,\n                borderWidth: 1\n            };\n            const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n            const centerY = colorY + boxHeight / 2;\n            ctx.strokeStyle = options.multiKeyBackground;\n            ctx.fillStyle = options.multiKeyBackground;\n            helpers_dataset.drawPoint(ctx, drawOptions, centerX, centerY);\n            ctx.strokeStyle = labelColor.borderColor;\n            ctx.fillStyle = labelColor.backgroundColor;\n            helpers_dataset.drawPoint(ctx, drawOptions, centerX, centerY);\n        } else {\n            ctx.lineWidth = helpers_dataset.isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;\n            ctx.strokeStyle = labelColor.borderColor;\n            ctx.setLineDash(labelColor.borderDash || []);\n            ctx.lineDashOffset = labelColor.borderDashOffset || 0;\n            const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);\n            const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);\n            const borderRadius = helpers_dataset.toTRBLCorners(labelColor.borderRadius);\n            if (Object.values(borderRadius).some((v)=>v !== 0)) {\n                ctx.beginPath();\n                ctx.fillStyle = options.multiKeyBackground;\n                helpers_dataset.addRoundedRectPath(ctx, {\n                    x: outerX,\n                    y: colorY,\n                    w: boxWidth,\n                    h: boxHeight,\n                    radius: borderRadius\n                });\n                ctx.fill();\n                ctx.stroke();\n                ctx.fillStyle = labelColor.backgroundColor;\n                ctx.beginPath();\n                helpers_dataset.addRoundedRectPath(ctx, {\n                    x: innerX,\n                    y: colorY + 1,\n                    w: boxWidth - 2,\n                    h: boxHeight - 2,\n                    radius: borderRadius\n                });\n                ctx.fill();\n            } else {\n                ctx.fillStyle = options.multiKeyBackground;\n                ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n                ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n                ctx.fillStyle = labelColor.backgroundColor;\n                ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n            }\n        }\n        ctx.fillStyle = this.labelTextColors[i];\n    }\n    drawBody(pt, ctx, options) {\n        const { body  } = this;\n        const { bodySpacing , bodyAlign , displayColors , boxHeight , boxWidth , boxPadding  } = options;\n        const bodyFont = helpers_dataset.toFont(options.bodyFont);\n        let bodyLineHeight = bodyFont.lineHeight;\n        let xLinePadding = 0;\n        const rtlHelper = helpers_dataset.getRtlAdapter(options.rtl, this.x, this.width);\n        const fillLineOfText = function(line) {\n            ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n            pt.y += bodyLineHeight + bodySpacing;\n        };\n        const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n        let bodyItem, textColor, lines, i, j, ilen, jlen;\n        ctx.textAlign = bodyAlign;\n        ctx.textBaseline = 'middle';\n        ctx.font = bodyFont.string;\n        pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n        ctx.fillStyle = options.bodyColor;\n        helpers_dataset.each(this.beforeBody, fillLineOfText);\n        xLinePadding = displayColors && bodyAlignForCalculation !== 'right' ? bodyAlign === 'center' ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;\n        for(i = 0, ilen = body.length; i < ilen; ++i){\n            bodyItem = body[i];\n            textColor = this.labelTextColors[i];\n            ctx.fillStyle = textColor;\n            helpers_dataset.each(bodyItem.before, fillLineOfText);\n            lines = bodyItem.lines;\n            if (displayColors && lines.length) {\n                this._drawColorBox(ctx, pt, i, rtlHelper, options);\n                bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n            }\n            for(j = 0, jlen = lines.length; j < jlen; ++j){\n                fillLineOfText(lines[j]);\n                bodyLineHeight = bodyFont.lineHeight;\n            }\n            helpers_dataset.each(bodyItem.after, fillLineOfText);\n        }\n        xLinePadding = 0;\n        bodyLineHeight = bodyFont.lineHeight;\n        helpers_dataset.each(this.afterBody, fillLineOfText);\n        pt.y -= bodySpacing;\n    }\n    drawFooter(pt, ctx, options) {\n        const footer = this.footer;\n        const length = footer.length;\n        let footerFont, i;\n        if (length) {\n            const rtlHelper = helpers_dataset.getRtlAdapter(options.rtl, this.x, this.width);\n            pt.x = getAlignedX(this, options.footerAlign, options);\n            pt.y += options.footerMarginTop;\n            ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n            ctx.textBaseline = 'middle';\n            footerFont = helpers_dataset.toFont(options.footerFont);\n            ctx.fillStyle = options.footerColor;\n            ctx.font = footerFont.string;\n            for(i = 0; i < length; ++i){\n                ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n                pt.y += footerFont.lineHeight + options.footerSpacing;\n            }\n        }\n    }\n    drawBackground(pt, ctx, tooltipSize, options) {\n        const { xAlign , yAlign  } = this;\n        const { x , y  } = pt;\n        const { width , height  } = tooltipSize;\n        const { topLeft , topRight , bottomLeft , bottomRight  } = helpers_dataset.toTRBLCorners(options.cornerRadius);\n        ctx.fillStyle = options.backgroundColor;\n        ctx.strokeStyle = options.borderColor;\n        ctx.lineWidth = options.borderWidth;\n        ctx.beginPath();\n        ctx.moveTo(x + topLeft, y);\n        if (yAlign === 'top') {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + width - topRight, y);\n        ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n        if (yAlign === 'center' && xAlign === 'right') {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + width, y + height - bottomRight);\n        ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n        if (yAlign === 'bottom') {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + bottomLeft, y + height);\n        ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n        if (yAlign === 'center' && xAlign === 'left') {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x, y + topLeft);\n        ctx.quadraticCurveTo(x, y, x + topLeft, y);\n        ctx.closePath();\n        ctx.fill();\n        if (options.borderWidth > 0) {\n            ctx.stroke();\n        }\n    }\n _updateAnimationTarget(options) {\n        const chart = this.chart;\n        const anims = this.$animations;\n        const animX = anims && anims.x;\n        const animY = anims && anims.y;\n        if (animX || animY) {\n            const position = positioners[options.position].call(this, this._active, this._eventPosition);\n            if (!position) {\n                return;\n            }\n            const size = this._size = getTooltipSize(this, options);\n            const positionAndSize = Object.assign({}, position, this._size);\n            const alignment = determineAlignment(chart, options, positionAndSize);\n            const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n            if (animX._to !== point.x || animY._to !== point.y) {\n                this.xAlign = alignment.xAlign;\n                this.yAlign = alignment.yAlign;\n                this.width = size.width;\n                this.height = size.height;\n                this.caretX = position.x;\n                this.caretY = position.y;\n                this._resolveAnimations().update(this, point);\n            }\n        }\n    }\n _willRender() {\n        return !!this.opacity;\n    }\n    draw(ctx) {\n        const options = this.options.setContext(this.getContext());\n        let opacity = this.opacity;\n        if (!opacity) {\n            return;\n        }\n        this._updateAnimationTarget(options);\n        const tooltipSize = {\n            width: this.width,\n            height: this.height\n        };\n        const pt = {\n            x: this.x,\n            y: this.y\n        };\n        opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n        const padding = helpers_dataset.toPadding(options.padding);\n        const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n        if (options.enabled && hasTooltipContent) {\n            ctx.save();\n            ctx.globalAlpha = opacity;\n            this.drawBackground(pt, ctx, tooltipSize, options);\n            helpers_dataset.overrideTextDirection(ctx, options.textDirection);\n            pt.y += padding.top;\n            this.drawTitle(pt, ctx, options);\n            this.drawBody(pt, ctx, options);\n            this.drawFooter(pt, ctx, options);\n            helpers_dataset.restoreTextDirection(ctx, options.textDirection);\n            ctx.restore();\n        }\n    }\n getActiveElements() {\n        return this._active || [];\n    }\n setActiveElements(activeElements, eventPosition) {\n        const lastActive = this._active;\n        const active = activeElements.map(({ datasetIndex , index  })=>{\n            const meta = this.chart.getDatasetMeta(datasetIndex);\n            if (!meta) {\n                throw new Error('Cannot find a dataset at index ' + datasetIndex);\n            }\n            return {\n                datasetIndex,\n                element: meta.data[index],\n                index\n            };\n        });\n        const changed = !helpers_dataset._elementsEqual(lastActive, active);\n        const positionChanged = this._positionChanged(active, eventPosition);\n        if (changed || positionChanged) {\n            this._active = active;\n            this._eventPosition = eventPosition;\n            this._ignoreReplayEvents = true;\n            this.update(true);\n        }\n    }\n handleEvent(e, replay, inChartArea = true) {\n        if (replay && this._ignoreReplayEvents) {\n            return false;\n        }\n        this._ignoreReplayEvents = false;\n        const options = this.options;\n        const lastActive = this._active || [];\n        const active = this._getActiveElements(e, lastActive, replay, inChartArea);\n        const positionChanged = this._positionChanged(active, e);\n        const changed = replay || !helpers_dataset._elementsEqual(active, lastActive) || positionChanged;\n        if (changed) {\n            this._active = active;\n            if (options.enabled || options.external) {\n                this._eventPosition = {\n                    x: e.x,\n                    y: e.y\n                };\n                this.update(true, replay);\n            }\n        }\n        return changed;\n    }\n _getActiveElements(e, lastActive, replay, inChartArea) {\n        const options = this.options;\n        if (e.type === 'mouseout') {\n            return [];\n        }\n        if (!inChartArea) {\n            return lastActive.filter((i)=>this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== undefined);\n        }\n        const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\n        if (options.reverse) {\n            active.reverse();\n        }\n        return active;\n    }\n _positionChanged(active, e) {\n        const { caretX , caretY , options  } = this;\n        const position = positioners[options.position].call(this, active, e);\n        return position !== false && (caretX !== position.x || caretY !== position.y);\n    }\n}\nvar plugin_tooltip = {\n    id: 'tooltip',\n    _element: Tooltip,\n    positioners,\n    afterInit (chart, _args, options) {\n        if (options) {\n            chart.tooltip = new Tooltip({\n                chart,\n                options\n            });\n        }\n    },\n    beforeUpdate (chart, _args, options) {\n        if (chart.tooltip) {\n            chart.tooltip.initialize(options);\n        }\n    },\n    reset (chart, _args, options) {\n        if (chart.tooltip) {\n            chart.tooltip.initialize(options);\n        }\n    },\n    afterDraw (chart) {\n        const tooltip = chart.tooltip;\n        if (tooltip && tooltip._willRender()) {\n            const args = {\n                tooltip\n            };\n            if (chart.notifyPlugins('beforeTooltipDraw', {\n                ...args,\n                cancelable: true\n            }) === false) {\n                return;\n            }\n            tooltip.draw(chart.ctx);\n            chart.notifyPlugins('afterTooltipDraw', args);\n        }\n    },\n    afterEvent (chart, args) {\n        if (chart.tooltip) {\n            const useFinalPosition = args.replay;\n            if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\n                args.changed = true;\n            }\n        }\n    },\n    defaults: {\n        enabled: true,\n        external: null,\n        position: 'average',\n        backgroundColor: 'rgba(0,0,0,0.8)',\n        titleColor: '#fff',\n        titleFont: {\n            weight: 'bold'\n        },\n        titleSpacing: 2,\n        titleMarginBottom: 6,\n        titleAlign: 'left',\n        bodyColor: '#fff',\n        bodySpacing: 2,\n        bodyFont: {},\n        bodyAlign: 'left',\n        footerColor: '#fff',\n        footerSpacing: 2,\n        footerMarginTop: 6,\n        footerFont: {\n            weight: 'bold'\n        },\n        footerAlign: 'left',\n        padding: 6,\n        caretPadding: 2,\n        caretSize: 5,\n        cornerRadius: 6,\n        boxHeight: (ctx, opts)=>opts.bodyFont.size,\n        boxWidth: (ctx, opts)=>opts.bodyFont.size,\n        multiKeyBackground: '#fff',\n        displayColors: true,\n        boxPadding: 0,\n        borderColor: 'rgba(0,0,0,0)',\n        borderWidth: 0,\n        animation: {\n            duration: 400,\n            easing: 'easeOutQuart'\n        },\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'x',\n                    'y',\n                    'width',\n                    'height',\n                    'caretX',\n                    'caretY'\n                ]\n            },\n            opacity: {\n                easing: 'linear',\n                duration: 200\n            }\n        },\n        callbacks: defaultCallbacks\n    },\n    defaultRoutes: {\n        bodyFont: 'font',\n        footerFont: 'font',\n        titleFont: 'font'\n    },\n    descriptors: {\n        _scriptable: (name)=>name !== 'filter' && name !== 'itemSort' && name !== 'external',\n        _indexable: false,\n        callbacks: {\n            _scriptable: false,\n            _indexable: false\n        },\n        animation: {\n            _fallback: false\n        },\n        animations: {\n            _fallback: 'animation'\n        }\n    },\n    additionalOptionScopes: [\n        'interaction'\n    ]\n};\n\nvar plugins = /*#__PURE__*/Object.freeze({\n__proto__: null,\nColors: plugin_colors,\nDecimation: plugin_decimation,\nFiller: index,\nLegend: plugin_legend,\nSubTitle: plugin_subtitle,\nTitle: plugin_title,\nTooltip: plugin_tooltip\n});\n\nconst addIfString = (labels, raw, index, addedLabels)=>{\n    if (typeof raw === 'string') {\n        index = labels.push(raw) - 1;\n        addedLabels.unshift({\n            index,\n            label: raw\n        });\n    } else if (isNaN(raw)) {\n        index = null;\n    }\n    return index;\n};\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\n    const first = labels.indexOf(raw);\n    if (first === -1) {\n        return addIfString(labels, raw, index, addedLabels);\n    }\n    const last = labels.lastIndexOf(raw);\n    return first !== last ? index : first;\n}\nconst validIndex = (index, max)=>index === null ? null : helpers_dataset._limitValue(Math.round(index), 0, max);\nfunction _getLabelForValue(value) {\n    const labels = this.getLabels();\n    if (value >= 0 && value < labels.length) {\n        return labels[value];\n    }\n    return value;\n}\nclass CategoryScale extends Scale {\n    static id = 'category';\n static defaults = {\n        ticks: {\n            callback: _getLabelForValue\n        }\n    };\n    constructor(cfg){\n        super(cfg);\n         this._startValue = undefined;\n        this._valueRange = 0;\n        this._addedLabels = [];\n    }\n    init(scaleOptions) {\n        const added = this._addedLabels;\n        if (added.length) {\n            const labels = this.getLabels();\n            for (const { index , label  } of added){\n                if (labels[index] === label) {\n                    labels.splice(index, 1);\n                }\n            }\n            this._addedLabels = [];\n        }\n        super.init(scaleOptions);\n    }\n    parse(raw, index) {\n        if (helpers_dataset.isNullOrUndef(raw)) {\n            return null;\n        }\n        const labels = this.getLabels();\n        index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, helpers_dataset.valueOrDefault(index, raw), this._addedLabels);\n        return validIndex(index, labels.length - 1);\n    }\n    determineDataLimits() {\n        const { minDefined , maxDefined  } = this.getUserBounds();\n        let { min , max  } = this.getMinMax(true);\n        if (this.options.bounds === 'ticks') {\n            if (!minDefined) {\n                min = 0;\n            }\n            if (!maxDefined) {\n                max = this.getLabels().length - 1;\n            }\n        }\n        this.min = min;\n        this.max = max;\n    }\n    buildTicks() {\n        const min = this.min;\n        const max = this.max;\n        const offset = this.options.offset;\n        const ticks = [];\n        let labels = this.getLabels();\n        labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);\n        this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n        this._startValue = this.min - (offset ? 0.5 : 0);\n        for(let value = min; value <= max; value++){\n            ticks.push({\n                value\n            });\n        }\n        return ticks;\n    }\n    getLabelForValue(value) {\n        return _getLabelForValue.call(this, value);\n    }\n configure() {\n        super.configure();\n        if (!this.isHorizontal()) {\n            this._reversePixels = !this._reversePixels;\n        }\n    }\n    getPixelForValue(value) {\n        if (typeof value !== 'number') {\n            value = this.parse(value);\n        }\n        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n    }\n    getPixelForTick(index) {\n        const ticks = this.ticks;\n        if (index < 0 || index > ticks.length - 1) {\n            return null;\n        }\n        return this.getPixelForValue(ticks[index].value);\n    }\n    getValueForPixel(pixel) {\n        return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n    }\n    getBasePixel() {\n        return this.bottom;\n    }\n}\n\nfunction generateTicks$1(generationOptions, dataRange) {\n    const ticks = [];\n    const MIN_SPACING = 1e-14;\n    const { bounds , step , min , max , precision , count , maxTicks , maxDigits , includeBounds  } = generationOptions;\n    const unit = step || 1;\n    const maxSpaces = maxTicks - 1;\n    const { min: rmin , max: rmax  } = dataRange;\n    const minDefined = !helpers_dataset.isNullOrUndef(min);\n    const maxDefined = !helpers_dataset.isNullOrUndef(max);\n    const countDefined = !helpers_dataset.isNullOrUndef(count);\n    const minSpacing = (rmax - rmin) / (maxDigits + 1);\n    let spacing = helpers_dataset.niceNum((rmax - rmin) / maxSpaces / unit) * unit;\n    let factor, niceMin, niceMax, numSpaces;\n    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n        return [\n            {\n                value: rmin\n            },\n            {\n                value: rmax\n            }\n        ];\n    }\n    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n    if (numSpaces > maxSpaces) {\n        spacing = helpers_dataset.niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\n    }\n    if (!helpers_dataset.isNullOrUndef(precision)) {\n        factor = Math.pow(10, precision);\n        spacing = Math.ceil(spacing * factor) / factor;\n    }\n    if (bounds === 'ticks') {\n        niceMin = Math.floor(rmin / spacing) * spacing;\n        niceMax = Math.ceil(rmax / spacing) * spacing;\n    } else {\n        niceMin = rmin;\n        niceMax = rmax;\n    }\n    if (minDefined && maxDefined && step && helpers_dataset.almostWhole((max - min) / step, spacing / 1000)) {\n        numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n        spacing = (max - min) / numSpaces;\n        niceMin = min;\n        niceMax = max;\n    } else if (countDefined) {\n        niceMin = minDefined ? min : niceMin;\n        niceMax = maxDefined ? max : niceMax;\n        numSpaces = count - 1;\n        spacing = (niceMax - niceMin) / numSpaces;\n    } else {\n        numSpaces = (niceMax - niceMin) / spacing;\n        if (helpers_dataset.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n            numSpaces = Math.round(numSpaces);\n        } else {\n            numSpaces = Math.ceil(numSpaces);\n        }\n    }\n    const decimalPlaces = Math.max(helpers_dataset._decimalPlaces(spacing), helpers_dataset._decimalPlaces(niceMin));\n    factor = Math.pow(10, helpers_dataset.isNullOrUndef(precision) ? decimalPlaces : precision);\n    niceMin = Math.round(niceMin * factor) / factor;\n    niceMax = Math.round(niceMax * factor) / factor;\n    let j = 0;\n    if (minDefined) {\n        if (includeBounds && niceMin !== min) {\n            ticks.push({\n                value: min\n            });\n            if (niceMin < min) {\n                j++;\n            }\n            if (helpers_dataset.almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n                j++;\n            }\n        } else if (niceMin < min) {\n            j++;\n        }\n    }\n    for(; j < numSpaces; ++j){\n        const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;\n        if (maxDefined && tickValue > max) {\n            break;\n        }\n        ticks.push({\n            value: tickValue\n        });\n    }\n    if (maxDefined && includeBounds && niceMax !== max) {\n        if (ticks.length && helpers_dataset.almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n            ticks[ticks.length - 1].value = max;\n        } else {\n            ticks.push({\n                value: max\n            });\n        }\n    } else if (!maxDefined || niceMax === max) {\n        ticks.push({\n            value: niceMax\n        });\n    }\n    return ticks;\n}\nfunction relativeLabelSize(value, minSpacing, { horizontal , minRotation  }) {\n    const rad = helpers_dataset.toRadians(minRotation);\n    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n    const length = 0.75 * minSpacing * ('' + value).length;\n    return Math.min(minSpacing / ratio, length);\n}\nclass LinearScaleBase extends Scale {\n    constructor(cfg){\n        super(cfg);\n         this.start = undefined;\n         this.end = undefined;\n         this._startValue = undefined;\n         this._endValue = undefined;\n        this._valueRange = 0;\n    }\n    parse(raw, index) {\n        if (helpers_dataset.isNullOrUndef(raw)) {\n            return null;\n        }\n        if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\n            return null;\n        }\n        return +raw;\n    }\n    handleTickRangeOptions() {\n        const { beginAtZero  } = this.options;\n        const { minDefined , maxDefined  } = this.getUserBounds();\n        let { min , max  } = this;\n        const setMin = (v)=>min = minDefined ? min : v;\n        const setMax = (v)=>max = maxDefined ? max : v;\n        if (beginAtZero) {\n            const minSign = helpers_dataset.sign(min);\n            const maxSign = helpers_dataset.sign(max);\n            if (minSign < 0 && maxSign < 0) {\n                setMax(0);\n            } else if (minSign > 0 && maxSign > 0) {\n                setMin(0);\n            }\n        }\n        if (min === max) {\n            let offset = max === 0 ? 1 : Math.abs(max * 0.05);\n            setMax(max + offset);\n            if (!beginAtZero) {\n                setMin(min - offset);\n            }\n        }\n        this.min = min;\n        this.max = max;\n    }\n    getTickLimit() {\n        const tickOpts = this.options.ticks;\n        let { maxTicksLimit , stepSize  } = tickOpts;\n        let maxTicks;\n        if (stepSize) {\n            maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n            if (maxTicks > 1000) {\n                console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\n                maxTicks = 1000;\n            }\n        } else {\n            maxTicks = this.computeTickLimit();\n            maxTicksLimit = maxTicksLimit || 11;\n        }\n        if (maxTicksLimit) {\n            maxTicks = Math.min(maxTicksLimit, maxTicks);\n        }\n        return maxTicks;\n    }\n computeTickLimit() {\n        return Number.POSITIVE_INFINITY;\n    }\n    buildTicks() {\n        const opts = this.options;\n        const tickOpts = opts.ticks;\n        let maxTicks = this.getTickLimit();\n        maxTicks = Math.max(2, maxTicks);\n        const numericGeneratorOptions = {\n            maxTicks,\n            bounds: opts.bounds,\n            min: opts.min,\n            max: opts.max,\n            precision: tickOpts.precision,\n            step: tickOpts.stepSize,\n            count: tickOpts.count,\n            maxDigits: this._maxDigits(),\n            horizontal: this.isHorizontal(),\n            minRotation: tickOpts.minRotation || 0,\n            includeBounds: tickOpts.includeBounds !== false\n        };\n        const dataRange = this._range || this;\n        const ticks = generateTicks$1(numericGeneratorOptions, dataRange);\n        if (opts.bounds === 'ticks') {\n            helpers_dataset._setMinAndMaxByKey(ticks, this, 'value');\n        }\n        if (opts.reverse) {\n            ticks.reverse();\n            this.start = this.max;\n            this.end = this.min;\n        } else {\n            this.start = this.min;\n            this.end = this.max;\n        }\n        return ticks;\n    }\n configure() {\n        const ticks = this.ticks;\n        let start = this.min;\n        let end = this.max;\n        super.configure();\n        if (this.options.offset && ticks.length) {\n            const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n            start -= offset;\n            end += offset;\n        }\n        this._startValue = start;\n        this._endValue = end;\n        this._valueRange = end - start;\n    }\n    getLabelForValue(value) {\n        return helpers_dataset.formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n    }\n}\n\nclass LinearScale extends LinearScaleBase {\n    static id = 'linear';\n static defaults = {\n        ticks: {\n            callback: helpers_dataset.Ticks.formatters.numeric\n        }\n    };\n    determineDataLimits() {\n        const { min , max  } = this.getMinMax(true);\n        this.min = helpers_dataset.isNumberFinite(min) ? min : 0;\n        this.max = helpers_dataset.isNumberFinite(max) ? max : 1;\n        this.handleTickRangeOptions();\n    }\n computeTickLimit() {\n        const horizontal = this.isHorizontal();\n        const length = horizontal ? this.width : this.height;\n        const minRotation = helpers_dataset.toRadians(this.options.ticks.minRotation);\n        const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n        const tickFont = this._resolveTickFontOptions(0);\n        return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n    }\n    getPixelForValue(value) {\n        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n    }\n    getValueForPixel(pixel) {\n        return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n    }\n}\n\nconst log10Floor = (v)=>Math.floor(helpers_dataset.log10(v));\nconst changeExponent = (v, m)=>Math.pow(10, log10Floor(v) + m);\nfunction isMajor(tickVal) {\n    const remain = tickVal / Math.pow(10, log10Floor(tickVal));\n    return remain === 1;\n}\nfunction steps(min, max, rangeExp) {\n    const rangeStep = Math.pow(10, rangeExp);\n    const start = Math.floor(min / rangeStep);\n    const end = Math.ceil(max / rangeStep);\n    return end - start;\n}\nfunction startExp(min, max) {\n    const range = max - min;\n    let rangeExp = log10Floor(range);\n    while(steps(min, max, rangeExp) > 10){\n        rangeExp++;\n    }\n    while(steps(min, max, rangeExp) < 10){\n        rangeExp--;\n    }\n    return Math.min(rangeExp, log10Floor(min));\n}\n function generateTicks(generationOptions, { min , max  }) {\n    min = helpers_dataset.finiteOrDefault(generationOptions.min, min);\n    const ticks = [];\n    const minExp = log10Floor(min);\n    let exp = startExp(min, max);\n    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n    const stepSize = Math.pow(10, exp);\n    const base = minExp > exp ? Math.pow(10, minExp) : 0;\n    const start = Math.round((min - base) * precision) / precision;\n    const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;\n    let significand = Math.floor((start - offset) / Math.pow(10, exp));\n    let value = helpers_dataset.finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);\n    while(value < max){\n        ticks.push({\n            value,\n            major: isMajor(value),\n            significand\n        });\n        if (significand >= 10) {\n            significand = significand < 15 ? 15 : 20;\n        } else {\n            significand++;\n        }\n        if (significand >= 20) {\n            exp++;\n            significand = 2;\n            precision = exp >= 0 ? 1 : precision;\n        }\n        value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;\n    }\n    const lastTick = helpers_dataset.finiteOrDefault(generationOptions.max, value);\n    ticks.push({\n        value: lastTick,\n        major: isMajor(lastTick),\n        significand\n    });\n    return ticks;\n}\nclass LogarithmicScale extends Scale {\n    static id = 'logarithmic';\n static defaults = {\n        ticks: {\n            callback: helpers_dataset.Ticks.formatters.logarithmic,\n            major: {\n                enabled: true\n            }\n        }\n    };\n    constructor(cfg){\n        super(cfg);\n         this.start = undefined;\n         this.end = undefined;\n         this._startValue = undefined;\n        this._valueRange = 0;\n    }\n    parse(raw, index) {\n        const value = LinearScaleBase.prototype.parse.apply(this, [\n            raw,\n            index\n        ]);\n        if (value === 0) {\n            this._zero = true;\n            return undefined;\n        }\n        return helpers_dataset.isNumberFinite(value) && value > 0 ? value : null;\n    }\n    determineDataLimits() {\n        const { min , max  } = this.getMinMax(true);\n        this.min = helpers_dataset.isNumberFinite(min) ? Math.max(0, min) : null;\n        this.max = helpers_dataset.isNumberFinite(max) ? Math.max(0, max) : null;\n        if (this.options.beginAtZero) {\n            this._zero = true;\n        }\n        if (this._zero && this.min !== this._suggestedMin && !helpers_dataset.isNumberFinite(this._userMin)) {\n            this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);\n        }\n        this.handleTickRangeOptions();\n    }\n    handleTickRangeOptions() {\n        const { minDefined , maxDefined  } = this.getUserBounds();\n        let min = this.min;\n        let max = this.max;\n        const setMin = (v)=>min = minDefined ? min : v;\n        const setMax = (v)=>max = maxDefined ? max : v;\n        if (min === max) {\n            if (min <= 0) {\n                setMin(1);\n                setMax(10);\n            } else {\n                setMin(changeExponent(min, -1));\n                setMax(changeExponent(max, +1));\n            }\n        }\n        if (min <= 0) {\n            setMin(changeExponent(max, -1));\n        }\n        if (max <= 0) {\n            setMax(changeExponent(min, +1));\n        }\n        this.min = min;\n        this.max = max;\n    }\n    buildTicks() {\n        const opts = this.options;\n        const generationOptions = {\n            min: this._userMin,\n            max: this._userMax\n        };\n        const ticks = generateTicks(generationOptions, this);\n        if (opts.bounds === 'ticks') {\n            helpers_dataset._setMinAndMaxByKey(ticks, this, 'value');\n        }\n        if (opts.reverse) {\n            ticks.reverse();\n            this.start = this.max;\n            this.end = this.min;\n        } else {\n            this.start = this.min;\n            this.end = this.max;\n        }\n        return ticks;\n    }\n getLabelForValue(value) {\n        return value === undefined ? '0' : helpers_dataset.formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n    }\n configure() {\n        const start = this.min;\n        super.configure();\n        this._startValue = helpers_dataset.log10(start);\n        this._valueRange = helpers_dataset.log10(this.max) - helpers_dataset.log10(start);\n    }\n    getPixelForValue(value) {\n        if (value === undefined || value === 0) {\n            value = this.min;\n        }\n        if (value === null || isNaN(value)) {\n            return NaN;\n        }\n        return this.getPixelForDecimal(value === this.min ? 0 : (helpers_dataset.log10(value) - this._startValue) / this._valueRange);\n    }\n    getValueForPixel(pixel) {\n        const decimal = this.getDecimalForPixel(pixel);\n        return Math.pow(10, this._startValue + decimal * this._valueRange);\n    }\n}\n\nfunction getTickBackdropHeight(opts) {\n    const tickOpts = opts.ticks;\n    if (tickOpts.display && opts.display) {\n        const padding = helpers_dataset.toPadding(tickOpts.backdropPadding);\n        return helpers_dataset.valueOrDefault(tickOpts.font && tickOpts.font.size, helpers_dataset.defaults.font.size) + padding.height;\n    }\n    return 0;\n}\nfunction measureLabelSize(ctx, font, label) {\n    label = helpers_dataset.isArray(label) ? label : [\n        label\n    ];\n    return {\n        w: helpers_dataset._longestText(ctx, font.string, label),\n        h: label.length * font.lineHeight\n    };\n}\nfunction determineLimits(angle, pos, size, min, max) {\n    if (angle === min || angle === max) {\n        return {\n            start: pos - size / 2,\n            end: pos + size / 2\n        };\n    } else if (angle < min || angle > max) {\n        return {\n            start: pos - size,\n            end: pos\n        };\n    }\n    return {\n        start: pos,\n        end: pos + size\n    };\n}\n function fitWithPointLabels(scale) {\n    const orig = {\n        l: scale.left + scale._padding.left,\n        r: scale.right - scale._padding.right,\n        t: scale.top + scale._padding.top,\n        b: scale.bottom - scale._padding.bottom\n    };\n    const limits = Object.assign({}, orig);\n    const labelSizes = [];\n    const padding = [];\n    const valueCount = scale._pointLabels.length;\n    const pointLabelOpts = scale.options.pointLabels;\n    const additionalAngle = pointLabelOpts.centerPointLabels ? helpers_dataset.PI / valueCount : 0;\n    for(let i = 0; i < valueCount; i++){\n        const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\n        padding[i] = opts.padding;\n        const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\n        const plFont = helpers_dataset.toFont(opts.font);\n        const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n        labelSizes[i] = textSize;\n        const angleRadians = helpers_dataset._normalizeAngle(scale.getIndexAngle(i) + additionalAngle);\n        const angle = Math.round(helpers_dataset.toDegrees(angleRadians));\n        const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n        const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n        updateLimits(limits, orig, angleRadians, hLimits, vLimits);\n    }\n    scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);\n    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\n    const sin = Math.abs(Math.sin(angle));\n    const cos = Math.abs(Math.cos(angle));\n    let x = 0;\n    let y = 0;\n    if (hLimits.start < orig.l) {\n        x = (orig.l - hLimits.start) / sin;\n        limits.l = Math.min(limits.l, orig.l - x);\n    } else if (hLimits.end > orig.r) {\n        x = (hLimits.end - orig.r) / sin;\n        limits.r = Math.max(limits.r, orig.r + x);\n    }\n    if (vLimits.start < orig.t) {\n        y = (orig.t - vLimits.start) / cos;\n        limits.t = Math.min(limits.t, orig.t - y);\n    } else if (vLimits.end > orig.b) {\n        y = (vLimits.end - orig.b) / cos;\n        limits.b = Math.max(limits.b, orig.b + y);\n    }\n}\nfunction createPointLabelItem(scale, index, itemOpts) {\n    const outerDistance = scale.drawingArea;\n    const { extra , additionalAngle , padding , size  } = itemOpts;\n    const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);\n    const angle = Math.round(helpers_dataset.toDegrees(helpers_dataset._normalizeAngle(pointLabelPosition.angle + helpers_dataset.HALF_PI)));\n    const y = yForAngle(pointLabelPosition.y, size.h, angle);\n    const textAlign = getTextAlignForAngle(angle);\n    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n    return {\n        visible: true,\n        x: pointLabelPosition.x,\n        y,\n        textAlign,\n        left,\n        top: y,\n        right: left + size.w,\n        bottom: y + size.h\n    };\n}\nfunction isNotOverlapped(item, area) {\n    if (!area) {\n        return true;\n    }\n    const { left , top , right , bottom  } = item;\n    const apexesInArea = helpers_dataset._isPointInArea({\n        x: left,\n        y: top\n    }, area) || helpers_dataset._isPointInArea({\n        x: left,\n        y: bottom\n    }, area) || helpers_dataset._isPointInArea({\n        x: right,\n        y: top\n    }, area) || helpers_dataset._isPointInArea({\n        x: right,\n        y: bottom\n    }, area);\n    return !apexesInArea;\n}\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n    const items = [];\n    const valueCount = scale._pointLabels.length;\n    const opts = scale.options;\n    const { centerPointLabels , display  } = opts.pointLabels;\n    const itemOpts = {\n        extra: getTickBackdropHeight(opts) / 2,\n        additionalAngle: centerPointLabels ? helpers_dataset.PI / valueCount : 0\n    };\n    let area;\n    for(let i = 0; i < valueCount; i++){\n        itemOpts.padding = padding[i];\n        itemOpts.size = labelSizes[i];\n        const item = createPointLabelItem(scale, i, itemOpts);\n        items.push(item);\n        if (display === 'auto') {\n            item.visible = isNotOverlapped(item, area);\n            if (item.visible) {\n                area = item;\n            }\n        }\n    }\n    return items;\n}\nfunction getTextAlignForAngle(angle) {\n    if (angle === 0 || angle === 180) {\n        return 'center';\n    } else if (angle < 180) {\n        return 'left';\n    }\n    return 'right';\n}\nfunction leftForTextAlign(x, w, align) {\n    if (align === 'right') {\n        x -= w;\n    } else if (align === 'center') {\n        x -= w / 2;\n    }\n    return x;\n}\nfunction yForAngle(y, h, angle) {\n    if (angle === 90 || angle === 270) {\n        y -= h / 2;\n    } else if (angle > 270 || angle < 90) {\n        y -= h;\n    }\n    return y;\n}\nfunction drawPointLabelBox(ctx, opts, item) {\n    const { left , top , right , bottom  } = item;\n    const { backdropColor  } = opts;\n    if (!helpers_dataset.isNullOrUndef(backdropColor)) {\n        const borderRadius = helpers_dataset.toTRBLCorners(opts.borderRadius);\n        const padding = helpers_dataset.toPadding(opts.backdropPadding);\n        ctx.fillStyle = backdropColor;\n        const backdropLeft = left - padding.left;\n        const backdropTop = top - padding.top;\n        const backdropWidth = right - left + padding.width;\n        const backdropHeight = bottom - top + padding.height;\n        if (Object.values(borderRadius).some((v)=>v !== 0)) {\n            ctx.beginPath();\n            helpers_dataset.addRoundedRectPath(ctx, {\n                x: backdropLeft,\n                y: backdropTop,\n                w: backdropWidth,\n                h: backdropHeight,\n                radius: borderRadius\n            });\n            ctx.fill();\n        } else {\n            ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\n        }\n    }\n}\nfunction drawPointLabels(scale, labelCount) {\n    const { ctx , options: { pointLabels  }  } = scale;\n    for(let i = labelCount - 1; i >= 0; i--){\n        const item = scale._pointLabelItems[i];\n        if (!item.visible) {\n            continue;\n        }\n        const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n        drawPointLabelBox(ctx, optsAtIndex, item);\n        const plFont = helpers_dataset.toFont(optsAtIndex.font);\n        const { x , y , textAlign  } = item;\n        helpers_dataset.renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {\n            color: optsAtIndex.color,\n            textAlign: textAlign,\n            textBaseline: 'middle'\n        });\n    }\n}\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n    const { ctx  } = scale;\n    if (circular) {\n        ctx.arc(scale.xCenter, scale.yCenter, radius, 0, helpers_dataset.TAU);\n    } else {\n        let pointPosition = scale.getPointPosition(0, radius);\n        ctx.moveTo(pointPosition.x, pointPosition.y);\n        for(let i = 1; i < labelCount; i++){\n            pointPosition = scale.getPointPosition(i, radius);\n            ctx.lineTo(pointPosition.x, pointPosition.y);\n        }\n    }\n}\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {\n    const ctx = scale.ctx;\n    const circular = gridLineOpts.circular;\n    const { color , lineWidth  } = gridLineOpts;\n    if (!circular && !labelCount || !color || !lineWidth || radius < 0) {\n        return;\n    }\n    ctx.save();\n    ctx.strokeStyle = color;\n    ctx.lineWidth = lineWidth;\n    ctx.setLineDash(borderOpts.dash || []);\n    ctx.lineDashOffset = borderOpts.dashOffset;\n    ctx.beginPath();\n    pathRadiusLine(scale, radius, circular, labelCount);\n    ctx.closePath();\n    ctx.stroke();\n    ctx.restore();\n}\nfunction createPointLabelContext(parent, index, label) {\n    return helpers_dataset.createContext(parent, {\n        label,\n        index,\n        type: 'pointLabel'\n    });\n}\nclass RadialLinearScale extends LinearScaleBase {\n    static id = 'radialLinear';\n static defaults = {\n        display: true,\n        animate: true,\n        position: 'chartArea',\n        angleLines: {\n            display: true,\n            lineWidth: 1,\n            borderDash: [],\n            borderDashOffset: 0.0\n        },\n        grid: {\n            circular: false\n        },\n        startAngle: 0,\n        ticks: {\n            showLabelBackdrop: true,\n            callback: helpers_dataset.Ticks.formatters.numeric\n        },\n        pointLabels: {\n            backdropColor: undefined,\n            backdropPadding: 2,\n            display: true,\n            font: {\n                size: 10\n            },\n            callback (label) {\n                return label;\n            },\n            padding: 5,\n            centerPointLabels: false\n        }\n    };\n    static defaultRoutes = {\n        'angleLines.color': 'borderColor',\n        'pointLabels.color': 'color',\n        'ticks.color': 'color'\n    };\n    static descriptors = {\n        angleLines: {\n            _fallback: 'grid'\n        }\n    };\n    constructor(cfg){\n        super(cfg);\n         this.xCenter = undefined;\n         this.yCenter = undefined;\n         this.drawingArea = undefined;\n         this._pointLabels = [];\n        this._pointLabelItems = [];\n    }\n    setDimensions() {\n        const padding = this._padding = helpers_dataset.toPadding(getTickBackdropHeight(this.options) / 2);\n        const w = this.width = this.maxWidth - padding.width;\n        const h = this.height = this.maxHeight - padding.height;\n        this.xCenter = Math.floor(this.left + w / 2 + padding.left);\n        this.yCenter = Math.floor(this.top + h / 2 + padding.top);\n        this.drawingArea = Math.floor(Math.min(w, h) / 2);\n    }\n    determineDataLimits() {\n        const { min , max  } = this.getMinMax(false);\n        this.min = helpers_dataset.isNumberFinite(min) && !isNaN(min) ? min : 0;\n        this.max = helpers_dataset.isNumberFinite(max) && !isNaN(max) ? max : 0;\n        this.handleTickRangeOptions();\n    }\n computeTickLimit() {\n        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n    }\n    generateTickLabels(ticks) {\n        LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n        this._pointLabels = this.getLabels().map((value, index)=>{\n            const label = helpers_dataset.callback(this.options.pointLabels.callback, [\n                value,\n                index\n            ], this);\n            return label || label === 0 ? label : '';\n        }).filter((v, i)=>this.chart.getDataVisibility(i));\n    }\n    fit() {\n        const opts = this.options;\n        if (opts.display && opts.pointLabels.display) {\n            fitWithPointLabels(this);\n        } else {\n            this.setCenterPoint(0, 0, 0, 0);\n        }\n    }\n    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n        this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\n        this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\n        this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\n    }\n    getIndexAngle(index) {\n        const angleMultiplier = helpers_dataset.TAU / (this._pointLabels.length || 1);\n        const startAngle = this.options.startAngle || 0;\n        return helpers_dataset._normalizeAngle(index * angleMultiplier + helpers_dataset.toRadians(startAngle));\n    }\n    getDistanceFromCenterForValue(value) {\n        if (helpers_dataset.isNullOrUndef(value)) {\n            return NaN;\n        }\n        const scalingFactor = this.drawingArea / (this.max - this.min);\n        if (this.options.reverse) {\n            return (this.max - value) * scalingFactor;\n        }\n        return (value - this.min) * scalingFactor;\n    }\n    getValueForDistanceFromCenter(distance) {\n        if (helpers_dataset.isNullOrUndef(distance)) {\n            return NaN;\n        }\n        const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n        return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n    }\n    getPointLabelContext(index) {\n        const pointLabels = this._pointLabels || [];\n        if (index >= 0 && index < pointLabels.length) {\n            const pointLabel = pointLabels[index];\n            return createPointLabelContext(this.getContext(), index, pointLabel);\n        }\n    }\n    getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\n        const angle = this.getIndexAngle(index) - helpers_dataset.HALF_PI + additionalAngle;\n        return {\n            x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n            y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n            angle\n        };\n    }\n    getPointPositionForValue(index, value) {\n        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n    }\n    getBasePosition(index) {\n        return this.getPointPositionForValue(index || 0, this.getBaseValue());\n    }\n    getPointLabelPosition(index) {\n        const { left , top , right , bottom  } = this._pointLabelItems[index];\n        return {\n            left,\n            top,\n            right,\n            bottom\n        };\n    }\n drawBackground() {\n        const { backgroundColor , grid: { circular  }  } = this.options;\n        if (backgroundColor) {\n            const ctx = this.ctx;\n            ctx.save();\n            ctx.beginPath();\n            pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\n            ctx.closePath();\n            ctx.fillStyle = backgroundColor;\n            ctx.fill();\n            ctx.restore();\n        }\n    }\n drawGrid() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        const { angleLines , grid , border  } = opts;\n        const labelCount = this._pointLabels.length;\n        let i, offset, position;\n        if (opts.pointLabels.display) {\n            drawPointLabels(this, labelCount);\n        }\n        if (grid.display) {\n            this.ticks.forEach((tick, index)=>{\n                if (index !== 0 || index === 0 && this.min < 0) {\n                    offset = this.getDistanceFromCenterForValue(tick.value);\n                    const context = this.getContext(index);\n                    const optsAtIndex = grid.setContext(context);\n                    const optsAtIndexBorder = border.setContext(context);\n                    drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);\n                }\n            });\n        }\n        if (angleLines.display) {\n            ctx.save();\n            for(i = labelCount - 1; i >= 0; i--){\n                const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n                const { color , lineWidth  } = optsAtIndex;\n                if (!lineWidth || !color) {\n                    continue;\n                }\n                ctx.lineWidth = lineWidth;\n                ctx.strokeStyle = color;\n                ctx.setLineDash(optsAtIndex.borderDash);\n                ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n                offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);\n                position = this.getPointPosition(i, offset);\n                ctx.beginPath();\n                ctx.moveTo(this.xCenter, this.yCenter);\n                ctx.lineTo(position.x, position.y);\n                ctx.stroke();\n            }\n            ctx.restore();\n        }\n    }\n drawBorder() {}\n drawLabels() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        const tickOpts = opts.ticks;\n        if (!tickOpts.display) {\n            return;\n        }\n        const startAngle = this.getIndexAngle(0);\n        let offset, width;\n        ctx.save();\n        ctx.translate(this.xCenter, this.yCenter);\n        ctx.rotate(startAngle);\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        this.ticks.forEach((tick, index)=>{\n            if (index === 0 && this.min >= 0 && !opts.reverse) {\n                return;\n            }\n            const optsAtIndex = tickOpts.setContext(this.getContext(index));\n            const tickFont = helpers_dataset.toFont(optsAtIndex.font);\n            offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\n            if (optsAtIndex.showLabelBackdrop) {\n                ctx.font = tickFont.string;\n                width = ctx.measureText(tick.label).width;\n                ctx.fillStyle = optsAtIndex.backdropColor;\n                const padding = helpers_dataset.toPadding(optsAtIndex.backdropPadding);\n                ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);\n            }\n            helpers_dataset.renderText(ctx, tick.label, 0, -offset, tickFont, {\n                color: optsAtIndex.color,\n                strokeColor: optsAtIndex.textStrokeColor,\n                strokeWidth: optsAtIndex.textStrokeWidth\n            });\n        });\n        ctx.restore();\n    }\n drawTitle() {}\n}\n\nconst INTERVALS = {\n    millisecond: {\n        common: true,\n        size: 1,\n        steps: 1000\n    },\n    second: {\n        common: true,\n        size: 1000,\n        steps: 60\n    },\n    minute: {\n        common: true,\n        size: 60000,\n        steps: 60\n    },\n    hour: {\n        common: true,\n        size: 3600000,\n        steps: 24\n    },\n    day: {\n        common: true,\n        size: 86400000,\n        steps: 30\n    },\n    week: {\n        common: false,\n        size: 604800000,\n        steps: 4\n    },\n    month: {\n        common: true,\n        size: 2.628e9,\n        steps: 12\n    },\n    quarter: {\n        common: false,\n        size: 7.884e9,\n        steps: 4\n    },\n    year: {\n        common: true,\n        size: 3.154e10\n    }\n};\n const UNITS =  /* #__PURE__ */ Object.keys(INTERVALS);\n function sorter(a, b) {\n    return a - b;\n}\n function parse(scale, input) {\n    if (helpers_dataset.isNullOrUndef(input)) {\n        return null;\n    }\n    const adapter = scale._adapter;\n    const { parser , round , isoWeekday  } = scale._parseOpts;\n    let value = input;\n    if (typeof parser === 'function') {\n        value = parser(value);\n    }\n    if (!helpers_dataset.isNumberFinite(value)) {\n        value = typeof parser === 'string' ? adapter.parse(value, parser) : adapter.parse(value);\n    }\n    if (value === null) {\n        return null;\n    }\n    if (round) {\n        value = round === 'week' && (helpers_dataset.isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, 'isoWeek', isoWeekday) : adapter.startOf(value, round);\n    }\n    return +value;\n}\n function determineUnitForAutoTicks(minUnit, min, max, capacity) {\n    const ilen = UNITS.length;\n    for(let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i){\n        const interval = INTERVALS[UNITS[i]];\n        const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n            return UNITS[i];\n        }\n    }\n    return UNITS[ilen - 1];\n}\n function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n    for(let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--){\n        const unit = UNITS[i];\n        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n            return unit;\n        }\n    }\n    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\n function determineMajorUnit(unit) {\n    for(let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i){\n        if (INTERVALS[UNITS[i]].common) {\n            return UNITS[i];\n        }\n    }\n}\n function addTick(ticks, time, timestamps) {\n    if (!timestamps) {\n        ticks[time] = true;\n    } else if (timestamps.length) {\n        const { lo , hi  } = helpers_dataset._lookup(timestamps, time);\n        const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n        ticks[timestamp] = true;\n    }\n}\n function setMajorTicks(scale, ticks, map, majorUnit) {\n    const adapter = scale._adapter;\n    const first = +adapter.startOf(ticks[0].value, majorUnit);\n    const last = ticks[ticks.length - 1].value;\n    let major, index;\n    for(major = first; major <= last; major = +adapter.add(major, 1, majorUnit)){\n        index = map[major];\n        if (index >= 0) {\n            ticks[index].major = true;\n        }\n    }\n    return ticks;\n}\n function ticksFromTimestamps(scale, values, majorUnit) {\n    const ticks = [];\n     const map = {};\n    const ilen = values.length;\n    let i, value;\n    for(i = 0; i < ilen; ++i){\n        value = values[i];\n        map[value] = i;\n        ticks.push({\n            value,\n            major: false\n        });\n    }\n    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\nclass TimeScale extends Scale {\n    static id = 'time';\n static defaults = {\n bounds: 'data',\n        adapters: {},\n        time: {\n            parser: false,\n            unit: false,\n            round: false,\n            isoWeekday: false,\n            minUnit: 'millisecond',\n            displayFormats: {}\n        },\n        ticks: {\n source: 'auto',\n            callback: false,\n            major: {\n                enabled: false\n            }\n        }\n    };\n constructor(props){\n        super(props);\n         this._cache = {\n            data: [],\n            labels: [],\n            all: []\n        };\n         this._unit = 'day';\n         this._majorUnit = undefined;\n        this._offsets = {};\n        this._normalized = false;\n        this._parseOpts = undefined;\n    }\n    init(scaleOpts, opts = {}) {\n        const time = scaleOpts.time || (scaleOpts.time = {});\n         const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n        adapter.init(opts);\n        helpers_dataset.mergeIf(time.displayFormats, adapter.formats());\n        this._parseOpts = {\n            parser: time.parser,\n            round: time.round,\n            isoWeekday: time.isoWeekday\n        };\n        super.init(scaleOpts);\n        this._normalized = opts.normalized;\n    }\n parse(raw, index) {\n        if (raw === undefined) {\n            return null;\n        }\n        return parse(this, raw);\n    }\n    beforeLayout() {\n        super.beforeLayout();\n        this._cache = {\n            data: [],\n            labels: [],\n            all: []\n        };\n    }\n    determineDataLimits() {\n        const options = this.options;\n        const adapter = this._adapter;\n        const unit = options.time.unit || 'day';\n        let { min , max , minDefined , maxDefined  } = this.getUserBounds();\n function _applyBounds(bounds) {\n            if (!minDefined && !isNaN(bounds.min)) {\n                min = Math.min(min, bounds.min);\n            }\n            if (!maxDefined && !isNaN(bounds.max)) {\n                max = Math.max(max, bounds.max);\n            }\n        }\n        if (!minDefined || !maxDefined) {\n            _applyBounds(this._getLabelBounds());\n            if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\n                _applyBounds(this.getMinMax(false));\n            }\n        }\n        min = helpers_dataset.isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n        max = helpers_dataset.isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n        this.min = Math.min(min, max - 1);\n        this.max = Math.max(min + 1, max);\n    }\n _getLabelBounds() {\n        const arr = this.getLabelTimestamps();\n        let min = Number.POSITIVE_INFINITY;\n        let max = Number.NEGATIVE_INFINITY;\n        if (arr.length) {\n            min = arr[0];\n            max = arr[arr.length - 1];\n        }\n        return {\n            min,\n            max\n        };\n    }\n buildTicks() {\n        const options = this.options;\n        const timeOpts = options.time;\n        const tickOpts = options.ticks;\n        const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();\n        if (options.bounds === 'ticks' && timestamps.length) {\n            this.min = this._userMin || timestamps[0];\n            this.max = this._userMax || timestamps[timestamps.length - 1];\n        }\n        const min = this.min;\n        const max = this.max;\n        const ticks = helpers_dataset._filterBetween(timestamps, min, max);\n        this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n        this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined : determineMajorUnit(this._unit);\n        this.initOffsets(timestamps);\n        if (options.reverse) {\n            ticks.reverse();\n        }\n        return ticksFromTimestamps(this, ticks, this._majorUnit);\n    }\n    afterAutoSkip() {\n        if (this.options.offsetAfterAutoskip) {\n            this.initOffsets(this.ticks.map((tick)=>+tick.value));\n        }\n    }\n initOffsets(timestamps = []) {\n        let start = 0;\n        let end = 0;\n        let first, last;\n        if (this.options.offset && timestamps.length) {\n            first = this.getDecimalForValue(timestamps[0]);\n            if (timestamps.length === 1) {\n                start = 1 - first;\n            } else {\n                start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n            }\n            last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n            if (timestamps.length === 1) {\n                end = last;\n            } else {\n                end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n            }\n        }\n        const limit = timestamps.length < 3 ? 0.5 : 0.25;\n        start = helpers_dataset._limitValue(start, 0, limit);\n        end = helpers_dataset._limitValue(end, 0, limit);\n        this._offsets = {\n            start,\n            end,\n            factor: 1 / (start + 1 + end)\n        };\n    }\n _generate() {\n        const adapter = this._adapter;\n        const min = this.min;\n        const max = this.max;\n        const options = this.options;\n        const timeOpts = options.time;\n        const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n        const stepSize = helpers_dataset.valueOrDefault(options.ticks.stepSize, 1);\n        const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n        const hasWeekday = helpers_dataset.isNumber(weekday) || weekday === true;\n        const ticks = {};\n        let first = min;\n        let time, count;\n        if (hasWeekday) {\n            first = +adapter.startOf(first, 'isoWeek', weekday);\n        }\n        first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n        if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n            throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n        }\n        const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();\n        for(time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++){\n            addTick(ticks, time, timestamps);\n        }\n        if (time === max || options.bounds === 'ticks' || count === 1) {\n            addTick(ticks, time, timestamps);\n        }\n        return Object.keys(ticks).sort(sorter).map((x)=>+x);\n    }\n getLabelForValue(value) {\n        const adapter = this._adapter;\n        const timeOpts = this.options.time;\n        if (timeOpts.tooltipFormat) {\n            return adapter.format(value, timeOpts.tooltipFormat);\n        }\n        return adapter.format(value, timeOpts.displayFormats.datetime);\n    }\n format(value, format) {\n        const options = this.options;\n        const formats = options.time.displayFormats;\n        const unit = this._unit;\n        const fmt = format || formats[unit];\n        return this._adapter.format(value, fmt);\n    }\n _tickFormatFunction(time, index, ticks, format) {\n        const options = this.options;\n        const formatter = options.ticks.callback;\n        if (formatter) {\n            return helpers_dataset.callback(formatter, [\n                time,\n                index,\n                ticks\n            ], this);\n        }\n        const formats = options.time.displayFormats;\n        const unit = this._unit;\n        const majorUnit = this._majorUnit;\n        const minorFormat = unit && formats[unit];\n        const majorFormat = majorUnit && formats[majorUnit];\n        const tick = ticks[index];\n        const major = majorUnit && majorFormat && tick && tick.major;\n        return this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n    }\n generateTickLabels(ticks) {\n        let i, ilen, tick;\n        for(i = 0, ilen = ticks.length; i < ilen; ++i){\n            tick = ticks[i];\n            tick.label = this._tickFormatFunction(tick.value, i, ticks);\n        }\n    }\n getDecimalForValue(value) {\n        return value === null ? NaN : (value - this.min) / (this.max - this.min);\n    }\n getPixelForValue(value) {\n        const offsets = this._offsets;\n        const pos = this.getDecimalForValue(value);\n        return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n    }\n getValueForPixel(pixel) {\n        const offsets = this._offsets;\n        const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n        return this.min + pos * (this.max - this.min);\n    }\n _getLabelSize(label) {\n        const ticksOpts = this.options.ticks;\n        const tickLabelWidth = this.ctx.measureText(label).width;\n        const angle = helpers_dataset.toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n        const cosRotation = Math.cos(angle);\n        const sinRotation = Math.sin(angle);\n        const tickFontSize = this._resolveTickFontOptions(0).size;\n        return {\n            w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,\n            h: tickLabelWidth * sinRotation + tickFontSize * cosRotation\n        };\n    }\n _getLabelCapacity(exampleTime) {\n        const timeOpts = this.options.time;\n        const displayFormats = timeOpts.displayFormats;\n        const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n        const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [\n            exampleTime\n        ], this._majorUnit), format);\n        const size = this._getLabelSize(exampleLabel);\n        const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n        return capacity > 0 ? capacity : 1;\n    }\n getDataTimestamps() {\n        let timestamps = this._cache.data || [];\n        let i, ilen;\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const metas = this.getMatchingVisibleMetas();\n        if (this._normalized && metas.length) {\n            return this._cache.data = metas[0].controller.getAllParsedValues(this);\n        }\n        for(i = 0, ilen = metas.length; i < ilen; ++i){\n            timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n        }\n        return this._cache.data = this.normalize(timestamps);\n    }\n getLabelTimestamps() {\n        const timestamps = this._cache.labels || [];\n        let i, ilen;\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const labels = this.getLabels();\n        for(i = 0, ilen = labels.length; i < ilen; ++i){\n            timestamps.push(parse(this, labels[i]));\n        }\n        return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);\n    }\n normalize(values) {\n        return helpers_dataset._arrayUnique(values.sort(sorter));\n    }\n}\n\nfunction interpolate(table, val, reverse) {\n    let lo = 0;\n    let hi = table.length - 1;\n    let prevSource, nextSource, prevTarget, nextTarget;\n    if (reverse) {\n        if (val >= table[lo].pos && val <= table[hi].pos) {\n            ({ lo , hi  } = helpers_dataset._lookupByKey(table, 'pos', val));\n        }\n        ({ pos: prevSource , time: prevTarget  } = table[lo]);\n        ({ pos: nextSource , time: nextTarget  } = table[hi]);\n    } else {\n        if (val >= table[lo].time && val <= table[hi].time) {\n            ({ lo , hi  } = helpers_dataset._lookupByKey(table, 'time', val));\n        }\n        ({ time: prevSource , pos: prevTarget  } = table[lo]);\n        ({ time: nextSource , pos: nextTarget  } = table[hi]);\n    }\n    const span = nextSource - prevSource;\n    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\nclass TimeSeriesScale extends TimeScale {\n    static id = 'timeseries';\n static defaults = TimeScale.defaults;\n constructor(props){\n        super(props);\n         this._table = [];\n         this._minPos = undefined;\n         this._tableRange = undefined;\n    }\n initOffsets() {\n        const timestamps = this._getTimestampsForTable();\n        const table = this._table = this.buildLookupTable(timestamps);\n        this._minPos = interpolate(table, this.min);\n        this._tableRange = interpolate(table, this.max) - this._minPos;\n        super.initOffsets(timestamps);\n    }\n buildLookupTable(timestamps) {\n        const { min , max  } = this;\n        const items = [];\n        const table = [];\n        let i, ilen, prev, curr, next;\n        for(i = 0, ilen = timestamps.length; i < ilen; ++i){\n            curr = timestamps[i];\n            if (curr >= min && curr <= max) {\n                items.push(curr);\n            }\n        }\n        if (items.length < 2) {\n            return [\n                {\n                    time: min,\n                    pos: 0\n                },\n                {\n                    time: max,\n                    pos: 1\n                }\n            ];\n        }\n        for(i = 0, ilen = items.length; i < ilen; ++i){\n            next = items[i + 1];\n            prev = items[i - 1];\n            curr = items[i];\n            if (Math.round((next + prev) / 2) !== curr) {\n                table.push({\n                    time: curr,\n                    pos: i / (ilen - 1)\n                });\n            }\n        }\n        return table;\n    }\n _generate() {\n        const min = this.min;\n        const max = this.max;\n        let timestamps = super.getDataTimestamps();\n        if (!timestamps.includes(min) || !timestamps.length) {\n            timestamps.splice(0, 0, min);\n        }\n        if (!timestamps.includes(max) || timestamps.length === 1) {\n            timestamps.push(max);\n        }\n        return timestamps.sort((a, b)=>a - b);\n    }\n _getTimestampsForTable() {\n        let timestamps = this._cache.all || [];\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const data = this.getDataTimestamps();\n        const label = this.getLabelTimestamps();\n        if (data.length && label.length) {\n            timestamps = this.normalize(data.concat(label));\n        } else {\n            timestamps = data.length ? data : label;\n        }\n        timestamps = this._cache.all = timestamps;\n        return timestamps;\n    }\n getDecimalForValue(value) {\n        return (interpolate(this._table, value) - this._minPos) / this._tableRange;\n    }\n getValueForPixel(pixel) {\n        const offsets = this._offsets;\n        const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n        return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\n    }\n}\n\nvar scales = /*#__PURE__*/Object.freeze({\n__proto__: null,\nCategoryScale: CategoryScale,\nLinearScale: LinearScale,\nLogarithmicScale: LogarithmicScale,\nRadialLinearScale: RadialLinearScale,\nTimeScale: TimeScale,\nTimeSeriesScale: TimeSeriesScale\n});\n\nconst registerables = [\n    controllers,\n    elements,\n    plugins,\n    scales\n];\n\nexports.Ticks = helpers_dataset.Ticks;\nexports.defaults = helpers_dataset.defaults;\nexports.Animation = Animation;\nexports.Animations = Animations;\nexports.ArcElement = ArcElement;\nexports.BarController = BarController;\nexports.BarElement = BarElement;\nexports.BasePlatform = BasePlatform;\nexports.BasicPlatform = BasicPlatform;\nexports.BubbleController = BubbleController;\nexports.CategoryScale = CategoryScale;\nexports.Chart = Chart;\nexports.Colors = plugin_colors;\nexports.DatasetController = DatasetController;\nexports.Decimation = plugin_decimation;\nexports.DomPlatform = DomPlatform;\nexports.DoughnutController = DoughnutController;\nexports.Element = Element;\nexports.Filler = index;\nexports.Interaction = Interaction;\nexports.Legend = plugin_legend;\nexports.LineController = LineController;\nexports.LineElement = LineElement;\nexports.LinearScale = LinearScale;\nexports.LogarithmicScale = LogarithmicScale;\nexports.PieController = PieController;\nexports.PointElement = PointElement;\nexports.PolarAreaController = PolarAreaController;\nexports.RadarController = RadarController;\nexports.RadialLinearScale = RadialLinearScale;\nexports.Scale = Scale;\nexports.ScatterController = ScatterController;\nexports.SubTitle = plugin_subtitle;\nexports.TimeScale = TimeScale;\nexports.TimeSeriesScale = TimeSeriesScale;\nexports.Title = plugin_title;\nexports.Tooltip = plugin_tooltip;\nexports._adapters = adapters;\nexports._detectPlatform = _detectPlatform;\nexports.animator = animator;\nexports.controllers = controllers;\nexports.elements = elements;\nexports.layouts = layouts;\nexports.plugins = plugins;\nexports.registerables = registerables;\nexports.registry = registry;\nexports.scales = scales;\n//# sourceMappingURL=chart.cjs.map\n\n\n//# sourceURL=webpack://qasm-quantum-simulator/./node_modules/chart.js/dist/chart.cjs?\n}");

/***/ }),

/***/ "./node_modules/chart.js/dist/chunks/helpers.dataset.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/chart.js/dist/chunks/helpers.dataset.cjs ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{/*!\n * Chart.js v4.5.0\n * https://www.chartjs.org\n * (c) 2025 Chart.js Contributors\n * Released under the MIT License\n */\n\n\nvar color$1 = __webpack_require__(/*! @kurkle/color */ \"./node_modules/@kurkle/color/dist/color.cjs\");\n\n/**\n * @namespace Chart.helpers\n */ /**\n * An empty function that can be used, for example, for optional callback.\n */ function noop() {\n/* noop */ }\n/**\n * Returns a unique id, sequentially generated from a global variable.\n */ const uid = (()=>{\n    let id = 0;\n    return ()=>id++;\n})();\n/**\n * Returns true if `value` is neither null nor undefined, else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */ function isNullOrUndef(value) {\n    return value === null || value === undefined;\n}\n/**\n * Returns true if `value` is an array (including typed arrays), else returns false.\n * @param value - The value to test.\n * @function\n */ function isArray(value) {\n    if (Array.isArray && Array.isArray(value)) {\n        return true;\n    }\n    const type = Object.prototype.toString.call(value);\n    if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {\n        return true;\n    }\n    return false;\n}\n/**\n * Returns true if `value` is an object (excluding null), else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */ function isObject(value) {\n    return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\n/**\n * Returns true if `value` is a finite number, else returns false\n * @param value  - The value to test.\n */ function isNumberFinite(value) {\n    return (typeof value === 'number' || value instanceof Number) && isFinite(+value);\n}\n/**\n * Returns `value` if finite, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is not finite.\n */ function finiteOrDefault(value, defaultValue) {\n    return isNumberFinite(value) ? value : defaultValue;\n}\n/**\n * Returns `value` if defined, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is undefined.\n */ function valueOrDefault(value, defaultValue) {\n    return typeof value === 'undefined' ? defaultValue : value;\n}\nconst toPercentage = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 : +value / dimension;\nconst toDimension = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 * dimension : +value;\n/**\n * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\n * value returned by `fn`. If `fn` is not a function, this method returns undefined.\n * @param fn - The function to call.\n * @param args - The arguments with which `fn` should be called.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n */ function callback(fn, args, thisArg) {\n    if (fn && typeof fn.call === 'function') {\n        return fn.apply(thisArg, args);\n    }\n}\nfunction each(loopable, fn, thisArg, reverse) {\n    let i, len, keys;\n    if (isArray(loopable)) {\n        len = loopable.length;\n        if (reverse) {\n            for(i = len - 1; i >= 0; i--){\n                fn.call(thisArg, loopable[i], i);\n            }\n        } else {\n            for(i = 0; i < len; i++){\n                fn.call(thisArg, loopable[i], i);\n            }\n        }\n    } else if (isObject(loopable)) {\n        keys = Object.keys(loopable);\n        len = keys.length;\n        for(i = 0; i < len; i++){\n            fn.call(thisArg, loopable[keys[i]], keys[i]);\n        }\n    }\n}\n/**\n * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\n * @param a0 - The array to compare\n * @param a1 - The array to compare\n * @private\n */ function _elementsEqual(a0, a1) {\n    let i, ilen, v0, v1;\n    if (!a0 || !a1 || a0.length !== a1.length) {\n        return false;\n    }\n    for(i = 0, ilen = a0.length; i < ilen; ++i){\n        v0 = a0[i];\n        v1 = a1[i];\n        if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Returns a deep copy of `source` without keeping references on objects and arrays.\n * @param source - The value to clone.\n */ function clone(source) {\n    if (isArray(source)) {\n        return source.map(clone);\n    }\n    if (isObject(source)) {\n        const target = Object.create(null);\n        const keys = Object.keys(source);\n        const klen = keys.length;\n        let k = 0;\n        for(; k < klen; ++k){\n            target[keys[k]] = clone(source[keys[k]]);\n        }\n        return target;\n    }\n    return source;\n}\nfunction isValidKey(key) {\n    return [\n        '__proto__',\n        'prototype',\n        'constructor'\n    ].indexOf(key) === -1;\n}\n/**\n * The default merger when Chart.helpers.merge is called without merger option.\n * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.\n * @private\n */ function _merger(key, target, source, options) {\n    if (!isValidKey(key)) {\n        return;\n    }\n    const tval = target[key];\n    const sval = source[key];\n    if (isObject(tval) && isObject(sval)) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        merge(tval, sval, options);\n    } else {\n        target[key] = clone(sval);\n    }\n}\nfunction merge(target, source, options) {\n    const sources = isArray(source) ? source : [\n        source\n    ];\n    const ilen = sources.length;\n    if (!isObject(target)) {\n        return target;\n    }\n    options = options || {};\n    const merger = options.merger || _merger;\n    let current;\n    for(let i = 0; i < ilen; ++i){\n        current = sources[i];\n        if (!isObject(current)) {\n            continue;\n        }\n        const keys = Object.keys(current);\n        for(let k = 0, klen = keys.length; k < klen; ++k){\n            merger(keys[k], target, current, options);\n        }\n    }\n    return target;\n}\nfunction mergeIf(target, source) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return merge(target, source, {\n        merger: _mergerIf\n    });\n}\n/**\n * Merges source[key] in target[key] only if target[key] is undefined.\n * @private\n */ function _mergerIf(key, target, source) {\n    if (!isValidKey(key)) {\n        return;\n    }\n    const tval = target[key];\n    const sval = source[key];\n    if (isObject(tval) && isObject(sval)) {\n        mergeIf(tval, sval);\n    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n        target[key] = clone(sval);\n    }\n}\n/**\n * @private\n */ function _deprecated(scope, value, previous, current) {\n    if (value !== undefined) {\n        console.warn(scope + ': \"' + previous + '\" is deprecated. Please use \"' + current + '\" instead');\n    }\n}\n// resolveObjectKey resolver cache\nconst keyResolvers = {\n    // Chart.helpers.core resolveObjectKey should resolve empty key to root object\n    '': (v)=>v,\n    // default resolvers\n    x: (o)=>o.x,\n    y: (o)=>o.y\n};\n/**\n * @private\n */ function _splitKey(key) {\n    const parts = key.split('.');\n    const keys = [];\n    let tmp = '';\n    for (const part of parts){\n        tmp += part;\n        if (tmp.endsWith('\\\\')) {\n            tmp = tmp.slice(0, -1) + '.';\n        } else {\n            keys.push(tmp);\n            tmp = '';\n        }\n    }\n    return keys;\n}\nfunction _getKeyResolver(key) {\n    const keys = _splitKey(key);\n    return (obj)=>{\n        for (const k of keys){\n            if (k === '') {\n                break;\n            }\n            obj = obj && obj[k];\n        }\n        return obj;\n    };\n}\nfunction resolveObjectKey(obj, key) {\n    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n    return resolver(obj);\n}\n/**\n * @private\n */ function _capitalize(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\nconst defined = (value)=>typeof value !== 'undefined';\nconst isFunction = (value)=>typeof value === 'function';\n// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384\nconst setsEqual = (a, b)=>{\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const item of a){\n        if (!b.has(item)) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * @param e - The event\n * @private\n */ function _isClickEvent(e) {\n    return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';\n}\n\n/**\n * @alias Chart.helpers.math\n * @namespace\n */ const PI = Math.PI;\nconst TAU = 2 * PI;\nconst PITAU = TAU + PI;\nconst INFINITY = Number.POSITIVE_INFINITY;\nconst RAD_PER_DEG = PI / 180;\nconst HALF_PI = PI / 2;\nconst QUARTER_PI = PI / 4;\nconst TWO_THIRDS_PI = PI * 2 / 3;\nconst log10 = Math.log10;\nconst sign = Math.sign;\nfunction almostEquals(x, y, epsilon) {\n    return Math.abs(x - y) < epsilon;\n}\n/**\n * Implementation of the nice number algorithm used in determining where axis labels will go\n */ function niceNum(range) {\n    const roundedRange = Math.round(range);\n    range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n    const niceRange = Math.pow(10, Math.floor(log10(range)));\n    const fraction = range / niceRange;\n    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n    return niceFraction * niceRange;\n}\n/**\n * Returns an array of factors sorted from 1 to sqrt(value)\n * @private\n */ function _factorize(value) {\n    const result = [];\n    const sqrt = Math.sqrt(value);\n    let i;\n    for(i = 1; i < sqrt; i++){\n        if (value % i === 0) {\n            result.push(i);\n            result.push(value / i);\n        }\n    }\n    if (sqrt === (sqrt | 0)) {\n        result.push(sqrt);\n    }\n    result.sort((a, b)=>a - b).pop();\n    return result;\n}\n/**\n * Verifies that attempting to coerce n to string or number won't throw a TypeError.\n */ function isNonPrimitive(n) {\n    return typeof n === 'symbol' || typeof n === 'object' && n !== null && !(Symbol.toPrimitive in n || 'toString' in n || 'valueOf' in n);\n}\nfunction isNumber(n) {\n    return !isNonPrimitive(n) && !isNaN(parseFloat(n)) && isFinite(n);\n}\nfunction almostWhole(x, epsilon) {\n    const rounded = Math.round(x);\n    return rounded - epsilon <= x && rounded + epsilon >= x;\n}\n/**\n * @private\n */ function _setMinAndMaxByKey(array, target, property) {\n    let i, ilen, value;\n    for(i = 0, ilen = array.length; i < ilen; i++){\n        value = array[i][property];\n        if (!isNaN(value)) {\n            target.min = Math.min(target.min, value);\n            target.max = Math.max(target.max, value);\n        }\n    }\n}\nfunction toRadians(degrees) {\n    return degrees * (PI / 180);\n}\nfunction toDegrees(radians) {\n    return radians * (180 / PI);\n}\n/**\n * Returns the number of decimal places\n * i.e. the number of digits after the decimal point, of the value of this Number.\n * @param x - A number.\n * @returns The number of decimal places.\n * @private\n */ function _decimalPlaces(x) {\n    if (!isNumberFinite(x)) {\n        return;\n    }\n    let e = 1;\n    let p = 0;\n    while(Math.round(x * e) / e !== x){\n        e *= 10;\n        p++;\n    }\n    return p;\n}\n// Gets the angle from vertical upright to the point about a centre.\nfunction getAngleFromPoint(centrePoint, anglePoint) {\n    const distanceFromXCenter = anglePoint.x - centrePoint.x;\n    const distanceFromYCenter = anglePoint.y - centrePoint.y;\n    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n    if (angle < -0.5 * PI) {\n        angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n    }\n    return {\n        angle,\n        distance: radialDistanceFromCenter\n    };\n}\nfunction distanceBetweenPoints(pt1, pt2) {\n    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\n/**\n * Shortest distance between angles, in either direction.\n * @private\n */ function _angleDiff(a, b) {\n    return (a - b + PITAU) % TAU - PI;\n}\n/**\n * Normalize angle to be between 0 and 2*PI\n * @private\n */ function _normalizeAngle(a) {\n    return (a % TAU + TAU) % TAU;\n}\n/**\n * @private\n */ function _angleBetween(angle, start, end, sameAngleIsFullCircle) {\n    const a = _normalizeAngle(angle);\n    const s = _normalizeAngle(start);\n    const e = _normalizeAngle(end);\n    const angleToStart = _normalizeAngle(s - a);\n    const angleToEnd = _normalizeAngle(e - a);\n    const startToAngle = _normalizeAngle(a - s);\n    const endToAngle = _normalizeAngle(a - e);\n    return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;\n}\n/**\n * Limit `value` between `min` and `max`\n * @param value\n * @param min\n * @param max\n * @private\n */ function _limitValue(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\n/**\n * @param {number} value\n * @private\n */ function _int16Range(value) {\n    return _limitValue(value, -32768, 32767);\n}\n/**\n * @param value\n * @param start\n * @param end\n * @param [epsilon]\n * @private\n */ function _isBetween(value, start, end, epsilon = 1e-6) {\n    return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\n\nfunction _lookup(table, value, cmp) {\n    cmp = cmp || ((index)=>table[index] < value);\n    let hi = table.length - 1;\n    let lo = 0;\n    let mid;\n    while(hi - lo > 1){\n        mid = lo + hi >> 1;\n        if (cmp(mid)) {\n            lo = mid;\n        } else {\n            hi = mid;\n        }\n    }\n    return {\n        lo,\n        hi\n    };\n}\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @param last - lookup last index\n * @private\n */ const _lookupByKey = (table, key, value, last)=>_lookup(table, value, last ? (index)=>{\n        const ti = table[index][key];\n        return ti < value || ti === value && table[index + 1][key] === value;\n    } : (index)=>table[index][key] < value);\n/**\n * Reverse binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @private\n */ const _rlookupByKey = (table, key, value)=>_lookup(table, value, (index)=>table[index][key] >= value);\n/**\n * Return subset of `values` between `min` and `max` inclusive.\n * Values are assumed to be in sorted order.\n * @param values - sorted array of values\n * @param min - min value\n * @param max - max value\n */ function _filterBetween(values, min, max) {\n    let start = 0;\n    let end = values.length;\n    while(start < end && values[start] < min){\n        start++;\n    }\n    while(end > start && values[end - 1] > max){\n        end--;\n    }\n    return start > 0 || end < values.length ? values.slice(start, end) : values;\n}\nconst arrayEvents = [\n    'push',\n    'pop',\n    'shift',\n    'splice',\n    'unshift'\n];\nfunction listenArrayEvents(array, listener) {\n    if (array._chartjs) {\n        array._chartjs.listeners.push(listener);\n        return;\n    }\n    Object.defineProperty(array, '_chartjs', {\n        configurable: true,\n        enumerable: false,\n        value: {\n            listeners: [\n                listener\n            ]\n        }\n    });\n    arrayEvents.forEach((key)=>{\n        const method = '_onData' + _capitalize(key);\n        const base = array[key];\n        Object.defineProperty(array, key, {\n            configurable: true,\n            enumerable: false,\n            value (...args) {\n                const res = base.apply(this, args);\n                array._chartjs.listeners.forEach((object)=>{\n                    if (typeof object[method] === 'function') {\n                        object[method](...args);\n                    }\n                });\n                return res;\n            }\n        });\n    });\n}\nfunction unlistenArrayEvents(array, listener) {\n    const stub = array._chartjs;\n    if (!stub) {\n        return;\n    }\n    const listeners = stub.listeners;\n    const index = listeners.indexOf(listener);\n    if (index !== -1) {\n        listeners.splice(index, 1);\n    }\n    if (listeners.length > 0) {\n        return;\n    }\n    arrayEvents.forEach((key)=>{\n        delete array[key];\n    });\n    delete array._chartjs;\n}\n/**\n * @param items\n */ function _arrayUnique(items) {\n    const set = new Set(items);\n    if (set.size === items.length) {\n        return items;\n    }\n    return Array.from(set);\n}\n\nfunction fontString(pixelSize, fontStyle, fontFamily) {\n    return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\n/**\n* Request animation polyfill\n*/ const requestAnimFrame = function() {\n    if (typeof window === 'undefined') {\n        return function(callback) {\n            return callback();\n        };\n    }\n    return window.requestAnimationFrame;\n}();\n/**\n * Throttles calling `fn` once per animation frame\n * Latest arguments are used on the actual call\n */ function throttled(fn, thisArg) {\n    let argsToUse = [];\n    let ticking = false;\n    return function(...args) {\n        // Save the args for use later\n        argsToUse = args;\n        if (!ticking) {\n            ticking = true;\n            requestAnimFrame.call(window, ()=>{\n                ticking = false;\n                fn.apply(thisArg, argsToUse);\n            });\n        }\n    };\n}\n/**\n * Debounces calling `fn` for `delay` ms\n */ function debounce(fn, delay) {\n    let timeout;\n    return function(...args) {\n        if (delay) {\n            clearTimeout(timeout);\n            timeout = setTimeout(fn, delay, args);\n        } else {\n            fn.apply(this, args);\n        }\n        return delay;\n    };\n}\n/**\n * Converts 'start' to 'left', 'end' to 'right' and others to 'center'\n * @private\n */ const _toLeftRightCenter = (align)=>align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\n/**\n * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`\n * @private\n */ const _alignStartEnd = (align, start, end)=>align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\n/**\n * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`\n * @private\n */ const _textX = (align, left, right, rtl)=>{\n    const check = rtl ? 'left' : 'right';\n    return align === check ? right : align === 'center' ? (left + right) / 2 : left;\n};\n/**\n * Return start and count of visible points.\n * @private\n */ function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {\n    const pointCount = points.length;\n    let start = 0;\n    let count = pointCount;\n    if (meta._sorted) {\n        const { iScale , vScale , _parsed  } = meta;\n        const spanGaps = meta.dataset ? meta.dataset.options ? meta.dataset.options.spanGaps : null : null;\n        const axis = iScale.axis;\n        const { min , max , minDefined , maxDefined  } = iScale.getUserBounds();\n        if (minDefined) {\n            start = Math.min(// @ts-expect-error Need to type _parsed\n            _lookupByKey(_parsed, axis, min).lo, // @ts-expect-error Need to fix types on _lookupByKey\n            animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo);\n            if (spanGaps) {\n                const distanceToDefinedLo = _parsed.slice(0, start + 1).reverse().findIndex((point)=>!isNullOrUndef(point[vScale.axis]));\n                start -= Math.max(0, distanceToDefinedLo);\n            }\n            start = _limitValue(start, 0, pointCount - 1);\n        }\n        if (maxDefined) {\n            let end = Math.max(// @ts-expect-error Need to type _parsed\n            _lookupByKey(_parsed, iScale.axis, max, true).hi + 1, // @ts-expect-error Need to fix types on _lookupByKey\n            animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1);\n            if (spanGaps) {\n                const distanceToDefinedHi = _parsed.slice(end - 1).findIndex((point)=>!isNullOrUndef(point[vScale.axis]));\n                end += Math.max(0, distanceToDefinedHi);\n            }\n            count = _limitValue(end, start, pointCount) - start;\n        } else {\n            count = pointCount - start;\n        }\n    }\n    return {\n        start,\n        count\n    };\n}\n/**\n * Checks if the scale ranges have changed.\n * @param {object} meta - dataset meta.\n * @returns {boolean}\n * @private\n */ function _scaleRangesChanged(meta) {\n    const { xScale , yScale , _scaleRanges  } = meta;\n    const newRanges = {\n        xmin: xScale.min,\n        xmax: xScale.max,\n        ymin: yScale.min,\n        ymax: yScale.max\n    };\n    if (!_scaleRanges) {\n        meta._scaleRanges = newRanges;\n        return true;\n    }\n    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;\n    Object.assign(_scaleRanges, newRanges);\n    return changed;\n}\n\nconst atEdge = (t)=>t === 0 || t === 1;\nconst elasticIn = (t, s, p)=>-(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t, s, p)=>Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\n/**\n * Easing functions adapted from Robert Penner's easing equations.\n * @namespace Chart.helpers.easing.effects\n * @see http://www.robertpenner.com/easing/\n */ const effects = {\n    linear: (t)=>t,\n    easeInQuad: (t)=>t * t,\n    easeOutQuad: (t)=>-t * (t - 2),\n    easeInOutQuad: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),\n    easeInCubic: (t)=>t * t * t,\n    easeOutCubic: (t)=>(t -= 1) * t * t + 1,\n    easeInOutCubic: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),\n    easeInQuart: (t)=>t * t * t * t,\n    easeOutQuart: (t)=>-((t -= 1) * t * t * t - 1),\n    easeInOutQuart: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),\n    easeInQuint: (t)=>t * t * t * t * t,\n    easeOutQuint: (t)=>(t -= 1) * t * t * t * t + 1,\n    easeInOutQuint: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),\n    easeInSine: (t)=>-Math.cos(t * HALF_PI) + 1,\n    easeOutSine: (t)=>Math.sin(t * HALF_PI),\n    easeInOutSine: (t)=>-0.5 * (Math.cos(PI * t) - 1),\n    easeInExpo: (t)=>t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),\n    easeOutExpo: (t)=>t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,\n    easeInOutExpo: (t)=>atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n    easeInCirc: (t)=>t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),\n    easeOutCirc: (t)=>Math.sqrt(1 - (t -= 1) * t),\n    easeInOutCirc: (t)=>(t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n    easeInElastic: (t)=>atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n    easeOutElastic: (t)=>atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n    easeInOutElastic (t) {\n        const s = 0.1125;\n        const p = 0.45;\n        return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n    },\n    easeInBack (t) {\n        const s = 1.70158;\n        return t * t * ((s + 1) * t - s);\n    },\n    easeOutBack (t) {\n        const s = 1.70158;\n        return (t -= 1) * t * ((s + 1) * t + s) + 1;\n    },\n    easeInOutBack (t) {\n        let s = 1.70158;\n        if ((t /= 0.5) < 1) {\n            return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));\n        }\n        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\n    },\n    easeInBounce: (t)=>1 - effects.easeOutBounce(1 - t),\n    easeOutBounce (t) {\n        const m = 7.5625;\n        const d = 2.75;\n        if (t < 1 / d) {\n            return m * t * t;\n        }\n        if (t < 2 / d) {\n            return m * (t -= 1.5 / d) * t + 0.75;\n        }\n        if (t < 2.5 / d) {\n            return m * (t -= 2.25 / d) * t + 0.9375;\n        }\n        return m * (t -= 2.625 / d) * t + 0.984375;\n    },\n    easeInOutBounce: (t)=>t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5\n};\n\nfunction isPatternOrGradient(value) {\n    if (value && typeof value === 'object') {\n        const type = value.toString();\n        return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';\n    }\n    return false;\n}\nfunction color(value) {\n    return isPatternOrGradient(value) ? value : new color$1.Color(value);\n}\nfunction getHoverColor(value) {\n    return isPatternOrGradient(value) ? value : new color$1.Color(value).saturate(0.5).darken(0.1).hexString();\n}\n\nconst numbers = [\n    'x',\n    'y',\n    'borderWidth',\n    'radius',\n    'tension'\n];\nconst colors = [\n    'color',\n    'borderColor',\n    'backgroundColor'\n];\nfunction applyAnimationsDefaults(defaults) {\n    defaults.set('animation', {\n        delay: undefined,\n        duration: 1000,\n        easing: 'easeOutQuart',\n        fn: undefined,\n        from: undefined,\n        loop: undefined,\n        to: undefined,\n        type: undefined\n    });\n    defaults.describe('animation', {\n        _fallback: false,\n        _indexable: false,\n        _scriptable: (name)=>name !== 'onProgress' && name !== 'onComplete' && name !== 'fn'\n    });\n    defaults.set('animations', {\n        colors: {\n            type: 'color',\n            properties: colors\n        },\n        numbers: {\n            type: 'number',\n            properties: numbers\n        }\n    });\n    defaults.describe('animations', {\n        _fallback: 'animation'\n    });\n    defaults.set('transitions', {\n        active: {\n            animation: {\n                duration: 400\n            }\n        },\n        resize: {\n            animation: {\n                duration: 0\n            }\n        },\n        show: {\n            animations: {\n                colors: {\n                    from: 'transparent'\n                },\n                visible: {\n                    type: 'boolean',\n                    duration: 0\n                }\n            }\n        },\n        hide: {\n            animations: {\n                colors: {\n                    to: 'transparent'\n                },\n                visible: {\n                    type: 'boolean',\n                    easing: 'linear',\n                    fn: (v)=>v | 0\n                }\n            }\n        }\n    });\n}\n\nfunction applyLayoutsDefaults(defaults) {\n    defaults.set('layout', {\n        autoPadding: true,\n        padding: {\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0\n        }\n    });\n}\n\nconst intlCache = new Map();\nfunction getNumberFormat(locale, options) {\n    options = options || {};\n    const cacheKey = locale + JSON.stringify(options);\n    let formatter = intlCache.get(cacheKey);\n    if (!formatter) {\n        formatter = new Intl.NumberFormat(locale, options);\n        intlCache.set(cacheKey, formatter);\n    }\n    return formatter;\n}\nfunction formatNumber(num, locale, options) {\n    return getNumberFormat(locale, options).format(num);\n}\n\nconst formatters = {\n values (value) {\n        return isArray(value) ?  value : '' + value;\n    },\n numeric (tickValue, index, ticks) {\n        if (tickValue === 0) {\n            return '0';\n        }\n        const locale = this.chart.options.locale;\n        let notation;\n        let delta = tickValue;\n        if (ticks.length > 1) {\n            const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n            if (maxTick < 1e-4 || maxTick > 1e+15) {\n                notation = 'scientific';\n            }\n            delta = calculateDelta(tickValue, ticks);\n        }\n        const logDelta = log10(Math.abs(delta));\n        const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n        const options = {\n            notation,\n            minimumFractionDigits: numDecimal,\n            maximumFractionDigits: numDecimal\n        };\n        Object.assign(options, this.options.ticks.format);\n        return formatNumber(tickValue, locale, options);\n    },\n logarithmic (tickValue, index, ticks) {\n        if (tickValue === 0) {\n            return '0';\n        }\n        const remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));\n        if ([\n            1,\n            2,\n            3,\n            5,\n            10,\n            15\n        ].includes(remain) || index > 0.8 * ticks.length) {\n            return formatters.numeric.call(this, tickValue, index, ticks);\n        }\n        return '';\n    }\n};\nfunction calculateDelta(tickValue, ticks) {\n    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n        delta = tickValue - Math.floor(tickValue);\n    }\n    return delta;\n}\n var Ticks = {\n    formatters\n};\n\nfunction applyScaleDefaults(defaults) {\n    defaults.set('scale', {\n        display: true,\n        offset: false,\n        reverse: false,\n        beginAtZero: false,\n bounds: 'ticks',\n        clip: true,\n grace: 0,\n        grid: {\n            display: true,\n            lineWidth: 1,\n            drawOnChartArea: true,\n            drawTicks: true,\n            tickLength: 8,\n            tickWidth: (_ctx, options)=>options.lineWidth,\n            tickColor: (_ctx, options)=>options.color,\n            offset: false\n        },\n        border: {\n            display: true,\n            dash: [],\n            dashOffset: 0.0,\n            width: 1\n        },\n        title: {\n            display: false,\n            text: '',\n            padding: {\n                top: 4,\n                bottom: 4\n            }\n        },\n        ticks: {\n            minRotation: 0,\n            maxRotation: 50,\n            mirror: false,\n            textStrokeWidth: 0,\n            textStrokeColor: '',\n            padding: 3,\n            display: true,\n            autoSkip: true,\n            autoSkipPadding: 3,\n            labelOffset: 0,\n            callback: Ticks.formatters.values,\n            minor: {},\n            major: {},\n            align: 'center',\n            crossAlign: 'near',\n            showLabelBackdrop: false,\n            backdropColor: 'rgba(255, 255, 255, 0.75)',\n            backdropPadding: 2\n        }\n    });\n    defaults.route('scale.ticks', 'color', '', 'color');\n    defaults.route('scale.grid', 'color', '', 'borderColor');\n    defaults.route('scale.border', 'color', '', 'borderColor');\n    defaults.route('scale.title', 'color', '', 'color');\n    defaults.describe('scale', {\n        _fallback: false,\n        _scriptable: (name)=>!name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\n        _indexable: (name)=>name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash'\n    });\n    defaults.describe('scales', {\n        _fallback: 'scale'\n    });\n    defaults.describe('scale.ticks', {\n        _scriptable: (name)=>name !== 'backdropPadding' && name !== 'callback',\n        _indexable: (name)=>name !== 'backdropPadding'\n    });\n}\n\nconst overrides = Object.create(null);\nconst descriptors = Object.create(null);\n function getScope$1(node, key) {\n    if (!key) {\n        return node;\n    }\n    const keys = key.split('.');\n    for(let i = 0, n = keys.length; i < n; ++i){\n        const k = keys[i];\n        node = node[k] || (node[k] = Object.create(null));\n    }\n    return node;\n}\nfunction set(root, scope, values) {\n    if (typeof scope === 'string') {\n        return merge(getScope$1(root, scope), values);\n    }\n    return merge(getScope$1(root, ''), scope);\n}\n class Defaults {\n    constructor(_descriptors, _appliers){\n        this.animation = undefined;\n        this.backgroundColor = 'rgba(0,0,0,0.1)';\n        this.borderColor = 'rgba(0,0,0,0.1)';\n        this.color = '#666';\n        this.datasets = {};\n        this.devicePixelRatio = (context)=>context.chart.platform.getDevicePixelRatio();\n        this.elements = {};\n        this.events = [\n            'mousemove',\n            'mouseout',\n            'click',\n            'touchstart',\n            'touchmove'\n        ];\n        this.font = {\n            family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n            size: 12,\n            style: 'normal',\n            lineHeight: 1.2,\n            weight: null\n        };\n        this.hover = {};\n        this.hoverBackgroundColor = (ctx, options)=>getHoverColor(options.backgroundColor);\n        this.hoverBorderColor = (ctx, options)=>getHoverColor(options.borderColor);\n        this.hoverColor = (ctx, options)=>getHoverColor(options.color);\n        this.indexAxis = 'x';\n        this.interaction = {\n            mode: 'nearest',\n            intersect: true,\n            includeInvisible: false\n        };\n        this.maintainAspectRatio = true;\n        this.onHover = null;\n        this.onClick = null;\n        this.parsing = true;\n        this.plugins = {};\n        this.responsive = true;\n        this.scale = undefined;\n        this.scales = {};\n        this.showLine = true;\n        this.drawActiveElementsOnTop = true;\n        this.describe(_descriptors);\n        this.apply(_appliers);\n    }\n set(scope, values) {\n        return set(this, scope, values);\n    }\n get(scope) {\n        return getScope$1(this, scope);\n    }\n describe(scope, values) {\n        return set(descriptors, scope, values);\n    }\n    override(scope, values) {\n        return set(overrides, scope, values);\n    }\n route(scope, name, targetScope, targetName) {\n        const scopeObject = getScope$1(this, scope);\n        const targetScopeObject = getScope$1(this, targetScope);\n        const privateName = '_' + name;\n        Object.defineProperties(scopeObject, {\n            [privateName]: {\n                value: scopeObject[name],\n                writable: true\n            },\n            [name]: {\n                enumerable: true,\n                get () {\n                    const local = this[privateName];\n                    const target = targetScopeObject[targetName];\n                    if (isObject(local)) {\n                        return Object.assign({}, target, local);\n                    }\n                    return valueOrDefault(local, target);\n                },\n                set (value) {\n                    this[privateName] = value;\n                }\n            }\n        });\n    }\n    apply(appliers) {\n        appliers.forEach((apply)=>apply(this));\n    }\n}\nvar defaults = /* #__PURE__ */ new Defaults({\n    _scriptable: (name)=>!name.startsWith('on'),\n    _indexable: (name)=>name !== 'events',\n    hover: {\n        _fallback: 'interaction'\n    },\n    interaction: {\n        _scriptable: false,\n        _indexable: false\n    }\n}, [\n    applyAnimationsDefaults,\n    applyLayoutsDefaults,\n    applyScaleDefaults\n]);\n\n/**\n * Converts the given font object into a CSS font string.\n * @param font - A font object.\n * @return The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font\n * @private\n */ function toFontString(font) {\n    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n        return null;\n    }\n    return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;\n}\n/**\n * @private\n */ function _measureText(ctx, data, gc, longest, string) {\n    let textWidth = data[string];\n    if (!textWidth) {\n        textWidth = data[string] = ctx.measureText(string).width;\n        gc.push(string);\n    }\n    if (textWidth > longest) {\n        longest = textWidth;\n    }\n    return longest;\n}\n/**\n * @private\n */ // eslint-disable-next-line complexity\nfunction _longestText(ctx, font, arrayOfThings, cache) {\n    cache = cache || {};\n    let data = cache.data = cache.data || {};\n    let gc = cache.garbageCollect = cache.garbageCollect || [];\n    if (cache.font !== font) {\n        data = cache.data = {};\n        gc = cache.garbageCollect = [];\n        cache.font = font;\n    }\n    ctx.save();\n    ctx.font = font;\n    let longest = 0;\n    const ilen = arrayOfThings.length;\n    let i, j, jlen, thing, nestedThing;\n    for(i = 0; i < ilen; i++){\n        thing = arrayOfThings[i];\n        // Undefined strings and arrays should not be measured\n        if (thing !== undefined && thing !== null && !isArray(thing)) {\n            longest = _measureText(ctx, data, gc, longest, thing);\n        } else if (isArray(thing)) {\n            // if it is an array lets measure each element\n            // to do maybe simplify this function a bit so we can do this more recursively?\n            for(j = 0, jlen = thing.length; j < jlen; j++){\n                nestedThing = thing[j];\n                // Undefined strings and arrays should not be measured\n                if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n                    longest = _measureText(ctx, data, gc, longest, nestedThing);\n                }\n            }\n        }\n    }\n    ctx.restore();\n    const gcLen = gc.length / 2;\n    if (gcLen > arrayOfThings.length) {\n        for(i = 0; i < gcLen; i++){\n            delete data[gc[i]];\n        }\n        gc.splice(0, gcLen);\n    }\n    return longest;\n}\n/**\n * Returns the aligned pixel value to avoid anti-aliasing blur\n * @param chart - The chart instance.\n * @param pixel - A pixel value.\n * @param width - The width of the element.\n * @returns The aligned pixel value.\n * @private\n */ function _alignPixel(chart, pixel, width) {\n    const devicePixelRatio = chart.currentDevicePixelRatio;\n    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\n/**\n * Clears the entire canvas.\n */ function clearCanvas(canvas, ctx) {\n    if (!ctx && !canvas) {\n        return;\n    }\n    ctx = ctx || canvas.getContext('2d');\n    ctx.save();\n    // canvas.width and canvas.height do not consider the canvas transform,\n    // while clearRect does\n    ctx.resetTransform();\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.restore();\n}\nfunction drawPoint(ctx, options, x, y) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    drawPointLegend(ctx, options, x, y, null);\n}\n// eslint-disable-next-line complexity\nfunction drawPointLegend(ctx, options, x, y, w) {\n    let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;\n    const style = options.pointStyle;\n    const rotation = options.rotation;\n    const radius = options.radius;\n    let rad = (rotation || 0) * RAD_PER_DEG;\n    if (style && typeof style === 'object') {\n        type = style.toString();\n        if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n            ctx.save();\n            ctx.translate(x, y);\n            ctx.rotate(rad);\n            ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n            ctx.restore();\n            return;\n        }\n    }\n    if (isNaN(radius) || radius <= 0) {\n        return;\n    }\n    ctx.beginPath();\n    switch(style){\n        // Default includes circle\n        default:\n            if (w) {\n                ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n            } else {\n                ctx.arc(x, y, radius, 0, TAU);\n            }\n            ctx.closePath();\n            break;\n        case 'triangle':\n            width = w ? w / 2 : radius;\n            ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n            rad += TWO_THIRDS_PI;\n            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n            rad += TWO_THIRDS_PI;\n            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n            ctx.closePath();\n            break;\n        case 'rectRounded':\n            // NOTE: the rounded rect implementation changed to use `arc` instead of\n            // `quadraticCurveTo` since it generates better results when rect is\n            // almost a circle. 0.516 (instead of 0.5) produces results with visually\n            // closer proportion to the previous impl and it is inscribed in the\n            // circle with `radius`. For more details, see the following PRs:\n            // https://github.com/chartjs/Chart.js/issues/5597\n            // https://github.com/chartjs/Chart.js/issues/5858\n            cornerRadius = radius * 0.516;\n            size = radius - cornerRadius;\n            xOffset = Math.cos(rad + QUARTER_PI) * size;\n            xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n            yOffset = Math.sin(rad + QUARTER_PI) * size;\n            yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n            ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n            ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n            ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n            ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n            ctx.closePath();\n            break;\n        case 'rect':\n            if (!rotation) {\n                size = Math.SQRT1_2 * radius;\n                width = w ? w / 2 : size;\n                ctx.rect(x - width, y - size, 2 * width, 2 * size);\n                break;\n            }\n            rad += QUARTER_PI;\n        /* falls through */ case 'rectRot':\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            ctx.closePath();\n            break;\n        case 'crossRot':\n            rad += QUARTER_PI;\n        /* falls through */ case 'cross':\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.moveTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            break;\n        case 'star':\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.moveTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            rad += QUARTER_PI;\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.moveTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            break;\n        case 'line':\n            xOffset = w ? w / 2 : Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            ctx.moveTo(x - xOffset, y - yOffset);\n            ctx.lineTo(x + xOffset, y + yOffset);\n            break;\n        case 'dash':\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);\n            break;\n        case false:\n            ctx.closePath();\n            break;\n    }\n    ctx.fill();\n    if (options.borderWidth > 0) {\n        ctx.stroke();\n    }\n}\n/**\n * Returns true if the point is inside the rectangle\n * @param point - The point to test\n * @param area - The rectangle\n * @param margin - allowed margin\n * @private\n */ function _isPointInArea(point, area, margin) {\n    margin = margin || 0.5; // margin - default is to match rounded decimals\n    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;\n}\nfunction clipArea(ctx, area) {\n    ctx.save();\n    ctx.beginPath();\n    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n    ctx.clip();\n}\nfunction unclipArea(ctx) {\n    ctx.restore();\n}\n/**\n * @private\n */ function _steppedLineTo(ctx, previous, target, flip, mode) {\n    if (!previous) {\n        return ctx.lineTo(target.x, target.y);\n    }\n    if (mode === 'middle') {\n        const midpoint = (previous.x + target.x) / 2.0;\n        ctx.lineTo(midpoint, previous.y);\n        ctx.lineTo(midpoint, target.y);\n    } else if (mode === 'after' !== !!flip) {\n        ctx.lineTo(previous.x, target.y);\n    } else {\n        ctx.lineTo(target.x, previous.y);\n    }\n    ctx.lineTo(target.x, target.y);\n}\n/**\n * @private\n */ function _bezierCurveTo(ctx, previous, target, flip) {\n    if (!previous) {\n        return ctx.lineTo(target.x, target.y);\n    }\n    ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);\n}\nfunction setRenderOpts(ctx, opts) {\n    if (opts.translation) {\n        ctx.translate(opts.translation[0], opts.translation[1]);\n    }\n    if (!isNullOrUndef(opts.rotation)) {\n        ctx.rotate(opts.rotation);\n    }\n    if (opts.color) {\n        ctx.fillStyle = opts.color;\n    }\n    if (opts.textAlign) {\n        ctx.textAlign = opts.textAlign;\n    }\n    if (opts.textBaseline) {\n        ctx.textBaseline = opts.textBaseline;\n    }\n}\nfunction decorateText(ctx, x, y, line, opts) {\n    if (opts.strikethrough || opts.underline) {\n        /**\n     * Now that IE11 support has been dropped, we can use more\n     * of the TextMetrics object. The actual bounding boxes\n     * are unflagged in Chrome, Firefox, Edge, and Safari so they\n     * can be safely used.\n     * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility\n     */ const metrics = ctx.measureText(line);\n        const left = x - metrics.actualBoundingBoxLeft;\n        const right = x + metrics.actualBoundingBoxRight;\n        const top = y - metrics.actualBoundingBoxAscent;\n        const bottom = y + metrics.actualBoundingBoxDescent;\n        const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n        ctx.strokeStyle = ctx.fillStyle;\n        ctx.beginPath();\n        ctx.lineWidth = opts.decorationWidth || 2;\n        ctx.moveTo(left, yDecoration);\n        ctx.lineTo(right, yDecoration);\n        ctx.stroke();\n    }\n}\nfunction drawBackdrop(ctx, opts) {\n    const oldColor = ctx.fillStyle;\n    ctx.fillStyle = opts.color;\n    ctx.fillRect(opts.left, opts.top, opts.width, opts.height);\n    ctx.fillStyle = oldColor;\n}\n/**\n * Render text onto the canvas\n */ function renderText(ctx, text, x, y, font, opts = {}) {\n    const lines = isArray(text) ? text : [\n        text\n    ];\n    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\n    let i, line;\n    ctx.save();\n    ctx.font = font.string;\n    setRenderOpts(ctx, opts);\n    for(i = 0; i < lines.length; ++i){\n        line = lines[i];\n        if (opts.backdrop) {\n            drawBackdrop(ctx, opts.backdrop);\n        }\n        if (stroke) {\n            if (opts.strokeColor) {\n                ctx.strokeStyle = opts.strokeColor;\n            }\n            if (!isNullOrUndef(opts.strokeWidth)) {\n                ctx.lineWidth = opts.strokeWidth;\n            }\n            ctx.strokeText(line, x, y, opts.maxWidth);\n        }\n        ctx.fillText(line, x, y, opts.maxWidth);\n        decorateText(ctx, x, y, line, opts);\n        y += Number(font.lineHeight);\n    }\n    ctx.restore();\n}\n/**\n * Add a path of a rectangle with rounded corners to the current sub-path\n * @param ctx - Context\n * @param rect - Bounding rect\n */ function addRoundedRectPath(ctx, rect) {\n    const { x , y , w , h , radius  } = rect;\n    // top left arc\n    ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);\n    // line from top left to bottom left\n    ctx.lineTo(x, y + h - radius.bottomLeft);\n    // bottom left arc\n    ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n    // line from bottom left to bottom right\n    ctx.lineTo(x + w - radius.bottomRight, y + h);\n    // bottom right arc\n    ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n    // line from bottom right to top right\n    ctx.lineTo(x + w, y + radius.topRight);\n    // top right arc\n    ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n    // line from top right to top left\n    ctx.lineTo(x + radius.topLeft, y);\n}\n\nconst LINE_HEIGHT = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/;\nconst FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\n/**\n * @alias Chart.helpers.options\n * @namespace\n */ /**\n * Converts the given line height `value` in pixels for a specific font `size`.\n * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\n * @param size - The font size (in pixels) used to resolve relative `value`.\n * @returns The effective line height in pixels (size * 1.2 if value is invalid).\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\n * @since 2.7.0\n */ function toLineHeight(value, size) {\n    const matches = ('' + value).match(LINE_HEIGHT);\n    if (!matches || matches[1] === 'normal') {\n        return size * 1.2;\n    }\n    value = +matches[2];\n    switch(matches[3]){\n        case 'px':\n            return value;\n        case '%':\n            value /= 100;\n            break;\n    }\n    return size * value;\n}\nconst numberOrZero = (v)=>+v || 0;\nfunction _readValueToProps(value, props) {\n    const ret = {};\n    const objProps = isObject(props);\n    const keys = objProps ? Object.keys(props) : props;\n    const read = isObject(value) ? objProps ? (prop)=>valueOrDefault(value[prop], value[props[prop]]) : (prop)=>value[prop] : ()=>value;\n    for (const prop of keys){\n        ret[prop] = numberOrZero(read(prop));\n    }\n    return ret;\n}\n/**\n * Converts the given value into a TRBL object.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left)\n * @since 3.0.0\n */ function toTRBL(value) {\n    return _readValueToProps(value, {\n        top: 'y',\n        right: 'x',\n        bottom: 'y',\n        left: 'x'\n    });\n}\n/**\n * Converts the given value into a TRBL corners object (similar with css border-radius).\n * @param value - If a number, set the value to all TRBL corner components,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)\n * @since 3.0.0\n */ function toTRBLCorners(value) {\n    return _readValueToProps(value, [\n        'topLeft',\n        'topRight',\n        'bottomLeft',\n        'bottomRight'\n    ]);\n}\n/**\n * Converts the given value into a padding object with pre-computed width/height.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left, width, height)\n * @since 2.7.0\n */ function toPadding(value) {\n    const obj = toTRBL(value);\n    obj.width = obj.left + obj.right;\n    obj.height = obj.top + obj.bottom;\n    return obj;\n}\n/**\n * Parses font options and returns the font object.\n * @param options - A object that contains font options to be parsed.\n * @param fallback - A object that contains fallback font options.\n * @return The font object.\n * @private\n */ function toFont(options, fallback) {\n    options = options || {};\n    fallback = fallback || defaults.font;\n    let size = valueOrDefault(options.size, fallback.size);\n    if (typeof size === 'string') {\n        size = parseInt(size, 10);\n    }\n    let style = valueOrDefault(options.style, fallback.style);\n    if (style && !('' + style).match(FONT_STYLE)) {\n        console.warn('Invalid font style specified: \"' + style + '\"');\n        style = undefined;\n    }\n    const font = {\n        family: valueOrDefault(options.family, fallback.family),\n        lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n        size,\n        style,\n        weight: valueOrDefault(options.weight, fallback.weight),\n        string: ''\n    };\n    font.string = toFontString(font);\n    return font;\n}\n/**\n * Evaluates the given `inputs` sequentially and returns the first defined value.\n * @param inputs - An array of values, falling back to the last value.\n * @param context - If defined and the current value is a function, the value\n * is called with `context` as first argument and the result becomes the new input.\n * @param index - If defined and the current value is an array, the value\n * at `index` become the new input.\n * @param info - object to return information about resolution in\n * @param info.cacheable - Will be set to `false` if option is not cacheable.\n * @since 2.7.0\n */ function resolve(inputs, context, index, info) {\n    let cacheable = true;\n    let i, ilen, value;\n    for(i = 0, ilen = inputs.length; i < ilen; ++i){\n        value = inputs[i];\n        if (value === undefined) {\n            continue;\n        }\n        if (context !== undefined && typeof value === 'function') {\n            value = value(context);\n            cacheable = false;\n        }\n        if (index !== undefined && isArray(value)) {\n            value = value[index % value.length];\n            cacheable = false;\n        }\n        if (value !== undefined) {\n            if (info && !cacheable) {\n                info.cacheable = false;\n            }\n            return value;\n        }\n    }\n}\n/**\n * @param minmax\n * @param grace\n * @param beginAtZero\n * @private\n */ function _addGrace(minmax, grace, beginAtZero) {\n    const { min , max  } = minmax;\n    const change = toDimension(grace, (max - min) / 2);\n    const keepZero = (value, add)=>beginAtZero && value === 0 ? 0 : value + add;\n    return {\n        min: keepZero(min, -Math.abs(change)),\n        max: keepZero(max, change)\n    };\n}\nfunction createContext(parentContext, context) {\n    return Object.assign(Object.create(parentContext), context);\n}\n\n/**\n * Creates a Proxy for resolving raw values for options.\n * @param scopes - The option scopes to look for values, in resolution order\n * @param prefixes - The prefixes for values, in resolution order.\n * @param rootScopes - The root option scopes\n * @param fallback - Parent scopes fallback\n * @param getTarget - callback for getting the target for changed values\n * @returns Proxy\n * @private\n */ function _createResolver(scopes, prefixes = [\n    ''\n], rootScopes, fallback, getTarget = ()=>scopes[0]) {\n    const finalRootScopes = rootScopes || scopes;\n    if (typeof fallback === 'undefined') {\n        fallback = _resolve('_fallback', scopes);\n    }\n    const cache = {\n        [Symbol.toStringTag]: 'Object',\n        _cacheable: true,\n        _scopes: scopes,\n        _rootScopes: finalRootScopes,\n        _fallback: fallback,\n        _getTarget: getTarget,\n        override: (scope)=>_createResolver([\n                scope,\n                ...scopes\n            ], prefixes, finalRootScopes, fallback)\n    };\n    return new Proxy(cache, {\n        /**\n     * A trap for the delete operator.\n     */ deleteProperty (target, prop) {\n            delete target[prop]; // remove from cache\n            delete target._keys; // remove cached keys\n            delete scopes[0][prop]; // remove from top level scope\n            return true;\n        },\n        /**\n     * A trap for getting property values.\n     */ get (target, prop) {\n            return _cached(target, prop, ()=>_resolveWithPrefixes(prop, prefixes, scopes, target));\n        },\n        /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */ getOwnPropertyDescriptor (target, prop) {\n            return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n        },\n        /**\n     * A trap for Object.getPrototypeOf.\n     */ getPrototypeOf () {\n            return Reflect.getPrototypeOf(scopes[0]);\n        },\n        /**\n     * A trap for the in operator.\n     */ has (target, prop) {\n            return getKeysFromAllScopes(target).includes(prop);\n        },\n        /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */ ownKeys (target) {\n            return getKeysFromAllScopes(target);\n        },\n        /**\n     * A trap for setting property values.\n     */ set (target, prop, value) {\n            const storage = target._storage || (target._storage = getTarget());\n            target[prop] = storage[prop] = value; // set to top level scope + cache\n            delete target._keys; // remove cached keys\n            return true;\n        }\n    });\n}\n/**\n * Returns an Proxy for resolving option values with context.\n * @param proxy - The Proxy returned by `_createResolver`\n * @param context - Context object for scriptable/indexable options\n * @param subProxy - The proxy provided for scriptable options\n * @param descriptorDefaults - Defaults for descriptors\n * @private\n */ function _attachContext(proxy, context, subProxy, descriptorDefaults) {\n    const cache = {\n        _cacheable: false,\n        _proxy: proxy,\n        _context: context,\n        _subProxy: subProxy,\n        _stack: new Set(),\n        _descriptors: _descriptors(proxy, descriptorDefaults),\n        setContext: (ctx)=>_attachContext(proxy, ctx, subProxy, descriptorDefaults),\n        override: (scope)=>_attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n    };\n    return new Proxy(cache, {\n        /**\n     * A trap for the delete operator.\n     */ deleteProperty (target, prop) {\n            delete target[prop]; // remove from cache\n            delete proxy[prop]; // remove from proxy\n            return true;\n        },\n        /**\n     * A trap for getting property values.\n     */ get (target, prop, receiver) {\n            return _cached(target, prop, ()=>_resolveWithContext(target, prop, receiver));\n        },\n        /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */ getOwnPropertyDescriptor (target, prop) {\n            return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {\n                enumerable: true,\n                configurable: true\n            } : undefined : Reflect.getOwnPropertyDescriptor(proxy, prop);\n        },\n        /**\n     * A trap for Object.getPrototypeOf.\n     */ getPrototypeOf () {\n            return Reflect.getPrototypeOf(proxy);\n        },\n        /**\n     * A trap for the in operator.\n     */ has (target, prop) {\n            return Reflect.has(proxy, prop);\n        },\n        /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */ ownKeys () {\n            return Reflect.ownKeys(proxy);\n        },\n        /**\n     * A trap for setting property values.\n     */ set (target, prop, value) {\n            proxy[prop] = value; // set to proxy\n            delete target[prop]; // remove from cache\n            return true;\n        }\n    });\n}\n/**\n * @private\n */ function _descriptors(proxy, defaults = {\n    scriptable: true,\n    indexable: true\n}) {\n    const { _scriptable =defaults.scriptable , _indexable =defaults.indexable , _allKeys =defaults.allKeys  } = proxy;\n    return {\n        allKeys: _allKeys,\n        scriptable: _scriptable,\n        indexable: _indexable,\n        isScriptable: isFunction(_scriptable) ? _scriptable : ()=>_scriptable,\n        isIndexable: isFunction(_indexable) ? _indexable : ()=>_indexable\n    };\n}\nconst readKey = (prefix, name)=>prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop, value)=>isObject(value) && prop !== 'adapters' && (Object.getPrototypeOf(value) === null || value.constructor === Object);\nfunction _cached(target, prop, resolve) {\n    if (Object.prototype.hasOwnProperty.call(target, prop) || prop === 'constructor') {\n        return target[prop];\n    }\n    const value = resolve();\n    // cache the resolved value\n    target[prop] = value;\n    return value;\n}\nfunction _resolveWithContext(target, prop, receiver) {\n    const { _proxy , _context , _subProxy , _descriptors: descriptors  } = target;\n    let value = _proxy[prop]; // resolve from proxy\n    // resolve with context\n    if (isFunction(value) && descriptors.isScriptable(prop)) {\n        value = _resolveScriptable(prop, value, target, receiver);\n    }\n    if (isArray(value) && value.length) {\n        value = _resolveArray(prop, value, target, descriptors.isIndexable);\n    }\n    if (needsSubResolver(prop, value)) {\n        // if the resolved value is an object, create a sub resolver for it\n        value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n    }\n    return value;\n}\nfunction _resolveScriptable(prop, getValue, target, receiver) {\n    const { _proxy , _context , _subProxy , _stack  } = target;\n    if (_stack.has(prop)) {\n        throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\n    }\n    _stack.add(prop);\n    let value = getValue(_context, _subProxy || receiver);\n    _stack.delete(prop);\n    if (needsSubResolver(prop, value)) {\n        // When scriptable option returns an object, create a resolver on that.\n        value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n    }\n    return value;\n}\nfunction _resolveArray(prop, value, target, isIndexable) {\n    const { _proxy , _context , _subProxy , _descriptors: descriptors  } = target;\n    if (typeof _context.index !== 'undefined' && isIndexable(prop)) {\n        return value[_context.index % value.length];\n    } else if (isObject(value[0])) {\n        // Array of objects, return array or resolvers\n        const arr = value;\n        const scopes = _proxy._scopes.filter((s)=>s !== arr);\n        value = [];\n        for (const item of arr){\n            const resolver = createSubResolver(scopes, _proxy, prop, item);\n            value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n        }\n    }\n    return value;\n}\nfunction resolveFallback(fallback, prop, value) {\n    return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\nconst getScope = (key, parent)=>key === true ? parent : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\nfunction addScopes(set, parentScopes, key, parentFallback, value) {\n    for (const parent of parentScopes){\n        const scope = getScope(key, parent);\n        if (scope) {\n            set.add(scope);\n            const fallback = resolveFallback(scope._fallback, key, value);\n            if (typeof fallback !== 'undefined' && fallback !== key && fallback !== parentFallback) {\n                // When we reach the descriptor that defines a new _fallback, return that.\n                // The fallback will resume to that new scope.\n                return fallback;\n            }\n        } else if (scope === false && typeof parentFallback !== 'undefined' && key !== parentFallback) {\n            // Fallback to `false` results to `false`, when falling back to different key.\n            // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`\n            return null;\n        }\n    }\n    return false;\n}\nfunction createSubResolver(parentScopes, resolver, prop, value) {\n    const rootScopes = resolver._rootScopes;\n    const fallback = resolveFallback(resolver._fallback, prop, value);\n    const allScopes = [\n        ...parentScopes,\n        ...rootScopes\n    ];\n    const set = new Set();\n    set.add(value);\n    let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n    if (key === null) {\n        return false;\n    }\n    if (typeof fallback !== 'undefined' && fallback !== prop) {\n        key = addScopesFromKey(set, allScopes, fallback, key, value);\n        if (key === null) {\n            return false;\n        }\n    }\n    return _createResolver(Array.from(set), [\n        ''\n    ], rootScopes, fallback, ()=>subGetTarget(resolver, prop, value));\n}\nfunction addScopesFromKey(set, allScopes, key, fallback, item) {\n    while(key){\n        key = addScopes(set, allScopes, key, fallback, item);\n    }\n    return key;\n}\nfunction subGetTarget(resolver, prop, value) {\n    const parent = resolver._getTarget();\n    if (!(prop in parent)) {\n        parent[prop] = {};\n    }\n    const target = parent[prop];\n    if (isArray(target) && isObject(value)) {\n        // For array of objects, the object is used to store updated values\n        return value;\n    }\n    return target || {};\n}\nfunction _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\n    let value;\n    for (const prefix of prefixes){\n        value = _resolve(readKey(prefix, prop), scopes);\n        if (typeof value !== 'undefined') {\n            return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;\n        }\n    }\n}\nfunction _resolve(key, scopes) {\n    for (const scope of scopes){\n        if (!scope) {\n            continue;\n        }\n        const value = scope[key];\n        if (typeof value !== 'undefined') {\n            return value;\n        }\n    }\n}\nfunction getKeysFromAllScopes(target) {\n    let keys = target._keys;\n    if (!keys) {\n        keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n    }\n    return keys;\n}\nfunction resolveKeysFromAllScopes(scopes) {\n    const set = new Set();\n    for (const scope of scopes){\n        for (const key of Object.keys(scope).filter((k)=>!k.startsWith('_'))){\n            set.add(key);\n        }\n    }\n    return Array.from(set);\n}\nfunction _parseObjectDataRadialScale(meta, data, start, count) {\n    const { iScale  } = meta;\n    const { key ='r'  } = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n    for(i = 0, ilen = count; i < ilen; ++i){\n        index = i + start;\n        item = data[index];\n        parsed[i] = {\n            r: iScale.parse(resolveObjectKey(item, key), index)\n        };\n    }\n    return parsed;\n}\n\nconst EPSILON = Number.EPSILON || 1e-14;\nconst getPoint = (points, i)=>i < points.length && !points[i].skip && points[i];\nconst getValueAxis = (indexAxis)=>indexAxis === 'x' ? 'y' : 'x';\nfunction splineCurve(firstPoint, middlePoint, afterPoint, t) {\n    // Props to Rob Spencer at scaled innovation for his post on splining between points\n    // http://scaledinnovation.com/analytics/splines/aboutSplines.html\n    // This function must also respect \"skipped\" points\n    const previous = firstPoint.skip ? middlePoint : firstPoint;\n    const current = middlePoint;\n    const next = afterPoint.skip ? middlePoint : afterPoint;\n    const d01 = distanceBetweenPoints(current, previous);\n    const d12 = distanceBetweenPoints(next, current);\n    let s01 = d01 / (d01 + d12);\n    let s12 = d12 / (d01 + d12);\n    // If all points are the same, s01 & s02 will be inf\n    s01 = isNaN(s01) ? 0 : s01;\n    s12 = isNaN(s12) ? 0 : s12;\n    const fa = t * s01; // scaling factor for triangle Ta\n    const fb = t * s12;\n    return {\n        previous: {\n            x: current.x - fa * (next.x - previous.x),\n            y: current.y - fa * (next.y - previous.y)\n        },\n        next: {\n            x: current.x + fb * (next.x - previous.x),\n            y: current.y + fb * (next.y - previous.y)\n        }\n    };\n}\n/**\n * Adjust tangents to ensure monotonic properties\n */ function monotoneAdjust(points, deltaK, mK) {\n    const pointsLen = points.length;\n    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(let i = 0; i < pointsLen - 1; ++i){\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent || !pointAfter) {\n            continue;\n        }\n        if (almostEquals(deltaK[i], 0, EPSILON)) {\n            mK[i] = mK[i + 1] = 0;\n            continue;\n        }\n        alphaK = mK[i] / deltaK[i];\n        betaK = mK[i + 1] / deltaK[i];\n        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n        if (squaredMagnitude <= 9) {\n            continue;\n        }\n        tauK = 3 / Math.sqrt(squaredMagnitude);\n        mK[i] = alphaK * tauK * deltaK[i];\n        mK[i + 1] = betaK * tauK * deltaK[i];\n    }\n}\nfunction monotoneCompute(points, mK, indexAxis = 'x') {\n    const valueAxis = getValueAxis(indexAxis);\n    const pointsLen = points.length;\n    let delta, pointBefore, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(let i = 0; i < pointsLen; ++i){\n        pointBefore = pointCurrent;\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent) {\n            continue;\n        }\n        const iPixel = pointCurrent[indexAxis];\n        const vPixel = pointCurrent[valueAxis];\n        if (pointBefore) {\n            delta = (iPixel - pointBefore[indexAxis]) / 3;\n            pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n            pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n        }\n        if (pointAfter) {\n            delta = (pointAfter[indexAxis] - iPixel) / 3;\n            pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n            pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n        }\n    }\n}\n/**\n * This function calculates Bézier control points in a similar way than |splineCurve|,\n * but preserves monotonicity of the provided data and ensures no local extremums are added\n * between the dataset discrete points due to the interpolation.\n * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n */ function splineCurveMonotone(points, indexAxis = 'x') {\n    const valueAxis = getValueAxis(indexAxis);\n    const pointsLen = points.length;\n    const deltaK = Array(pointsLen).fill(0);\n    const mK = Array(pointsLen);\n    // Calculate slopes (deltaK) and initialize tangents (mK)\n    let i, pointBefore, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(i = 0; i < pointsLen; ++i){\n        pointBefore = pointCurrent;\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent) {\n            continue;\n        }\n        if (pointAfter) {\n            const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n            // In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n            deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n        }\n        mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;\n    }\n    monotoneAdjust(points, deltaK, mK);\n    monotoneCompute(points, mK, indexAxis);\n}\nfunction capControlPoint(pt, min, max) {\n    return Math.max(Math.min(pt, max), min);\n}\nfunction capBezierPoints(points, area) {\n    let i, ilen, point, inArea, inAreaPrev;\n    let inAreaNext = _isPointInArea(points[0], area);\n    for(i = 0, ilen = points.length; i < ilen; ++i){\n        inAreaPrev = inArea;\n        inArea = inAreaNext;\n        inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n        if (!inArea) {\n            continue;\n        }\n        point = points[i];\n        if (inAreaPrev) {\n            point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n            point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n        }\n        if (inAreaNext) {\n            point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n            point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n        }\n    }\n}\n/**\n * @private\n */ function _updateBezierControlPoints(points, options, area, loop, indexAxis) {\n    let i, ilen, point, controlPoints;\n    // Only consider points that are drawn in case the spanGaps option is used\n    if (options.spanGaps) {\n        points = points.filter((pt)=>!pt.skip);\n    }\n    if (options.cubicInterpolationMode === 'monotone') {\n        splineCurveMonotone(points, indexAxis);\n    } else {\n        let prev = loop ? points[points.length - 1] : points[0];\n        for(i = 0, ilen = points.length; i < ilen; ++i){\n            point = points[i];\n            controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);\n            point.cp1x = controlPoints.previous.x;\n            point.cp1y = controlPoints.previous.y;\n            point.cp2x = controlPoints.next.x;\n            point.cp2y = controlPoints.next.y;\n            prev = point;\n        }\n    }\n    if (options.capBezierPoints) {\n        capBezierPoints(points, area);\n    }\n}\n\n/**\n * @private\n */ function _isDomSupported() {\n    return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n/**\n * @private\n */ function _getParentNode(domNode) {\n    let parent = domNode.parentNode;\n    if (parent && parent.toString() === '[object ShadowRoot]') {\n        parent = parent.host;\n    }\n    return parent;\n}\n/**\n * convert max-width/max-height values that may be percentages into a number\n * @private\n */ function parseMaxStyle(styleValue, node, parentProperty) {\n    let valueInPixels;\n    if (typeof styleValue === 'string') {\n        valueInPixels = parseInt(styleValue, 10);\n        if (styleValue.indexOf('%') !== -1) {\n            // percentage * size in dimension\n            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n        }\n    } else {\n        valueInPixels = styleValue;\n    }\n    return valueInPixels;\n}\nconst getComputedStyle = (element)=>element.ownerDocument.defaultView.getComputedStyle(element, null);\nfunction getStyle(el, property) {\n    return getComputedStyle(el).getPropertyValue(property);\n}\nconst positions = [\n    'top',\n    'right',\n    'bottom',\n    'left'\n];\nfunction getPositionedStyle(styles, style, suffix) {\n    const result = {};\n    suffix = suffix ? '-' + suffix : '';\n    for(let i = 0; i < 4; i++){\n        const pos = positions[i];\n        result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n    }\n    result.width = result.left + result.right;\n    result.height = result.top + result.bottom;\n    return result;\n}\nconst useOffsetPos = (x, y, target)=>(x > 0 || y > 0) && (!target || !target.shadowRoot);\n/**\n * @param e\n * @param canvas\n * @returns Canvas position\n */ function getCanvasPosition(e, canvas) {\n    const touches = e.touches;\n    const source = touches && touches.length ? touches[0] : e;\n    const { offsetX , offsetY  } = source;\n    let box = false;\n    let x, y;\n    if (useOffsetPos(offsetX, offsetY, e.target)) {\n        x = offsetX;\n        y = offsetY;\n    } else {\n        const rect = canvas.getBoundingClientRect();\n        x = source.clientX - rect.left;\n        y = source.clientY - rect.top;\n        box = true;\n    }\n    return {\n        x,\n        y,\n        box\n    };\n}\n/**\n * Gets an event's x, y coordinates, relative to the chart area\n * @param event\n * @param chart\n * @returns x and y coordinates of the event\n */ function getRelativePosition(event, chart) {\n    if ('native' in event) {\n        return event;\n    }\n    const { canvas , currentDevicePixelRatio  } = chart;\n    const style = getComputedStyle(canvas);\n    const borderBox = style.boxSizing === 'border-box';\n    const paddings = getPositionedStyle(style, 'padding');\n    const borders = getPositionedStyle(style, 'border', 'width');\n    const { x , y , box  } = getCanvasPosition(event, canvas);\n    const xOffset = paddings.left + (box && borders.left);\n    const yOffset = paddings.top + (box && borders.top);\n    let { width , height  } = chart;\n    if (borderBox) {\n        width -= paddings.width + borders.width;\n        height -= paddings.height + borders.height;\n    }\n    return {\n        x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n        y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n    };\n}\nfunction getContainerSize(canvas, width, height) {\n    let maxWidth, maxHeight;\n    if (width === undefined || height === undefined) {\n        const container = canvas && _getParentNode(canvas);\n        if (!container) {\n            width = canvas.clientWidth;\n            height = canvas.clientHeight;\n        } else {\n            const rect = container.getBoundingClientRect(); // this is the border box of the container\n            const containerStyle = getComputedStyle(container);\n            const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n            const containerPadding = getPositionedStyle(containerStyle, 'padding');\n            width = rect.width - containerPadding.width - containerBorder.width;\n            height = rect.height - containerPadding.height - containerBorder.height;\n            maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n            maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n        }\n    }\n    return {\n        width,\n        height,\n        maxWidth: maxWidth || INFINITY,\n        maxHeight: maxHeight || INFINITY\n    };\n}\nconst round1 = (v)=>Math.round(v * 10) / 10;\n// eslint-disable-next-line complexity\nfunction getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {\n    const style = getComputedStyle(canvas);\n    const margins = getPositionedStyle(style, 'margin');\n    const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\n    const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\n    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n    let { width , height  } = containerSize;\n    if (style.boxSizing === 'content-box') {\n        const borders = getPositionedStyle(style, 'border', 'width');\n        const paddings = getPositionedStyle(style, 'padding');\n        width -= paddings.width + borders.width;\n        height -= paddings.height + borders.height;\n    }\n    width = Math.max(0, width - margins.width);\n    height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);\n    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n    if (width && !height) {\n        // https://github.com/chartjs/Chart.js/issues/4659\n        // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)\n        height = round1(width / 2);\n    }\n    const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;\n    if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {\n        height = containerSize.height;\n        width = round1(Math.floor(height * aspectRatio));\n    }\n    return {\n        width,\n        height\n    };\n}\n/**\n * @param chart\n * @param forceRatio\n * @param forceStyle\n * @returns True if the canvas context size or transformation has changed.\n */ function retinaScale(chart, forceRatio, forceStyle) {\n    const pixelRatio = forceRatio || 1;\n    const deviceHeight = Math.floor(chart.height * pixelRatio);\n    const deviceWidth = Math.floor(chart.width * pixelRatio);\n    chart.height = Math.floor(chart.height);\n    chart.width = Math.floor(chart.width);\n    const canvas = chart.canvas;\n    // If no style has been set on the canvas, the render size is used as display size,\n    // making the chart visually bigger, so let's enforce it to the \"correct\" values.\n    // See https://github.com/chartjs/Chart.js/issues/3575\n    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {\n        canvas.style.height = `${chart.height}px`;\n        canvas.style.width = `${chart.width}px`;\n    }\n    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {\n        chart.currentDevicePixelRatio = pixelRatio;\n        canvas.height = deviceHeight;\n        canvas.width = deviceWidth;\n        chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n        return true;\n    }\n    return false;\n}\n/**\n * Detects support for options object argument in addEventListener.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n * @private\n */ const supportsEventListenerOptions = function() {\n    let passiveSupported = false;\n    try {\n        const options = {\n            get passive () {\n                passiveSupported = true;\n                return false;\n            }\n        };\n        if (_isDomSupported()) {\n            window.addEventListener('test', null, options);\n            window.removeEventListener('test', null, options);\n        }\n    } catch (e) {\n    // continue regardless of error\n    }\n    return passiveSupported;\n}();\n/**\n * The \"used\" size is the final value of a dimension property after all calculations have\n * been performed. This method uses the computed style of `element` but returns undefined\n * if the computed style is not expressed in pixels. That can happen in some cases where\n * `element` has a size relative to its parent and this last one is not yet displayed,\n * for example because of `display: none` on a parent node.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n * @returns Size in pixels or undefined if unknown.\n */ function readUsedSize(element, property) {\n    const value = getStyle(element, property);\n    const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n    return matches ? +matches[1] : undefined;\n}\n\n/**\n * @private\n */ function _pointInLine(p1, p2, t, mode) {\n    return {\n        x: p1.x + t * (p2.x - p1.x),\n        y: p1.y + t * (p2.y - p1.y)\n    };\n}\n/**\n * @private\n */ function _steppedInterpolation(p1, p2, t, mode) {\n    return {\n        x: p1.x + t * (p2.x - p1.x),\n        y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y : mode === 'after' ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y\n    };\n}\n/**\n * @private\n */ function _bezierInterpolation(p1, p2, t, mode) {\n    const cp1 = {\n        x: p1.cp2x,\n        y: p1.cp2y\n    };\n    const cp2 = {\n        x: p2.cp1x,\n        y: p2.cp1y\n    };\n    const a = _pointInLine(p1, cp1, t);\n    const b = _pointInLine(cp1, cp2, t);\n    const c = _pointInLine(cp2, p2, t);\n    const d = _pointInLine(a, b, t);\n    const e = _pointInLine(b, c, t);\n    return _pointInLine(d, e, t);\n}\n\nconst getRightToLeftAdapter = function(rectX, width) {\n    return {\n        x (x) {\n            return rectX + rectX + width - x;\n        },\n        setWidth (w) {\n            width = w;\n        },\n        textAlign (align) {\n            if (align === 'center') {\n                return align;\n            }\n            return align === 'right' ? 'left' : 'right';\n        },\n        xPlus (x, value) {\n            return x - value;\n        },\n        leftForLtr (x, itemWidth) {\n            return x - itemWidth;\n        }\n    };\n};\nconst getLeftToRightAdapter = function() {\n    return {\n        x (x) {\n            return x;\n        },\n        setWidth (w) {},\n        textAlign (align) {\n            return align;\n        },\n        xPlus (x, value) {\n            return x + value;\n        },\n        leftForLtr (x, _itemWidth) {\n            return x;\n        }\n    };\n};\nfunction getRtlAdapter(rtl, rectX, width) {\n    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\nfunction overrideTextDirection(ctx, direction) {\n    let style, original;\n    if (direction === 'ltr' || direction === 'rtl') {\n        style = ctx.canvas.style;\n        original = [\n            style.getPropertyValue('direction'),\n            style.getPropertyPriority('direction')\n        ];\n        style.setProperty('direction', direction, 'important');\n        ctx.prevTextDirection = original;\n    }\n}\nfunction restoreTextDirection(ctx, original) {\n    if (original !== undefined) {\n        delete ctx.prevTextDirection;\n        ctx.canvas.style.setProperty('direction', original[0], original[1]);\n    }\n}\n\nfunction propertyFn(property) {\n    if (property === 'angle') {\n        return {\n            between: _angleBetween,\n            compare: _angleDiff,\n            normalize: _normalizeAngle\n        };\n    }\n    return {\n        between: _isBetween,\n        compare: (a, b)=>a - b,\n        normalize: (x)=>x\n    };\n}\nfunction normalizeSegment({ start , end , count , loop , style  }) {\n    return {\n        start: start % count,\n        end: end % count,\n        loop: loop && (end - start + 1) % count === 0,\n        style\n    };\n}\nfunction getSegment(segment, points, bounds) {\n    const { property , start: startBound , end: endBound  } = bounds;\n    const { between , normalize  } = propertyFn(property);\n    const count = points.length;\n    let { start , end , loop  } = segment;\n    let i, ilen;\n    if (loop) {\n        start += count;\n        end += count;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n                break;\n            }\n            start--;\n            end--;\n        }\n        start %= count;\n        end %= count;\n    }\n    if (end < start) {\n        end += count;\n    }\n    return {\n        start,\n        end,\n        loop,\n        style: segment.style\n    };\n}\n function _boundSegment(segment, points, bounds) {\n    if (!bounds) {\n        return [\n            segment\n        ];\n    }\n    const { property , start: startBound , end: endBound  } = bounds;\n    const count = points.length;\n    const { compare , between , normalize  } = propertyFn(property);\n    const { start , end , loop , style  } = getSegment(segment, points, bounds);\n    const result = [];\n    let inside = false;\n    let subStart = null;\n    let value, point, prevValue;\n    const startIsBefore = ()=>between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n    const endIsBefore = ()=>compare(endBound, value) === 0 || between(endBound, prevValue, value);\n    const shouldStart = ()=>inside || startIsBefore();\n    const shouldStop = ()=>!inside || endIsBefore();\n    for(let i = start, prev = start; i <= end; ++i){\n        point = points[i % count];\n        if (point.skip) {\n            continue;\n        }\n        value = normalize(point[property]);\n        if (value === prevValue) {\n            continue;\n        }\n        inside = between(value, startBound, endBound);\n        if (subStart === null && shouldStart()) {\n            subStart = compare(value, startBound) === 0 ? i : prev;\n        }\n        if (subStart !== null && shouldStop()) {\n            result.push(normalizeSegment({\n                start: subStart,\n                end: i,\n                loop,\n                count,\n                style\n            }));\n            subStart = null;\n        }\n        prev = i;\n        prevValue = value;\n    }\n    if (subStart !== null) {\n        result.push(normalizeSegment({\n            start: subStart,\n            end,\n            loop,\n            count,\n            style\n        }));\n    }\n    return result;\n}\n function _boundSegments(line, bounds) {\n    const result = [];\n    const segments = line.segments;\n    for(let i = 0; i < segments.length; i++){\n        const sub = _boundSegment(segments[i], line.points, bounds);\n        if (sub.length) {\n            result.push(...sub);\n        }\n    }\n    return result;\n}\n function findStartAndEnd(points, count, loop, spanGaps) {\n    let start = 0;\n    let end = count - 1;\n    if (loop && !spanGaps) {\n        while(start < count && !points[start].skip){\n            start++;\n        }\n    }\n    while(start < count && points[start].skip){\n        start++;\n    }\n    start %= count;\n    if (loop) {\n        end += start;\n    }\n    while(end > start && points[end % count].skip){\n        end--;\n    }\n    end %= count;\n    return {\n        start,\n        end\n    };\n}\n function solidSegments(points, start, max, loop) {\n    const count = points.length;\n    const result = [];\n    let last = start;\n    let prev = points[start];\n    let end;\n    for(end = start + 1; end <= max; ++end){\n        const cur = points[end % count];\n        if (cur.skip || cur.stop) {\n            if (!prev.skip) {\n                loop = false;\n                result.push({\n                    start: start % count,\n                    end: (end - 1) % count,\n                    loop\n                });\n                start = last = cur.stop ? end : null;\n            }\n        } else {\n            last = end;\n            if (prev.skip) {\n                start = end;\n            }\n        }\n        prev = cur;\n    }\n    if (last !== null) {\n        result.push({\n            start: start % count,\n            end: last % count,\n            loop\n        });\n    }\n    return result;\n}\n function _computeSegments(line, segmentOptions) {\n    const points = line.points;\n    const spanGaps = line.options.spanGaps;\n    const count = points.length;\n    if (!count) {\n        return [];\n    }\n    const loop = !!line._loop;\n    const { start , end  } = findStartAndEnd(points, count, loop, spanGaps);\n    if (spanGaps === true) {\n        return splitByStyles(line, [\n            {\n                start,\n                end,\n                loop\n            }\n        ], points, segmentOptions);\n    }\n    const max = end < start ? end + count : end;\n    const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n    return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\n function splitByStyles(line, segments, points, segmentOptions) {\n    if (!segmentOptions || !segmentOptions.setContext || !points) {\n        return segments;\n    }\n    return doSplitByStyles(line, segments, points, segmentOptions);\n}\n function doSplitByStyles(line, segments, points, segmentOptions) {\n    const chartContext = line._chart.getContext();\n    const baseStyle = readStyle(line.options);\n    const { _datasetIndex: datasetIndex , options: { spanGaps  }  } = line;\n    const count = points.length;\n    const result = [];\n    let prevStyle = baseStyle;\n    let start = segments[0].start;\n    let i = start;\n    function addStyle(s, e, l, st) {\n        const dir = spanGaps ? -1 : 1;\n        if (s === e) {\n            return;\n        }\n        s += count;\n        while(points[s % count].skip){\n            s -= dir;\n        }\n        while(points[e % count].skip){\n            e += dir;\n        }\n        if (s % count !== e % count) {\n            result.push({\n                start: s % count,\n                end: e % count,\n                loop: l,\n                style: st\n            });\n            prevStyle = st;\n            start = e % count;\n        }\n    }\n    for (const segment of segments){\n        start = spanGaps ? start : segment.start;\n        let prev = points[start % count];\n        let style;\n        for(i = start + 1; i <= segment.end; i++){\n            const pt = points[i % count];\n            style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n                type: 'segment',\n                p0: prev,\n                p1: pt,\n                p0DataIndex: (i - 1) % count,\n                p1DataIndex: i % count,\n                datasetIndex\n            })));\n            if (styleChanged(style, prevStyle)) {\n                addStyle(start, i - 1, segment.loop, prevStyle);\n            }\n            prev = pt;\n            prevStyle = style;\n        }\n        if (start < i - 1) {\n            addStyle(start, i - 1, segment.loop, prevStyle);\n        }\n    }\n    return result;\n}\nfunction readStyle(options) {\n    return {\n        backgroundColor: options.backgroundColor,\n        borderCapStyle: options.borderCapStyle,\n        borderDash: options.borderDash,\n        borderDashOffset: options.borderDashOffset,\n        borderJoinStyle: options.borderJoinStyle,\n        borderWidth: options.borderWidth,\n        borderColor: options.borderColor\n    };\n}\nfunction styleChanged(style, prevStyle) {\n    if (!prevStyle) {\n        return false;\n    }\n    const cache = [];\n    const replacer = function(key, value) {\n        if (!isPatternOrGradient(value)) {\n            return value;\n        }\n        if (!cache.includes(value)) {\n            cache.push(value);\n        }\n        return cache.indexOf(value);\n    };\n    return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);\n}\n\nfunction getSizeForArea(scale, chartArea, field) {\n    return scale.options.clip ? scale[field] : chartArea[field];\n}\nfunction getDatasetArea(meta, chartArea) {\n    const { xScale , yScale  } = meta;\n    if (xScale && yScale) {\n        return {\n            left: getSizeForArea(xScale, chartArea, 'left'),\n            right: getSizeForArea(xScale, chartArea, 'right'),\n            top: getSizeForArea(yScale, chartArea, 'top'),\n            bottom: getSizeForArea(yScale, chartArea, 'bottom')\n        };\n    }\n    return chartArea;\n}\nfunction getDatasetClipArea(chart, meta) {\n    const clip = meta._clip;\n    if (clip.disabled) {\n        return false;\n    }\n    const area = getDatasetArea(meta, chart.chartArea);\n    return {\n        left: clip.left === false ? 0 : area.left - (clip.left === true ? 0 : clip.left),\n        right: clip.right === false ? chart.width : area.right + (clip.right === true ? 0 : clip.right),\n        top: clip.top === false ? 0 : area.top - (clip.top === true ? 0 : clip.top),\n        bottom: clip.bottom === false ? chart.height : area.bottom + (clip.bottom === true ? 0 : clip.bottom)\n    };\n}\n\nexports.HALF_PI = HALF_PI;\nexports.INFINITY = INFINITY;\nexports.PI = PI;\nexports.PITAU = PITAU;\nexports.QUARTER_PI = QUARTER_PI;\nexports.RAD_PER_DEG = RAD_PER_DEG;\nexports.TAU = TAU;\nexports.TWO_THIRDS_PI = TWO_THIRDS_PI;\nexports.Ticks = Ticks;\nexports._addGrace = _addGrace;\nexports._alignPixel = _alignPixel;\nexports._alignStartEnd = _alignStartEnd;\nexports._angleBetween = _angleBetween;\nexports._angleDiff = _angleDiff;\nexports._arrayUnique = _arrayUnique;\nexports._attachContext = _attachContext;\nexports._bezierCurveTo = _bezierCurveTo;\nexports._bezierInterpolation = _bezierInterpolation;\nexports._boundSegment = _boundSegment;\nexports._boundSegments = _boundSegments;\nexports._capitalize = _capitalize;\nexports._computeSegments = _computeSegments;\nexports._createResolver = _createResolver;\nexports._decimalPlaces = _decimalPlaces;\nexports._deprecated = _deprecated;\nexports._descriptors = _descriptors;\nexports._elementsEqual = _elementsEqual;\nexports._factorize = _factorize;\nexports._filterBetween = _filterBetween;\nexports._getParentNode = _getParentNode;\nexports._getStartAndCountOfVisiblePoints = _getStartAndCountOfVisiblePoints;\nexports._int16Range = _int16Range;\nexports._isBetween = _isBetween;\nexports._isClickEvent = _isClickEvent;\nexports._isDomSupported = _isDomSupported;\nexports._isPointInArea = _isPointInArea;\nexports._limitValue = _limitValue;\nexports._longestText = _longestText;\nexports._lookup = _lookup;\nexports._lookupByKey = _lookupByKey;\nexports._measureText = _measureText;\nexports._merger = _merger;\nexports._mergerIf = _mergerIf;\nexports._normalizeAngle = _normalizeAngle;\nexports._parseObjectDataRadialScale = _parseObjectDataRadialScale;\nexports._pointInLine = _pointInLine;\nexports._readValueToProps = _readValueToProps;\nexports._rlookupByKey = _rlookupByKey;\nexports._scaleRangesChanged = _scaleRangesChanged;\nexports._setMinAndMaxByKey = _setMinAndMaxByKey;\nexports._splitKey = _splitKey;\nexports._steppedInterpolation = _steppedInterpolation;\nexports._steppedLineTo = _steppedLineTo;\nexports._textX = _textX;\nexports._toLeftRightCenter = _toLeftRightCenter;\nexports._updateBezierControlPoints = _updateBezierControlPoints;\nexports.addRoundedRectPath = addRoundedRectPath;\nexports.almostEquals = almostEquals;\nexports.almostWhole = almostWhole;\nexports.callback = callback;\nexports.clearCanvas = clearCanvas;\nexports.clipArea = clipArea;\nexports.clone = clone;\nexports.color = color;\nexports.createContext = createContext;\nexports.debounce = debounce;\nexports.defaults = defaults;\nexports.defined = defined;\nexports.descriptors = descriptors;\nexports.distanceBetweenPoints = distanceBetweenPoints;\nexports.drawPoint = drawPoint;\nexports.drawPointLegend = drawPointLegend;\nexports.each = each;\nexports.effects = effects;\nexports.finiteOrDefault = finiteOrDefault;\nexports.fontString = fontString;\nexports.formatNumber = formatNumber;\nexports.getAngleFromPoint = getAngleFromPoint;\nexports.getDatasetClipArea = getDatasetClipArea;\nexports.getHoverColor = getHoverColor;\nexports.getMaximumSize = getMaximumSize;\nexports.getRelativePosition = getRelativePosition;\nexports.getRtlAdapter = getRtlAdapter;\nexports.getStyle = getStyle;\nexports.isArray = isArray;\nexports.isFunction = isFunction;\nexports.isNullOrUndef = isNullOrUndef;\nexports.isNumber = isNumber;\nexports.isNumberFinite = isNumberFinite;\nexports.isObject = isObject;\nexports.isPatternOrGradient = isPatternOrGradient;\nexports.listenArrayEvents = listenArrayEvents;\nexports.log10 = log10;\nexports.merge = merge;\nexports.mergeIf = mergeIf;\nexports.niceNum = niceNum;\nexports.noop = noop;\nexports.overrideTextDirection = overrideTextDirection;\nexports.overrides = overrides;\nexports.readUsedSize = readUsedSize;\nexports.renderText = renderText;\nexports.requestAnimFrame = requestAnimFrame;\nexports.resolve = resolve;\nexports.resolveObjectKey = resolveObjectKey;\nexports.restoreTextDirection = restoreTextDirection;\nexports.retinaScale = retinaScale;\nexports.setsEqual = setsEqual;\nexports.sign = sign;\nexports.splineCurve = splineCurve;\nexports.splineCurveMonotone = splineCurveMonotone;\nexports.supportsEventListenerOptions = supportsEventListenerOptions;\nexports.throttled = throttled;\nexports.toDegrees = toDegrees;\nexports.toDimension = toDimension;\nexports.toFont = toFont;\nexports.toFontString = toFontString;\nexports.toLineHeight = toLineHeight;\nexports.toPadding = toPadding;\nexports.toPercentage = toPercentage;\nexports.toRadians = toRadians;\nexports.toTRBL = toTRBL;\nexports.toTRBLCorners = toTRBLCorners;\nexports.uid = uid;\nexports.unclipArea = unclipArea;\nexports.unlistenArrayEvents = unlistenArrayEvents;\nexports.valueOrDefault = valueOrDefault;\n//# sourceMappingURL=helpers.dataset.cjs.map\n\n\n//# sourceURL=webpack://qasm-quantum-simulator/./node_modules/chart.js/dist/chunks/helpers.dataset.cjs?\n}");

/***/ }),

/***/ "./node_modules/path/path.js":
/*!***********************************!*\
  !*** ./node_modules/path/path.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("{// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n\r\n\r\nvar isWindows = process.platform === 'win32';\r\nvar util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\r\n\r\n\r\n// resolves . and .. elements in a path array with directory names there\r\n// must be no slashes or device names (c:\\) in the array\r\n// (so also no leading and trailing slashes - it does not distinguish\r\n// relative and absolute paths)\r\nfunction normalizeArray(parts, allowAboveRoot) {\r\n  var res = [];\r\n  for (var i = 0; i < parts.length; i++) {\r\n    var p = parts[i];\r\n\r\n    // ignore empty parts\r\n    if (!p || p === '.')\r\n      continue;\r\n\r\n    if (p === '..') {\r\n      if (res.length && res[res.length - 1] !== '..') {\r\n        res.pop();\r\n      } else if (allowAboveRoot) {\r\n        res.push('..');\r\n      }\r\n    } else {\r\n      res.push(p);\r\n    }\r\n  }\r\n\r\n  return res;\r\n}\r\n\r\n// returns an array with empty elements removed from either end of the input\r\n// array or the original array if no elements need to be removed\r\nfunction trimArray(arr) {\r\n  var lastIndex = arr.length - 1;\r\n  var start = 0;\r\n  for (; start <= lastIndex; start++) {\r\n    if (arr[start])\r\n      break;\r\n  }\r\n\r\n  var end = lastIndex;\r\n  for (; end >= 0; end--) {\r\n    if (arr[end])\r\n      break;\r\n  }\r\n\r\n  if (start === 0 && end === lastIndex)\r\n    return arr;\r\n  if (start > end)\r\n    return [];\r\n  return arr.slice(start, end + 1);\r\n}\r\n\r\n// Regex to split a windows path into three parts: [*, device, slash,\r\n// tail] windows-only\r\nvar splitDeviceRe =\r\n    /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\r\n\r\n// Regex to split the tail part of the above into [*, dir, basename, ext]\r\nvar splitTailRe =\r\n    /^([\\s\\S]*?)((?:\\.{1,2}|[^\\\\\\/]+?|)(\\.[^.\\/\\\\]*|))(?:[\\\\\\/]*)$/;\r\n\r\nvar win32 = {};\r\n\r\n// Function to split a filename into [root, dir, basename, ext]\r\nfunction win32SplitPath(filename) {\r\n  // Separate device+slash from tail\r\n  var result = splitDeviceRe.exec(filename),\r\n      device = (result[1] || '') + (result[2] || ''),\r\n      tail = result[3] || '';\r\n  // Split the tail into dir, basename and extension\r\n  var result2 = splitTailRe.exec(tail),\r\n      dir = result2[1],\r\n      basename = result2[2],\r\n      ext = result2[3];\r\n  return [device, dir, basename, ext];\r\n}\r\n\r\nfunction win32StatPath(path) {\r\n  var result = splitDeviceRe.exec(path),\r\n      device = result[1] || '',\r\n      isUnc = !!device && device[1] !== ':';\r\n  return {\r\n    device: device,\r\n    isUnc: isUnc,\r\n    isAbsolute: isUnc || !!result[2], // UNC paths are always absolute\r\n    tail: result[3]\r\n  };\r\n}\r\n\r\nfunction normalizeUNCRoot(device) {\r\n  return '\\\\\\\\' + device.replace(/^[\\\\\\/]+/, '').replace(/[\\\\\\/]+/g, '\\\\');\r\n}\r\n\r\n// path.resolve([from ...], to)\r\nwin32.resolve = function() {\r\n  var resolvedDevice = '',\r\n      resolvedTail = '',\r\n      resolvedAbsolute = false;\r\n\r\n  for (var i = arguments.length - 1; i >= -1; i--) {\r\n    var path;\r\n    if (i >= 0) {\r\n      path = arguments[i];\r\n    } else if (!resolvedDevice) {\r\n      path = process.cwd();\r\n    } else {\r\n      // Windows has the concept of drive-specific current working\r\n      // directories. If we've resolved a drive letter but not yet an\r\n      // absolute path, get cwd for that drive. We're sure the device is not\r\n      // an unc path at this points, because unc paths are always absolute.\r\n      path = process.env['=' + resolvedDevice];\r\n      // Verify that a drive-local cwd was found and that it actually points\r\n      // to our drive. If not, default to the drive's root.\r\n      if (!path || path.substr(0, 3).toLowerCase() !==\r\n          resolvedDevice.toLowerCase() + '\\\\') {\r\n        path = resolvedDevice + '\\\\';\r\n      }\r\n    }\r\n\r\n    // Skip empty and invalid entries\r\n    if (!util.isString(path)) {\r\n      throw new TypeError('Arguments to path.resolve must be strings');\r\n    } else if (!path) {\r\n      continue;\r\n    }\r\n\r\n    var result = win32StatPath(path),\r\n        device = result.device,\r\n        isUnc = result.isUnc,\r\n        isAbsolute = result.isAbsolute,\r\n        tail = result.tail;\r\n\r\n    if (device &&\r\n        resolvedDevice &&\r\n        device.toLowerCase() !== resolvedDevice.toLowerCase()) {\r\n      // This path points to another device so it is not applicable\r\n      continue;\r\n    }\r\n\r\n    if (!resolvedDevice) {\r\n      resolvedDevice = device;\r\n    }\r\n    if (!resolvedAbsolute) {\r\n      resolvedTail = tail + '\\\\' + resolvedTail;\r\n      resolvedAbsolute = isAbsolute;\r\n    }\r\n\r\n    if (resolvedDevice && resolvedAbsolute) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  // Convert slashes to backslashes when `resolvedDevice` points to an UNC\r\n  // root. Also squash multiple slashes into a single one where appropriate.\r\n  if (isUnc) {\r\n    resolvedDevice = normalizeUNCRoot(resolvedDevice);\r\n  }\r\n\r\n  // At this point the path should be resolved to a full absolute path,\r\n  // but handle relative paths to be safe (might happen when process.cwd()\r\n  // fails)\r\n\r\n  // Normalize the tail path\r\n  resolvedTail = normalizeArray(resolvedTail.split(/[\\\\\\/]+/),\r\n                                !resolvedAbsolute).join('\\\\');\r\n\r\n  return (resolvedDevice + (resolvedAbsolute ? '\\\\' : '') + resolvedTail) ||\r\n         '.';\r\n};\r\n\r\n\r\nwin32.normalize = function(path) {\r\n  var result = win32StatPath(path),\r\n      device = result.device,\r\n      isUnc = result.isUnc,\r\n      isAbsolute = result.isAbsolute,\r\n      tail = result.tail,\r\n      trailingSlash = /[\\\\\\/]$/.test(tail);\r\n\r\n  // Normalize the tail path\r\n  tail = normalizeArray(tail.split(/[\\\\\\/]+/), !isAbsolute).join('\\\\');\r\n\r\n  if (!tail && !isAbsolute) {\r\n    tail = '.';\r\n  }\r\n  if (tail && trailingSlash) {\r\n    tail += '\\\\';\r\n  }\r\n\r\n  // Convert slashes to backslashes when `device` points to an UNC root.\r\n  // Also squash multiple slashes into a single one where appropriate.\r\n  if (isUnc) {\r\n    device = normalizeUNCRoot(device);\r\n  }\r\n\r\n  return device + (isAbsolute ? '\\\\' : '') + tail;\r\n};\r\n\r\n\r\nwin32.isAbsolute = function(path) {\r\n  return win32StatPath(path).isAbsolute;\r\n};\r\n\r\nwin32.join = function() {\r\n  var paths = [];\r\n  for (var i = 0; i < arguments.length; i++) {\r\n    var arg = arguments[i];\r\n    if (!util.isString(arg)) {\r\n      throw new TypeError('Arguments to path.join must be strings');\r\n    }\r\n    if (arg) {\r\n      paths.push(arg);\r\n    }\r\n  }\r\n\r\n  var joined = paths.join('\\\\');\r\n\r\n  // Make sure that the joined path doesn't start with two slashes, because\r\n  // normalize() will mistake it for an UNC path then.\r\n  //\r\n  // This step is skipped when it is very clear that the user actually\r\n  // intended to point at an UNC path. This is assumed when the first\r\n  // non-empty string arguments starts with exactly two slashes followed by\r\n  // at least one more non-slash character.\r\n  //\r\n  // Note that for normalize() to treat a path as an UNC path it needs to\r\n  // have at least 2 components, so we don't filter for that here.\r\n  // This means that the user can use join to construct UNC paths from\r\n  // a server name and a share name; for example:\r\n  //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\')\r\n  if (!/^[\\\\\\/]{2}[^\\\\\\/]/.test(paths[0])) {\r\n    joined = joined.replace(/^[\\\\\\/]{2,}/, '\\\\');\r\n  }\r\n\r\n  return win32.normalize(joined);\r\n};\r\n\r\n\r\n// path.relative(from, to)\r\n// it will solve the relative path from 'from' to 'to', for instance:\r\n// from = 'C:\\\\orandea\\\\test\\\\aaa'\r\n// to = 'C:\\\\orandea\\\\impl\\\\bbb'\r\n// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\r\nwin32.relative = function(from, to) {\r\n  from = win32.resolve(from);\r\n  to = win32.resolve(to);\r\n\r\n  // windows is not case sensitive\r\n  var lowerFrom = from.toLowerCase();\r\n  var lowerTo = to.toLowerCase();\r\n\r\n  var toParts = trimArray(to.split('\\\\'));\r\n\r\n  var lowerFromParts = trimArray(lowerFrom.split('\\\\'));\r\n  var lowerToParts = trimArray(lowerTo.split('\\\\'));\r\n\r\n  var length = Math.min(lowerFromParts.length, lowerToParts.length);\r\n  var samePartsLength = length;\r\n  for (var i = 0; i < length; i++) {\r\n    if (lowerFromParts[i] !== lowerToParts[i]) {\r\n      samePartsLength = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (samePartsLength == 0) {\r\n    return to;\r\n  }\r\n\r\n  var outputParts = [];\r\n  for (var i = samePartsLength; i < lowerFromParts.length; i++) {\r\n    outputParts.push('..');\r\n  }\r\n\r\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\r\n\r\n  return outputParts.join('\\\\');\r\n};\r\n\r\n\r\nwin32._makeLong = function(path) {\r\n  // Note: this will *probably* throw somewhere.\r\n  if (!util.isString(path))\r\n    return path;\r\n\r\n  if (!path) {\r\n    return '';\r\n  }\r\n\r\n  var resolvedPath = win32.resolve(path);\r\n\r\n  if (/^[a-zA-Z]\\:\\\\/.test(resolvedPath)) {\r\n    // path is local filesystem path, which needs to be converted\r\n    // to long UNC path.\r\n    return '\\\\\\\\?\\\\' + resolvedPath;\r\n  } else if (/^\\\\\\\\[^?.]/.test(resolvedPath)) {\r\n    // path is network UNC path, which needs to be converted\r\n    // to long UNC path.\r\n    return '\\\\\\\\?\\\\UNC\\\\' + resolvedPath.substring(2);\r\n  }\r\n\r\n  return path;\r\n};\r\n\r\n\r\nwin32.dirname = function(path) {\r\n  var result = win32SplitPath(path),\r\n      root = result[0],\r\n      dir = result[1];\r\n\r\n  if (!root && !dir) {\r\n    // No dirname whatsoever\r\n    return '.';\r\n  }\r\n\r\n  if (dir) {\r\n    // It has a dirname, strip trailing slash\r\n    dir = dir.substr(0, dir.length - 1);\r\n  }\r\n\r\n  return root + dir;\r\n};\r\n\r\n\r\nwin32.basename = function(path, ext) {\r\n  var f = win32SplitPath(path)[2];\r\n  // TODO: make this comparison case-insensitive on windows?\r\n  if (ext && f.substr(-1 * ext.length) === ext) {\r\n    f = f.substr(0, f.length - ext.length);\r\n  }\r\n  return f;\r\n};\r\n\r\n\r\nwin32.extname = function(path) {\r\n  return win32SplitPath(path)[3];\r\n};\r\n\r\n\r\nwin32.format = function(pathObject) {\r\n  if (!util.isObject(pathObject)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathObject' must be an object, not \" + typeof pathObject\r\n    );\r\n  }\r\n\r\n  var root = pathObject.root || '';\r\n\r\n  if (!util.isString(root)) {\r\n    throw new TypeError(\r\n        \"'pathObject.root' must be a string or undefined, not \" +\r\n        typeof pathObject.root\r\n    );\r\n  }\r\n\r\n  var dir = pathObject.dir;\r\n  var base = pathObject.base || '';\r\n  if (!dir) {\r\n    return base;\r\n  }\r\n  if (dir[dir.length - 1] === win32.sep) {\r\n    return dir + base;\r\n  }\r\n  return dir + win32.sep + base;\r\n};\r\n\r\n\r\nwin32.parse = function(pathString) {\r\n  if (!util.isString(pathString)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathString' must be a string, not \" + typeof pathString\r\n    );\r\n  }\r\n  var allParts = win32SplitPath(pathString);\r\n  if (!allParts || allParts.length !== 4) {\r\n    throw new TypeError(\"Invalid path '\" + pathString + \"'\");\r\n  }\r\n  return {\r\n    root: allParts[0],\r\n    dir: allParts[0] + allParts[1].slice(0, -1),\r\n    base: allParts[2],\r\n    ext: allParts[3],\r\n    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\r\n  };\r\n};\r\n\r\n\r\nwin32.sep = '\\\\';\r\nwin32.delimiter = ';';\r\n\r\n\r\n// Split a filename into [root, dir, basename, ext], unix version\r\n// 'root' is just a slash, or nothing.\r\nvar splitPathRe =\r\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\r\nvar posix = {};\r\n\r\n\r\nfunction posixSplitPath(filename) {\r\n  return splitPathRe.exec(filename).slice(1);\r\n}\r\n\r\n\r\n// path.resolve([from ...], to)\r\n// posix version\r\nposix.resolve = function() {\r\n  var resolvedPath = '',\r\n      resolvedAbsolute = false;\r\n\r\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\r\n    var path = (i >= 0) ? arguments[i] : process.cwd();\r\n\r\n    // Skip empty and invalid entries\r\n    if (!util.isString(path)) {\r\n      throw new TypeError('Arguments to path.resolve must be strings');\r\n    } else if (!path) {\r\n      continue;\r\n    }\r\n\r\n    resolvedPath = path + '/' + resolvedPath;\r\n    resolvedAbsolute = path[0] === '/';\r\n  }\r\n\r\n  // At this point the path should be resolved to a full absolute path, but\r\n  // handle relative paths to be safe (might happen when process.cwd() fails)\r\n\r\n  // Normalize the path\r\n  resolvedPath = normalizeArray(resolvedPath.split('/'),\r\n                                !resolvedAbsolute).join('/');\r\n\r\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\r\n};\r\n\r\n// path.normalize(path)\r\n// posix version\r\nposix.normalize = function(path) {\r\n  var isAbsolute = posix.isAbsolute(path),\r\n      trailingSlash = path && path[path.length - 1] === '/';\r\n\r\n  // Normalize the path\r\n  path = normalizeArray(path.split('/'), !isAbsolute).join('/');\r\n\r\n  if (!path && !isAbsolute) {\r\n    path = '.';\r\n  }\r\n  if (path && trailingSlash) {\r\n    path += '/';\r\n  }\r\n\r\n  return (isAbsolute ? '/' : '') + path;\r\n};\r\n\r\n// posix version\r\nposix.isAbsolute = function(path) {\r\n  return path.charAt(0) === '/';\r\n};\r\n\r\n// posix version\r\nposix.join = function() {\r\n  var path = '';\r\n  for (var i = 0; i < arguments.length; i++) {\r\n    var segment = arguments[i];\r\n    if (!util.isString(segment)) {\r\n      throw new TypeError('Arguments to path.join must be strings');\r\n    }\r\n    if (segment) {\r\n      if (!path) {\r\n        path += segment;\r\n      } else {\r\n        path += '/' + segment;\r\n      }\r\n    }\r\n  }\r\n  return posix.normalize(path);\r\n};\r\n\r\n\r\n// path.relative(from, to)\r\n// posix version\r\nposix.relative = function(from, to) {\r\n  from = posix.resolve(from).substr(1);\r\n  to = posix.resolve(to).substr(1);\r\n\r\n  var fromParts = trimArray(from.split('/'));\r\n  var toParts = trimArray(to.split('/'));\r\n\r\n  var length = Math.min(fromParts.length, toParts.length);\r\n  var samePartsLength = length;\r\n  for (var i = 0; i < length; i++) {\r\n    if (fromParts[i] !== toParts[i]) {\r\n      samePartsLength = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  var outputParts = [];\r\n  for (var i = samePartsLength; i < fromParts.length; i++) {\r\n    outputParts.push('..');\r\n  }\r\n\r\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\r\n\r\n  return outputParts.join('/');\r\n};\r\n\r\n\r\nposix._makeLong = function(path) {\r\n  return path;\r\n};\r\n\r\n\r\nposix.dirname = function(path) {\r\n  var result = posixSplitPath(path),\r\n      root = result[0],\r\n      dir = result[1];\r\n\r\n  if (!root && !dir) {\r\n    // No dirname whatsoever\r\n    return '.';\r\n  }\r\n\r\n  if (dir) {\r\n    // It has a dirname, strip trailing slash\r\n    dir = dir.substr(0, dir.length - 1);\r\n  }\r\n\r\n  return root + dir;\r\n};\r\n\r\n\r\nposix.basename = function(path, ext) {\r\n  var f = posixSplitPath(path)[2];\r\n  // TODO: make this comparison case-insensitive on windows?\r\n  if (ext && f.substr(-1 * ext.length) === ext) {\r\n    f = f.substr(0, f.length - ext.length);\r\n  }\r\n  return f;\r\n};\r\n\r\n\r\nposix.extname = function(path) {\r\n  return posixSplitPath(path)[3];\r\n};\r\n\r\n\r\nposix.format = function(pathObject) {\r\n  if (!util.isObject(pathObject)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathObject' must be an object, not \" + typeof pathObject\r\n    );\r\n  }\r\n\r\n  var root = pathObject.root || '';\r\n\r\n  if (!util.isString(root)) {\r\n    throw new TypeError(\r\n        \"'pathObject.root' must be a string or undefined, not \" +\r\n        typeof pathObject.root\r\n    );\r\n  }\r\n\r\n  var dir = pathObject.dir ? pathObject.dir + posix.sep : '';\r\n  var base = pathObject.base || '';\r\n  return dir + base;\r\n};\r\n\r\n\r\nposix.parse = function(pathString) {\r\n  if (!util.isString(pathString)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathString' must be a string, not \" + typeof pathString\r\n    );\r\n  }\r\n  var allParts = posixSplitPath(pathString);\r\n  if (!allParts || allParts.length !== 4) {\r\n    throw new TypeError(\"Invalid path '\" + pathString + \"'\");\r\n  }\r\n  allParts[1] = allParts[1] || '';\r\n  allParts[2] = allParts[2] || '';\r\n  allParts[3] = allParts[3] || '';\r\n\r\n  return {\r\n    root: allParts[0],\r\n    dir: allParts[0] + allParts[1].slice(0, -1),\r\n    base: allParts[2],\r\n    ext: allParts[3],\r\n    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\r\n  };\r\n};\r\n\r\n\r\nposix.sep = '/';\r\nposix.delimiter = ':';\r\n\r\n\r\nif (isWindows)\r\n  module.exports = win32;\r\nelse /* posix */\r\n  module.exports = posix;\r\n\r\nmodule.exports.posix = posix;\r\nmodule.exports.win32 = win32;\r\n\n\n//# sourceURL=webpack://qasm-quantum-simulator/./node_modules/path/path.js?\n}");

/***/ }),

/***/ "./node_modules/qasm-ts/dist/errors.js":
/*!*********************************************!*\
  !*** ./node_modules/qasm-ts/dist/errors.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BadArgumentError: () => (/* binding */ BadArgumentError),\n/* harmony export */   BadBarrierError: () => (/* binding */ BadBarrierError),\n/* harmony export */   BadClassicalTypeError: () => (/* binding */ BadClassicalTypeError),\n/* harmony export */   BadConditionalError: () => (/* binding */ BadConditionalError),\n/* harmony export */   BadCregError: () => (/* binding */ BadCregError),\n/* harmony export */   BadEqualsError: () => (/* binding */ BadEqualsError),\n/* harmony export */   BadExpressionError: () => (/* binding */ BadExpressionError),\n/* harmony export */   BadGateError: () => (/* binding */ BadGateError),\n/* harmony export */   BadIncludeError: () => (/* binding */ BadIncludeError),\n/* harmony export */   BadLoopError: () => (/* binding */ BadLoopError),\n/* harmony export */   BadMeasurementError: () => (/* binding */ BadMeasurementError),\n/* harmony export */   BadParameterError: () => (/* binding */ BadParameterError),\n/* harmony export */   BadQregError: () => (/* binding */ BadQregError),\n/* harmony export */   BadQuantumInstructionError: () => (/* binding */ BadQuantumInstructionError),\n/* harmony export */   BadStringLiteralError: () => (/* binding */ BadStringLiteralError),\n/* harmony export */   BadSubroutineError: () => (/* binding */ BadSubroutineError),\n/* harmony export */   MissingBraceError: () => (/* binding */ MissingBraceError),\n/* harmony export */   MissingSemicolonError: () => (/* binding */ MissingSemicolonError),\n/* harmony export */   UnsupportedOpenQASMVersionError: () => (/* binding */ UnsupportedOpenQASMVersionError)\n/* harmony export */ });\n/**\n * Error classes for QASM parsing and validation\n *\n * This module provides specific error types for different parsing failures,\n * enabling precise error handling and debugging. Each error includes contextual\n * information about where the error occurred in the source code.\n *\n * @module Error Handling\n */\n/** Class representing a bad argument exception. */\nclass BadArgumentError extends Error {\n    constructor(message) {\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.name = BadArgumentError.name;\n    }\n}\n/** Class representing a bad include statement */\nclass BadIncludeError extends Error {\n    constructor(message) {\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.name = BadIncludeError.name;\n    }\n}\n/** Class representing a bad quantum register exception. */\nclass BadQregError extends Error {\n    constructor(message) {\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.name = BadQregError.name;\n    }\n}\n/** Class representing a bad equality exception. */\nclass BadEqualsError extends Error {\n    constructor(message) {\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.name = BadEqualsError.name;\n    }\n}\n/** Class representing a bad classical register exception. */\nclass BadCregError extends Error {\n    constructor(message) {\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.name = BadCregError.name;\n    }\n}\n/** Class representing a bad conditional exception. */\nclass BadConditionalError extends Error {\n    constructor(message) {\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.name = BadConditionalError.name;\n    }\n}\n/** Class representing a bad barrier exception. */\nclass BadBarrierError extends Error {\n    constructor(message) {\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.name = BadBarrierError.name;\n    }\n}\n/** Class representing a bad measurement exception. */\nclass BadMeasurementError extends Error {\n    constructor(message) {\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.name = BadMeasurementError.name;\n    }\n}\n/** Class representing a bad gate exception. */\nclass BadGateError extends Error {\n    constructor(message) {\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.name = BadGateError.name;\n    }\n}\n/** Class representing a bad parameter exception. */\nclass BadParameterError extends Error {\n    constructor(message) {\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.name = BadParameterError.name;\n    }\n}\n/** Class representing a missing semicolon exception. */\nclass MissingSemicolonError extends Error {\n    constructor(message) {\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.name = MissingSemicolonError.name;\n    }\n}\n/** Class representing a missing opening or closing parenthesis, bracket, or curly brakcet. */\nclass MissingBraceError extends Error {\n    constructor(message) {\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.name = MissingSemicolonError.name;\n    }\n}\n/** Class representing an unsupported OpenQASM version exception. */\nclass UnsupportedOpenQASMVersionError extends Error {\n    constructor(message) {\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.name = UnsupportedOpenQASMVersionError.name;\n    }\n}\n/** Class representing an error parsing an expected string literal. */\nclass BadStringLiteralError extends Error {\n    constructor(message) {\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.name = BadStringLiteralError.name;\n    }\n}\n/** Class representing an error parsing scalar types. */\nclass BadClassicalTypeError extends Error {\n    constructor(message) {\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.name = BadClassicalTypeError.name;\n    }\n}\n/** Class representing an error parsing an expression. */\nclass BadExpressionError extends Error {\n    constructor(message) {\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.name = BadExpressionError.name;\n    }\n}\n/** Class representing an error in defining or calling a custom subroutine. */\nclass BadSubroutineError extends Error {\n    constructor(message) {\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.name = BadSubroutineError.name;\n    }\n}\n/** Class representing a bad loop statement declaration. */\nclass BadLoopError extends Error {\n    constructor(message) {\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.name = BadLoopError.name;\n    }\n}\n/** Class representing a bad quantum instruction. */\nclass BadQuantumInstructionError extends Error {\n    constructor(message) {\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.name = BadQuantumInstructionError.name;\n    }\n}\n\n\n\n//# sourceURL=webpack://qasm-quantum-simulator/./node_modules/qasm-ts/dist/errors.js?\n}");

/***/ }),

/***/ "./node_modules/qasm-ts/dist/lexer.js":
/*!********************************************!*\
  !*** ./node_modules/qasm-ts/dist/lexer.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   lex: () => (/* binding */ lex)\n/* harmony export */ });\n/* harmony import */ var _qasm2_lexer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./qasm2/lexer */ \"./node_modules/qasm-ts/dist/qasm2/lexer.js\");\n/* harmony import */ var _qasm3_lexer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./qasm3/lexer */ \"./node_modules/qasm-ts/dist/qasm3/lexer.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./version */ \"./node_modules/qasm-ts/dist/version.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors */ \"./node_modules/qasm-ts/dist/errors.js\");\n/**\n * Main lexer interface for tokenizing QASM code\n *\n * The lexer is responsible for breaking down QASM source code into tokens\n * that can be consumed by the parser. It supports both OpenQASM 2.0 and 3.0\n * syntax, with version-specific lexers handling the differences in token types\n * and syntax rules.\n *\n * The specific Lexer implementations can be found at:\n * - {@link Qasm3Lexer}\n * - {@link Qasm2Lexer}\n *\n * @module Lexing\n *\n * @example Token Flow\n * ```\n * Source Code → Lexer → Tokens → Parser → AST\n * \"h q[0];\"  →  [Id, Id, LSParen, NNInteger, RSParen, Semicolon]\n * ```\n *\n *  * @example Basic lexing workflow\n * ```typescript\n * import { lex } from './lexer';\n *\n * const qasmCode = 'OPENQASM 3.0; qubit q; h q;';\n * const tokens = lex(qasmCode);\n * console.log(tokens);\n * // [\n * //   [Token.OpenQASM, undefined],\n * //   [Token.Id, 'qubit'],\n * //   [Token.Id, 'q'],\n * //   [Token.Semicolon, undefined],\n * //   [Token.Id, 'h'],\n * //   [Token.Id, 'q'],\n * //   [Token.Semicolon, undefined]\n * // ]\n * ```\n */\n\n\n\n\n/**\n * Tokenizes OpenQASM source code into an array of tokens.\n *\n * This is the main entry point for lexical analysis. It automatically selects\n * the appropriate lexer implementation based on the OpenQASM version and returns\n * an array of tokens that can be consumed by the parser.\n *\n * Each token is represented as a tuple containing:\n * - **Token type**: An enum value indicating the kind of token\n * - **Token value**: The associated value (for literals, identifiers, operators)\n *\n * @group Lexing\n * @param qasm - The OpenQASM source code to tokenize\n * @param cursor - Starting position in the input string (defaults to 0)\n * @param version - OpenQASM version to use for lexing (defaults to 3.0)\n * @returns Array of token tuples [TokenType, value?]\n * @throws {UnsupportedOpenQASMVersionError} When an unsupported version is specified\n *\n * @example Tokenize OpenQASM 3.0 code\n * ```typescript\n * const tokens = lex('qubit[2] q; h q[0];', 0, 3);\n * // Returns tokens using OpenQASM 3.0 syntax rules\n * ```\n *\n * @example Tokenize OpenQASM 2.0 code\n * ```typescript\n * const tokens = lex('qreg q[2]; h q[0];', 0, 2);\n * // Returns tokens using OpenQASM 2.0 syntax rules\n * ```\n *\n * @example Resume lexing from specific position\n * ```typescript\n * const code = 'OPENQASM 3.0; qubit q;';\n * const tokens = lex(code, 12); // Start after \"OPENQASM 3.0\"\n * ```\n */\nfunction lex(qasm, cursor, version) {\n    let lexer;\n    if (version instanceof _version__WEBPACK_IMPORTED_MODULE_2__.OpenQASMVersion) {\n        switch (version.major) {\n            case _version__WEBPACK_IMPORTED_MODULE_2__.OpenQASMMajorVersion.Version2:\n                lexer = new _qasm2_lexer__WEBPACK_IMPORTED_MODULE_0__[\"default\"](qasm, cursor);\n                break;\n            case _version__WEBPACK_IMPORTED_MODULE_2__.OpenQASMMajorVersion.Version3:\n                lexer = new _qasm3_lexer__WEBPACK_IMPORTED_MODULE_1__[\"default\"](qasm, cursor);\n                break;\n            default:\n                throw new _errors__WEBPACK_IMPORTED_MODULE_3__.UnsupportedOpenQASMVersionError(`Unsupported OpenQASM version detected: ${version.major}`);\n        }\n    }\n    else if (typeof version === \"number\") {\n        switch (version) {\n            case 2:\n                lexer = new _qasm2_lexer__WEBPACK_IMPORTED_MODULE_0__[\"default\"](qasm, cursor);\n                break;\n            case 3:\n                lexer = new _qasm3_lexer__WEBPACK_IMPORTED_MODULE_1__[\"default\"](qasm, cursor);\n                break;\n            default:\n                throw new _errors__WEBPACK_IMPORTED_MODULE_3__.UnsupportedOpenQASMVersionError(`Unsupported OpenQASM version detected: ${version}`);\n        }\n    }\n    else if (version === _version__WEBPACK_IMPORTED_MODULE_2__.OpenQASMMajorVersion.Version2) {\n        lexer = new _qasm2_lexer__WEBPACK_IMPORTED_MODULE_0__[\"default\"](qasm, cursor);\n    }\n    else if (version === _version__WEBPACK_IMPORTED_MODULE_2__.OpenQASMMajorVersion.Version3) {\n        lexer = new _qasm3_lexer__WEBPACK_IMPORTED_MODULE_1__[\"default\"](qasm, cursor);\n    }\n    else {\n        lexer = new _qasm3_lexer__WEBPACK_IMPORTED_MODULE_1__[\"default\"](qasm, cursor);\n    }\n    const tokens = lexer.lex();\n    return tokens;\n}\n\n\n//# sourceURL=webpack://qasm-quantum-simulator/./node_modules/qasm-ts/dist/lexer.js?\n}");

/***/ }),

/***/ "./node_modules/qasm-ts/dist/main.js":
/*!*******************************************!*\
  !*** ./node_modules/qasm-ts/dist/main.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseFile: () => (/* binding */ parseFile),\n/* harmony export */   parseString: () => (/* binding */ parseString)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"?253a\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lexer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lexer */ \"./node_modules/qasm-ts/dist/lexer.js\");\n/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parser */ \"./node_modules/qasm-ts/dist/parser.js\");\n/* eslint-disable  @typescript-eslint/no-explicit-any */\n/**\n * Main parsing functions for qasm-ts - the primary entry points for parsing OpenQASM code\n * @module Main Functions\n */\n\n\n\n/**\n * Parses OpenQASM code from a string and returns the abstract syntax tree.\n *\n * This is the primary entry point for parsing OpenQASM code. It handles both\n * OpenQASM 2.0 and 3.0 syntax, automatically selecting the appropriate lexer\n * and parser based on the version parameter.\n *\n * @group Main Functions\n * @param qasm - The OpenQASM code string to parse\n * @param version - The OpenQASM version to use (defaults to 3.0)\n * @param verbose - Whether to include class names in the output (defaults to false)\n * @param stringify - Whether to return stringified JSON (defaults to false)\n * @returns The corresponding AST as an array of nodes, or stringified JSON if stringify is true\n *\n * @example Basic OpenQASM 3.0 parsing\n * ```typescript\n * import { parseString } from 'qasm-ts';\n *\n * const qasmCode = `\n * OPENQASM 3.0;\n * include \"stdgates.inc\";\n * qubit[2] q;\n * h q[0];\n * cx q[0], q[1];\n * `;\n *\n * const ast = parseString(qasmCode);\n * console.log(ast);\n * ```\n *\n * @example OpenQASM 2.0 parsing\n * ```typescript\n * const qasm2Code = `\n * OPENQASM 2.0;\n * include \"qelib1.inc\";\n * qreg q[2];\n * creg c[2];\n * h q[0];\n * cx q[0],q[1];\n * measure q -> c;\n * `;\n *\n * const ast = parseString(qasm2Code, 2);\n * ```\n *\n * @example Verbose output with class names\n * ```typescript\n * const ast = parseString(qasmCode, 3, true);\n * // Output will include __className__ properties for each node\n * ```\n */\nfunction parseString(qasm, version, verbose, stringify) {\n    let ast;\n    const tokens = (0,_lexer__WEBPACK_IMPORTED_MODULE_1__.lex)(qasm, undefined, version);\n    ast = (0,_parser__WEBPACK_IMPORTED_MODULE_2__.parse)(tokens, version);\n    if (verbose === true) {\n        if (stringify === true) {\n            ast = JSON.stringify(getDetailedOutput(ast), null, 2);\n        }\n        ast = getDetailedOutput(ast);\n    }\n    else {\n        if (stringify === true) {\n            ast = JSON.stringify(ast, null, 2);\n        }\n    }\n    return ast;\n}\n/**\n * Parses OpenQASM code from a file and returns the abstract syntax tree.\n *\n * @group Main Functions\n * @param file - The path to the .qasm file to parse\n * @param version - The OpenQASM version to use (defaults to 3.0)\n * @param verbose - Whether to include class names in the output (defaults to false)\n * @param stringify - Whether to return stringified JSON (defaults to false)\n * @returns The corresponding AST as an array of nodes, or stringified JSON if stringify is true\n *\n * @example Parse a QASM file\n * ```typescript\n * import { parseFile } from 'qasm-ts';\n *\n * // Parse OpenQASM 3.0 file\n * const ast = parseFile('./my-circuit.qasm');\n *\n * // Parse OpenQASM 2.0 file\n * const ast2 = parseFile('./legacy-circuit.qasm', 2);\n * ```\n *\n * @example Parse with verbose output\n * ```typescript\n * const ast = parseFile('./circuit.qasm', 3, true);\n * // Includes detailed class information for each AST node\n * ```\n */\nfunction parseFile(file, version, verbose, stringify) {\n    return parseString(fs__WEBPACK_IMPORTED_MODULE_0__.readFileSync(file, \"utf8\"), version, verbose, stringify);\n}\n/**\n * Adds class names to AST nodes for detailed inspection.\n * @internal\n */\nfunction getDetailedOutput(object) {\n    if (Array.isArray(object)) {\n        return object.map(getDetailedOutput);\n    }\n    else if (object !== null && typeof object === \"object\") {\n        const result = {};\n        result[\"__className__\"] = object.constructor.name;\n        for (const [key, value] of Object.entries(object)) {\n            result[key] = getDetailedOutput(value);\n        }\n        return result;\n    }\n    else {\n        return object;\n    }\n}\n\n\n//# sourceURL=webpack://qasm-quantum-simulator/./node_modules/qasm-ts/dist/main.js?\n}");

/***/ }),

/***/ "./node_modules/qasm-ts/dist/parser.js":
/*!*********************************************!*\
  !*** ./node_modules/qasm-ts/dist/parser.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parse: () => (/* binding */ parse)\n/* harmony export */ });\n/* harmony import */ var _qasm2_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./qasm2/parser */ \"./node_modules/qasm-ts/dist/qasm2/parser.js\");\n/* harmony import */ var _qasm3_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./qasm3/parser */ \"./node_modules/qasm-ts/dist/qasm3/parser.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./version */ \"./node_modules/qasm-ts/dist/version.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors */ \"./node_modules/qasm-ts/dist/errors.js\");\n/**\n * Main parser interface for generating AST from tokens\n *\n * The parser is responsible for transforming a stream of tokens into an Abstract\n * Syntax Tree (AST) that represents the structure of the OpenQASM program. It acts\n * as a dispatcher, selecting the appropriate version-specific parser based on the\n * OpenQASM version being used.\n *\n * The parsing process follows these steps:\n * 1. Receive tokenized input from the lexer\n * 2. Determine OpenQASM version (2.0 or 3.0)\n * 3. Select appropriate parser implementation\n * 4. Generate version-specific AST nodes\n *\n * The specific Parser implementations can be found at:\n * - {@link Qasm3Parser}\n * - {@link Qasm2Parser}\n *\n * @module Parsing\n *\n * @example Basic parsing workflow\n * ```typescript\n * import { lex } from './lexer';\n * import { parse } from './parser';\n *\n * const qasmCode = 'OPENQASM 3.0; h q[0];';\n * const tokens = lex(qasmCode, undefined, 3);\n * const ast = parse(tokens, 3);\n * console.log(ast); // Array of AST nodes\n * ```\n *\n * @example Version-specific parsing\n * ```typescript\n * // Parse as OpenQASM 2.0\n * const ast2 = parse(tokens, 2);\n *\n * // Parse as OpenQASM 3.0\n * const ast3 = parse(tokens, 3);\n *\n * // Use OpenQASMVersion object\n * const version = new OpenQASMVersion(3, 0);\n * const ast = parse(tokens, version);\n * ```\n */\n\n\n\n\n/**\n * Parses an array of tokens into an Abstract Syntax Tree (AST).\n *\n * This is the main entry point for parsing tokenized OpenQASM code. It automatically\n * selects the appropriate parser implementation based on the specified version and\n * returns an AST that can be used for further analysis, compilation, or execution.\n *\n * @group Parsing\n * @param tokens - Array of tokens generated by the lexer\n * @param version - OpenQASM version to use for parsing (defaults to 3.0)\n * @returns Abstract Syntax Tree representing the parsed program\n * @throws {UnsupportedOpenQASMVersionError} When an unsupported version is specified\n *\n * @example Parse OpenQASM 3.0 tokens\n * ```typescript\n * const tokens = lex('OPENQASM 3.0; qubit q; h q;');\n * const ast = parse(tokens, 3);\n * // Returns array of OpenQASM 3.0 AST nodes\n * ```\n *\n * @example Parse OpenQASM 2.0 tokens\n * ```typescript\n * const tokens = lex('OPENQASM 2.0; qreg q[1]; h q[0];');\n * const ast = parse(tokens, 2);\n * // Returns array of OpenQASM 2.0 AST nodes\n * ```\n */\nfunction parse(tokens, version) {\n    let parser;\n    let castTokens;\n    if (version instanceof _version__WEBPACK_IMPORTED_MODULE_2__.OpenQASMVersion) {\n        switch (version.major) {\n            case _version__WEBPACK_IMPORTED_MODULE_2__.OpenQASMMajorVersion.Version2:\n                castTokens = tokens;\n                parser = new _qasm2_parser__WEBPACK_IMPORTED_MODULE_0__[\"default\"](castTokens);\n                break;\n            case _version__WEBPACK_IMPORTED_MODULE_2__.OpenQASMMajorVersion.Version3:\n                castTokens = tokens;\n                parser = new _qasm2_parser__WEBPACK_IMPORTED_MODULE_0__[\"default\"](castTokens);\n                break;\n            default:\n                throw new _errors__WEBPACK_IMPORTED_MODULE_3__.UnsupportedOpenQASMVersionError(`Unsupported OpenQASM version detected: ${version.major}`);\n        }\n    }\n    else if (typeof version === \"number\") {\n        switch (version) {\n            case 2:\n                castTokens = tokens;\n                parser = new _qasm2_parser__WEBPACK_IMPORTED_MODULE_0__[\"default\"](castTokens);\n                break;\n            case 3:\n                castTokens = tokens;\n                parser = new _qasm3_parser__WEBPACK_IMPORTED_MODULE_1__[\"default\"](castTokens);\n                break;\n            default:\n                throw new _errors__WEBPACK_IMPORTED_MODULE_3__.UnsupportedOpenQASMVersionError(`Unsupported OpenQASM version detected: ${version}`);\n        }\n    }\n    else if (version === _version__WEBPACK_IMPORTED_MODULE_2__.OpenQASMMajorVersion.Version2) {\n        castTokens = tokens;\n        parser = new _qasm2_parser__WEBPACK_IMPORTED_MODULE_0__[\"default\"](castTokens);\n    }\n    else if (version === _version__WEBPACK_IMPORTED_MODULE_2__.OpenQASMMajorVersion.Version3) {\n        castTokens = tokens;\n        parser = new _qasm3_parser__WEBPACK_IMPORTED_MODULE_1__[\"default\"](castTokens);\n    }\n    else {\n        castTokens = tokens;\n        parser = new _qasm3_parser__WEBPACK_IMPORTED_MODULE_1__[\"default\"](castTokens);\n    }\n    const ast = parser.parse();\n    return ast;\n}\n\n\n//# sourceURL=webpack://qasm-quantum-simulator/./node_modules/qasm-ts/dist/parser.js?\n}");

/***/ }),

/***/ "./node_modules/qasm-ts/dist/qasm2/ast.js":
/*!************************************************!*\
  !*** ./node_modules/qasm-ts/dist/qasm2/ast.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApplyGate: () => (/* binding */ ApplyGate),\n/* harmony export */   AstNode: () => (/* binding */ AstNode),\n/* harmony export */   Barrier: () => (/* binding */ Barrier),\n/* harmony export */   CReg: () => (/* binding */ CReg),\n/* harmony export */   Cos: () => (/* binding */ Cos),\n/* harmony export */   Divide: () => (/* binding */ Divide),\n/* harmony export */   Exp: () => (/* binding */ Exp),\n/* harmony export */   Gate: () => (/* binding */ Gate),\n/* harmony export */   Id: () => (/* binding */ Id),\n/* harmony export */   If: () => (/* binding */ If),\n/* harmony export */   Include: () => (/* binding */ Include),\n/* harmony export */   Ln: () => (/* binding */ Ln),\n/* harmony export */   Measure: () => (/* binding */ Measure),\n/* harmony export */   Minus: () => (/* binding */ Minus),\n/* harmony export */   NNInteger: () => (/* binding */ NNInteger),\n/* harmony export */   Opaque: () => (/* binding */ Opaque),\n/* harmony export */   Pi: () => (/* binding */ Pi),\n/* harmony export */   Plus: () => (/* binding */ Plus),\n/* harmony export */   Power: () => (/* binding */ Power),\n/* harmony export */   QReg: () => (/* binding */ QReg),\n/* harmony export */   Real: () => (/* binding */ Real),\n/* harmony export */   Sin: () => (/* binding */ Sin),\n/* harmony export */   Sqrt: () => (/* binding */ Sqrt),\n/* harmony export */   Tan: () => (/* binding */ Tan),\n/* harmony export */   Times: () => (/* binding */ Times),\n/* harmony export */   Variable: () => (/* binding */ Variable),\n/* harmony export */   Version: () => (/* binding */ Version)\n/* harmony export */ });\n/**\n * OpenQASM 2.0 Abstract Syntax Tree Node Definitions\n *\n * This module defines the AST node classes for OpenQASM 2.0, which provides\n * a simpler and more limited set of constructs compared to OpenQASM 3.0.\n *\n * OpenQASM 2.0 focuses on:\n * - Basic quantum register (`qreg`) and classical register (`creg`) declarations\n * - Gate definitions and applications\n * - Measurement operations\n * - Simple conditional statements\n * - Basic arithmetic expressions\n *\n * Key limitations compared to 3.0:\n * - No advanced classical types (only registers)\n * - No control flow structures (loops, complex conditionals)\n * - No function definitions or subroutines\n * - Limited expression capabilities\n *\n * @module\n *\n * @example Basic OpenQASM 2.0 constructs\n * ```typescript\n * // Quantum register: qreg q[2];\n * new QReg('q', 2)\n *\n * // Gate application: h q[0];\n * new ApplyGate('h', [['q', 0]], [])\n *\n * // Measurement: measure q[0] -> c[0];\n * new Measure('q', 'c', 0, 0)\n * ```\n */\n/** Base class representing a basic AST node. */\nclass AstNode {\n}\n/** Class representing the version statement. */\nclass Version extends AstNode {\n    constructor(version) {\n        super();\n        this.version = version;\n    }\n}\n/** Class representing an include statement. */\nclass Include extends AstNode {\n    constructor(filename) {\n        super();\n        this.filename = filename;\n    }\n}\n/** Class representing a qubit register. */\nclass QReg extends AstNode {\n    constructor(id, size) {\n        super();\n        this.id = id;\n        this.size = size;\n    }\n}\n/** Class representing a classical register. */\nclass CReg extends AstNode {\n    constructor(id, size) {\n        super();\n        this.id = id;\n        this.size = size;\n    }\n}\n/** Class representing an identifier. */\nclass Id extends AstNode {\n    constructor(id) {\n        super();\n        this.id = id;\n    }\n}\n/** Class representing a barrier. */\nclass Barrier extends AstNode {\n    constructor(register, index) {\n        super();\n        this.index = index || null;\n        this.register = register;\n    }\n}\n/** Class representing a variable. */\nclass Variable extends AstNode {\n    constructor(value) {\n        super();\n        this.value = value || null;\n    }\n}\n/** Class representing a measurement. */\nclass Measure extends AstNode {\n    constructor(src_register, dest_register, src_index, dest_index) {\n        super();\n        this.src_index = src_index != undefined ? src_index : null;\n        this.src_register = src_register;\n        this.dest_index = dest_index != undefined ? dest_index : null;\n        this.dest_register = dest_register;\n    }\n}\n/** Class representing a gate application. */\nclass ApplyGate extends AstNode {\n    constructor(name, qubits, params) {\n        super();\n        this.name = name;\n        this.qubits = qubits;\n        this.params = params;\n    }\n}\n/** Class representing a gate. */\nclass Gate extends AstNode {\n    constructor(name, registers, params, nodes) {\n        super();\n        this.name = name;\n        this.registers = registers;\n        this.params = params;\n        this.nodes = nodes;\n    }\n}\n/** Class representing an opaque gate declaration (only available in OpenQASM 2.x versions) */\nclass Opaque extends AstNode {\n    constructor(name, qubits, params = []) {\n        super();\n        this.name = name;\n        this.qubits = qubits;\n        this.params = params;\n    }\n}\n/** Class representing conditional. */\nclass If extends AstNode {\n    constructor(register, param, gate) {\n        super();\n        this.register = register;\n        this.param = param;\n        this.gate = gate;\n    }\n}\n/** Class representing minus. */\nclass Minus extends AstNode {\n}\n/** Class representing plus. */\nclass Plus extends AstNode {\n}\n/** Class representing times. */\nclass Times extends AstNode {\n}\n/** Class representing power. */\nclass Power extends AstNode {\n}\n/** Class representing division. */\nclass Divide extends AstNode {\n}\n/** Class representing pi. */\nclass Pi extends AstNode {\n}\n/** Class representing the square root. */\nclass Sqrt extends AstNode {\n}\n/** Class representing natural logarithm. */\nclass Ln extends AstNode {\n}\n/** Class representing exponentiation. */\nclass Exp extends AstNode {\n}\n/** Class representing tagnent. */\nclass Tan extends AstNode {\n}\n/** Class representing cosine. */\nclass Cos extends AstNode {\n}\n/** Class representing sine. */\nclass Sin extends AstNode {\n}\n/** Class representing an integer. */\nclass NNInteger extends AstNode {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n}\n/** Class representing a real. */\nclass Real extends AstNode {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n}\n\n\n\n//# sourceURL=webpack://qasm-quantum-simulator/./node_modules/qasm-ts/dist/qasm2/ast.js?\n}");

/***/ }),

/***/ "./node_modules/qasm-ts/dist/qasm2/lexer.js":
/*!**************************************************!*\
  !*** ./node_modules/qasm-ts/dist/qasm2/lexer.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _token__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./token */ \"./node_modules/qasm-ts/dist/qasm2/token.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors */ \"./node_modules/qasm-ts/dist/errors.js\");\n/**\n * OpenQASM 2.0 Lexical Analyzer\n *\n * This module implements the lexer for OpenQASM 2.0, which provides a simpler\n * token set compared to OpenQASM 3.0. The lexer focuses on basic quantum circuit\n * constructs without the advanced classical programming features of version 3.0.\n *\n * Key characteristics of OpenQASM 2.0 lexing:\n * - **Limited token set**: Basic quantum and classical registers only\n * - **Simple operators**: Basic arithmetic and comparison operators\n * - **No control flow**: No tokens for loops, conditionals, or functions\n * - **Gate-focused**: Emphasis on gate definitions and applications\n * - **Mathematical functions**: Built-in math functions (sin, cos, etc.)\n *\n * Supported constructs:\n * - Quantum registers (`qreg`) and classical registers (`creg`)\n * - Gate definitions and applications\n * - Measurements with arrow notation (`->`)\n * - Basic arithmetic expressions for gate parameters\n * - Include statements for library files\n *\n * @module\n *\n * @example OpenQASM 2.0 lexing\n * ```typescript\n * const lexer = new Lexer('qreg q[2]; h q[0]; measure q -> c;');\n * const tokens = lexer.lex();\n * // Produces tokens for register declaration, gate, and measurement\n * ```\n */\n\n\n/**\n * Handles throwing lexer errors with basic stack trace.\n * @param error - The error to throw.\n * @param number - The line number in the source code.\n * @param code - The source code that the error is about.\n */\nfunction throwLexerError(error, line, code) {\n    throw new error(`Line ${line}: ${code}`);\n}\n/**\n * Returns whether a given character could be an element of a numeric value.\n * @param c - The character.\n * @return Whether the character is numeric.\n */\nfunction isNumeric(c) {\n    return c == \".\" || !isNaN(parseInt(c));\n}\n/**\n * Returns whether a given character is a letter.\n * @param c - The character.\n * @param matchCase - Whether to check for a letter that is upper case, lower case, or either. (optional)\n * @return Whether the character is a letter.\n */\nfunction isLetter(c, matchCase) {\n    switch (matchCase) {\n        case \"upper\":\n            return /^[A-Z]$/.test(c);\n        case \"lower\":\n            return /^[a-z]$/.test(c);\n        default:\n            return /^[A-Za-z]$/.test(c);\n    }\n}\n/**\n * Returns whether a given character is unicode.\n * @param c - The character.\n * @param excludePi - Whether to exclude the Pi symbol from consideration.\n * @return - Whether the given character is valid unicode.\n */\nfunction isUnicode(c, excludePi) {\n    const isBasicUnicode = /^\\u0000-\\u00ff/.test(c);\n    switch (excludePi) {\n        case true:\n            return isBasicUnicode && c !== \"\\u03C0\";\n        case false:\n            return isBasicUnicode;\n        default:\n            return isBasicUnicode;\n    }\n}\n/**\n * Returns whether a given character is alphanumeric.\n * @param c - The character.\n * @return Whether the character is alphanumeric.\n */\nfunction isAlpha(c) {\n    return /^[0-9a-zA-Z]+$/.test(c);\n}\n/**\n * Returns whether a given character is a newline character.\n * @param c - The character.\n * @return Whether the character is a newline.\n */\nfunction isNewline(c) {\n    return /\\n|\\r(?!\\n)|\\u2028|\\u2029|\\r\\n/.test(c);\n}\n/**\n * OpenQASM 2.0 Lexical Analyzer\n *\n * A simpler lexer implementation focused on the core quantum circuit description\n * features of OpenQASM 2.0. This lexer handles the essential constructs needed\n * for basic quantum programming without the complexity of classical programming\n * language features.\n *\n * @example Basic OpenQASM 2.0 tokenization\n * ```typescript\n * const source = `\n *   OPENQASM 2.0;\n *   include \"qelib1.inc\";\n *   qreg q[2];\n *   creg c[2];\n *   h q[0];\n *   cx q[0],q[1];\n *   measure q -> c;\n * `;\n *\n * const lexer = new Lexer(source);\n * const tokens = lexer.lex();\n * ```\n */\nclass Lexer {\n    /**\n     * Creates a lexer.\n     * @param input - The string to lex.\n     * @param cursor - The starting cursor position.\n     */\n    constructor(input, cursor = 0) {\n        /**\n         * Verifies that all appropriate lines end with a semicolon.\n         * @return A tuple of the status and if False, returns the problematic line.\n         */\n        this.verifyInput = () => {\n            const lines = this.input.split(/\\n|\\r(?!\\n)|\\u2028|\\u2029|\\r\\n/g);\n            for (let i = 0; i < lines.length; i++) {\n                if (!lines[i].startsWith(\"//\") &&\n                    !(lines[i].length == 0) &&\n                    !lines[i].includes(\"gate\") &&\n                    !(lines[i].trim() == \"{\" || lines[i].trim() == \"}\") &&\n                    !lines[i].includes(\";\")) {\n                    return [false, i + 1, lines[i]];\n                }\n            }\n            return [true, null, null];\n        };\n        /**\n         * Calling this method lexes the code represented by the provided string.\n         * @return An array of tokens and their corresponding values.\n         */\n        this.lex = () => {\n            const tokens = [];\n            let token;\n            const verifyInputResult = this.verifyInput();\n            if (!verifyInputResult[0]) {\n                throwLexerError(_errors__WEBPACK_IMPORTED_MODULE_1__.MissingSemicolonError, verifyInputResult[1], verifyInputResult[2]);\n            }\n            while (this.cursor < this.input.length) {\n                token = this.nextToken();\n                if (token) {\n                    tokens.push(token);\n                }\n            }\n            return tokens;\n        };\n        /**\n         * Reads a character and advances the cursor.\n         * @param num - Optional cursor position modifier.\n         */\n        this.readChar = (num = 1) => {\n            this.cursor += num;\n            return this.input[this.cursor - num];\n        };\n        /**\n         * Advances the cusor past the next comment.\n         */\n        this.skipComment = () => {\n            let char = \"\";\n            while (!isNewline(char)) {\n                char = this.readChar();\n            }\n        };\n        /**\n         * Determines whether the next character to process equals a given character.\n         * @param c - The given character.\n         * @return Whether the next character equals the given character.\n         */\n        this.peekEq = (c) => this.peek() == c;\n        /**\n         * Reads a character without advancing the cursor.\n         * @param index - Optional peek position offset.\n         */\n        this.peek = () => this.input[this.cursor];\n        /**\n         * Reads a numeric value.\n         * @return The numeric value as a string.\n         */\n        this.readNumeric = () => {\n            let num = \"\";\n            while (isNumeric(this.peek())) {\n                num += this.readChar();\n            }\n            return num;\n        };\n        /**\n         * Reads an identifier.\n         * @return The identifier as a string.\n         */\n        this.readIdentifier = () => {\n            let id = \"\";\n            let next = this.peek();\n            while (isAlpha(next) || next == \"_\" || isUnicode(next)) {\n                id += this.readChar();\n                next = this.peek();\n            }\n            return id;\n        };\n        /**\n         * Reads a string literal.\n         * @param terminator - The literal's termination character.\n         * @return The literal as a string.\n         */\n        this.readStringLiteral = (terminator) => {\n            let lit = \"\";\n            let char = \"\";\n            while (!(terminator == char)) {\n                char = this.readChar();\n                lit += char;\n            }\n            return lit;\n        };\n        /**\n         * Advances the cusor past the next block of whitespace.\n         */\n        this.skipWhitespace = () => {\n            while (\" \\t\\n\\r\\v\".indexOf(this.peek()) > -1) {\n                this.cursor += 1;\n            }\n            return null;\n        };\n        /**\n         * Lexes the next token.\n         * @return The next token and its corresponding value.\n         */\n        this.nextToken = () => {\n            this.skipWhitespace();\n            if (this.cursor == this.input.length) {\n                return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.EndOfFile];\n            }\n            const char = this.peek();\n            this.readChar();\n            switch (char) {\n                case \"=\":\n                    if (this.peekEq(\"=\")) {\n                        this.readChar();\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Equals];\n                    }\n                    else {\n                        throwLexerError(_errors__WEBPACK_IMPORTED_MODULE_1__.BadEqualsError, this.getLineNumber(this.cursor), this.getCurrentLine(this.cursor));\n                        break;\n                    }\n                case \"-\":\n                    if (this.peekEq(\">\")) {\n                        this.readChar();\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Arrow];\n                    }\n                    else {\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Minus];\n                    }\n                case \"+\":\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Plus];\n                case \"*\":\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Times];\n                case \"^\":\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Power];\n                case \";\":\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon];\n                case \",\":\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Comma];\n                case \"(\":\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LParen];\n                case \"[\":\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LSParen];\n                case \"{\":\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LCParen];\n                case \")\":\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RParen];\n                case \"]\":\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RSParen];\n                case \"}\":\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RCParen];\n                case \"/\":\n                    if (this.peekEq(\"/\")) {\n                        this.skipComment();\n                        return;\n                    }\n                    else {\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Divide];\n                    }\n                case \"g\":\n                    if (this.input[this.cursor] == \"a\" &&\n                        this.input[this.cursor + 1] == \"t\" &&\n                        this.input[this.cursor + 2] == \"e\") {\n                        this.readChar(3);\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Gate];\n                    }\n                    {\n                        const literal = char + this.readIdentifier();\n                        return [(0,_token__WEBPACK_IMPORTED_MODULE_0__.lookup)(literal), literal];\n                    }\n                case \"q\":\n                    if (this.input[this.cursor] == \"r\" &&\n                        this.input[this.cursor + 1] == \"e\" &&\n                        this.input[this.cursor + 2] == \"g\") {\n                        this.readChar(3);\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.QReg];\n                    }\n                    {\n                        const qregLit = char + this.readIdentifier();\n                        return [(0,_token__WEBPACK_IMPORTED_MODULE_0__.lookup)(qregLit), qregLit];\n                    }\n                case \"c\":\n                    if (this.input[this.cursor] == \"r\" &&\n                        this.input[this.cursor + 1] == \"e\" &&\n                        this.input[this.cursor + 2] == \"g\") {\n                        this.readChar(3);\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.CReg];\n                    }\n                    {\n                        const cregLit = char + this.readIdentifier();\n                        return [(0,_token__WEBPACK_IMPORTED_MODULE_0__.lookup)(cregLit), cregLit];\n                    }\n                case \"b\":\n                    if (this.input[this.cursor] == \"a\" &&\n                        this.input[this.cursor + 1] == \"r\" &&\n                        this.input[this.cursor + 2] == \"r\" &&\n                        this.input[this.cursor + 3] == \"i\" &&\n                        this.input[this.cursor + 4] == \"e\" &&\n                        this.input[this.cursor + 5] == \"r\") {\n                        this.readChar(6);\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Barrier];\n                    }\n                    {\n                        const barLit = char + this.readIdentifier();\n                        return [(0,_token__WEBPACK_IMPORTED_MODULE_0__.lookup)(barLit), barLit];\n                    }\n                case \"m\":\n                    if (this.input[this.cursor] == \"e\" &&\n                        this.input[this.cursor + 1] == \"a\" &&\n                        this.input[this.cursor + 2] == \"s\" &&\n                        this.input[this.cursor + 3] == \"u\" &&\n                        this.input[this.cursor + 4] == \"r\" &&\n                        this.input[this.cursor + 5] == \"e\") {\n                        this.readChar(6);\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Measure];\n                    }\n                    {\n                        const measureLit = char + this.readIdentifier();\n                        return [(0,_token__WEBPACK_IMPORTED_MODULE_0__.lookup)(measureLit), measureLit];\n                    }\n                case \"O\":\n                    if (this.input[this.cursor].toLowerCase() == \"p\" &&\n                        this.input[this.cursor + 1].toLowerCase() == \"e\" &&\n                        this.input[this.cursor + 2].toLowerCase() == \"n\" &&\n                        this.input[this.cursor + 3] == \"Q\" &&\n                        this.input[this.cursor + 4] == \"A\" &&\n                        this.input[this.cursor + 5] == \"S\" &&\n                        this.input[this.cursor + 6] == \"M\") {\n                        this.readChar(7);\n                        let offset = 0;\n                        while (this.cursor + offset < this.input.length &&\n                            \" \\t\".indexOf(this.input[this.cursor + offset]) > -1) {\n                            offset++;\n                        }\n                        // Read the major version\n                        let majorVersion = \"\";\n                        while (this.cursor + offset < this.input.length &&\n                            !isNaN(parseInt(this.input[this.cursor + offset], 10))) {\n                            majorVersion += this.input[this.cursor + offset];\n                            offset++;\n                        }\n                        // Attempt to read the minor version\n                        let minorVersion = undefined;\n                        if (this.input[this.cursor + offset] == \".\") {\n                            offset++;\n                            minorVersion = \"\";\n                            while (this.cursor + offset < this.input.length &&\n                                !isNaN(parseInt(this.input[this.cursor + offset], 10))) {\n                                minorVersion += this.input[this.cursor + offset];\n                                offset++;\n                            }\n                        }\n                        // Parse major and minor versions\n                        const major = parseInt(majorVersion, 10);\n                        const minor = minorVersion ? parseInt(minorVersion, 10) : undefined;\n                        if (major !== 2) {\n                            throw new _errors__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOpenQASMVersionError(`Unsupported OpenQASM version detected: ${majorVersion}.${minor !== null && minor !== void 0 ? minor : 0}`);\n                        }\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.OpenQASM];\n                    }\n                    {\n                        const openQasmLit = char + this.readIdentifier();\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.lookup[openQasmLit], openQasmLit];\n                    }\n                case \"i\":\n                    if (this.input[this.cursor] == \"n\" &&\n                        this.input[this.cursor + 1] == \"c\" &&\n                        this.input[this.cursor + 2] == \"l\" &&\n                        this.input[this.cursor + 3] == \"u\" &&\n                        this.input[this.cursor + 4] == \"d\" &&\n                        this.input[this.cursor + 5] == \"e\") {\n                        this.readChar(6);\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Include];\n                    }\n                    {\n                        const includeLit = char + this.readIdentifier();\n                        return [(0,_token__WEBPACK_IMPORTED_MODULE_0__.lookup)(includeLit), includeLit];\n                    }\n                case \"o\":\n                    if (this.input[this.cursor] == \"p\" &&\n                        this.input[this.cursor + 1] == \"a\" &&\n                        this.input[this.cursor + 2] == \"q\" &&\n                        this.input[this.cursor + 3] == \"u\" &&\n                        this.input[this.cursor + 4] == \"e\") {\n                        this.readChar(5);\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Opaque];\n                    }\n                    {\n                        const opaqueLit = char + this.readIdentifier();\n                        return [(0,_token__WEBPACK_IMPORTED_MODULE_0__.lookup)(opaqueLit), opaqueLit];\n                    }\n                case '\"': {\n                    const stringLiteral = char + this.readStringLiteral('\"');\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.String, stringLiteral];\n                }\n                case \"’\": {\n                    const singleStringLiteral = char + this.readStringLiteral(\"’\");\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.String, singleStringLiteral];\n                }\n                default:\n                    if (isLetter(char)) {\n                        const literal = char + this.readIdentifier();\n                        return [(0,_token__WEBPACK_IMPORTED_MODULE_0__.lookup)(literal), literal];\n                    }\n                    else if (isNumeric(char)) {\n                        const num = char + this.readNumeric();\n                        if (num.indexOf(\".\") != -1) {\n                            return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Real, parseFloat(num)];\n                        }\n                        else {\n                            return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.NNInteger, parseFloat(num)];\n                        }\n                    }\n                    else {\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Illegal];\n                    }\n            }\n        };\n        /**\n         * Returns the line number where the current cursor is located.\n         * @param cursor - The current cursor position in the input string.\n         * @return The line number.\n         */\n        this.getLineNumber = (cursor) => {\n            return this.input\n                .substring(0, cursor)\n                .split(/\\n|\\r(?!\\n)|\\u2028|\\u2029|\\r\\n/).length;\n        };\n        /**\n         * Returns the current line of code where the cursor is located.\n         * @param cursor - The current cursor position in the input string.\n         * @return The specific line where the cursor is located.\n         */\n        this.getCurrentLine = (cursor) => {\n            const lines = this.input.split(/\\n|\\r(?!\\n)|\\u2028|\\u2029|\\r\\n/);\n            const lineNumber = this.getLineNumber(cursor);\n            return lines[lineNumber - 1];\n        };\n        this.input = input;\n        this.cursor = cursor;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Lexer);\n\n\n//# sourceURL=webpack://qasm-quantum-simulator/./node_modules/qasm-ts/dist/qasm2/lexer.js?\n}");

/***/ }),

/***/ "./node_modules/qasm-ts/dist/qasm2/parser.js":
/*!***************************************************!*\
  !*** ./node_modules/qasm-ts/dist/qasm2/parser.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _token__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./token */ \"./node_modules/qasm-ts/dist/qasm2/token.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../version */ \"./node_modules/qasm-ts/dist/version.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../errors */ \"./node_modules/qasm-ts/dist/errors.js\");\n/* harmony import */ var _ast__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ast */ \"./node_modules/qasm-ts/dist/qasm2/ast.js\");\n/**\n * OpenQASM 2.0 Parser Implementation\n *\n * This module implements a parser for OpenQASM 2.0 that focuses on the core\n * quantum circuit description language without the advanced features of version 3.0.\n * The parser handles quantum and classical register declarations, gate definitions\n * and applications, measurements, and basic control structures.\n *\n * OpenQASM 2.0 parsing capabilities:\n * - **Register declarations**: qreg and creg with size specifications\n * - **Gate definitions**: Custom gate definitions with parameters and bodies\n * - **Gate applications**: Built-in and custom gate applications\n * - **Measurements**: Quantum measurements with classical result storage\n * - **Basic conditionals**: Simple if statements based on classical register values\n * - **Arithmetic expressions**: Parameter expressions for gate operations\n * - **Opaque gates**: External gate declarations\n *\n * The parser maintains a list of known gates and validates gate applications\n * against declared gates and built-in operations.\n *\n * @module\n *\n * @example Parsing OpenQASM 2.0 code\n * ```typescript\n * const tokens = lexer.lex();\n * const parser = new Parser(tokens);\n * const ast = parser.parse();\n *\n * // AST contains simplified node structure for OpenQASM 2.0\n * ```\n */\n\n\n\n\n/**\n * OpenQASM 2.0 Parser\n *\n * A straightforward recursive descent parser for OpenQASM 2.0 that produces\n * a simplified AST structure appropriate for the more limited feature set\n * of the 2.0 language specification.\n *\n * @example Basic parsing workflow\n * ```typescript\n * const parser = new Parser(tokens);\n * const ast = parser.parse();\n *\n * // Process the resulting AST nodes\n * ast.forEach(node => {\n *   if (node instanceof QReg) {\n *     console.log(`Quantum register: ${node.id}[${node.size}]`);\n *   }\n * });\n * ```\n */\nclass Parser {\n    /**\n     * Creates a parser.\n     * @param tokens - Tokens to parse.\n     */\n    constructor(tokens) {\n        this.tokens = tokens;\n        this.gates = [\n            \"x\",\n            \"y\",\n            \"z\",\n            \"u1\",\n            \"u2\",\n            \"u3\",\n            \"s\",\n            \"sdg\",\n            \"h\",\n            \"tdg\",\n            \"cx\",\n            \"cy\",\n            \"cz\",\n            \"t\",\n            \"ccx\",\n            \"reset\",\n            \"cu1\",\n            \"ccy\",\n            \"ccz\",\n        ];\n    }\n    /**\n     * Calling this method parses the code represented by the provided tokens.\n     * @return The abstract syntax tree.\n     */\n    parse() {\n        let ast = [];\n        let i = 0;\n        while (i < this.tokens.length - 1) {\n            const nodes = this.parseNode(this.tokens.slice(i));\n            ast = ast.concat(nodes ? nodes : []);\n            while (!this.matchNext(this.tokens.slice(i), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n                if (this.matchNext(this.tokens.slice(i), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LCParen])) {\n                    while (!this.matchNext(this.tokens.slice(i), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RCParen])) {\n                        i++;\n                    }\n                    break;\n                }\n                i++;\n            }\n            i++;\n        }\n        return ast;\n    }\n    /**\n    * Delegates the parsing of the next set of tokens to the appropriate method.\n    * @param tokens - Remaining tokens to parse.\n    * @param allowVariables - Whether encountered identifiers should be consider\n        variable initializations or references.\n    * @return A set of AST nodes.\n    */\n    parseNode(tokens, allowVariables = false) {\n        const token = tokens[0];\n        switch (token[0]) {\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Include:\n                return [this.include(tokens.slice(1))];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.OpenQASM:\n                return [this.versionHeader(tokens.slice(1))];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.QReg:\n                return [this.qreg(tokens.slice(1))];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.CReg:\n                return [this.creg(tokens.slice(1))];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Barrier:\n                return [this.barrier(tokens.slice(1))];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Measure:\n                return [this.measure(tokens.slice(1))];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Id:\n                if (!(token[1].toString().indexOf(\"QASM\") != -1) &&\n                    !(token[1].toString().indexOf(\"include\") != -1)) {\n                    if (this.gates.includes(token[1].toString())) {\n                        return [this.application(tokens, token[1].toString())];\n                    }\n                    else if (allowVariables) {\n                        return [new _ast__WEBPACK_IMPORTED_MODULE_3__.Variable(token[1].toString())];\n                    }\n                    else {\n                        throw _errors__WEBPACK_IMPORTED_MODULE_2__.BadGateError;\n                    }\n                }\n                else {\n                    return [];\n                }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Gate:\n                return [this.gate(tokens.slice(1))];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Opaque:\n                return [this.opaque(tokens.slice(1))];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.If:\n                return [this.conditional(tokens.slice(1))];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Power:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.Power()];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Divide:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.Divide()];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Times:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.Times()];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Plus:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.Plus()];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Minus:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.Minus()];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Pi:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.Pi()];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Sin:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.Sin()];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Cos:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.Cos()];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Exp:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.Exp()];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Ln:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.Ln()];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Sqrt:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.Sqrt()];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Tan:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.Tan()];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.NNInteger:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.NNInteger(Number(token[1]))];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Real:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.Real(Number(token[1]))];\n        }\n    }\n    /**\n     * Checks if the next tokens match those expected.\n     * @param tokens - Remaining tokens to parse.\n     * @param expectedTokens - Expected tokens.\n     * @return Whether these is a match.\n     */\n    matchNext(tokens, expectedTokens) {\n        let matches = true;\n        let i = 0;\n        if (tokens.length == 0) {\n            return false;\n        }\n        while (i < expectedTokens.length) {\n            if (tokens[i][0] != expectedTokens[i]) {\n                matches = false;\n                break;\n            }\n            i++;\n        }\n        return matches;\n    }\n    /**\n     * Parses a quantum register.\n     * @param tokens - Remaining tokens to parse.\n     * @return An AST node representing the quantum register.\n     */\n    qreg(tokens) {\n        if (this.matchNext(tokens, [\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.Id,\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.LSParen,\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.NNInteger,\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.RSParen,\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon,\n        ])) {\n            const id = tokens[0][1].toString();\n            if (!this.validateIdentifier(id)) {\n                throw _errors__WEBPACK_IMPORTED_MODULE_2__.BadQregError;\n            }\n            const size = tokens[2][1];\n            return new _ast__WEBPACK_IMPORTED_MODULE_3__.QReg(id.toString(), Number(size));\n        }\n        else {\n            throw _errors__WEBPACK_IMPORTED_MODULE_2__.BadQregError;\n        }\n    }\n    /**\n     * Parses a classical register.\n     * @param tokens - Remaining tokens to parse.\n     * @return An AST node representing the classical register.\n     */\n    creg(tokens) {\n        if (this.matchNext(tokens, [\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.Id,\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.LSParen,\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.NNInteger,\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.RSParen,\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon,\n        ])) {\n            const id = tokens[0][1].toString();\n            if (!this.validateIdentifier(id)) {\n                throw _errors__WEBPACK_IMPORTED_MODULE_2__.BadCregError;\n            }\n            const size = tokens[2][1];\n            return new _ast__WEBPACK_IMPORTED_MODULE_3__.CReg(id.toString(), Number(size));\n        }\n        else {\n            throw _errors__WEBPACK_IMPORTED_MODULE_2__.BadCregError;\n        }\n    }\n    /**\n     * Parses a conditional.\n     * @param tokens - Remaining tokens to parse.\n     * @return An AST node representing the conditional.\n     */\n    conditional(tokens) {\n        if (this.matchNext(tokens, [\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.LParen,\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.Id,\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.Equals,\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.NNInteger,\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.RParen,\n        ])) {\n            const id = tokens[1][1];\n            const val = tokens[3][1];\n            const node = this.parseNode(tokens.slice(5));\n            return new _ast__WEBPACK_IMPORTED_MODULE_3__.If(id.toString(), Number(val), node);\n        }\n        else {\n            throw _errors__WEBPACK_IMPORTED_MODULE_2__.BadConditionalError;\n        }\n    }\n    /**\n     * Parses a barrier.\n     * @param tokens - Remaining tokens to parse.\n     * @return An AST node representing the barrier.\n     */\n    barrier(tokens) {\n        if (this.matchNext(tokens, [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Id, _token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n            const id = tokens[0][1];\n            return new _ast__WEBPACK_IMPORTED_MODULE_3__.Barrier(id.toString());\n        }\n        else if (this.matchNext(tokens, [\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.Id,\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.LParen,\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.NNInteger,\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.RParen,\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon,\n        ])) {\n            const id = tokens[0][1];\n            const index = tokens[2][1];\n            return new _ast__WEBPACK_IMPORTED_MODULE_3__.Barrier(id.toString(), Number(index));\n        }\n        else {\n            throw _errors__WEBPACK_IMPORTED_MODULE_2__.BadBarrierError;\n        }\n    }\n    /**\n     * Parses a measurement.\n     * @param tokens - Remaining tokens to parse.\n     * @return An AST node representing the measurement.\n     */\n    measure(tokens) {\n        let first_id;\n        let second_id;\n        let first_index;\n        let second_index;\n        if (this.matchNext(tokens, [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Id, _token__WEBPACK_IMPORTED_MODULE_0__.Token.Arrow])) {\n            first_id = tokens[0][1].toString();\n            tokens = tokens.slice(2);\n        }\n        else if (this.matchNext(tokens, [\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.Id,\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.LSParen,\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.NNInteger,\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.RSParen,\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.Arrow,\n        ])) {\n            first_id = tokens[0][1].toString();\n            first_index = Number(tokens[2][1]);\n            tokens = tokens.slice(5);\n        }\n        else {\n            throw _errors__WEBPACK_IMPORTED_MODULE_2__.BadMeasurementError;\n        }\n        if (this.matchNext(tokens, [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Id, _token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n            second_id = tokens[0][1].toString();\n            tokens = tokens.slice(2);\n        }\n        else if (this.matchNext(tokens, [\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.Id,\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.LSParen,\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.NNInteger,\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.RSParen,\n            _token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon,\n        ])) {\n            second_id = tokens[0][1].toString();\n            second_index = Number(tokens[2][1]);\n            tokens = tokens.slice(5);\n        }\n        else {\n            throw _errors__WEBPACK_IMPORTED_MODULE_2__.BadMeasurementError;\n        }\n        if (first_index != undefined && second_index != undefined) {\n            return new _ast__WEBPACK_IMPORTED_MODULE_3__.Measure(first_id, second_id, first_index, second_index);\n        }\n        else if (first_index != undefined) {\n            return new _ast__WEBPACK_IMPORTED_MODULE_3__.Measure(first_id, second_id, first_index, null);\n        }\n        else if (second_index != undefined) {\n            return new _ast__WEBPACK_IMPORTED_MODULE_3__.Measure(first_id, second_id, null, second_index);\n        }\n        return new _ast__WEBPACK_IMPORTED_MODULE_3__.Measure(first_id, second_id);\n    }\n    /**\n     * Parses an application of one of the allowed gates.\n     * @param tokens - Remaining tokens to parse.\n     * @return An AST node representing the gate application.\n     */\n    application(tokens, op) {\n        let params = [];\n        const list = [];\n        const applications = [];\n        if (tokens[0][1] == op) {\n            tokens = tokens.slice(1);\n        }\n        if (this.matchNext(tokens, [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LParen])) {\n            if (this.matchNext(tokens.slice(1), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RParen])) {\n                params = [];\n                tokens = tokens.slice(2);\n            }\n            else {\n                params = this.matchParamList(tokens.slice(1));\n                let count = 0;\n                let commas = 0;\n                for (const i in params) {\n                    commas += 1;\n                    for (const j in params[i]) {\n                        count++;\n                    }\n                }\n                tokens = tokens.slice(count + (commas - 1) + 2);\n            }\n        }\n        const args = this.matchArgList(tokens);\n        for (const arg in args) {\n            list.push(args[arg]);\n        }\n        applications.push(new _ast__WEBPACK_IMPORTED_MODULE_3__.ApplyGate(op, list, params));\n        return applications;\n    }\n    /**\n     * Parses a subroutine used in a custom gate definition.\n     * @param tokens - Expression tokens to parse.\n     * @return A parsed subroutine.\n     */\n    sub(tokens) {\n        let ast = [];\n        let i = 0;\n        if (this.matchNext(tokens.slice(i), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LCParen])) {\n            tokens = tokens.slice(1);\n        }\n        while (i < tokens.length - 1 && tokens[i][0] != _token__WEBPACK_IMPORTED_MODULE_0__.Token.RCParen) {\n            const nodes = this.parseNode(tokens.slice(i));\n            ast = ast.concat(nodes ? nodes : []);\n            while (!this.matchNext(tokens.slice(i), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon]) &&\n                !this.matchNext(tokens.slice(i), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RCParen])) {\n                i++;\n            }\n            if (this.matchNext(tokens.slice(i), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RCParen])) {\n                break;\n            }\n            i++;\n        }\n        return ast;\n    }\n    /**\n     * Parses a parameter value.\n     * @param tokens - Tokens to parse.\n     * @return An AST node representing the parameter value.\n     */\n    matchParam(tokens) {\n        let param;\n        if (!(0,_token__WEBPACK_IMPORTED_MODULE_0__.notParam)(tokens[0][0])) {\n            param = this.parseNode([tokens[0]], true);\n        }\n        else {\n            throw _errors__WEBPACK_IMPORTED_MODULE_2__.BadParameterError;\n        }\n        return param;\n    }\n    /**\n     * Parses a list of parameter values.\n     * @param tokens - Tokens to parse.\n     * @return An array of AST nodes representing the parameter values.\n     */\n    matchParamList(tokens) {\n        const args = [];\n        let i = 0;\n        let j = 0;\n        args[0] = [];\n        while (!this.matchNext(tokens.slice(j), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RParen])) {\n            while (!this.matchNext(tokens.slice(j), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Comma]) &&\n                !this.matchNext(tokens.slice(j), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RParen])) {\n                if ((0,_token__WEBPACK_IMPORTED_MODULE_0__.notParam)(tokens[j][0])) {\n                    throw _errors__WEBPACK_IMPORTED_MODULE_2__.BadParameterError;\n                }\n                const next = this.matchParam(tokens.slice(j));\n                args[i].push(next);\n                j++;\n            }\n            if (this.matchNext(tokens.slice(j), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RParen])) {\n                break;\n            }\n            i++;\n            j++;\n            args[i] = [];\n        }\n        return args;\n    }\n    /**\n     * Parses an argument value.\n     * @param tokens - Tokens to parse.\n     * @return An AST node representing the argument value.\n     */\n    matchArg(tokens) {\n        let index;\n        if (this.matchNext(tokens, [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LSParen])) {\n            tokens = tokens.slice(1);\n            if (this.matchNext(tokens, [_token__WEBPACK_IMPORTED_MODULE_0__.Token.NNInteger])) {\n                index = Number(tokens[0][1]);\n                tokens = tokens.slice(1);\n            }\n            else {\n                throw _errors__WEBPACK_IMPORTED_MODULE_2__.BadArgumentError;\n            }\n            if (this.matchNext(tokens, [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RSParen])) {\n                return index;\n            }\n            else {\n                throw _errors__WEBPACK_IMPORTED_MODULE_2__.BadArgumentError;\n            }\n        }\n    }\n    /**\n     * Parses a list of argument values.\n     * @param tokens - Tokens to parse.\n     * @return An array of AST nodes representing the argument values.\n     */\n    matchArgList(tokens) {\n        const args = [];\n        let next;\n        let id;\n        let j = 0;\n        while (j < tokens.length &&\n            !this.matchNext(tokens.slice(j), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n            if (this.matchNext(tokens.slice(j), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Id])) {\n                id = tokens[j][1].toString();\n                const index = this.matchArg(tokens.slice(j + 1));\n                next = [id, index];\n                args.push(next);\n                if (index != undefined) {\n                    j += 4;\n                }\n                else {\n                    j++;\n                }\n                if (this.matchNext(tokens.slice(j), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Comma])) {\n                    j++;\n                }\n            }\n            else {\n                throw _errors__WEBPACK_IMPORTED_MODULE_2__.BadArgumentError;\n            }\n        }\n        return args;\n    }\n    /**\n     * Parses an include statement.\n     * @param tokens - Tokens to parse.\n     * @return An Include node representing the include statement.\n     */\n    include(tokens) {\n        let filename;\n        if (this.matchNext(tokens, [_token__WEBPACK_IMPORTED_MODULE_0__.Token.String, _token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n            filename = tokens[0][1].toString();\n            return new _ast__WEBPACK_IMPORTED_MODULE_3__.Include(filename);\n        }\n        throw _errors__WEBPACK_IMPORTED_MODULE_2__.BadIncludeError;\n    }\n    /**\n     * Parses the version header and sets the parser version.\n     * @param tokens - Tokens to parse.\n     * @return A Version node representing the version statement.\n     */\n    versionHeader(tokens) {\n        let version;\n        if (this.matchNext(tokens, [_token__WEBPACK_IMPORTED_MODULE_0__.Token.NNInteger, _token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n            version = new _version__WEBPACK_IMPORTED_MODULE_1__.OpenQASMVersion(Number(tokens[0][1]));\n            if (!version.isVersion2()) {\n                throw _errors__WEBPACK_IMPORTED_MODULE_2__.UnsupportedOpenQASMVersionError;\n            }\n            return new _ast__WEBPACK_IMPORTED_MODULE_3__.Version(version);\n        }\n        else if (this.matchNext(tokens, [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Real, _token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n            const versionSplits = tokens[0][1].toString().split(\".\");\n            version = new _version__WEBPACK_IMPORTED_MODULE_1__.OpenQASMVersion(Number(versionSplits[0]), Number(versionSplits[1]));\n            if (!version.isVersion2()) {\n                throw _errors__WEBPACK_IMPORTED_MODULE_2__.UnsupportedOpenQASMVersionError;\n            }\n            return new _ast__WEBPACK_IMPORTED_MODULE_3__.Version(version);\n        }\n        throw _errors__WEBPACK_IMPORTED_MODULE_2__.UnsupportedOpenQASMVersionError;\n    }\n    /**\n     * Parses a list of identifiers.\n     * @param tokens - Tokens to parse.\n     * @return An array of AST nodes representing the identifiers.\n     */\n    matchIdList(tokens) {\n        let args = [];\n        let head;\n        if (this.matchNext(tokens, [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Id])) {\n            head = tokens[0][1].toString();\n        }\n        tokens = tokens.slice(1);\n        args.push(head);\n        if (this.matchNext(tokens, [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Comma])) {\n            tokens = tokens.slice(1);\n            const sub = this.matchIdList(tokens);\n            args = args.concat(sub);\n        }\n        return args;\n    }\n    /**\n     * Parses a gate.\n     * @param tokens - Remaining tokens to parse.\n     * @return An AST node representing the gate.\n     */\n    gate(tokens) {\n        let name;\n        let params;\n        if (this.matchNext(tokens, [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Id])) {\n            name = tokens[0][1].toString();\n            if (!this.validateIdentifier(name)) {\n                throw _errors__WEBPACK_IMPORTED_MODULE_2__.BadGateError;\n            }\n        }\n        else {\n            throw _errors__WEBPACK_IMPORTED_MODULE_2__.BadGateError;\n        }\n        tokens = tokens.slice(1);\n        if (this.matchNext(tokens, [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LParen])) {\n            tokens = tokens.slice(1);\n            if (this.matchNext(tokens, [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RParen])) {\n                params = [];\n                tokens = tokens.slice(1);\n            }\n            else {\n                params = this.matchIdList(tokens);\n                const count = params.length;\n                tokens = tokens.slice(count + 1);\n            }\n        }\n        const registers = this.matchIdList(tokens);\n        const count = registers.length;\n        tokens = tokens.slice(count + (count - 1));\n        const applications = this.sub(tokens);\n        this.gates.push(name);\n        return new _ast__WEBPACK_IMPORTED_MODULE_3__.Gate(name, registers, params, applications);\n    }\n    /**\n     * Parses an opaque declaration if using OpenQASM 2. If using OpenQASM 3 it skips the line.\n     * @param tokens - Remaining tokens to parse.\n     * @return An AST node representing the opaque declaration.\n     */\n    opaque(tokens) {\n        let name;\n        let params;\n        let qubits = [];\n        if (this.matchNext(tokens, [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Id])) {\n            name = tokens[0][1].toString();\n            tokens = tokens.slice(1);\n        }\n        else {\n            throw _errors__WEBPACK_IMPORTED_MODULE_2__.BadGateError;\n        }\n        if (this.matchNext(tokens, [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LParen])) {\n            tokens = tokens.slice(1);\n            if (!this.matchNext(tokens, [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RParen])) {\n                params = this.matchIdList(tokens);\n                tokens = tokens.slice(params.length + 1);\n            }\n            else {\n                tokens = tokens.slice(1);\n            }\n        }\n        qubits = this.matchArgList(tokens);\n        tokens = tokens.slice(qubits.length * 2);\n        if (!this.matchNext(tokens, [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n            throw _errors__WEBPACK_IMPORTED_MODULE_2__.BadGateError;\n        }\n        return new _ast__WEBPACK_IMPORTED_MODULE_3__.Opaque(name, qubits, params);\n    }\n    /**\n     * Validates whether a register or gate identifier.\n     * @param identifier - The identifier to validate.\n     * @return Boolean indicating successful validation or not.\n     */\n    validateIdentifier(identifier) {\n        const firstChar = identifier[0];\n        return /^[a-z]$/.test(firstChar);\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Parser);\n\n\n//# sourceURL=webpack://qasm-quantum-simulator/./node_modules/qasm-ts/dist/qasm2/parser.js?\n}");

/***/ }),

/***/ "./node_modules/qasm-ts/dist/qasm2/token.js":
/*!**************************************************!*\
  !*** ./node_modules/qasm-ts/dist/qasm2/token.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Token: () => (/* binding */ Token),\n/* harmony export */   inverseLookup: () => (/* binding */ inverseLookup),\n/* harmony export */   lookup: () => (/* binding */ lookup),\n/* harmony export */   notParam: () => (/* binding */ notParam)\n/* harmony export */ });\n/**\n * OpenQASM 2.0 Token Definitions and Utilities\n *\n * This module defines the token types used in OpenQASM 2.0 syntax. OpenQASM 2.0\n * has a simpler token set compared to 3.0, focusing on basic quantum operations\n * and classical registers without advanced control flow or data types.\n *\n * Key differences from OpenQASM 3.0:\n * - Limited to `qreg` and `creg` declarations (no advanced types)\n * - No control flow tokens (if/else/for/while)\n * - No subroutine or function definitions\n * - Simpler expression and operator support\n *\n * @module\n *\n * @example OpenQASM 2.0 token usage\n * ```typescript\n * import { lookup, Token } from './qasm2/token';\n *\n * console.log(lookup('qreg'));    // Token.QReg\n * console.log(lookup('barrier')); // Token.Barrier\n * console.log(lookup('measure')); // Token.Measure\n * ```\n */\n/**\n * Enumeration of OpenQASM 2.0 token types.\n *\n * This simplified token set reflects OpenQASM 2.0's focus on basic quantum\n * circuit description without the advanced features of version 3.0.\n */\nvar Token;\n(function (Token) {\n    // 0; invalid or unrecognized token\n    Token[Token[\"Illegal\"] = 0] = \"Illegal\";\n    // 1; end of file character\n    Token[Token[\"EndOfFile\"] = 1] = \"EndOfFile\";\n    // 2; real number (floating point)\n    Token[Token[\"Real\"] = 2] = \"Real\";\n    // 3; non-negative integer\n    Token[Token[\"NNInteger\"] = 3] = \"NNInteger\";\n    // 4; identifier (variables names, function names, etc.)\n    Token[Token[\"Id\"] = 4] = \"Id\";\n    // 5; OPENQASM version declaration\n    Token[Token[\"OpenQASM\"] = 5] = \"OpenQASM\";\n    // 6; semicolon to terminate statements\n    Token[Token[\"Semicolon\"] = 6] = \"Semicolon\";\n    // 7; comma\n    Token[Token[\"Comma\"] = 7] = \"Comma\";\n    // 8; left paren (\n    Token[Token[\"LParen\"] = 8] = \"LParen\";\n    // 9; left square bracket [\n    Token[Token[\"LSParen\"] = 9] = \"LSParen\";\n    // 10; left curly brakcet {\n    Token[Token[\"LCParen\"] = 10] = \"LCParen\";\n    // 11; right paren )\n    Token[Token[\"RParen\"] = 11] = \"RParen\";\n    // 12; right square paren ]\n    Token[Token[\"RSParen\"] = 12] = \"RSParen\";\n    // 13; right curly bracket }\n    Token[Token[\"RCParen\"] = 13] = \"RCParen\";\n    // 14; arrow (->) used in measurement operations\n    Token[Token[\"Arrow\"] = 14] = \"Arrow\";\n    // 15; equality operator (==)\n    Token[Token[\"Equals\"] = 15] = \"Equals\";\n    // 16; addition operator (+)\n    Token[Token[\"Plus\"] = 16] = \"Plus\";\n    // 17; subtraction operator (-)\n    Token[Token[\"Minus\"] = 17] = \"Minus\";\n    // 18; multiplication operator (*)\n    Token[Token[\"Times\"] = 18] = \"Times\";\n    // 19; division operator (/)\n    Token[Token[\"Divide\"] = 19] = \"Divide\";\n    // 20; exponentiation operator (^)\n    Token[Token[\"Power\"] = 20] = \"Power\";\n    // 21; sine function\n    Token[Token[\"Sin\"] = 21] = \"Sin\";\n    // 22; cosine function\n    Token[Token[\"Cos\"] = 22] = \"Cos\";\n    // 23; tangent function\n    Token[Token[\"Tan\"] = 23] = \"Tan\";\n    // 24; exponential function\n    Token[Token[\"Exp\"] = 24] = \"Exp\";\n    // 25; natural logarithm function\n    Token[Token[\"Ln\"] = 25] = \"Ln\";\n    // 26; square root function\n    Token[Token[\"Sqrt\"] = 26] = \"Sqrt\";\n    // 27; mathematical constant pi\n    Token[Token[\"Pi\"] = 27] = \"Pi\";\n    // 28; quantum register declaration\n    Token[Token[\"QReg\"] = 28] = \"QReg\";\n    // 29; classical register declaration\n    Token[Token[\"CReg\"] = 29] = \"CReg\";\n    // 30; barrier operation\n    Token[Token[\"Barrier\"] = 30] = \"Barrier\";\n    // 31; gate declaration or application\n    Token[Token[\"Gate\"] = 31] = \"Gate\";\n    // 32; measurement operation\n    Token[Token[\"Measure\"] = 32] = \"Measure\";\n    // 33; qubit reset operation\n    Token[Token[\"Reset\"] = 33] = \"Reset\";\n    // 34; include statement\n    Token[Token[\"Include\"] = 34] = \"Include\";\n    // 35; if statement conditional\n    Token[Token[\"If\"] = 35] = \"If\";\n    // 36; string literal\n    Token[Token[\"String\"] = 36] = \"String\";\n    // 37; opaque keyword\n    Token[Token[\"Opaque\"] = 37] = \"Opaque\";\n})(Token || (Token = {}));\nconst lookupMap = {\n    if: Token.If,\n    sin: Token.Sin,\n    cos: Token.Cos,\n    tan: Token.Tan,\n    exp: Token.Exp,\n    ln: Token.Ln,\n    sqrt: Token.Sqrt,\n    pi: Token.Pi,\n    \"+\": Token.Plus,\n    \"-\": Token.Minus,\n    \"/\": Token.Divide,\n    \"*\": Token.Times,\n    \"^\": Token.Power,\n};\n/**\n * Returns the token that represents a given string.\n * @param ident - The string.\n * @return The corresponding token.\n */\nfunction lookup(ident) {\n    return ident in lookupMap ? lookupMap[ident] : Token.Id;\n}\n/**\n * Returns the string representation of a token.\n * @param tokens - The token.\n * @return The string representation of the token.\n */\nfunction inverseLookup(token) {\n    return Object.keys(lookupMap).find((ident) => lookupMap[ident] == token);\n}\n/**\n * Determines whether a token denotes a parameter.\n * @param tokens - The token.\n * @return Whether the token does NOT denote a parameter.\n */\nfunction notParam(token) {\n    if (token == Token.NNInteger ||\n        token == Token.Real ||\n        token == Token.Id ||\n        inverseLookup(token)) {\n        return false;\n    }\n    return true;\n}\n\n\n\n//# sourceURL=webpack://qasm-quantum-simulator/./node_modules/qasm-ts/dist/qasm2/token.js?\n}");

/***/ }),

/***/ "./node_modules/qasm-ts/dist/qasm3/ast.js":
/*!************************************************!*\
  !*** ./node_modules/qasm-ts/dist/qasm3/ast.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AliasStatement: () => (/* binding */ AliasStatement),\n/* harmony export */   AngleType: () => (/* binding */ AngleType),\n/* harmony export */   Arithmetic: () => (/* binding */ Arithmetic),\n/* harmony export */   ArithmeticOp: () => (/* binding */ ArithmeticOp),\n/* harmony export */   ArrayAccess: () => (/* binding */ ArrayAccess),\n/* harmony export */   ArrayDeclaration: () => (/* binding */ ArrayDeclaration),\n/* harmony export */   ArrayInitializer: () => (/* binding */ ArrayInitializer),\n/* harmony export */   ArrayReference: () => (/* binding */ ArrayReference),\n/* harmony export */   ArrayReferenceModifier: () => (/* binding */ ArrayReferenceModifier),\n/* harmony export */   AssignmentStatement: () => (/* binding */ AssignmentStatement),\n/* harmony export */   AstNode: () => (/* binding */ AstNode),\n/* harmony export */   Binary: () => (/* binding */ Binary),\n/* harmony export */   BinaryOp: () => (/* binding */ BinaryOp),\n/* harmony export */   BitType: () => (/* binding */ BitType),\n/* harmony export */   BitstringLiteral: () => (/* binding */ BitstringLiteral),\n/* harmony export */   BoolType: () => (/* binding */ BoolType),\n/* harmony export */   BooleanLiteral: () => (/* binding */ BooleanLiteral),\n/* harmony export */   BoxDefinition: () => (/* binding */ BoxDefinition),\n/* harmony export */   BranchingStatement: () => (/* binding */ BranchingStatement),\n/* harmony export */   BreakStatement: () => (/* binding */ BreakStatement),\n/* harmony export */   CalibrationGrammarDeclaration: () => (/* binding */ CalibrationGrammarDeclaration),\n/* harmony export */   CaseStatement: () => (/* binding */ CaseStatement),\n/* harmony export */   Cast: () => (/* binding */ Cast),\n/* harmony export */   ClassicalDeclaration: () => (/* binding */ ClassicalDeclaration),\n/* harmony export */   ClassicalType: () => (/* binding */ ClassicalType),\n/* harmony export */   ComplexType: () => (/* binding */ ComplexType),\n/* harmony export */   ContinueStatement: () => (/* binding */ ContinueStatement),\n/* harmony export */   DefaultStatement: () => (/* binding */ DefaultStatement),\n/* harmony export */   DurationLiteral: () => (/* binding */ DurationLiteral),\n/* harmony export */   DurationOf: () => (/* binding */ DurationOf),\n/* harmony export */   DurationType: () => (/* binding */ DurationType),\n/* harmony export */   DurationUnit: () => (/* binding */ DurationUnit),\n/* harmony export */   Euler: () => (/* binding */ Euler),\n/* harmony export */   Expression: () => (/* binding */ Expression),\n/* harmony export */   ExternSignature: () => (/* binding */ ExternSignature),\n/* harmony export */   FloatLiteral: () => (/* binding */ FloatLiteral),\n/* harmony export */   FloatType: () => (/* binding */ FloatType),\n/* harmony export */   ForLoopStatement: () => (/* binding */ ForLoopStatement),\n/* harmony export */   HardwareQubit: () => (/* binding */ HardwareQubit),\n/* harmony export */   IODeclaration: () => (/* binding */ IODeclaration),\n/* harmony export */   IOModifier: () => (/* binding */ IOModifier),\n/* harmony export */   Identifier: () => (/* binding */ Identifier),\n/* harmony export */   ImaginaryLiteral: () => (/* binding */ ImaginaryLiteral),\n/* harmony export */   Include: () => (/* binding */ Include),\n/* harmony export */   IndexSet: () => (/* binding */ IndexSet),\n/* harmony export */   IntType: () => (/* binding */ IntType),\n/* harmony export */   IntegerLiteral: () => (/* binding */ IntegerLiteral),\n/* harmony export */   MathFunction: () => (/* binding */ MathFunction),\n/* harmony export */   MathFunctionTypes: () => (/* binding */ MathFunctionTypes),\n/* harmony export */   NumericLiteral: () => (/* binding */ NumericLiteral),\n/* harmony export */   Parameters: () => (/* binding */ Parameters),\n/* harmony export */   Pi: () => (/* binding */ Pi),\n/* harmony export */   ProgramBlock: () => (/* binding */ ProgramBlock),\n/* harmony export */   QuantumBarrier: () => (/* binding */ QuantumBarrier),\n/* harmony export */   QuantumBlock: () => (/* binding */ QuantumBlock),\n/* harmony export */   QuantumDeclaration: () => (/* binding */ QuantumDeclaration),\n/* harmony export */   QuantumDelay: () => (/* binding */ QuantumDelay),\n/* harmony export */   QuantumGateCall: () => (/* binding */ QuantumGateCall),\n/* harmony export */   QuantumGateDefinition: () => (/* binding */ QuantumGateDefinition),\n/* harmony export */   QuantumGateModifier: () => (/* binding */ QuantumGateModifier),\n/* harmony export */   QuantumGateModifierName: () => (/* binding */ QuantumGateModifierName),\n/* harmony export */   QuantumMeasurement: () => (/* binding */ QuantumMeasurement),\n/* harmony export */   QuantumMeasurementAssignment: () => (/* binding */ QuantumMeasurementAssignment),\n/* harmony export */   QuantumReset: () => (/* binding */ QuantumReset),\n/* harmony export */   Range: () => (/* binding */ Range),\n/* harmony export */   ReturnStatement: () => (/* binding */ ReturnStatement),\n/* harmony export */   SizeOf: () => (/* binding */ SizeOf),\n/* harmony export */   Statement: () => (/* binding */ Statement),\n/* harmony export */   StretchType: () => (/* binding */ StretchType),\n/* harmony export */   SubroutineBlock: () => (/* binding */ SubroutineBlock),\n/* harmony export */   SubroutineCall: () => (/* binding */ SubroutineCall),\n/* harmony export */   SubroutineDefinition: () => (/* binding */ SubroutineDefinition),\n/* harmony export */   SubscriptedIdentifier: () => (/* binding */ SubscriptedIdentifier),\n/* harmony export */   SwitchStatement: () => (/* binding */ SwitchStatement),\n/* harmony export */   Tau: () => (/* binding */ Tau),\n/* harmony export */   TrigFunction: () => (/* binding */ TrigFunction),\n/* harmony export */   TrigFunctionTypes: () => (/* binding */ TrigFunctionTypes),\n/* harmony export */   UIntType: () => (/* binding */ UIntType),\n/* harmony export */   Unary: () => (/* binding */ Unary),\n/* harmony export */   UnaryOp: () => (/* binding */ UnaryOp),\n/* harmony export */   Version: () => (/* binding */ Version),\n/* harmony export */   WhileLoopStatement: () => (/* binding */ WhileLoopStatement)\n/* harmony export */ });\n/* eslint-disable  @typescript-eslint/no-explicit-any */\n/** Base class representing a basic AST node. */\nclass AstNode {\n}\n/**\n * Base class representing an instruction which performs an action.\n *\n * statement\n *  : expressionStatement\n *  | assignmentStatement\n *  | classicalDeclarationStatement\n *  | branchingStatement\n *  | loopStatement\n *  | endStatement\n *  | aliasStatement\n *  | quantumStatement\n */\nclass Statement extends AstNode {\n}\n/**\n * Class representing a custom grammar for specifying calibrations.\n *\n * calibrationGrammarStatement:\n *  | DEFCALGRAMMAR StringLiteral SEMICOLON\n */\nclass CalibrationGrammarDeclaration extends Statement {\n    constructor(name) {\n        super();\n        this.name = name;\n    }\n}\n/**\n * Class representing an include statement.\n *\n * includeStatement:\n *   INCLUDE StringLiteral SEMICOLON\n */\nclass Include extends AstNode {\n    constructor(filename) {\n        super();\n        this.filename = filename;\n    }\n}\n/**\n * Class representing the version statement.\n *\n * version\n *  : 'OPENQASM'(Integer | RealNumber) SEMICOLON\n */\nclass Version extends AstNode {\n    constructor(version) {\n        super();\n        this.version = version;\n    }\n}\n/**\n * Base class representing a quantum instruction.\n *\n * quantumInstruction\n *  : quantumGateCall\n *  | quantumPhase\n *  | quantumMeasurement\n *  | quantumReset\n *  | quantumBarrier\n */\nclass QuantumInstruction extends AstNode {\n}\n/** Base class representing a classical computing type. */\nclass ClassicalType extends AstNode {\n}\n/**\n * Class representing a classical float type.\n *\n * scalarType:\n *   FLOAT designator?\n */\nclass FloatType extends ClassicalType {\n    constructor(width) {\n        super();\n        this.width = width ? width : null;\n    }\n}\n/**\n * Class representing a complex number type.\n *\n * scalarType:\n *   COMPLEX (LBRACKET scalarType RBRACKET)?\n */\nclass ComplexType extends ClassicalType {\n    constructor(float) {\n        super();\n        this.float = float;\n    }\n}\n/** Class representing a classical boolean type. */\nclass BoolType extends ClassicalType {\n}\n/** Class representing a classical signed integer type. */\nclass IntType extends ClassicalType {\n    constructor(size) {\n        super();\n        this.size = size ? size : null;\n    }\n}\n/** Class representing a classical unsigned integer type. */\nclass UIntType extends ClassicalType {\n    constructor(size) {\n        super();\n        this.size = size ? size : null;\n    }\n}\n/** Class representing a classical bit type. */\nclass BitType extends ClassicalType {\n    constructor(size) {\n        super();\n        this.size = size ? size : null;\n    }\n}\n/** Class representing an angle type. */\nclass AngleType extends ClassicalType {\n    constructor(size) {\n        super();\n        this.size = size ? size : null;\n    }\n}\n/** Class representing the stretch type. */\nclass StretchType extends ClassicalType {\n}\n/** Class representing a duration type. */\nclass DurationType extends ClassicalType {\n}\n/** Base class representing an expression. */\nclass Expression extends AstNode {\n}\n/** Class representing a list of parameters. */\nclass Parameters extends Expression {\n    constructor(args) {\n        super();\n        this.args = args;\n    }\n}\n/** Class representing a range. */\nclass Range extends Expression {\n    constructor(start, end, step) {\n        super();\n        this.start = start ? start : null;\n        this.end = end ? end : null;\n        this.step = step ? step : null;\n    }\n}\n/** Class representing an expression identifier. */\nclass Identifier extends Expression {\n    constructor(name) {\n        super();\n        this.name = name;\n    }\n}\n/** Class representing an identifier with subscripted access. */\nclass SubscriptedIdentifier extends Identifier {\n    constructor(name, subscript) {\n        super(name);\n        this.subscript = subscript;\n    }\n}\n/** Class representing the Pi constant. */\nclass Pi extends Expression {\n}\n/** Class representing the Euler constant. */\nclass Euler extends Expression {\n}\n/** Class representing the Tau constant. */\nclass Tau extends Expression {\n}\n/** Enum representing the available mathematical functions. */\nvar MathFunctionTypes;\n(function (MathFunctionTypes) {\n    MathFunctionTypes[\"CEILING\"] = \"ceiling\";\n    MathFunctionTypes[\"EXP\"] = \"exponential\";\n    MathFunctionTypes[\"FLOOR\"] = \"floor\";\n    MathFunctionTypes[\"LOG\"] = \"logarithm\";\n    MathFunctionTypes[\"MOD\"] = \"modulus\";\n    MathFunctionTypes[\"POPCOUNT\"] = \"popcount\";\n    MathFunctionTypes[\"POW\"] = \"power\";\n    MathFunctionTypes[\"SQRT\"] = \"sqrt\";\n    MathFunctionTypes[\"ROTR\"] = \"rotr\";\n    MathFunctionTypes[\"ROTL\"] = \"rotl\";\n})(MathFunctionTypes || (MathFunctionTypes = {}));\n/** Class representing a mathematical function. */\nclass MathFunction extends Expression {\n    constructor(mathType, operands) {\n        super();\n        this.mathType = mathType;\n        this.operands = operands;\n    }\n}\n/** Enum representing the available trigonometric functions. */\nvar TrigFunctionTypes;\n(function (TrigFunctionTypes) {\n    TrigFunctionTypes[\"ARCCOS\"] = \"ArcCos\";\n    TrigFunctionTypes[\"ARCSIN\"] = \"ArcSin\";\n    TrigFunctionTypes[\"ARCTAN\"] = \"ArcTan\";\n    TrigFunctionTypes[\"COS\"] = \"Cos\";\n    TrigFunctionTypes[\"SIN\"] = \"Sin\";\n    TrigFunctionTypes[\"TAN\"] = \"Tan\";\n})(TrigFunctionTypes || (TrigFunctionTypes = {}));\n/** Class representing a trigonometric function. */\nclass TrigFunction extends Expression {\n    constructor(trigType, operand) {\n        super();\n        this.trigType = trigType;\n        this.operand = operand;\n    }\n}\n/** Class representing an integer literal. */\nclass IntegerLiteral extends Expression {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n}\n/** Class representing a scientific notation, binary, octal, or hex literal. */\nclass NumericLiteral extends Expression {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n}\n/** Class representing a float literal. */\nclass FloatLiteral extends Expression {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n}\n/** Class representing an imaginary number literal. */\nclass ImaginaryLiteral extends Expression {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n}\n/** Class representing a boolean literal. */\nclass BooleanLiteral extends Expression {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n}\n/** Class representing a bit string literal. */\nclass BitstringLiteral extends Expression {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n}\n/** Enum representing the supported duration units. */\nvar DurationUnit;\n(function (DurationUnit) {\n    DurationUnit[\"NANOSECOND\"] = \"ns\";\n    DurationUnit[\"MICROSECOND\"] = \"us\";\n    DurationUnit[\"MILLISECOND\"] = \"ms\";\n    DurationUnit[\"SECOND\"] = \"s\";\n    DurationUnit[\"SAMPLE\"] = \"dt\";\n})(DurationUnit || (DurationUnit = {}));\n/** Class representing a duration literal. */\nclass DurationLiteral extends Expression {\n    constructor(value, unit) {\n        super();\n        this.value = value;\n        this.unit = unit;\n    }\n}\n/** Class representing a durationof function call. */\nclass DurationOf extends Expression {\n    constructor(scope) {\n        super();\n        this.scope = scope;\n    }\n}\n/** Class representing a sizeof function call. */\nclass SizeOf extends Expression {\n    constructor(array, dimensionIndex) {\n        super();\n        this.array = array;\n        this.dimensionIndex =\n            dimensionIndex !== undefined && dimensionIndex !== null\n                ? dimensionIndex\n                : new IntegerLiteral(0);\n    }\n}\n/** Enum representing Unary operands. */\nvar UnaryOp;\n(function (UnaryOp) {\n    UnaryOp[\"LOGIC_NOT\"] = \"!\";\n    UnaryOp[\"BIT_NOT\"] = \"~\";\n    UnaryOp[\"MINUS\"] = \"-\";\n})(UnaryOp || (UnaryOp = {}));\n/** Class representing a unary operator. */\nclass Unary extends Expression {\n    constructor(op, operand) {\n        super();\n        this.op = op;\n        this.operand = operand;\n    }\n}\n/** Enum representing arithmetic operations. */\nvar ArithmeticOp;\n(function (ArithmeticOp) {\n    ArithmeticOp[\"POWER\"] = \"**\";\n    ArithmeticOp[\"TIMES\"] = \"*\";\n    ArithmeticOp[\"DIVISION\"] = \"/\";\n    ArithmeticOp[\"MOD\"] = \"%\";\n    ArithmeticOp[\"PLUS\"] = \"+\";\n    ArithmeticOp[\"MINUS\"] = \"-\";\n    ArithmeticOp[\"CONCAT\"] = \"++\";\n})(ArithmeticOp || (ArithmeticOp = {}));\n/** Class representing an arithmetic operator expression. */\nclass Arithmetic extends Expression {\n    constructor(op, left, right) {\n        super();\n        this.op = op;\n        this.left = left;\n        this.right = right;\n    }\n}\n/** Enum representing binary operands. */\nvar BinaryOp;\n(function (BinaryOp) {\n    BinaryOp[\"BIT_AND\"] = \"&\";\n    BinaryOp[\"BIT_OR\"] = \"|\";\n    BinaryOp[\"BIT_XOR\"] = \"^\";\n    BinaryOp[\"LOGIC_AND\"] = \"&&\";\n    BinaryOp[\"LOGIC_OR\"] = \"||\";\n    BinaryOp[\"LESS\"] = \"<\";\n    BinaryOp[\"LESS_EQUAL\"] = \"<=\";\n    BinaryOp[\"GREATER\"] = \">\";\n    BinaryOp[\"GREATER_EQUAL\"] = \">=\";\n    BinaryOp[\"EQUAL\"] = \"==\";\n    BinaryOp[\"NOT_EQUAL\"] = \"!=\";\n    BinaryOp[\"SHIFT_LEFT\"] = \"<<\";\n    BinaryOp[\"SHIFT_RIGHT\"] = \">>\";\n})(BinaryOp || (BinaryOp = {}));\n/** Class representing binary operator expressions. */\nclass Binary extends Expression {\n    constructor(op, left, right) {\n        super();\n        this.op = op;\n        this.left = left;\n        this.right = right;\n    }\n}\n/** Class representing an cast expression. */\nclass Cast extends Expression {\n    constructor(type, operand) {\n        super();\n        this.type = type;\n        this.operand = operand;\n    }\n}\n/**\n * Class representing a literal index set of values.\n *\n * { Expression (, Expression )* }\n */\nclass IndexSet extends Expression {\n    constructor(values) {\n        super();\n        this.values = values;\n    }\n}\n/** Enum representing the supported array reference modifiers. */\nvar ArrayReferenceModifier;\n(function (ArrayReferenceModifier) {\n    ArrayReferenceModifier[\"READONLY\"] = \"readonly\";\n    ArrayReferenceModifier[\"MUTABLE\"] = \"mutable\";\n})(ArrayReferenceModifier || (ArrayReferenceModifier = {}));\n/** Class representing an array reference. */\nclass ArrayReference extends Expression {\n    constructor(array, modifier) {\n        super();\n        this.array = array;\n        this.modifier = modifier;\n    }\n}\n/** Class representing a statically sized array. */\nclass ArrayDeclaration extends Statement {\n    constructor(baseType, dimensions, identifier, initializer) {\n        super();\n        this.baseType = baseType;\n        this.dimensions = dimensions;\n        this.identifier = identifier;\n        this.initializer =\n            initializer !== undefined && initializer !== null ? initializer : null;\n    }\n}\n/** Class representing an initial value for an ArrayDeclaration. */\nclass ArrayInitializer extends Expression {\n    constructor(values) {\n        super();\n        this.values = values;\n    }\n}\n/** Class representing an array access */\nclass ArrayAccess extends Expression {\n    constructor(array, indices) {\n        super();\n        this.array = array;\n        this.indices = indices !== undefined && indices !== null ? indices : null;\n    }\n}\n/**\n * Class representing a quantum measurement.\n *\n * quantumMeasurement\n *  : `measure` identifierList\n */\nclass QuantumMeasurement extends AstNode {\n    constructor(identifierList) {\n        super();\n        this.identifierList = identifierList;\n    }\n}\n/**\n * Class representing a quantum measurement assignment statement.\n *\n * QuantumMeasurementAssignment\n *  : quantumMeasurement ARROW indexIdentifierList\n *  | indexIdentifier EQUALS quantumMeasurement\n */\nclass QuantumMeasurementAssignment extends Statement {\n    constructor(identifier, quantumMeasurement) {\n        super();\n        this.identifier = identifier;\n        this.quantumMeasurement = quantumMeasurement;\n    }\n}\n/** Class representing the declaration of a classical type, optionally initializing it to a value. */\nclass ClassicalDeclaration extends Statement {\n    constructor(classicalType, identifier, initializer, isConst) {\n        super();\n        this.classicalType = classicalType;\n        this.identifier =\n            identifier !== undefined && identifier !== null ? identifier : null;\n        this.initializer =\n            initializer !== undefined && initializer !== null ? initializer : null;\n        this.isConst = isConst !== undefined && isConst !== null ? isConst : false;\n    }\n}\n/** Class representing an expression to a left value. */\nclass AssignmentStatement extends Statement {\n    constructor(leftValue, rightValue) {\n        super();\n        this.leftValue = leftValue;\n        this.rightValue = rightValue;\n    }\n}\n/**\n * Class representing a quantum declaration.\n *\n * quantumDeclaration\n *  : `qreg` Identifier designator?\n *    `qubit` designator? Identifier\n */\nclass QuantumDeclaration extends AstNode {\n    constructor(identifier, size) {\n        super();\n        this.identifier = identifier;\n        this.size = size ? size : null;\n    }\n}\n/**\n * Class representing a hardware qubit.\n *\n * $[NUM]\n */\nclass HardwareQubit extends AstNode {\n    constructor(number) {\n        super();\n        this.number = number;\n    }\n}\n/** Class representing an alias statement. */\nclass AliasStatement extends AstNode {\n    constructor(identifier, value) {\n        super();\n        this.identifier = identifier;\n        this.value = value;\n    }\n}\n/** Enum representing the available quantum gate modifiers. */\nvar QuantumGateModifierName;\n(function (QuantumGateModifierName) {\n    QuantumGateModifierName[QuantumGateModifierName[\"CTRL\"] = 0] = \"CTRL\";\n    QuantumGateModifierName[QuantumGateModifierName[\"NRGCTRL\"] = 1] = \"NRGCTRL\";\n    QuantumGateModifierName[QuantumGateModifierName[\"INV\"] = 2] = \"INV\";\n    QuantumGateModifierName[QuantumGateModifierName[\"POW\"] = 3] = \"POW\";\n})(QuantumGateModifierName || (QuantumGateModifierName = {}));\n/** Class representing a modifier of a gate. */\nclass QuantumGateModifier extends AstNode {\n    constructor(modifier, argument) {\n        super();\n        this.modifier = modifier;\n        this.argument = argument ? argument : null;\n    }\n}\n/**\n * Class representing a quantum gate call.\n *\n * quantumGateCall\n *  : quantumGateModifier* quantumGateName ( LPAREN expressionList? RPAREN )? indexIdentifierList\n */\nclass QuantumGateCall extends QuantumInstruction {\n    constructor(quantumGateCall, qubits, parameters, modifiers) {\n        super();\n        this.quantumGateName = quantumGateCall;\n        this.qubits = qubits;\n        this.parameters = parameters ? parameters : null;\n        this.modifiers = modifiers ? modifiers : [];\n    }\n}\n/**\n * Class representing a quantum barrier.\n *\n * quantumBarrier\n *  : `barrier` indexIdentifierList\n */\nclass QuantumBarrier extends QuantumInstruction {\n    constructor(qubits) {\n        super();\n        this.qubits = qubits;\n    }\n}\n/** Class representing a quantum reset instruction. */\nclass QuantumReset extends QuantumInstruction {\n    constructor(identifier) {\n        super();\n        this.identifier = identifier;\n    }\n}\n/** Class representing a quantum delay instruction. */\nclass QuantumDelay extends QuantumInstruction {\n    constructor(duration, qubits) {\n        super();\n        this.duration = duration;\n        this.qubits = qubits;\n    }\n}\n/** Class representing a return statement. */\nclass ReturnStatement extends Statement {\n    constructor(expression) {\n        super();\n        this.expression = expression ? expression : null;\n    }\n}\n/**\n * Base class representing a program block.\n *\n * programBlock\n *  : statement | controlDirective\n *  | LBRACE(statement | controlDirective) * RBRACEj\n */\nclass ProgramBlock extends AstNode {\n    constructor(statements) {\n        super();\n        this.statements = statements;\n    }\n}\n/**\n * Class representing a block of quantum operation statements.\n *\n * quantumBlock\n *  : LBRACE (quantumStatement | quantumLoop) * RBRACE\n */\nclass QuantumBlock extends ProgramBlock {\n    constructor(statements) {\n        super(statements);\n    }\n}\n/**\n * Class representing a block of statements in a subroutine.\n *\n * subroutineBlock\n *  : LBRACE statement* returnStatement? RBRACE\n */\nclass SubroutineBlock extends ProgramBlock {\n    constructor(statements) {\n        super(statements);\n    }\n}\n/**\n * Class representing a quantum gate definition.\n *\n * quantumGateDefinition\n *  : `gate` quantumGateDefinition quantumBlock\n */\nclass QuantumGateDefinition extends Statement {\n    constructor(name, params, qubits, body) {\n        super();\n        this.name = name;\n        this.params = params;\n        this.qubits = qubits;\n        this.body = body;\n    }\n}\n/**\n * Class representing an extern function signature.\n *\n * externStatement\n *   : EXTERN Identifier LPAREN externArgumentList? RPAREN returnSignature? SEMICOLON;\n */\nclass ExternSignature extends Statement {\n    constructor(name, args, returnType) {\n        super();\n        this.name = name;\n        this.args = args;\n        this.returnType =\n            returnType !== undefined && returnType !== null ? returnType : null;\n    }\n}\n/**\n * Class representing a subroutine.\n *\n * subroutineDefinition\n *  : `def` Identifier LPAREN anyTypeArgumentList? RPAREN\n *  returnSignature? subroutineBlock\n */\nclass SubroutineDefinition extends Statement {\n    constructor(name, subroutineBlock, args, returnType) {\n        super();\n        this.name = name;\n        this.subroutineBlock = subroutineBlock;\n        this.args = args;\n        this.returnType = returnType ? returnType : null;\n    }\n}\n/**\n * Class representing a box scoping statement.\n *\n * boxStatement\n *   : BOX designator? scope;\n */\nclass BoxDefinition extends Statement {\n    constructor(scope, designator) {\n        super();\n        this.scope = scope;\n        this.designator =\n            designator !== undefined && designator !== null ? designator : null;\n    }\n}\n/** Class representing a subroutine call. */\nclass SubroutineCall extends Statement {\n    constructor(subroutineName, parameters) {\n        super();\n        this.subroutineName = subroutineName;\n        this.parameters = parameters ? parameters : null;\n    }\n}\n/**\n * Class representing a branching if statement.\n *\n * branchingStatement\n *  : `if` LPAREN booleanExpression RPAREN programBlock (`else` programBlock)?\n */\nclass BranchingStatement extends Statement {\n    constructor(condition, trueBody, falseBody) {\n        super();\n        this.condition = condition;\n        this.trueBody = trueBody;\n        this.falseBody = falseBody;\n    }\n}\n/**\n * Class representing a for loop statement.\n *\n * ForLoop: \"for\" Identifier \"in\" SetDeclaration ProgramBlock\n * SetDeclaration:\n *  | Identifier\n *  | \"{\" Expression (\",\" Expression)* \"}\"\n *  | \"[\" Range \"]\"\n */\nclass ForLoopStatement extends Statement {\n    constructor(indexSet, loopVarType, parameter, body) {\n        super();\n        this.indexSet = indexSet;\n        this.loopVarType = loopVarType;\n        this.parameter = parameter;\n        this.body = body;\n    }\n}\n/**\n * Class representing a while loop statement.\n *\n * WhileLoop: \"while\" \"(\" Expression \")\" ProgramBlock\n */\nclass WhileLoopStatement extends Statement {\n    constructor(condition, body) {\n        super();\n        this.condition = condition;\n        this.body = body;\n    }\n}\n/** Class representing a break loop statement. */\nclass BreakStatement extends Statement {\n}\n/** Class representing a continue loop statement. */\nclass ContinueStatement extends Statement {\n}\n/** Enum representing the available IO modifiers. */\nvar IOModifier;\n(function (IOModifier) {\n    IOModifier[\"INPUT\"] = \"input\";\n    IOModifier[\"OUTPUT\"] = \"output\";\n})(IOModifier || (IOModifier = {}));\n/** Class representing a declaration of an IO variable. */\nclass IODeclaration extends Statement {\n    constructor(modifier, classicalType) {\n        super();\n        this.modifier = modifier;\n        this.classicalType = classicalType;\n    }\n}\n/** Class representing a switch statement. */\nclass SwitchStatement extends Statement {\n    constructor(controlExpression, cases, defaultBlock) {\n        super();\n        this.controlExpression = controlExpression;\n        this.cases = cases;\n        this.defaultBlock = defaultBlock ? defaultBlock : null;\n    }\n}\n/** Class representing a single case in a switch statement. */\nclass CaseStatement extends Statement {\n    constructor(labels, body) {\n        super();\n        this.labels = labels;\n        this.body = body;\n    }\n}\n/** Class representing the default case in a swtich statement. */\nclass DefaultStatement extends Statement {\n    constructor(body) {\n        super();\n        this.body = body;\n    }\n}\n\n\n\n//# sourceURL=webpack://qasm-quantum-simulator/./node_modules/qasm-ts/dist/qasm3/ast.js?\n}");

/***/ }),

/***/ "./node_modules/qasm-ts/dist/qasm3/lexer.js":
/*!**************************************************!*\
  !*** ./node_modules/qasm-ts/dist/qasm3/lexer.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _token__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./token */ \"./node_modules/qasm-ts/dist/qasm3/token.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors */ \"./node_modules/qasm-ts/dist/errors.js\");\n/* eslint-disable no-useless-escape */\n/**\n * OpenQASM 3.0 Lexical Analyzer\n *\n * This module implements the lexer for OpenQASM 3.0, which transforms source code\n * into a stream of tokens. The lexer handles the significantly expanded syntax of\n * OpenQASM 3.0, including classical programming constructs, control flow, and\n * advanced quantum features.\n *\n * Key features of the OpenQASM 3.0 lexer:\n * - **Extended token set**: Classical types, control flow, functions\n * - **Complex operators**: Compound assignment, bitwise operations\n * - **Advanced literals**: Scientific notation, binary/hex/octal, durations\n * - **Gate modifiers**: ctrl, negctrl, inv, pow with @ syntax\n * - **Unicode support**: Mathematical constants (π, ℇ, τ)\n * - **Robust error handling**: Detailed syntax error reporting\n *\n * The lexer performs several validation passes:\n * - Semicolon verification for statement termination\n * - Comment handling (single-line // and multi-line /* *\\/)\n * - String literal parsing with multiple quote styles\n * - Number format validation and conversion\n *\n * @module\n *\n * @example Basic lexing process\n * ```typescript\n * const lexer = new Lexer('qubit[2] q; h q[0];');\n * const tokens = lexer.lex();\n * // Returns: [\n * //   [Token.Id, 'qubit'], [Token.LSParen], [Token.NNInteger, 2],\n * //   [Token.RSParen], [Token.Id, 'q'], [Token.Semicolon], ...\n * // ]\n * ```\n */\n\n\n/**\n * Handles throwing lexer errors with basic stack trace.\n * @param error - The error to throw.\n * @param number - The line number in the source code.\n * @param code - The source code that the error is about.\n */\nfunction throwLexerError(error, line, code) {\n    throw new error(`Line ${line}: ${code}`);\n}\n/**\n * Returns whether a given character could be an element of a numeric value.\n * @param c - The character.\n * @return Whether the character is numeric.\n */\nfunction isNumeric(c) {\n    return c == \".\" || c == \"e\" || c == \"_\" || !isNaN(parseInt(c));\n}\n/**\n * Returns whether a given character is a letter.\n * @param c - The character.\n * @param matchCase - Whether to check for a letter that is upper case, lower case, or either. (optional)\n * @return Whether the character is a letter.\n */\nfunction isLetter(c, matchCase) {\n    switch (matchCase) {\n        case \"upper\":\n            return /^[A-Z]$/.test(c);\n        case \"lower\":\n            return /^[a-z]$/.test(c);\n        default:\n            return /^[A-Za-z]$/.test(c);\n    }\n}\n/**\n * Returns whether a given character is unicode.\n * @param c - The character.\n * @param excludePi - Whether to exclude the Pi symbol from consideration.\n * @return - Whether the given character is valid unicode.\n */\nfunction isUnicode(c, excludePi) {\n    const isBasicUnicode = /^\\u0000-\\u00ff/.test(c);\n    switch (excludePi) {\n        case true:\n            return isBasicUnicode && c !== \"\\u03C0\";\n        case false:\n            return isBasicUnicode;\n        default:\n            return isBasicUnicode;\n    }\n}\n/**\n * Returns whether a given character is alphanumeric.\n * @param c - The character.\n * @return Whether the character is alphanumeric.\n */\nfunction isAlpha(c) {\n    return /^[0-9a-zA-Z]+$/.test(c);\n}\n/**\n * Returns whether a given character is a newline character.\n * @param c - The character.\n * @return Whether the character is a newline.\n */\nfunction isNewline(c) {\n    return /\\n|\\r(?!\\n)|\\u2028|\\u2029|\\r\\n/.test(c);\n}\n/**\n * OpenQASM 3.0 Lexical Analyzer\n *\n * The main lexer class that processes OpenQASM 3.0 source code character by\n * character and produces a stream of tokens for the parser to consume.\n *\n * The lexer maintains state including:\n * - Current cursor position in the input\n * - Input validation status\n * - Error reporting context\n *\n * @example Creating and using a lexer\n * ```typescript\n * const source = `\n *   OPENQASM 3.0;\n *   include \"stdgates.inc\";\n *   qubit[2] q;\n *   h q[0];\n *   cx q[0], q[1];\n * `;\n *\n * const lexer = new Lexer(source);\n * const tokens = lexer.lex();\n * ```\n */\nclass Lexer {\n    /**\n     * Creates a lexer.\n     * @param input - The string to lex.\n     * @param cursor - The starting cursor position.\n     */\n    constructor(input, cursor = 0) {\n        /**\n         * Verifies that all appropriate lines end with a semicolon.\n         * @return A tuple of the status and if False, returns the problematic line.\n         */\n        this.verifyInput = () => {\n            const lines = this.input.split(/\\n|\\r(?!\\n)|\\u2028|\\u2029|\\r\\n/g);\n            for (let i = 0; i < lines.length; i++) {\n                const trimmedLine = lines[i].trim();\n                if (!trimmedLine.startsWith(\"//\") &&\n                    !trimmedLine.startsWith(\"/*\") &&\n                    !trimmedLine.startsWith(\"*\") &&\n                    !trimmedLine.startsWith(\"*/\") &&\n                    trimmedLine.length > 0 &&\n                    !trimmedLine.startsWith(\"gate\") &&\n                    trimmedLine !== \"{\" &&\n                    trimmedLine !== \"}\" &&\n                    !trimmedLine.includes(\";\") &&\n                    !trimmedLine.startsWith(\"def\") &&\n                    !trimmedLine.startsWith(\"if\") &&\n                    !trimmedLine.startsWith(\"else\") &&\n                    !trimmedLine.startsWith(\"for\") &&\n                    !trimmedLine.startsWith(\"while\") &&\n                    !trimmedLine.startsWith(\"switch\") &&\n                    !trimmedLine.startsWith(\"case\") &&\n                    !trimmedLine.startsWith(\"box\") &&\n                    !trimmedLine.startsWith(\"array\") &&\n                    !trimmedLine.startsWith(\"{\") &&\n                    !trimmedLine.startsWith(\"default\")) {\n                    return [false, i + 1, lines[i]];\n                }\n            }\n            return [true, null, null];\n        };\n        /**\n         * Calling this method lexes the code represented by the provided string.\n         * @return An array of tokens and their corresponding values.\n         */\n        this.lex = () => {\n            const tokens = [];\n            let token;\n            const verifyInputResult = this.verifyInput();\n            if (!verifyInputResult[0]) {\n                throwLexerError(_errors__WEBPACK_IMPORTED_MODULE_1__.MissingSemicolonError, verifyInputResult[1], verifyInputResult[2]);\n            }\n            while (this.cursor < this.input.length) {\n                token = this.nextToken();\n                if (token) {\n                    tokens.push(token);\n                }\n            }\n            return tokens;\n        };\n        /**\n         * Reads a character and advances the cursor.\n         * @param num - Optional cursor position modifier.\n         */\n        this.readChar = (num = 1) => {\n            this.cursor += num;\n            return this.input[this.cursor - num];\n        };\n        /**\n         * Advances the cusor past the next comment.\n         */\n        this.skipComment = () => {\n            let char = \"\";\n            while (!isNewline(char)) {\n                char = this.readChar();\n            }\n        };\n        /**\n         * Advances the cursor past a multiline comment.\n         */\n        this.skipMultiLineComment = () => {\n            let char = \"\";\n            let nextChar = \"\";\n            const multiLineCommentTerminator = \"*/\";\n            while (`${char}${nextChar}` !== multiLineCommentTerminator) {\n                char = this.readChar();\n                nextChar = this.peek();\n            }\n            this.readChar();\n        };\n        /**\n         * Determines whether the next character to process equals a given character.\n         * @param c - The given character.\n         * @return Whether the next character equals the given character.\n         */\n        this.peekEq = (c) => this.peek() == c;\n        /**\n         * Reads a character without advancing the cursor.\n         * @param index - Optional peek position offset.\n         */\n        this.peek = () => this.input[this.cursor];\n        /**\n         * Reads a numeric value.\n         * @return The numeric value as a string.\n         */\n        this.readNumeric = () => {\n            let num = \"\";\n            let char = this.peek();\n            while (isNumeric(char) || char === \"e\") {\n                num += this.readChar();\n                if (char === \"e\" && this.peek() === \"-\") {\n                    num += this.readChar();\n                }\n                char = this.peek();\n            }\n            return num;\n        };\n        /**\n         * Reads an identifier.\n         * @return The identifier as a string.\n         */\n        this.readIdentifier = () => {\n            let id = \"\";\n            let next = this.peek();\n            while (isAlpha(next) || next == \"_\" || isUnicode(next)) {\n                id += this.readChar();\n                next = this.peek();\n            }\n            return id;\n        };\n        /**\n         * Reds a keyword or identifier.\n         * If the character sequence matches a keyword, returns the corresponding token.\n         * Otherwise, treats the sequence as an identifier.\n         * @param char - The first character of the keyword or identifier.\n         * @return The corresponding token or identifier.\n         */\n        this.readKeywordOrIdentifier = (char) => {\n            const identifier = char + this.readIdentifier();\n            return [(0,_token__WEBPACK_IMPORTED_MODULE_0__.lookup)(identifier), identifier];\n        };\n        /**\n         * Reads a string literal.\n         * @param terminator - The literal's termination character.\n         * @return The literal as a string.\n         */\n        this.readStringLiteral = (terminator) => {\n            let lit = \"\";\n            let char = \"\";\n            while (!(terminator == char)) {\n                char = this.readChar();\n                lit += char;\n            }\n            return lit;\n        };\n        /**\n         * Advances the cusor past the next block of whitespace.\n         */\n        this.skipWhitespace = () => {\n            while (\" \\t\\n\\r\\v\".indexOf(this.peek()) > -1) {\n                this.cursor += 1;\n            }\n            return null;\n        };\n        /**\n         * Lexes the next token.\n         * @return The next token and its corresponding value.\n         */\n        this.nextToken = () => {\n            this.skipWhitespace();\n            if (this.cursor == this.input.length) {\n                return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.EndOfFile];\n            }\n            const char = this.peek();\n            this.readChar();\n            switch (char) {\n                case \"π\":\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Pi];\n                case \"ℇ\":\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Euler];\n                case \"τ\":\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Tau];\n                case \"@\":\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.At];\n                case \"θ\":\n                    return this.readKeywordOrIdentifier(char);\n                case \"!\":\n                    if (this.peekEq(\"=\")) {\n                        this.readChar();\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.BinaryOp, \"!=\"];\n                    }\n                    else {\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.UnaryOp, \"!\"];\n                    }\n                case \"~\":\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.UnaryOp, \"~\"];\n                case \"*\":\n                    if (this.peekEq(\"*\")) {\n                        this.readChar();\n                        if (this.peekEq(\"=\")) {\n                            this.readChar();\n                            return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.CompoundArithmeticOp, \"**=\"];\n                        }\n                        else {\n                            return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.ArithmeticOp, \"**\"];\n                        }\n                    }\n                    else if (this.peekEq(\"=\")) {\n                        this.readChar();\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.CompoundArithmeticOp, \"*=\"];\n                    }\n                    else {\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.ArithmeticOp, \"*\"];\n                    }\n                case \"/\":\n                    if (this.peekEq(\"/\")) {\n                        this.skipComment();\n                        return;\n                    }\n                    else if (this.peekEq(\"*\")) {\n                        this.skipMultiLineComment();\n                        return;\n                    }\n                    else if (this.peekEq(\"=\")) {\n                        this.readChar();\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.CompoundArithmeticOp, \"/=\"];\n                    }\n                    else {\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.ArithmeticOp, \"/\"];\n                    }\n                case \"%\":\n                    if (this.peekEq(\"=\")) {\n                        this.readChar();\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.CompoundArithmeticOp, \"%=\"];\n                    }\n                    else {\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.ArithmeticOp, \"%\"];\n                    }\n                case \"+\":\n                    if (this.peekEq(\"=\")) {\n                        this.readChar();\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.CompoundArithmeticOp, \"+=\"];\n                    }\n                    else if (this.peekEq(\"+\")) {\n                        this.readChar();\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.ArithmeticOp, \"++\"];\n                    }\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.ArithmeticOp, \"+\"];\n                case \"-\": {\n                    if (this.peekEq(\">\")) {\n                        this.readChar();\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Arrow];\n                    }\n                    else if (this.peekEq(\"=\")) {\n                        this.readChar();\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.CompoundArithmeticOp, \"-=\"];\n                    }\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.UnaryOp, \"-\"];\n                }\n                case \"&\":\n                    if (this.peekEq(\"&\")) {\n                        this.readChar();\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.BinaryOp, \"&&\"];\n                    }\n                    else {\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.BinaryOp, \"&\"];\n                    }\n                case \"|\":\n                    if (this.peekEq(\"|\")) {\n                        this.readChar();\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.BinaryOp, \"||\"];\n                    }\n                    else {\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.BinaryOp, \"|\"];\n                    }\n                case \"^\":\n                    if (this.peekEq(\"=\")) {\n                        this.readChar();\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.CompoundBinaryOp, \"^=\"];\n                    }\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.BinaryOp, \"^\"];\n                case \"<\":\n                    if (this.peekEq(\"=\")) {\n                        this.readChar();\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.BinaryOp, \"<=\"];\n                    }\n                    else if (this.input[this.cursor] == \"<\" &&\n                        this.input[this.cursor + 1] == \"=\") {\n                        this.readChar(2);\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.CompoundBinaryOp, \"<<=\"];\n                    }\n                    else if (this.peekEq(\"<\")) {\n                        this.readChar();\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.BinaryOp, \"<<\"];\n                    }\n                    else {\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.BinaryOp, \"<\"];\n                    }\n                case \">\":\n                    if (this.peekEq(\"=\")) {\n                        this.readChar();\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.BinaryOp, \">=\"];\n                    }\n                    else if (this.input[this.cursor] == \">\" &&\n                        this.input[this.cursor + 1] == \"=\") {\n                        this.readChar(2);\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.CompoundBinaryOp, \">>=\"];\n                    }\n                    else if (this.peekEq(\">\")) {\n                        this.readChar();\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.BinaryOp, \">>\"];\n                    }\n                    else {\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.BinaryOp, \">\"];\n                    }\n                case \"=\":\n                    if (this.peekEq(\"=\")) {\n                        this.readChar();\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.BinaryOp, \"==\"];\n                    }\n                    else {\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.EqualsAssmt];\n                    }\n                case \";\":\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon];\n                case \",\":\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Comma];\n                case \":\":\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Colon];\n                case \"(\":\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LParen];\n                case \"[\":\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LSParen];\n                case \"{\":\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LCParen];\n                case \")\":\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RParen];\n                case \"]\":\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RSParen];\n                case \"}\":\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RCParen];\n                case \"$\":\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Dollar];\n                case \"#\":\n                    if (this.input[this.cursor] == \"d\" &&\n                        this.input[this.cursor + 1] == \"i\" &&\n                        this.input[this.cursor + 2] == \"m\") {\n                        this.readChar(3);\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Dim];\n                    }\n                    return this.readKeywordOrIdentifier(char);\n                case \"c\":\n                    if (this.input[this.cursor] == \"t\" &&\n                        this.input[this.cursor + 1] == \"r\" &&\n                        this.input[this.cursor + 2] == \"l\") {\n                        this.readChar(3);\n                        return this.lexGateModifier(\"ctrl\");\n                    }\n                    return this.readKeywordOrIdentifier(char);\n                case \"n\":\n                    if (this.input[this.cursor] == \"e\" &&\n                        this.input[this.cursor + 1] == \"g\" &&\n                        this.input[this.cursor + 2] == \"c\" &&\n                        this.input[this.cursor + 3] == \"t\" &&\n                        this.input[this.cursor + 4] == \"r\" &&\n                        this.input[this.cursor + 5] == \"l\") {\n                        this.readChar(6);\n                        return this.lexGateModifier(\"negctrl\");\n                    }\n                    return this.readKeywordOrIdentifier(char);\n                case \"i\":\n                    if (this.input[this.cursor] == \"n\" &&\n                        this.input[this.cursor + 1] == \"v\") {\n                        this.readChar(2);\n                        return this.lexGateModifier(\"inv\");\n                    }\n                    return this.readKeywordOrIdentifier(char);\n                case \"p\":\n                    if (this.input[this.cursor] == \"o\" &&\n                        this.input[this.cursor + 1] == \"w\" &&\n                        !isLetter(this.input[this.cursor + 2])) {\n                        this.readChar(2);\n                        return this.lexGateModifier(\"pow\");\n                    }\n                    return this.readKeywordOrIdentifier(char);\n                case \"0\":\n                    if (this.peekEq(\"b\") || this.peekEq(\"B\")) {\n                        const char = this.readChar(1);\n                        const binaryLit = this.readIdentifier();\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.BinaryLiteral, `0${char}${binaryLit}`];\n                    }\n                    else if (this.peekEq(\"o\") || this.peekEq(\"O\")) {\n                        const char = this.readChar(1);\n                        const octalLit = this.readIdentifier();\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.OctalLiteral, `0${char}${octalLit}`];\n                    }\n                    else if (this.peekEq(\"x\") || this.peekEq(\"X\")) {\n                        const char = this.readChar(1);\n                        const hexLit = this.readIdentifier();\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.HexLiteral, `0${char}${hexLit}`];\n                    }\n                    else {\n                        const num = char + this.readNumeric();\n                        if (num.indexOf(\".\") != -1) {\n                            return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Real, parseFloat(num)];\n                        }\n                        else if (num.indexOf(\"_\") != -1) {\n                            return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Integer, num];\n                        }\n                        else {\n                            return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.NNInteger, parseInt(num)];\n                        }\n                    }\n                    // removed by dead control flow\n\n                case \"O\":\n                    if (this.input[this.cursor].toLowerCase() == \"p\" &&\n                        this.input[this.cursor + 1].toLowerCase() == \"e\" &&\n                        this.input[this.cursor + 2].toLowerCase() == \"n\" &&\n                        this.input[this.cursor + 3] == \"Q\" &&\n                        this.input[this.cursor + 4] == \"A\" &&\n                        this.input[this.cursor + 5] == \"S\" &&\n                        this.input[this.cursor + 6] == \"M\") {\n                        this.readChar(7);\n                        let offset = 0;\n                        while (this.cursor + offset < this.input.length &&\n                            \" \\t\".indexOf(this.input[this.cursor + offset]) > -1) {\n                            offset++;\n                        }\n                        // Read the major version\n                        let majorVersion = \"\";\n                        while (this.cursor + offset < this.input.length &&\n                            !isNaN(parseInt(this.input[this.cursor + offset], 10))) {\n                            majorVersion += this.input[this.cursor + offset];\n                            offset++;\n                        }\n                        // Attempt to read the minor version\n                        let minorVersion = undefined;\n                        if (this.input[this.cursor + offset] == \".\") {\n                            offset++;\n                            minorVersion = \"\";\n                            while (this.cursor + offset < this.input.length &&\n                                !isNaN(parseInt(this.input[this.cursor + offset], 10))) {\n                                minorVersion += this.input[this.cursor + offset];\n                                offset++;\n                            }\n                        }\n                        // Parse major and minor versions\n                        const major = parseInt(majorVersion, 10);\n                        const minor = minorVersion ? parseInt(minorVersion, 10) : undefined;\n                        if (major !== 3) {\n                            throw new _errors__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOpenQASMVersionError(`Unsupported OpenQASM version detected: ${majorVersion}.${minor !== null && minor !== void 0 ? minor : 0}`);\n                        }\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.OpenQASM];\n                    }\n                    return this.readKeywordOrIdentifier(char);\n                case '\"': {\n                    const stringLiteral = char + this.readStringLiteral('\"');\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.String, stringLiteral];\n                }\n                case \"’\": {\n                    const singleStringLiteral = char + this.readStringLiteral(\"’\");\n                    return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.String, singleStringLiteral];\n                }\n                default:\n                    if (isLetter(char)) {\n                        return this.readKeywordOrIdentifier(char);\n                    }\n                    else if (isNumeric(char)) {\n                        const num = char + this.readNumeric();\n                        if (num.indexOf(\"e\") != -1) {\n                            return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.ScientificNotation, num];\n                        }\n                        else if (num.indexOf(\".\") != -1) {\n                            return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Real, parseFloat(num)];\n                        }\n                        else if (num.indexOf(\"_\") != -1) {\n                            return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Integer, num];\n                        }\n                        else {\n                            return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.NNInteger, parseInt(num)];\n                        }\n                    }\n                    else {\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Illegal];\n                    }\n            }\n        };\n        /**\n         * Returns the line number where the current cursor is located.\n         * @param cursor - The current cursor position in the input string.\n         * @return The line number.\n         */\n        this.getLineNumber = (cursor) => {\n            return this.input\n                .substring(0, cursor)\n                .split(/\\n|\\r(?!\\n)|\\u2028|\\u2029|\\r\\n/).length;\n        };\n        /**\n         * Returns the current line of code where the cursor is located.\n         * @param cursor - The current cursor position in the input string.\n         * @return The specific line where the cursor is located.\n         */\n        this.getCurrentLine = (cursor) => {\n            const lines = this.input.split(/\\n|\\r(?!\\n)|\\u2028|\\u2029|\\r\\n/);\n            const lineNumber = this.getLineNumber(cursor);\n            return lines[lineNumber - 1];\n        };\n        /**\n         * Retruns an identifier or gate modifier.\n         */\n        this.lexGateModifier = (keyword) => {\n            let offset = 1;\n            let currChar = \"\";\n            while (this.cursor + offset < this.input.length &&\n                this.input[this.cursor + offset] !== \";\") {\n                currChar = this.input[this.cursor + offset];\n                if (currChar === \"@\") {\n                    break;\n                }\n                offset++;\n            }\n            if (currChar === \"@\") {\n                switch (keyword) {\n                    case \"ctrl\":\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Ctrl];\n                    case \"negctrl\":\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.NegCtrl];\n                    case \"inv\":\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Inv];\n                    case \"pow\":\n                        return [_token__WEBPACK_IMPORTED_MODULE_0__.Token.PowM];\n                }\n            }\n            return this.readKeywordOrIdentifier(keyword);\n        };\n        this.input = input;\n        this.cursor = cursor;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Lexer);\n\n\n//# sourceURL=webpack://qasm-quantum-simulator/./node_modules/qasm-ts/dist/qasm3/lexer.js?\n}");

/***/ }),

/***/ "./node_modules/qasm-ts/dist/qasm3/parser.js":
/*!***************************************************!*\
  !*** ./node_modules/qasm-ts/dist/qasm3/parser.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _token__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./token */ \"./node_modules/qasm-ts/dist/qasm3/token.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../version */ \"./node_modules/qasm-ts/dist/version.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../errors */ \"./node_modules/qasm-ts/dist/errors.js\");\n/* harmony import */ var _ast__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ast */ \"./node_modules/qasm-ts/dist/qasm3/ast.js\");\n/* eslint-disable  @typescript-eslint/no-explicit-any */\n/**\n * OpenQASM 3.0 Parser Implementation\n *\n * This module implements a recursive descent parser for OpenQASM 3.0 that transforms\n * a stream of tokens into an Abstract Syntax Tree (AST). The parser handles the full\n * OpenQASM 3.0 language specification including classical programming constructs,\n * control flow, quantum operations, and advanced features.\n *\n * Key parsing capabilities:\n * - **Classical types**: int, uint, float, bool, bit, complex, angle\n * - **Control flow**: if/else, for/while loops, switch/case statements\n * - **Functions**: def, return, extern declarations, subroutine calls\n * - **Quantum operations**: gate definitions/calls, measurements, barriers, delays\n * - **Advanced features**: arrays, timing constructs, calibration grammar\n * - **Expressions**: Arithmetic, logical, function calls with proper precedence\n *\n * The parser maintains context about:\n * - Defined gates (built-in, standard library, custom)\n * - Declared subroutines and external functions\n * - Array declarations and aliases\n * - Type information for validation\n *\n * @module\n *\n * @example Basic parsing workflow\n * ```typescript\n * const tokens = lexer.lex();\n * const parser = new Parser(tokens);\n * const ast = parser.parse();\n * ```\n */\n\n\n\n\n/**\n * Handles throwing parser errors with basic stack trace.\n * @param error - The error to throw.\n * @param token - The source token for the error.\n * @param index - The token index.\n * @param message - Optional additional error context.\n */\nfunction throwParserError(error, token, index, message) {\n    const errorMessage = message\n        ? `index: ${index} at token [${token}], ${message}`\n        : `index: ${index} at token [${token}]`;\n    throw new error(errorMessage);\n}\n/**\n * OpenQASM 3.0 Recursive Descent Parser\n *\n * Implements a comprehensive parser for the OpenQASM 3.0 language specification.\n * The parser uses recursive descent parsing with appropriate error recovery and\n * maintains symbol tables for gates, subroutines, and variables.\n *\n * Parser state includes:\n * - Token stream and current position\n * - Symbol tables for gates, subroutines, arrays, aliases\n * - Machine-specific defaults (float width, int size)\n *\n * @example Creating and using the parser\n * ```typescript\n * const parser = new Parser(tokens);\n *\n * // Parse the entire program\n * const ast = parser.parse();\n *\n * // AST contains array of top-level statements and declarations\n * console.log(ast); // [VersionNode, IncludeNode, DeclarationNode, ...]\n * ```\n */\nclass Parser {\n    /**\n     * Creates a parser.\n     * @param tokens - Tokens to parse.\n     * @param defaultFloatWidth - Optional default float width override.\n     * @param machineIntSize - Optional default int size override.\n     */\n    constructor(tokens, defaultFloatWidth, machineIntSize) {\n        this.tokens = tokens;\n        this.gates = new Set([\"U\", \"gphase\"]);\n        this.standardGates = new Set();\n        this.customGates = new Set();\n        this.subroutines = new Set();\n        this.customArrays = new Set();\n        this.aliases = new Map();\n        this.index = 0;\n        this.machineFloatWidth = defaultFloatWidth ? defaultFloatWidth : 64;\n        this.machineIntSize = machineIntSize ? machineIntSize : 32;\n    }\n    /**\n     * Loads the standard library gates.\n     */\n    stdGates() {\n        const gates = [\n            \"p\",\n            \"x\",\n            \"y\",\n            \"z\",\n            \"h\",\n            \"s\",\n            \"sdg\",\n            \"t\",\n            \"tdg\",\n            \"sx\",\n            \"rx\",\n            \"ry\",\n            \"rz\",\n            \"cx\",\n            \"cy\",\n            \"cz\",\n            \"cp\",\n            \"crx\",\n            \"cry\",\n            \"crz\",\n            \"ch\",\n            \"swap\",\n            \"ccx\",\n            \"cswap\",\n            \"cu\",\n            // OpenQASM 2 backwards compatibility gates\n            \"CX\",\n            \"phase\",\n            \"cphase\",\n            \"id\",\n            \"u1\",\n            \"u2\",\n            \"u3\",\n        ];\n        gates.forEach(this.standardGates.add, this.standardGates);\n    }\n    /**\n     * Parses the token stream and generates an abstract syntax tree.\n     * @return The abstract syntax tree.\n     */\n    parse() {\n        let ast = [];\n        while (this.index < this.tokens.length - 1) {\n            const [nodes, consumed] = this.parseNode(this.tokens.slice(this.index));\n            ast = ast.concat(nodes ? nodes : []);\n            this.index += consumed;\n        }\n        return ast;\n        // let i = 0;\n        // while (i < this.tokens.length - 1) {\n        //   this.index = i;\n        //   const nodes = this.parseNode(this.tokens.slice(i))[0];\n        //   ast = ast.concat(nodes ? nodes : []);\n        //   while (!this.matchNext(this.tokens.slice(i), [Token.Semicolon])) {\n        //     if (this.matchNext(this.tokens.slice(i), [Token.LCParen])) {\n        //       while (!this.matchNext(this.tokens.slice(i), [Token.RCParen])) {\n        //         i++;\n        //       }\n        //       break;\n        //     } else if (this.matchNext(this.tokens.slice(i), [Token.RCParen])) {\n        //       break;\n        //     }\n        //     i++;\n        //   }\n        //   i++;\n        // }\n        // return ast;\n    }\n    /**\n    * Parses a single statement or declaration by delegating the parsing of the next set of tokens to the appropriate method.\n    * @param tokens - Remaining tokens to parse.\n    * @param allowVariables - Whether encountered identifiers should be consider\n        variable initializations or references.\n    * @return A set of AST nodes and the number of consumed tokens.\n    */\n    parseNode(tokens, allowVariables = true) {\n        const token = tokens[0];\n        switch (token[0]) {\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.DefcalGrammar: {\n                const [defcalGrammarNode, consumed] = this.defcalGrammarDeclaration(tokens);\n                return [[defcalGrammarNode], consumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Include: {\n                const [includeNode, consumed] = this.include(tokens);\n                if (includeNode.filename === '\"stdgates.inc\"') {\n                    this.stdGates();\n                }\n                return [[includeNode], consumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.OpenQASM: {\n                const [qasmNode, consumed] = this.versionHeader(tokens);\n                return [[qasmNode], consumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Const: {\n                const [constNode, consumed] = this.classicalDeclaration(tokens.slice(1), true);\n                return [[constNode], consumed + 1];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Input:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Output: {\n                const [ioType, consumed] = this.ioType(tokens);\n                return [[ioType], consumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Float:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Int:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.UInt:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Bool:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Angle:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Stretch:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Complex:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Duration: {\n                const [classicalNode, consumed] = this.classicalDeclaration(tokens, false);\n                return [[classicalNode], consumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Qubit:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.QReg: {\n                const [qregNode, qregConsumed] = this.quantumDeclaration(tokens);\n                return [[qregNode], qregConsumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Break:\n                return [[new _ast__WEBPACK_IMPORTED_MODULE_3__.BreakStatement()], 1];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Reset: {\n                const [resetNode, resetConsumed] = this.resetStatement(tokens);\n                return [[resetNode], resetConsumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Continue:\n                return [[new _ast__WEBPACK_IMPORTED_MODULE_3__.ContinueStatement()], 1];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Let: {\n                const [letNode, letConsumed] = this.aliasStatement(tokens);\n                return [[letNode], letConsumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Bit:\n                if (this.isMeasurement(tokens.slice(1))) {\n                    const [measureNode, measureConsumed] = this.measureStatement(tokens);\n                    return [[measureNode], measureConsumed];\n                }\n                else {\n                    const [classicalNode, consumed] = this.classicalDeclaration(tokens, false);\n                    return [[classicalNode], consumed];\n                }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.CReg: {\n                const [classicalNode, consumed] = this.classicalDeclaration(tokens, false);\n                return [[classicalNode], consumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Measure: {\n                const [measureNode, measureConsumed] = this.measureStatement(tokens);\n                return [[measureNode], measureConsumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Gate: {\n                const [gateNode, gateConsumed] = this.quantumGateDefinition(tokens);\n                this.customGates.add(gateNode.name.name);\n                return [[gateNode], gateConsumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Return: {\n                const [returnNode, returnConsumed] = this.returnStatement(tokens);\n                return [[returnNode], returnConsumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Def: {\n                const [subroutineNode, subroutineConsumed] = this.subroutineDefinition(tokens);\n                this.subroutines.add(subroutineNode.name.name);\n                return [[subroutineNode], subroutineConsumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Extern: {\n                const [externNode, consumed] = this.externSignature(tokens);\n                this.subroutines.add(externNode.name.name);\n                return [[externNode], consumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Ctrl:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.NegCtrl:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Inv:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.PowM: {\n                const [gateCallNode, gateCallConsumed] = this.quantumGateCall(tokens);\n                return [[gateCallNode], gateCallConsumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Ceiling:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Exp:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Floor:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Log:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Mod:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Popcount:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Pow:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Sqrt:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Rotr:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Rotl: {\n                const [expr, exprConsumed] = this.binaryExpression(tokens.slice(1));\n                let consumed = exprConsumed + 1;\n                const [math, mathConsumed] = this.createMathOrTrigFunction(token[0], expr);\n                consumed += mathConsumed;\n                return [[math], consumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Opaque: {\n                let consumed = 1;\n                while (consumed < this.tokens.length &&\n                    !this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n                    consumed++;\n                }\n                return [[], consumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.DurationOf: {\n                const [durationOfNOde, consumed] = this.durationOf(tokens);\n                return [[durationOfNOde], consumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.SizeOf: {\n                const [sizeOfNode, consumed] = this.sizeOf(tokens);\n                return [[sizeOfNode], consumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Delay: {\n                const [delayNode, delayConsumed] = this.delay(tokens);\n                return [[delayNode], delayConsumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.If: {\n                const [ifNode, ifConsumed] = this.ifStatement(tokens);\n                return [[ifNode], ifConsumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.For: {\n                const [forNode, forConsumed] = this.forLoopStatement(tokens);\n                return [[forNode], forConsumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.While: {\n                const [whileNode, whileConsumed] = this.whileLoopStatement(tokens);\n                return [[whileNode], whileConsumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Switch: {\n                const [switchNode, switchConsumed] = this.switchStatement(tokens);\n                return [[switchNode], switchConsumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Array: {\n                const [arrayNode, arrayConsumed] = this.arrayDeclaration(tokens);\n                this.customArrays.add(arrayNode.identifier.name);\n                return [[arrayNode], arrayConsumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Box: {\n                const [boxNode, boxConsumed] = this.box(tokens);\n                return [[boxNode], boxConsumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Barrier: {\n                const [barrierNode, barrierConsumed] = this.barrier(tokens);\n                return [[barrierNode], barrierConsumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Id:\n                if (this.isQuantumGateCall(tokens)) {\n                    const [gateCallNode, gateCallConsumed] = this.quantumGateCall(tokens);\n                    return [[gateCallNode], gateCallConsumed];\n                }\n                else if (this.isSubroutineCall(tokens)) {\n                    const [subroutineCallNode, subroutineCallConsumed] = this.subroutineCall(tokens);\n                    return [[subroutineCallNode], subroutineCallConsumed];\n                }\n                else if (this.isMeasurement(tokens)) {\n                    const [measureNode, measureConsumed] = this.measureStatement(tokens);\n                    return [[measureNode], measureConsumed];\n                }\n                else if (this.matchNext(tokens.slice(1), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.EqualsAssmt]) ||\n                    this.matchNext(tokens.slice(1), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.CompoundArithmeticOp]) ||\n                    this.matchNext(tokens.slice(1), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.CompoundBinaryOp]) ||\n                    this.isAssignment(tokens)) {\n                    const [assignmentNode, consumed] = this.assignment(tokens);\n                    return [[assignmentNode], consumed];\n                }\n                else if (allowVariables) {\n                    const [expr, consumed] = this.binaryExpression(tokens);\n                    if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n                        return [[expr], consumed + 1];\n                    }\n                    else {\n                        throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingSemicolonError, tokens[consumed], this.index + consumed, \"expected semicolon\");\n                    }\n                }\n                break;\n            default:\n                return [[], 1];\n        }\n    }\n    /**\n     * Checks if the next tokens match those expected.\n     * @param tokens - Remaining tokens to parse.\n     * @param expectedTokens - Expected tokens.\n     * @return Whether these is a match.\n     */\n    matchNext(tokens, expectedTokens) {\n        let matches = true;\n        let i = 0;\n        if (tokens.length == 0) {\n            return false;\n        }\n        while (i < expectedTokens.length) {\n            if (tokens[i][0] != expectedTokens[i]) {\n                matches = false;\n                break;\n            }\n            i++;\n        }\n        return matches;\n    }\n    /**\n     * Parses a `defcalgrammar` declaration.\n     *\n     * calibrationGrammarStatement:\n     *   DEFCALGRAMMAR StringLiteral SEMICOLON\n     *\n     * @param tokens - Remaining tokens to parse.\n     * @return The parsed CalibrationGrammarDeclaration AstNode node and the number of consumed tokens.\n     */\n    defcalGrammarDeclaration(tokens) {\n        const consumed = 1;\n        if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.String, _token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n            return [\n                new _ast__WEBPACK_IMPORTED_MODULE_3__.CalibrationGrammarDeclaration(tokens[0][1].toString()),\n                consumed + 2,\n            ];\n        }\n        throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadStringLiteralError, tokens[consumed], this.index + consumed, \"expected string literal following `defcalgrammar` keyword\");\n    }\n    /**\n     * Parses a classical type declaration.\n     * @param tokens - Remaining tokens to parse.\n     * @param isConst - Whether the declaration is for a constant, defaults to False.\n     * @return The parsed ClassicalDeclaration AstNode and the number of consumed tokens.\n     */\n    classicalDeclaration(tokens, isConst) {\n        const isConstParam = isConst ? isConst : false;\n        let id = null;\n        let initialValue;\n        let consumed = 0;\n        const [classicalType, classicalTypeConsumed] = this.parseClassicalType(tokens);\n        consumed += classicalTypeConsumed;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RParen]) &&\n            !this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Comma])) {\n            const [identifier, idConsumed] = this.unaryExpression(tokens.slice(consumed));\n            id = identifier;\n            consumed += idConsumed;\n            if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.EqualsAssmt])) {\n                consumed++;\n                const [value, valueConsumed] = this.binaryExpression(tokens.slice(consumed));\n                initialValue = value;\n                consumed += valueConsumed;\n            }\n            if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n                consumed++;\n            }\n        }\n        return [\n            new _ast__WEBPACK_IMPORTED_MODULE_3__.ClassicalDeclaration(classicalType, id, initialValue, isConstParam),\n            consumed,\n        ];\n    }\n    /**\n     * Parses an IO declaration statement.\n     * @param tokens - Remaining tokens to parse.\n     * @return A tuple containing the parsed IODeclaration and the number of tokens consumed.\n     */\n    ioType(tokens) {\n        let consumed = 0;\n        let modifier;\n        switch (tokens[consumed][0]) {\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Input:\n                modifier = _ast__WEBPACK_IMPORTED_MODULE_3__.IOModifier.INPUT;\n                break;\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Output:\n                modifier = _ast__WEBPACK_IMPORTED_MODULE_3__.IOModifier.OUTPUT;\n                break;\n            default:\n                throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadExpressionError, tokens[consumed], this.index + consumed, \"unsupported IO modifier\");\n        }\n        consumed++;\n        const [classicalDeclaration, typeConsumed] = this.classicalDeclaration(tokens.slice(consumed));\n        consumed += typeConsumed;\n        return [new _ast__WEBPACK_IMPORTED_MODULE_3__.IODeclaration(modifier, classicalDeclaration), consumed];\n    }\n    /**\n     * Parses a unary expression.\n     * @param tokens - Remaining tokens to parse.\n     * @return A tuple containing the parsed Expression and the number of tokens consumed.\n     */\n    unaryExpression(tokens) {\n        const token = tokens[0];\n        let consumed = 1;\n        switch (token[0]) {\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.NNInteger: {\n                if (this.isImaginary(tokens[consumed])) {\n                    return [\n                        new _ast__WEBPACK_IMPORTED_MODULE_3__.ImaginaryLiteral(`${token[1].toString()}im`),\n                        consumed + 1,\n                    ];\n                }\n                else if (this.isDuration(tokens.slice(consumed))) {\n                    return [\n                        new _ast__WEBPACK_IMPORTED_MODULE_3__.DurationLiteral(Number(token[1]), tokens[consumed][1].toString()),\n                        consumed + 1,\n                    ];\n                }\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.IntegerLiteral(Number(token[1])), consumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Integer: {\n                if (this.isImaginary(tokens[consumed])) {\n                    return [\n                        new _ast__WEBPACK_IMPORTED_MODULE_3__.ImaginaryLiteral(`${token[1].toString()}im`),\n                        consumed + 1,\n                    ];\n                }\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.IntegerLiteral(token[1].toString()), consumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.BinaryLiteral:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.OctalLiteral:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.HexLiteral:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.ScientificNotation:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.NumericLiteral(token[1].toString()), consumed];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Real:\n                if (this.isImaginary(tokens[consumed])) {\n                    return [\n                        new _ast__WEBPACK_IMPORTED_MODULE_3__.ImaginaryLiteral(`${token[1].toString()}im`),\n                        consumed + 1,\n                    ];\n                }\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.FloatLiteral(Number(token[1])), consumed];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.BoolLiteral:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.BooleanLiteral(token[1] === \"true\"), consumed];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Arccos:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Arcsin:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Arctan:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Cos:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Sin:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Tan:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Ceiling:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Exp:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Floor:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Log:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Mod:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Popcount:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Pow:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Sqrt:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Rotr:\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Rotl: {\n                const [funcExpr, funcConsumed] = this.unaryExpression(tokens.slice(1));\n                consumed += funcConsumed;\n                return [\n                    this.createMathOrTrigFunction(tokens[0][0], funcExpr),\n                    consumed,\n                ];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Id:\n                // Handle array identifiers, identifiers, and subscripted identifiers\n                if (this.matchNext(tokens.slice(1), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LSParen])) {\n                    if (this.isArray(tokens)) {\n                        const [arrayAccess, arrayAccessConsumed] = this.parseArrayAccess(tokens);\n                        return [arrayAccess, arrayAccessConsumed];\n                    }\n                    else {\n                        const identifier = new _ast__WEBPACK_IMPORTED_MODULE_3__.Identifier(token[1].toString());\n                        const [subscript, subscriptConsumed] = this.parseSubscript(tokens.slice(1));\n                        consumed += subscriptConsumed;\n                        return [\n                            new _ast__WEBPACK_IMPORTED_MODULE_3__.SubscriptedIdentifier(identifier.name, subscript),\n                            consumed,\n                        ];\n                    }\n                }\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.Identifier(token[1].toString()), consumed];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Pi:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.Pi(), consumed];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Euler:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.Euler(), consumed];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Tau:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.Tau(), consumed];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.String:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.BitstringLiteral(token[1].toString()), consumed];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.DurationOf:\n                return this.durationOf(tokens);\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.SizeOf:\n                return this.sizeOf(tokens);\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.UnaryOp: {\n                const [expr, exprConsumed] = this.unaryExpression(tokens.slice(1));\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.Unary(token[1], expr), consumed + exprConsumed];\n            }\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.LParen: {\n                let i = 1;\n                let parenCount = 1;\n                while (parenCount > 0 && i < tokens.length) {\n                    if (tokens[i][0] === _token__WEBPACK_IMPORTED_MODULE_0__.Token.LParen) {\n                        parenCount++;\n                    }\n                    else if (tokens[i][0] === _token__WEBPACK_IMPORTED_MODULE_0__.Token.RParen) {\n                        parenCount--;\n                    }\n                    else if (parenCount === 1 && tokens[i][0] === _token__WEBPACK_IMPORTED_MODULE_0__.Token.Comma) {\n                        return this.parseParameters(tokens);\n                    }\n                    i++;\n                }\n                const [expr, exprConsumed] = this.binaryExpression(tokens.slice(1));\n                consumed += exprConsumed;\n                if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RParen])) {\n                    throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[consumed], this.index + consumed, \"expected closing parenthesis\");\n                }\n                consumed++;\n                return [expr, consumed];\n            }\n            default:\n                if (isTypeToken(token[0])) {\n                    return this.parseTypeCast(tokens);\n                }\n                throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadExpressionError, token, this.index, \"invalid expression\");\n        }\n    }\n    /**\n     * Parses a binary expression.\n     * @param tokens - Remaining tokens to parse.\n     * @return A tuple containing the parsed Expression and the number of tokens consumed.\n     */\n    binaryExpression(tokens) {\n        const unaryExpr = this.unaryExpression(tokens);\n        let leftExpr = unaryExpr[0];\n        const leftConsumed = unaryExpr[1];\n        let consumed = leftConsumed;\n        while (consumed < tokens.length) {\n            const token = tokens[consumed];\n            if (token[0] === _token__WEBPACK_IMPORTED_MODULE_0__.Token.BinaryOp ||\n                token[0] === _token__WEBPACK_IMPORTED_MODULE_0__.Token.ArithmeticOp ||\n                (token[0] === _token__WEBPACK_IMPORTED_MODULE_0__.Token.UnaryOp && token[1] === \"-\")) {\n                consumed++;\n                const [rightExpr, rightConsumed] = this.unaryExpression(tokens.slice(consumed));\n                if (token[0] === _token__WEBPACK_IMPORTED_MODULE_0__.Token.BinaryOp) {\n                    leftExpr = new _ast__WEBPACK_IMPORTED_MODULE_3__.Binary(token[1], leftExpr, rightExpr);\n                }\n                else if (token[0] === _token__WEBPACK_IMPORTED_MODULE_0__.Token.UnaryOp && token[1] === \"-\") {\n                    leftExpr = new _ast__WEBPACK_IMPORTED_MODULE_3__.Arithmetic(_ast__WEBPACK_IMPORTED_MODULE_3__.ArithmeticOp.MINUS, leftExpr, rightExpr);\n                }\n                else {\n                    leftExpr = new _ast__WEBPACK_IMPORTED_MODULE_3__.Arithmetic(token[1], leftExpr, rightExpr);\n                }\n                consumed += rightConsumed;\n            }\n            else {\n                break;\n            }\n        }\n        return [leftExpr, consumed];\n    }\n    /**\n     * Parses an assignment statement.\n     * @param tokens - Remaining tokens to parse.\n     * @return The parsed AssignmentStatement AstNode and the number of consumed tokens.\n     */\n    assignment(tokens) {\n        let consumed = 0;\n        const [lhs, lhsConsumed] = this.unaryExpression(tokens);\n        consumed += lhsConsumed;\n        // Handle compound assignments\n        const operatorToken = tokens[consumed][0];\n        if (operatorToken === _token__WEBPACK_IMPORTED_MODULE_0__.Token.CompoundArithmeticOp ||\n            operatorToken === _token__WEBPACK_IMPORTED_MODULE_0__.Token.CompoundBinaryOp) {\n            consumed++;\n            const operator = tokens[lhsConsumed][1].toString();\n            const [rhs, rhsConsumed] = this.binaryExpression(tokens.slice(consumed));\n            consumed += rhsConsumed;\n            if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n                throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingSemicolonError, tokens[consumed], this.index + consumed, \"expected semicolon\");\n            }\n            consumed++;\n            let op;\n            let expression;\n            switch (operatorToken) {\n                case _token__WEBPACK_IMPORTED_MODULE_0__.Token.CompoundArithmeticOp:\n                    op = operator.slice(0, -1);\n                    expression = new _ast__WEBPACK_IMPORTED_MODULE_3__.Arithmetic(op, lhs, rhs);\n                    break;\n                case _token__WEBPACK_IMPORTED_MODULE_0__.Token.CompoundBinaryOp:\n                    op = operator.slice(0, -1);\n                    expression = new _ast__WEBPACK_IMPORTED_MODULE_3__.Binary(op, lhs, rhs);\n                    break;\n                default:\n                    throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadExpressionError, tokens[consumed], this.index + consumed, \"invalid compound operator\");\n            }\n            return [\n                new _ast__WEBPACK_IMPORTED_MODULE_3__.AssignmentStatement(lhs, expression),\n                consumed,\n            ];\n        }\n        if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.EqualsAssmt])) {\n            consumed++;\n        }\n        else {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadExpressionError, tokens[consumed], this.index + consumed, \"expected `=` in assignment statement\");\n        }\n        let rhs;\n        if (this.isSubroutineCall(tokens.slice(consumed))) {\n            const [subroutineCall, subroutineCallConsumed] = this.subroutineCall(tokens.slice(consumed));\n            rhs = subroutineCall;\n            consumed += subroutineCallConsumed;\n        }\n        else {\n            const [rhsExpression, rhsConsumed] = this.binaryExpression(tokens.slice(consumed));\n            rhs = rhsExpression;\n            consumed += rhsConsumed;\n        }\n        // if (!this.matchNext(tokens.slice(consumed), [Token.Semicolon])) {\n        //   throwParserError(\n        //     MissingSemicolonError,\n        //     tokens[consumed],\n        //     this.index + consumed,\n        //     \"expected semicolon\",\n        //   );\n        // }\n        // consumed++;\n        return [\n            new _ast__WEBPACK_IMPORTED_MODULE_3__.AssignmentStatement(lhs, rhs),\n            consumed,\n        ];\n    }\n    /**\n     * Parses a quantum declaration.\n     * @param tokens - Tokens to parse.\n     * @return A QuantumDeclaration node and the number of tokens consumed.\n     */\n    quantumDeclaration(tokens) {\n        let consumed = 1;\n        const isQubit = tokens[0][0] === _token__WEBPACK_IMPORTED_MODULE_0__.Token.Qubit;\n        let size = null;\n        // Qubit\n        if (isQubit) {\n            if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LSParen])) {\n                consumed++;\n                const [sizeExpr, sizeConsumed] = this.binaryExpression(tokens.slice(consumed));\n                consumed += sizeConsumed;\n                size = sizeExpr;\n                if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RSParen])) {\n                    throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[consumed], this.index + consumed, \"expected closing bracket ] for qubit declaration size\");\n                }\n                consumed++;\n            }\n        }\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Id])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadQregError, tokens[consumed], this.index + consumed, \"expected identifier for quantum declaration\");\n        }\n        const [identifier, idConsumed] = this.unaryExpression(tokens.slice(consumed, consumed + 1));\n        consumed += idConsumed;\n        // Qreg\n        if (!isQubit && this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LSParen])) {\n            consumed++;\n            const [sizeExpr, sizeConsumed] = this.binaryExpression(tokens.slice(consumed));\n            size = sizeExpr;\n            consumed += sizeConsumed;\n            if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RSParen])) {\n                throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[consumed], this.index + consumed, \"expected closing bracket ] for quantum register size\");\n            }\n            consumed++;\n        }\n        if (!(this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon]) ||\n            this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Comma]) ||\n            this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RParen]))) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadQregError, tokens[consumed], this.index + consumed, \"expected semicolon, comma, or closing parenthesis after quantum register declaration\");\n        }\n        // Only consume semicolon, if paren or comma that token will be handled in calling function\n        if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n            consumed++;\n        }\n        return [new _ast__WEBPACK_IMPORTED_MODULE_3__.QuantumDeclaration(identifier, size), consumed];\n    }\n    /**\n     * Parses a measure statement.\n     * @param tokens - Remaining tokens to parse.\n     * @return A tuple containing the QuantumMeasurementAssignment or QuantumMeasurement and the number of tokens consumed.\n     */\n    measureStatement(tokens) {\n        let consumed = 0;\n        // Legacy syntax: measure qubit|qubit[] -> bit|bit[];\n        if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Measure])) {\n            consumed++;\n            const qubitIdentifiers = [];\n            while (!(this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Arrow]) ||\n                this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon]))) {\n                const [identifier, idConsumed] = this.unaryExpression(tokens.slice(consumed));\n                qubitIdentifiers.push(identifier);\n                consumed += idConsumed;\n                if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Comma])) {\n                    consumed++;\n                }\n                else if (!(this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Arrow]) ||\n                    this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon]))) {\n                    throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadMeasurementError, tokens[consumed], this.index + consumed, \"expected comma or arrow in measurement statement\");\n                }\n            }\n            const measurement = new _ast__WEBPACK_IMPORTED_MODULE_3__.QuantumMeasurement(qubitIdentifiers);\n            // If there's an arrow, build a QuantumMeasurementAssignment\n            if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Arrow])) {\n                consumed++;\n                const [identifier, idConsumed] = this.unaryExpression(tokens.slice(consumed));\n                const classicalBit = identifier;\n                consumed += idConsumed;\n                if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n                    throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingSemicolonError, tokens[consumed], this.index + consumed);\n                }\n                consumed++;\n                return [\n                    new _ast__WEBPACK_IMPORTED_MODULE_3__.QuantumMeasurementAssignment(classicalBit, measurement),\n                    consumed,\n                ];\n            }\n            else {\n                if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n                    throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingSemicolonError, tokens[consumed], this.index + consumed);\n                }\n                consumed++;\n                return [measurement, consumed];\n            }\n        }\n        // New syntax: bit|bit[] = measure qubit|qreg;\n        else {\n            const [leftIdentifier, leftIdConsumed] = this.unaryExpression(tokens.slice(consumed));\n            const classicalBit = leftIdentifier;\n            consumed += leftIdConsumed;\n            if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.EqualsAssmt])) {\n                throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadMeasurementError, tokens[consumed], this.index + consumed, \"expected `=` in measurement assignment\");\n            }\n            consumed++;\n            if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Measure])) {\n                throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadMeasurementError, tokens[consumed], this.index + consumed, \"expected `measure` keyword in measurement assignment\");\n            }\n            consumed++;\n            const [rightIdentifier, rightIdConsumed] = this.unaryExpression(tokens.slice(consumed));\n            const qubitIdentifier = rightIdentifier;\n            consumed += rightIdConsumed;\n            if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n                throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingSemicolonError, tokens[consumed], this.index + consumed);\n            }\n            consumed++;\n            const measurement = new _ast__WEBPACK_IMPORTED_MODULE_3__.QuantumMeasurement([\n                qubitIdentifier,\n            ]);\n            return [\n                new _ast__WEBPACK_IMPORTED_MODULE_3__.QuantumMeasurementAssignment(classicalBit, measurement),\n                consumed,\n            ];\n        }\n    }\n    /**\n     * Parses a subroutine return statement.\n     * @param tokens - Remaining tokens to parse.\n     * @return A tuple containing the SubroutineDefinition and the number of tokens consumed.\n     */\n    returnStatement(tokens) {\n        let consumed = 1;\n        let expression = null;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n            const [expr, exprConsumed] = this.parseNode(tokens.slice(consumed));\n            expression = expr;\n            consumed += exprConsumed;\n        }\n        return [new _ast__WEBPACK_IMPORTED_MODULE_3__.ReturnStatement(expression), consumed];\n    }\n    /**\n     * Parses an extern signature.\n     * @param tokens - Remaining tokens to parse.\n     * @return A tuple containing the ExternSignature and the number of tokens consumed.\n     */\n    externSignature(tokens) {\n        let consumed = 1;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Id])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadSubroutineError, tokens[consumed], this.index + consumed, \"expected identifier following extern keyword\");\n        }\n        const [identifier, identifierConsumed] = this.unaryExpression(tokens.slice(consumed));\n        consumed += identifierConsumed;\n        let externParams = null;\n        if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LParen])) {\n            const [params, paramsConsumed] = this.parseParameters(tokens.slice(consumed));\n            externParams = params;\n            consumed += paramsConsumed;\n        }\n        let returnType = null;\n        if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Arrow])) {\n            consumed++;\n            const [type, typeConsumed] = this.parseClassicalType(tokens.slice(consumed));\n            returnType = type;\n            consumed += typeConsumed;\n        }\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingSemicolonError, tokens[consumed], this.index + consumed, \"expected semicolon\");\n        }\n        consumed++;\n        return [\n            new _ast__WEBPACK_IMPORTED_MODULE_3__.ExternSignature(identifier, externParams, returnType),\n            consumed,\n        ];\n    }\n    /**\n     * Parses a subroutine definition.\n     * @param tokens - Remaining tokens to parse.\n     * @return A tuple containing the SubroutineDefinition and the number of tokens consumed.\n     */\n    subroutineDefinition(tokens) {\n        let consumed = 1;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Id])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadSubroutineError, tokens[consumed], this.index + consumed, \"expected subroutine name\");\n        }\n        const [name, nameConsumed] = this.unaryExpression(tokens.slice(consumed));\n        consumed += nameConsumed;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LParen])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[consumed], this.index + consumed, \"expected opening parenthesis for subroutine definition\");\n        }\n        const [params, paramsConsumed] = this.parseParameters(tokens.slice(consumed));\n        consumed += paramsConsumed;\n        let returnType = null;\n        if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Arrow])) {\n            consumed++;\n            const [type, typeConsumed] = this.parseClassicalType(tokens.slice(consumed));\n            returnType = type;\n            consumed += typeConsumed;\n        }\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LCParen])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[consumed], this.index + consumed, \"expected opening brace for subroutine body\");\n        }\n        const [body, bodyConsumed] = this.programBlock(tokens.slice(consumed));\n        consumed += bodyConsumed;\n        return [\n            new _ast__WEBPACK_IMPORTED_MODULE_3__.SubroutineDefinition(name, body, params, returnType),\n            consumed,\n        ];\n    }\n    /**\n     * Parses a subroutine call.\n     * @param tokens - Remaining tokens to parse.\n     * @return A tuple containing the SubroutineCall and the number of tokens consumed.\n     */\n    subroutineCall(tokens) {\n        let consumed = 0;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Id])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadSubroutineError, tokens[consumed], this.index + consumed, \"expected subroutine name\");\n        }\n        const [subroutineName, subroutineNameConsumed] = this.unaryExpression(tokens.slice(consumed));\n        consumed += subroutineNameConsumed;\n        let callParams = null;\n        if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LParen])) {\n            const [params, paramsConsumed] = this.parseParameters(tokens.slice(consumed));\n            callParams = params;\n            consumed += paramsConsumed;\n        }\n        // if (!this.matchNext(tokens.slice(consumed), [Token.Semicolon])) {\n        //   throwParserError(\n        //     MissingSemicolonError,\n        //     tokens[consumed],\n        //     this.index + consumed,\n        //     \"expected semicolon after subroutine call\",\n        //   );\n        // }\n        if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n            consumed++;\n        }\n        return [\n            new _ast__WEBPACK_IMPORTED_MODULE_3__.SubroutineCall(subroutineName, callParams),\n            consumed,\n        ];\n    }\n    /**\n     * Parses a quantum gate definition.\n     * @param tokens - Remaining tokens to parse.\n     * @return A tuple containing the QuantumGateDefinition and the number of tokens consumed.\n     */\n    quantumGateDefinition(tokens) {\n        let consumed = 1;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Id])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadGateError, tokens[consumed], this.index + consumed, \"expected gate name\");\n        }\n        const [name, nameConsumed] = this.unaryExpression(tokens.slice(consumed));\n        consumed += nameConsumed;\n        // Parse optional parameters\n        const [params, paramsConsumed] = this.parseParameters(tokens.slice(consumed));\n        consumed += paramsConsumed;\n        // Parse qubits\n        const qubits = [];\n        while (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LCParen])) {\n            if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Id])) {\n                throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadGateError, tokens[consumed], this.index + consumed, \"expected qubit argument\");\n            }\n            const [qubit, qubitConsumed] = this.unaryExpression(tokens.slice(consumed));\n            qubits.push(qubit);\n            consumed += qubitConsumed;\n            if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Comma])) {\n                consumed++;\n            }\n            else if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LCParen])) {\n                throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadGateError, tokens[consumed], this.index + consumed, \"expected comma or opening brace for gate body\");\n            }\n        }\n        const [body, bodyConsumed] = this.programBlock(tokens.slice(consumed));\n        consumed += bodyConsumed;\n        return [\n            new _ast__WEBPACK_IMPORTED_MODULE_3__.QuantumGateDefinition(name, params, qubits, body),\n            consumed,\n        ];\n    }\n    /**\n     * Parses a quantum gate call.\n     * @param tokens - Remaining tokens to parse.\n     * @return A tuple containing the QuantumGateCall and the number of tokens consumed.\n     */\n    quantumGateCall(tokens) {\n        let consumed = 0;\n        const modifiers = [];\n        // Parse modifier(s)\n        while (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Ctrl]) ||\n            this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.NegCtrl]) ||\n            this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Inv]) ||\n            this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.PowM])) {\n            const [modifier, modifierConsumed] = this.parseQuantumGateModifier(tokens.slice(consumed));\n            modifiers.push(modifier);\n            consumed += modifierConsumed;\n        }\n        // Parse gate name\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Id])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadGateError, tokens[consumed], this.index + consumed, \"expected gate name\");\n        }\n        const [gateName, gateNameConsumed] = this.unaryExpression(tokens.slice(consumed));\n        consumed += gateNameConsumed;\n        let callParams = null;\n        // Parse optional parameters\n        if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LParen])) {\n            const [params, paramsConsumed] = this.parseParameters(tokens.slice(consumed));\n            callParams = params;\n            consumed += paramsConsumed;\n        }\n        // Parse qubit arguments\n        const [qubits, qubitsConsumed] = this.parseQubitList(tokens.slice(consumed));\n        consumed += qubitsConsumed;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingSemicolonError, tokens[consumed], this.index + consumed, \"expected semicolon\");\n        }\n        consumed++;\n        return [\n            new _ast__WEBPACK_IMPORTED_MODULE_3__.QuantumGateCall(gateName, qubits, callParams, modifiers),\n            consumed,\n        ];\n    }\n    /**\n     * Parses a list of qubits.\n     * @param tokens - Remaining tokens to parse.\n     * @return A tuple containing the list of qubits and the number of tokens consumed.\n     */\n    parseQubitList(tokens) {\n        let consumed = 0;\n        const qubits = [];\n        while (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n            if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Dollar, _token__WEBPACK_IMPORTED_MODULE_0__.Token.NNInteger])) {\n                const [hardwareQubit, hardwareQubitConsumed] = this.parseHardwareQubit(tokens.slice(consumed));\n                qubits.push(hardwareQubit);\n                consumed += hardwareQubitConsumed;\n                if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Comma])) {\n                    consumed++;\n                }\n                continue;\n            }\n            else if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Id])) {\n                throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadExpressionError, tokens[consumed], this.index + consumed, \"expected qubit argument\");\n            }\n            const [qubit, qubitConsumed] = this.unaryExpression(tokens.slice(consumed));\n            qubits.push(qubit);\n            consumed += qubitConsumed;\n            if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Comma])) {\n                consumed++;\n            }\n            else if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n                break;\n            }\n        }\n        return [qubits, consumed];\n    }\n    /**\n     * Parses a hardware qubit.\n     * @param tokens - Remaining tokens to parse.\n     * @return A tuple containing the HardwareQubit and the number of tokens consumed.\n     */\n    parseHardwareQubit(tokens) {\n        let consumed = 0;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Dollar])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadGateError, tokens[consumed], this.index + consumed, \"expected dollar sign for hardware qubit\");\n        }\n        consumed++;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.NNInteger])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadGateError, tokens[consumed], this.index + consumed, \"expected non-negative integer for hardware qubit\");\n        }\n        return [new _ast__WEBPACK_IMPORTED_MODULE_3__.HardwareQubit(Number(tokens[consumed][1])), consumed + 1];\n    }\n    /**\n     * Parses a gate modifier.\n     * @param tokens - Remaining tokens to parse.\n     * @return A tuple containing the gate modifier and the number of tokens consumed.\n     */\n    parseQuantumGateModifier(tokens) {\n        let consumed = 1;\n        const modifierToken = tokens[0][0];\n        let modifier;\n        let argument = null;\n        switch (modifierToken) {\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Ctrl:\n                modifier = _ast__WEBPACK_IMPORTED_MODULE_3__.QuantumGateModifierName.CTRL;\n                break;\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.NegCtrl:\n                modifier = _ast__WEBPACK_IMPORTED_MODULE_3__.QuantumGateModifierName.NRGCTRL;\n                break;\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Inv:\n                modifier = _ast__WEBPACK_IMPORTED_MODULE_3__.QuantumGateModifierName.INV;\n                break;\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.PowM:\n                modifier = _ast__WEBPACK_IMPORTED_MODULE_3__.QuantumGateModifierName.POW;\n                break;\n            default:\n                throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadGateError, tokens[0], this.index, \"invalid gate modifier\");\n        }\n        if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LParen])) {\n            consumed++;\n            const [arg, argConsumed] = this.binaryExpression(tokens.slice(consumed));\n            argument = arg;\n            consumed += argConsumed;\n            if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RParen])) {\n                throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadGateError, tokens[consumed], this.index + consumed, \"expected closing parenthesis after gate modifier argument\");\n            }\n            consumed++;\n        }\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.At])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadGateError, tokens[consumed], this.index + consumed, \"expected `@` symbol after gate modifier\");\n        }\n        consumed++;\n        return [new _ast__WEBPACK_IMPORTED_MODULE_3__.QuantumGateModifier(modifier, argument), consumed];\n    }\n    /**\n     * Parses a set of parameters.\n     * @param tokens - Remaining tokens to parse.\n     * @return A tuple containing the Parameters and the number of tokens consumed.\n     */\n    parseParameters(tokens) {\n        let consumed = 0;\n        const args = [];\n        if (this.matchNext(tokens, [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LParen])) {\n            consumed++;\n            while (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RParen])) {\n                if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Qubit])) {\n                    const [qubitParam, qubitConsumed] = this.parseNode(tokens.slice(consumed));\n                    args.push(qubitParam);\n                    consumed += qubitConsumed;\n                }\n                else if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Bit]) ||\n                    this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.CReg])) {\n                    const [bitParam, bitConsumed] = this.parseNode(tokens.slice(consumed));\n                    args.push(bitParam);\n                    consumed += bitConsumed;\n                }\n                else if (isTypeToken(tokens[consumed][0])) {\n                    const [param, paramConsumed] = this.classicalDeclaration(tokens.slice(consumed));\n                    args.push(param);\n                    consumed += paramConsumed;\n                }\n                else if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.ReadOnly]) ||\n                    this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Mutable])) {\n                    const [arrayRef, arrayRefConsumed] = this.parseArrayReference(tokens.slice(consumed));\n                    args.push(arrayRef);\n                    consumed += arrayRefConsumed;\n                }\n                else {\n                    const [param, paramConsumed] = this.binaryExpression(tokens.slice(consumed));\n                    args.push(param);\n                    consumed += paramConsumed;\n                }\n                if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Comma])) {\n                    consumed++;\n                }\n                else if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RParen])) {\n                    throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadParameterError, tokens[consumed], this.index + consumed, \"expected comma or closing parenthesis in parameter list\");\n                }\n            }\n            consumed++;\n        }\n        return [new _ast__WEBPACK_IMPORTED_MODULE_3__.Parameters(args), consumed];\n    }\n    /**\n     * Parses an array reference.\n     * @param tokens - Remaining tokens to parse.\n     * @return A tuple containing the ArrayReference and the number of tokens consumed.\n     */\n    parseArrayReference(tokens) {\n        let consumed = 0;\n        let modifier;\n        switch (tokens[consumed][0]) {\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Mutable:\n                modifier = _ast__WEBPACK_IMPORTED_MODULE_3__.ArrayReferenceModifier.MUTABLE;\n                break;\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.ReadOnly:\n                modifier = _ast__WEBPACK_IMPORTED_MODULE_3__.ArrayReferenceModifier.READONLY;\n                break;\n            default:\n                throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadExpressionError, tokens[consumed], this.index + consumed, \"unsupported array reference modifier\");\n        }\n        consumed++;\n        const [arrayNode, arrayConsumed] = this.arrayDeclaration(tokens.slice(consumed));\n        consumed += arrayConsumed;\n        return [new _ast__WEBPACK_IMPORTED_MODULE_3__.ArrayReference(arrayNode, modifier), consumed];\n    }\n    /**\n     * Parses an alias statement.\n     * @param tokens - Remaining tokens to parse.\n     * @return A tuple containing the AliasStatement and the number of tokens consumed.\n     */\n    aliasStatement(tokens) {\n        let consumed = 1;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Id])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadExpressionError, tokens[consumed], this.index + consumed, \"expected identifier for alias statement\");\n        }\n        const [identifier, identifierConsumed] = this.unaryExpression(tokens.slice(consumed));\n        consumed += identifierConsumed;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.EqualsAssmt])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadExpressionError, tokens[consumed], this.index + consumed, \"expected `=` symbol following identifier for alias statement\");\n        }\n        consumed++;\n        const [aliasExpression, aliasExpressionConsumed] = this.binaryExpression(tokens.slice(consumed));\n        consumed += aliasExpressionConsumed;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingSemicolonError, tokens[consumed], this.index + consumed, \"expected semicolon\");\n        }\n        consumed++;\n        return [\n            new _ast__WEBPACK_IMPORTED_MODULE_3__.AliasStatement(identifier, aliasExpression),\n            consumed,\n        ];\n    }\n    /**\n     * Parses a quantum reset.\n     * @param tokens - Remaining tokens to parse.\n     * @return A tuple containing the QuantumReset and the number of tokens consumed.\n     */\n    resetStatement(tokens) {\n        let consumed = 1;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Id])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadQuantumInstructionError, tokens[consumed], this.index + consumed, \"expected identifier after reset keyword\");\n        }\n        const [idNode, idConsumed] = this.unaryExpression(tokens.slice(consumed));\n        consumed += idConsumed;\n        let id = null;\n        if (idNode instanceof _ast__WEBPACK_IMPORTED_MODULE_3__.SubscriptedIdentifier) {\n            id = idNode;\n        }\n        else {\n            id = idNode;\n        }\n        consumed++;\n        return [new _ast__WEBPACK_IMPORTED_MODULE_3__.QuantumReset(id), consumed];\n    }\n    /**\n     * Parses a subscript expression as a Range.\n     * @param tokens - Remaining tokens to parse.\n     * @return A tuple containing the parsed Expression or Range and the number of tokens consumed.\n     */\n    parseSubscript(tokens) {\n        let consumed = 1;\n        let start = null;\n        let step = new _ast__WEBPACK_IMPORTED_MODULE_3__.IntegerLiteral(1);\n        let stop = null;\n        if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LCParen])) {\n            const [indexSet, indexSetConsumed] = this.parseIndexSet(tokens.slice(consumed));\n            consumed += indexSetConsumed;\n            if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RSParen])) {\n                throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[consumed], this.index + consumed, \"expected closing curly bracket } for index set\");\n            }\n            consumed++;\n            return [indexSet, consumed];\n        }\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Colon])) {\n            // Parse start\n            const [startExpr, startConsumed] = this.binaryExpression(tokens.slice(consumed));\n            start = startExpr;\n            consumed += startConsumed;\n        }\n        if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RSParen])) {\n            return [start, consumed + 1];\n        }\n        // Check for colon after start\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Colon])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadExpressionError, tokens[consumed], this.index + consumed, \"expected colon in range expression\");\n        }\n        consumed++;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RSParen])) {\n            const [expr, exprConsumed] = this.binaryExpression(tokens.slice(consumed));\n            consumed += exprConsumed;\n            // Check if its a step or stop\n            if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Colon])) {\n                step = expr;\n                consumed++;\n                // Parse stop\n                if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RSParen])) {\n                    throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadExpressionError, tokens[consumed], this.index + consumed, \"expected stop value in range expression\");\n                }\n                const [stopExpr, stopConsumed] = this.binaryExpression(tokens.slice(consumed));\n                stop = stopExpr;\n                consumed += stopConsumed;\n            }\n            else {\n                stop = expr;\n            }\n        }\n        // Check for closing square bracket\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RSParen])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[consumed], this.index + consumed, \"expected closing bracket ] for range expression\");\n        }\n        consumed++;\n        // Validate that both start and stop are provided\n        if (start === null || stop === null) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadExpressionError, tokens[0], this.index, \"both start and stop must be provided in range expression\");\n        }\n        return [new _ast__WEBPACK_IMPORTED_MODULE_3__.Range(start, stop, step), consumed];\n    }\n    /**\n     * Parses a type cast expression.\n     * @param tokens - Remaining tokens to parse.\n     * @return A tuple containing the parsed Cast Expression and the number of tokens consumed.\n     */\n    parseTypeCast(tokens) {\n        let consumed = 1;\n        let widthExpr = null;\n        if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LSParen])) {\n            consumed++;\n            const [width, widthConsumed] = this.binaryExpression(tokens.slice(consumed));\n            consumed += widthConsumed;\n            widthExpr = width;\n            if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RSParen])) {\n                throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[consumed], this.index + consumed, \"missing closing bracket ] for type designator\");\n            }\n            consumed++;\n        }\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LParen])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[0], this.index, \"expected opening parenthesis ( for type cast\");\n        }\n        consumed++;\n        const [castExpr, castConsumed] = this.binaryExpression(tokens.slice(consumed));\n        consumed += castConsumed;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RParen])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[0], this.index, \"expected closing parenthesis ) for type cast\");\n        }\n        consumed++;\n        const castType = this.createClassicalType(tokens[0][0], widthExpr);\n        return [new _ast__WEBPACK_IMPORTED_MODULE_3__.Cast(castType, castExpr), consumed];\n    }\n    /**\n     * Parses a branching condition (if) statement.\n     * @param tokens - Tokens to parse.\n     * @return A BranchingStatement node representing the if statement and the number of tokens consumed.\n     */\n    ifStatement(tokens) {\n        let consumed = 1;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LParen])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[consumed], this.index + consumed, \"expected opening parenthesis after if\");\n        }\n        consumed++;\n        const [condition, conditionConsumed] = this.binaryExpression(tokens.slice(consumed));\n        consumed += conditionConsumed;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RParen])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[consumed], this.index + consumed, \"expected closing parenthesis after if statement condition\");\n        }\n        consumed++;\n        const [trueBody, trueBodyConsumed] = this.programBlock(tokens.slice(consumed));\n        consumed += trueBodyConsumed;\n        let falseBody = null;\n        if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Else])) {\n            consumed++;\n            const [elseBody, elseBodyConsumed] = this.programBlock(tokens.slice(consumed));\n            falseBody = elseBody;\n            consumed += elseBodyConsumed;\n        }\n        return [new _ast__WEBPACK_IMPORTED_MODULE_3__.BranchingStatement(condition, trueBody, falseBody), consumed];\n    }\n    /**\n     * Parses a for loop.\n     * @param tokens - Tokens to parse.\n     * @return A ForLoopStatement node and the number of tokens consumed.\n     */\n    forLoopStatement(tokens) {\n        let consumed = 1;\n        // Parse the type of the loop variable\n        const [loopVarType, loopVarTypeConsumed] = this.parseClassicalType(tokens.slice(consumed));\n        consumed += loopVarTypeConsumed;\n        // Expect an identifier (loop variable)\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Id])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadLoopError, tokens[consumed], this.index + consumed, \"expected identifier for loop variable\");\n        }\n        const [loopVar, loopVarConsumed] = this.unaryExpression(tokens.slice(consumed));\n        if (!(loopVar instanceof _ast__WEBPACK_IMPORTED_MODULE_3__.Identifier)) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadLoopError, tokens[consumed], this.index + consumed, \"expected identifier for loop variable\");\n        }\n        consumed += loopVarConsumed;\n        // Expect `in` keyword\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.In])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadLoopError, tokens[consumed], this.index + consumed, \"expected `in` keyword in for loop\");\n        }\n        consumed++;\n        const [indexSet, indexSetConsumed] = this.parseSetDeclaration(tokens.slice(consumed));\n        consumed += indexSetConsumed;\n        const [body, bodyConsumed] = this.programBlock(tokens.slice(consumed));\n        consumed += bodyConsumed;\n        return [\n            new _ast__WEBPACK_IMPORTED_MODULE_3__.ForLoopStatement(indexSet, loopVarType, loopVar, body),\n            consumed,\n        ];\n    }\n    /**\n     * Parses a while loop.\n     * @param tokens - Tokens to parse.\n     * @return A ForLoopStatement node and the number of tokens consumed.\n     */\n    whileLoopStatement(tokens) {\n        let consumed = 1;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LParen])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[consumed], this.index + consumed, \"expected opening parenthesis after while keyword\");\n        }\n        consumed++;\n        const [condition, conditionConsumed] = this.binaryExpression(tokens.slice(consumed));\n        consumed += conditionConsumed;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RParen])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[consumed], this.index + consumed, \"expected closing parenthesis after while loop condition\");\n        }\n        consumed++;\n        const [body, bodyConsumed] = this.programBlock(tokens.slice(consumed));\n        consumed += bodyConsumed;\n        return [new _ast__WEBPACK_IMPORTED_MODULE_3__.WhileLoopStatement(condition, body), consumed];\n    }\n    /**\n     * Parses a barrier statement.\n     * @param tokens - Tokens to parse.\n     * @return An QuantumBarrier node and the number of tokens consumed.\n     */\n    barrier(tokens) {\n        let consumed = 1;\n        const [qubits, qubitsConsumed] = this.parseQubitList(tokens.slice(consumed));\n        consumed += qubitsConsumed;\n        return [new _ast__WEBPACK_IMPORTED_MODULE_3__.QuantumBarrier(qubits), consumed];\n    }\n    /**\n     * Parses a box statement.\n     * @param tokens - Tokens to parse.\n     * @return An BoxDefinition node and the number of tokens consumed.\n     */\n    box(tokens) {\n        let consumed = 1;\n        let designator = null;\n        if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LSParen])) {\n            consumed++;\n            const [desginatorNode, designatorConsumed] = this.binaryExpression(tokens.slice(consumed));\n            consumed += designatorConsumed;\n            designator = desginatorNode;\n            if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RSParen])) {\n                throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[consumed], this.index + consumed, \"expected closing ] bracket following box designator\");\n            }\n            consumed++;\n        }\n        const [scope, scopeConsumed] = this.programBlock(tokens.slice(consumed));\n        consumed += scopeConsumed;\n        return [new _ast__WEBPACK_IMPORTED_MODULE_3__.BoxDefinition(scope, designator), consumed];\n    }\n    /**\n     * Parses an array statement.\n     * @param tokens - Tokens to parse.\n     * @return An ArrayDeclaration node and the number of tokens consumed.\n     */\n    arrayDeclaration(tokens) {\n        let consumed = 1;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LSParen])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[consumed], this.index + consumed, \"expected [ after array keyword\");\n        }\n        consumed++;\n        const [baseType, baseTypeConsumed] = this.parseClassicalType(tokens.slice(consumed));\n        consumed += baseTypeConsumed;\n        let dimensions = [];\n        while (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Comma])) {\n            consumed++;\n            if (this.matchNext(tokens.slice(consumed), [\n                _token__WEBPACK_IMPORTED_MODULE_0__.Token.Dim,\n                _token__WEBPACK_IMPORTED_MODULE_0__.Token.EqualsAssmt,\n                _token__WEBPACK_IMPORTED_MODULE_0__.Token.NNInteger,\n            ])) {\n                consumed += 2;\n                dimensions = Number(tokens[consumed][1]);\n                consumed++;\n                break;\n            }\n            const [dimension, dimensionConsumed] = this.binaryExpression(tokens.slice(consumed));\n            dimensions.push(dimension);\n            consumed += dimensionConsumed;\n        }\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RSParen])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[consumed], this.index + consumed, \"expected ] after array type declaration\");\n        }\n        consumed++;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Id])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadExpressionError, tokens[consumed], this.index + consumed, \"expected identifier for array declaration\");\n        }\n        const [identifier, identifierConsumed] = this.unaryExpression(tokens.slice(consumed));\n        consumed += identifierConsumed;\n        let initializer = null;\n        if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.EqualsAssmt])) {\n            consumed++;\n            const [parsedInitializer, initializerConsumed] = this.parseArrayInitializer(tokens.slice(consumed));\n            initializer = parsedInitializer;\n            consumed += initializerConsumed;\n        }\n        if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n            consumed++;\n        }\n        return [\n            new _ast__WEBPACK_IMPORTED_MODULE_3__.ArrayDeclaration(baseType, dimensions, identifier, initializer),\n            consumed,\n        ];\n    }\n    /**\n     * Parses an array initializer.\n     * @param tokens - Tokens to parse.\n     * @return An ArrayInitializer node and the number of tokens consumed.\n     */\n    parseArrayInitializer(tokens) {\n        let consumed = 0;\n        if (!this.matchNext(tokens, [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LCParen])) {\n            const [expr, exprConsumed] = this.binaryExpression(tokens.slice(consumed));\n            consumed += exprConsumed;\n            return [expr, consumed];\n        }\n        consumed++;\n        const values = [];\n        while (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RCParen])) {\n            if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LCParen])) {\n                const [subInitializer, subConsumed] = this.parseArrayInitializer(tokens.slice(consumed));\n                values.push(subInitializer);\n                consumed += subConsumed;\n            }\n            else {\n                const [expr, exprConsumed] = this.binaryExpression(tokens.slice(consumed));\n                values.push(expr);\n                consumed += exprConsumed;\n            }\n            if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Comma])) {\n                consumed++;\n            }\n            else if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RCParen])) {\n                throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadExpressionError, tokens[consumed], this.index + consumed, \"expected comma or } in array initializer\");\n            }\n        }\n        consumed++;\n        return [new _ast__WEBPACK_IMPORTED_MODULE_3__.ArrayInitializer(values), consumed];\n    }\n    /**\n     * Parses an array access.\n     * @param tokens - Tokens to parse.\n     * @return An ArrayAccess  node and the number of tokens consumed.\n     */\n    parseArrayAccess(tokens) {\n        let consumed = 0;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Id])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadExpressionError, tokens[consumed], this.index + consumed, \"expected identifier for array access\");\n        }\n        const identifier = new _ast__WEBPACK_IMPORTED_MODULE_3__.Identifier(tokens[0][1].toString());\n        consumed++;\n        let indices = [];\n        if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LSParen])) {\n            consumed++;\n            while (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RSParen])) {\n                const [index1, index1Consumed] = this.binaryExpression(tokens.slice(consumed));\n                indices.push(index1);\n                consumed += index1Consumed;\n                if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Comma])) {\n                    consumed++;\n                }\n                else if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Colon])) {\n                    consumed++;\n                    let step = new _ast__WEBPACK_IMPORTED_MODULE_3__.IntegerLiteral(1);\n                    let stop;\n                    const [index2, index2Consumed] = this.binaryExpression(tokens.slice(consumed));\n                    consumed += index2Consumed;\n                    if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Colon])) {\n                        consumed++;\n                        const [index3, index3Consumed] = this.binaryExpression(tokens.slice(consumed));\n                        consumed += index3Consumed;\n                        stop = index3;\n                        step = index2;\n                    }\n                    else {\n                        stop = index2;\n                    }\n                    indices = new _ast__WEBPACK_IMPORTED_MODULE_3__.Range(index1, stop, step);\n                    break;\n                }\n                else if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RSParen])) {\n                    throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadExpressionError, tokens[consumed], this.index + consumed, \"expected comma or closing bracket for array access\");\n                }\n            }\n            if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RSParen])) {\n                throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[consumed], this.index + consumed, \"expected closing bracket ] for array access\");\n            }\n            consumed++;\n        }\n        return [new _ast__WEBPACK_IMPORTED_MODULE_3__.ArrayAccess(identifier, indices), consumed];\n    }\n    /**\n     * Parses a switch statement.\n     * @param tokens - Tokens to parse.\n     * @return A SwitchStatement node and the number of tokens consumed.\n     */\n    switchStatement(tokens) {\n        let consumed = 1;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LParen])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[consumed], this.index + consumed, \"expected opening parenthesis after switch keywork\");\n        }\n        consumed++;\n        const [controlExpr, controlExprConsumed] = this.binaryExpression(tokens.slice(consumed));\n        consumed += controlExprConsumed;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RParen])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[consumed], this.index + consumed, \"expected closing parenthesis after switch control expression\");\n        }\n        consumed++;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LCParen])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[consumed], this.index + consumed, \"expected opening curly brace for switch body\");\n        }\n        consumed++;\n        const cases = [];\n        let defaultCase = null;\n        while (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RCParen])) {\n            if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Case])) {\n                const [caseStmt, caseConsumed] = this.parseCaseStatement(tokens.slice(consumed));\n                cases.push(caseStmt);\n                consumed += caseConsumed;\n            }\n            else if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Default])) {\n                if (defaultCase !== null) {\n                    throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadExpressionError, tokens[consumed], this.index + consumed, \"multiple default statements not allowed in a swtich statement\");\n                }\n                const [defaultStmt, defaultConsumed] = this.parseDefaultStatement(tokens.slice(consumed));\n                defaultCase = defaultStmt;\n                consumed += defaultConsumed;\n            }\n            else {\n                throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadExpressionError, tokens[consumed], this.index + consumed, \"expected case or default statement in switch body\");\n            }\n        }\n        if (cases.length === 0) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadExpressionError, tokens[consumed], this.index + consumed, \"swtich statement must contain at least one case statement\");\n        }\n        consumed++;\n        return [new _ast__WEBPACK_IMPORTED_MODULE_3__.SwitchStatement(controlExpr, cases, defaultCase), consumed];\n    }\n    /**\n     * Parses a case statement.\n     * @param tokens - Tokens to parse.\n     * @return A CaseStatement node and the number of tokens consumed.\n     */\n    parseCaseStatement(tokens) {\n        let consumed = 1;\n        const labels = [];\n        while (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LCParen])) {\n            const [label, labelConsumed] = this.binaryExpression(tokens.slice(consumed));\n            labels.push(label);\n            consumed += labelConsumed;\n            if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Comma])) {\n                consumed++;\n            }\n            else if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LCParen])) {\n                throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadExpressionError, tokens[consumed], this.index + consumed, \"expected comma or opening brace in case statement\");\n            }\n        }\n        const [body, bodyConsumed] = this.programBlock(tokens.slice(consumed));\n        consumed += bodyConsumed;\n        return [new _ast__WEBPACK_IMPORTED_MODULE_3__.CaseStatement(labels, body), consumed];\n    }\n    /**\n     * Parses a default statement.\n     * @param tokens - Tokens to parse.\n     * @return A DefaultStatement node and the number of tokens consumed.\n     */\n    parseDefaultStatement(tokens) {\n        let consumed = 1;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LCParen])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[consumed], this.index + consumed, \"expecting opening brace for default statement\");\n        }\n        const [body, bodyConsumed] = this.programBlock(tokens.slice(consumed));\n        consumed += bodyConsumed;\n        return [new _ast__WEBPACK_IMPORTED_MODULE_3__.DefaultStatement(body), consumed];\n    }\n    /**\n     * Parses a delay statement.\n     * @param tokens - Tokens to parse.\n     * @return A QuantumDelay node and the number of tokens consumed.\n     */\n    delay(tokens) {\n        let consumed = 1;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LSParen])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[consumed], this.index + consumed, \"expected opening bracket [ after delay keyword\");\n        }\n        consumed++;\n        const [duration, durationConsumed] = this.binaryExpression(tokens.slice(consumed));\n        consumed += durationConsumed;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RSParen])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[consumed], this.index + consumed, \"expected closing bracket ] after delay designator\");\n        }\n        consumed++;\n        const [qubits, qubitsConsumed] = this.parseQubitList(tokens.slice(consumed));\n        consumed += qubitsConsumed;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingSemicolonError, tokens[consumed], this.index + consumed, \"expected semicolon\");\n        }\n        consumed++;\n        return [new _ast__WEBPACK_IMPORTED_MODULE_3__.QuantumDelay(duration, qubits), consumed];\n    }\n    /**\n     * Parses a durationof function call.\n     * @param tokens - Tokens to parse.\n     * @return A DurationOf node and the number of tokens consumed.\n     */\n    durationOf(tokens) {\n        let consumed = 1;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LParen])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[consumed], this.index + consumed, \"expected opening parenthesis after durationof\");\n        }\n        consumed++;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LCParen])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[consumed], this.index + consumed, \"expected opening brace for durationof scope\");\n        }\n        const [scope, scopeConsumed] = this.programBlock(tokens.slice(consumed));\n        consumed += scopeConsumed;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RParen])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[consumed], this.index + consumed, \"expected closing parenthesis after durationof scope\");\n        }\n        consumed++;\n        if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n            consumed++;\n        }\n        return [new _ast__WEBPACK_IMPORTED_MODULE_3__.DurationOf(scope), consumed];\n    }\n    /**\n     * Parses a sizeof function call.\n     * @param tokens - Tokens to parse.\n     * @return A SizeOf node and the number of tokens consumed.\n     */\n    sizeOf(tokens) {\n        let consumed = 1;\n        let dimensions = null;\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LParen])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[consumed], this.index + consumed, \"expected opening parenthesis for sizeof function call\");\n        }\n        consumed++;\n        const [arrayId, arrayIdConsumed] = this.unaryExpression(tokens.slice(consumed));\n        consumed += arrayIdConsumed;\n        if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Comma])) {\n            consumed++;\n            const [dim, dimConsumed] = this.binaryExpression(tokens.slice(consumed));\n            consumed += dimConsumed;\n            dimensions = dim;\n        }\n        if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RParen])) {\n            throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[consumed], this.index + consumed, \"expected closing parenthesis for sizeof function call\");\n        }\n        consumed++;\n        return [new _ast__WEBPACK_IMPORTED_MODULE_3__.SizeOf(arrayId, dimensions), consumed];\n    }\n    /**\n     * Parses a program block.\n     * @param tokens - Tokens to parse.\n     * @return A ProgramBlock node and the number of tokens consumed.\n     */\n    programBlock(tokens) {\n        const statements = [];\n        let consumed = 0;\n        let braceCount = 0;\n        if (this.matchNext(tokens, [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LCParen])) {\n            consumed++;\n            braceCount++;\n            while (braceCount > 0 && consumed < tokens.length) {\n                if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LCParen])) {\n                    braceCount++;\n                }\n                else if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RCParen])) {\n                    braceCount--;\n                }\n                if (braceCount === 0) {\n                    break;\n                }\n                const [node, nodeConsumed] = this.parseNode(tokens.slice(consumed));\n                if (node && node.length > 0) {\n                    statements.push(node[0]);\n                }\n                consumed += nodeConsumed;\n                if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n                    consumed++;\n                }\n            }\n            if (braceCount !== 0) {\n                throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[consumed], this.index + consumed, \"mismatched curly braces in program block\");\n            }\n            consumed++;\n        }\n        else {\n            const [node, nodeConsumed] = this.parseNode(tokens.slice(consumed));\n            if (node && node.length > 0) {\n                statements.push(node[0]);\n            }\n            consumed += nodeConsumed;\n            if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n                consumed++;\n            }\n        }\n        return [new _ast__WEBPACK_IMPORTED_MODULE_3__.ProgramBlock(statements), consumed];\n    }\n    /**\n     * Parses an include statement.\n     * @param tokens - Tokens to parse.\n     * @return An Include node representing the include statement and the number of consumed tokens.\n     */\n    include(tokens) {\n        let filename;\n        const consumed = 1;\n        if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.String, _token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n            filename = tokens[consumed][1].toString();\n            return [new _ast__WEBPACK_IMPORTED_MODULE_3__.Include(filename), consumed + 2];\n        }\n        throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadStringLiteralError, tokens[consumed], this.index + consumed, \"expected string literal following `include` keyword\");\n    }\n    /**\n     * Parses the version header and sets the parser version.\n     * @param tokens - Tokens to parse.\n     * @return A Version node representing the version statement and the number of consumed tokens.\n     */\n    versionHeader(tokens) {\n        let version;\n        let consumed = 1;\n        const slicedTokens = tokens.slice(consumed);\n        if (this.matchNext(slicedTokens, [_token__WEBPACK_IMPORTED_MODULE_0__.Token.NNInteger, _token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n            version = new _version__WEBPACK_IMPORTED_MODULE_1__.OpenQASMVersion(Number(tokens[0][1]));\n            if (!version.isVersion3()) {\n                throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.UnsupportedOpenQASMVersionError, tokens[consumed], this.index + consumed, \"expected QASM version 3\");\n            }\n            consumed += 2;\n            return [new _ast__WEBPACK_IMPORTED_MODULE_3__.Version(version), consumed];\n        }\n        else if (this.matchNext(slicedTokens, [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Real, _token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon])) {\n            const versionSplits = tokens[consumed][1].toString().split(\".\");\n            version = new _version__WEBPACK_IMPORTED_MODULE_1__.OpenQASMVersion(Number(versionSplits[0]), Number(versionSplits[1]));\n            if (!version.isVersion3()) {\n                throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.UnsupportedOpenQASMVersionError, tokens[consumed], this.index + consumed, \"expected QASM version 3\");\n            }\n            consumed += 2;\n            return [new _ast__WEBPACK_IMPORTED_MODULE_3__.Version(version), consumed];\n        }\n        throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.UnsupportedOpenQASMVersionError, tokens[consumed], this.index + consumed, \"expected QASM version 3\");\n    }\n    /**\n     * Parses a classical type.\n     * @param token - The token that represents the type.\n     * @return The ClassicalType and the number of consumed tokens.\n     */\n    parseClassicalType(tokens) {\n        let typeToken = tokens[0][0];\n        let consumed = 1;\n        let width;\n        let isComplex = false;\n        if (typeToken === _token__WEBPACK_IMPORTED_MODULE_0__.Token.Complex) {\n            if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LSParen, _token__WEBPACK_IMPORTED_MODULE_0__.Token.Float])) {\n                throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadClassicalTypeError, tokens[consumed], this.index + consumed, \"expected float type for complex number\");\n            }\n            isComplex = true;\n            consumed += 2;\n            typeToken = tokens[2][0];\n        }\n        // Check if there's a width or size specification\n        if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LSParen])) {\n            consumed++;\n            const [widthExpr, widthConsumed] = this.binaryExpression(tokens.slice(consumed));\n            width = widthExpr;\n            consumed += widthConsumed;\n            if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RSParen])) {\n                throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.MissingBraceError, tokens[consumed], this.index + consumed, \"expected closing bracket ] for type width\");\n            }\n            if (isComplex) {\n                consumed++;\n            }\n            consumed++;\n        }\n        const classicalType = this.createClassicalType(typeToken, width);\n        if (isComplex) {\n            return [new _ast__WEBPACK_IMPORTED_MODULE_3__.ComplexType(classicalType), consumed];\n        }\n        else {\n            return [classicalType, consumed];\n        }\n    }\n    /**\n     * Parses a set declaration.\n     * @param token - The token that represents the type.\n     * @return The resulting Identifier, IndexSet, or Range node and the number of consumed tokens.\n     */\n    parseSetDeclaration(tokens) {\n        if (this.matchNext(tokens, [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Id])) {\n            const [identifier, identifierConsumed] = this.unaryExpression(tokens);\n            return [identifier, identifierConsumed];\n        }\n        else if (this.matchNext(tokens, [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LCParen])) {\n            return this.parseIndexSet(tokens);\n        }\n        else if (this.matchNext(tokens, [_token__WEBPACK_IMPORTED_MODULE_0__.Token.LSParen])) {\n            return this.parseSubscript(tokens);\n        }\n        else {\n            return this.binaryExpression(tokens);\n        }\n    }\n    /**\n     * Parses an index set.\n     * @param token - The token that represents the type.\n     * @return The resulting Identifier, IndexSet, or Range node and the number of consumed tokens.\n     */\n    parseIndexSet(tokens) {\n        let consumed = 1;\n        const values = [];\n        while (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RCParen])) {\n            const [expr, exprConsumed] = this.binaryExpression(tokens.slice(consumed));\n            values.push(expr);\n            consumed += exprConsumed;\n            if (this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.Comma])) {\n                consumed++;\n            }\n            else if (!this.matchNext(tokens.slice(consumed), [_token__WEBPACK_IMPORTED_MODULE_0__.Token.RCParen])) {\n                throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadExpressionError, tokens[consumed], this.index + consumed, \"expected comma or closing curly brace in index set\");\n            }\n        }\n        consumed++;\n        return [new _ast__WEBPACK_IMPORTED_MODULE_3__.IndexSet(values), consumed];\n    }\n    /**\n     * Creates a classical type.\n     * @param token - The token that represents the type.\n     * @param width - The type's width or size, if applicable.\n     * @return The created ClassicalType.\n     */\n    createClassicalType(token, width) {\n        switch (token) {\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Int:\n                return new _ast__WEBPACK_IMPORTED_MODULE_3__.IntType(width || this.machineIntSize);\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.UInt:\n                return new _ast__WEBPACK_IMPORTED_MODULE_3__.UIntType(width || this.machineIntSize);\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Float:\n                return new _ast__WEBPACK_IMPORTED_MODULE_3__.FloatType(width || this.machineFloatWidth);\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Bool:\n                return new _ast__WEBPACK_IMPORTED_MODULE_3__.BoolType();\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Bit:\n                return new _ast__WEBPACK_IMPORTED_MODULE_3__.BitType(width);\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.CReg:\n                return new _ast__WEBPACK_IMPORTED_MODULE_3__.BitType(width);\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Stretch:\n                return new _ast__WEBPACK_IMPORTED_MODULE_3__.StretchType();\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Duration:\n                return new _ast__WEBPACK_IMPORTED_MODULE_3__.DurationType();\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Angle:\n                return new _ast__WEBPACK_IMPORTED_MODULE_3__.AngleType(width);\n            default:\n                throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadClassicalTypeError, token, this.index, \"unsupported classical type\");\n        }\n    }\n    /**\n     * Creates a math or trigonometric function node.\n     * @param token - The token representing the function.\n     * @param expr - The expression to which the function is applied.\n     * @return The created MathFunction or TrigFunction node and the number of consumed tokens.\n     */\n    createMathOrTrigFunction(token, expr) {\n        switch (token) {\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Arccos:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.TrigFunction(_ast__WEBPACK_IMPORTED_MODULE_3__.TrigFunctionTypes.ARCCOS, expr), 1];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Arcsin:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.TrigFunction(_ast__WEBPACK_IMPORTED_MODULE_3__.TrigFunctionTypes.ARCSIN, expr), 1];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Arctan:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.TrigFunction(_ast__WEBPACK_IMPORTED_MODULE_3__.TrigFunctionTypes.ARCTAN, expr), 1];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Cos:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.TrigFunction(_ast__WEBPACK_IMPORTED_MODULE_3__.TrigFunctionTypes.COS, expr), 1];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Sin:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.TrigFunction(_ast__WEBPACK_IMPORTED_MODULE_3__.TrigFunctionTypes.SIN, expr), 1];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Tan:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.TrigFunction(_ast__WEBPACK_IMPORTED_MODULE_3__.TrigFunctionTypes.TAN, expr), 1];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Ceiling:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.MathFunction(_ast__WEBPACK_IMPORTED_MODULE_3__.MathFunctionTypes.CEILING, expr), 1];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Exp:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.MathFunction(_ast__WEBPACK_IMPORTED_MODULE_3__.MathFunctionTypes.EXP, expr), 1];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Floor:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.MathFunction(_ast__WEBPACK_IMPORTED_MODULE_3__.MathFunctionTypes.FLOOR, expr), 1];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Log:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.MathFunction(_ast__WEBPACK_IMPORTED_MODULE_3__.MathFunctionTypes.LOG, expr), 1];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Mod:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.MathFunction(_ast__WEBPACK_IMPORTED_MODULE_3__.MathFunctionTypes.MOD, expr), 1];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Popcount:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.MathFunction(_ast__WEBPACK_IMPORTED_MODULE_3__.MathFunctionTypes.POPCOUNT, expr), 1];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Pow:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.MathFunction(_ast__WEBPACK_IMPORTED_MODULE_3__.MathFunctionTypes.POW, expr), 1];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Rotl:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.MathFunction(_ast__WEBPACK_IMPORTED_MODULE_3__.MathFunctionTypes.ROTL, expr), 1];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Rotr:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.MathFunction(_ast__WEBPACK_IMPORTED_MODULE_3__.MathFunctionTypes.ROTR, expr), 1];\n            case _token__WEBPACK_IMPORTED_MODULE_0__.Token.Sqrt:\n                return [new _ast__WEBPACK_IMPORTED_MODULE_3__.MathFunction(_ast__WEBPACK_IMPORTED_MODULE_3__.MathFunctionTypes.SQRT, expr), 1];\n            default:\n                throwParserError(_errors__WEBPACK_IMPORTED_MODULE_2__.BadExpressionError, token, this.index, \"unsupported math or trig function\");\n        }\n    }\n    /** Checks whether a Bit token precedes a measurement statement. */\n    isMeasurement(tokens) {\n        let i = 0;\n        while (i < tokens.length - 1 &&\n            tokens[i][0] !== _token__WEBPACK_IMPORTED_MODULE_0__.Token.LCParen &&\n            tokens[i][0] !== _token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon &&\n            tokens[i][0] !== _token__WEBPACK_IMPORTED_MODULE_0__.Token.EqualsAssmt) {\n            i++;\n        }\n        return (tokens[i][0] === _token__WEBPACK_IMPORTED_MODULE_0__.Token.EqualsAssmt && tokens[i + 1][0] === _token__WEBPACK_IMPORTED_MODULE_0__.Token.Measure);\n    }\n    /** Checks whether the statement is part of an assignment. */\n    isAssignment(tokens) {\n        let i = 0;\n        while (i < tokens.length - 1 &&\n            tokens[i][0] !== _token__WEBPACK_IMPORTED_MODULE_0__.Token.LCParen &&\n            tokens[i][0] !== _token__WEBPACK_IMPORTED_MODULE_0__.Token.Semicolon &&\n            tokens[i][0] !== _token__WEBPACK_IMPORTED_MODULE_0__.Token.EqualsAssmt) {\n            i++;\n        }\n        return tokens[i][0] === _token__WEBPACK_IMPORTED_MODULE_0__.Token.EqualsAssmt;\n    }\n    /** Checks whether an identifier is a quantum gate call. */\n    isQuantumGateCall(tokens) {\n        const gateName = tokens[0][1];\n        return (this.gates.has(gateName) ||\n            this.standardGates.has(gateName) ||\n            this.customGates.has(gateName));\n    }\n    /** Checks whether an identifier is a subroutine call. */\n    isSubroutineCall(tokens) {\n        const subroutineName = tokens[0][1];\n        return this.subroutines.has(subroutineName);\n    }\n    /** Checks whether a number is imaginary. */\n    isImaginary(token) {\n        if (token.length !== 2) {\n            return false;\n        }\n        return token[1].toString() === \"im\";\n    }\n    /** Checks whether an identifier is an array. */\n    isArray(tokens) {\n        if (tokens[0][0] !== _token__WEBPACK_IMPORTED_MODULE_0__.Token.Id) {\n            return false;\n        }\n        const identifierName = tokens[0][1].toString();\n        return this.customArrays.has(identifierName);\n    }\n    /** Checks whether an identifier represents a duration literal unit. */\n    isDuration(tokens) {\n        const checkToken = tokens[0];\n        if (checkToken.length !== 2 || checkToken[0] !== _token__WEBPACK_IMPORTED_MODULE_0__.Token.Id) {\n            return false;\n        }\n        if (Object.values(_ast__WEBPACK_IMPORTED_MODULE_3__.DurationUnit).includes(checkToken[1].toString())) {\n            return true;\n        }\n        return false;\n    }\n    /** TODO : update this\n     * Validates whether a register or gate identifier.\n     * @param identifier - The identifier to validate.\n     * @return Boolean indicating successful validation or not.\n     */\n    validateIdentifier(identifier) {\n        const firstChar = identifier[0];\n        return /^[a-z]$/.test(firstChar);\n    }\n}\n/**\n * Checks if a token represents a type.\n */\nfunction isTypeToken(token) {\n    return (token === _token__WEBPACK_IMPORTED_MODULE_0__.Token.Float ||\n        token === _token__WEBPACK_IMPORTED_MODULE_0__.Token.Int ||\n        token === _token__WEBPACK_IMPORTED_MODULE_0__.Token.UInt ||\n        token === _token__WEBPACK_IMPORTED_MODULE_0__.Token.Bool ||\n        token === _token__WEBPACK_IMPORTED_MODULE_0__.Token.Duration ||\n        token === _token__WEBPACK_IMPORTED_MODULE_0__.Token.Angle ||\n        token === _token__WEBPACK_IMPORTED_MODULE_0__.Token.Stretch ||\n        token === _token__WEBPACK_IMPORTED_MODULE_0__.Token.Bit);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Parser);\n\n\n//# sourceURL=webpack://qasm-quantum-simulator/./node_modules/qasm-ts/dist/qasm3/parser.js?\n}");

/***/ }),

/***/ "./node_modules/qasm-ts/dist/qasm3/token.js":
/*!**************************************************!*\
  !*** ./node_modules/qasm-ts/dist/qasm3/token.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Token: () => (/* binding */ Token),\n/* harmony export */   inverseLookup: () => (/* binding */ inverseLookup),\n/* harmony export */   lookup: () => (/* binding */ lookup),\n/* harmony export */   notParam: () => (/* binding */ notParam)\n/* harmony export */ });\n/**\n * OpenQASM 3.0 Token Definitions and Utilities\n *\n * This module defines all the token types used in OpenQASM 3.0 syntax, which\n * significantly extends OpenQASM 2.0 with modern programming language features.\n *\n * Major additions in OpenQASM 3.0:\n * - **Classical types**: int, uint, float, bool, bit, complex\n * - **Control flow**: if/else, for/while loops, switch/case\n * - **Functions**: def, return, extern declarations\n * - **Advanced features**: arrays, timing (delay, durationof), calibration\n * - **Quantum extensions**: qubit declarations, gate modifiers, hardware qubits\n *\n * @module\n *\n * @example OpenQASM 3.0 advanced tokens\n * ```typescript\n * import { lookup, Token } from './qasm3/token';\n *\n * console.log(lookup('qubit'));    // Token.Qubit\n * console.log(lookup('if'));       // Token.If\n * console.log(lookup('def'));      // Token.Def\n * console.log(lookup('complex'));  // Token.Complex\n * ```\n */\n/**\n * Enumeration of all OpenQASM 3.0 token types.\n *\n * Each token represents a specific syntactic element in OpenQASM 3.0 code.\n * The enum values correspond to different categories:\n * - Literals: NNInteger, Real, String, BoolLiteral\n * - Identifiers: Id\n * - Keywords: Qubit, Gate, Measure, If, For, While, etc.\n * - Operators: ArithmeticOp, BinaryOp, UnaryOp\n * - Punctuation: Semicolon, Comma, LParen, RParen, etc.\n * - Special: OpenQASM, Include, EndOfFile, Illegal\n */\nvar Token;\n(function (Token) {\n    // 0; invalid or unrecognized token\n    Token[Token[\"Illegal\"] = 0] = \"Illegal\";\n    // 1; end of file character\n    Token[Token[\"EndOfFile\"] = 1] = \"EndOfFile\";\n    // 2; real number (floating point)\n    Token[Token[\"Real\"] = 2] = \"Real\";\n    // 3; non-negative integer\n    Token[Token[\"NNInteger\"] = 3] = \"NNInteger\";\n    // 4; integer that supports underscores and negatives\n    Token[Token[\"Integer\"] = 4] = \"Integer\";\n    // 5; identifier (variables names, function names, etc.)\n    Token[Token[\"Id\"] = 5] = \"Id\";\n    // 6; OPENQASM version declaration\n    Token[Token[\"OpenQASM\"] = 6] = \"OpenQASM\";\n    // 7; include statement\n    Token[Token[\"Include\"] = 7] = \"Include\";\n    // 8; semicolon to terminate statements\n    Token[Token[\"Semicolon\"] = 8] = \"Semicolon\";\n    // 9; colon\n    Token[Token[\"Colon\"] = 9] = \"Colon\";\n    // 10; comma\n    Token[Token[\"Comma\"] = 10] = \"Comma\";\n    // 11; left paren (\n    Token[Token[\"LParen\"] = 11] = \"LParen\";\n    // 12; left square bracket [\n    Token[Token[\"LSParen\"] = 12] = \"LSParen\";\n    // 13; left curly brakcet {\n    Token[Token[\"LCParen\"] = 13] = \"LCParen\";\n    // 14; right paren )\n    Token[Token[\"RParen\"] = 14] = \"RParen\";\n    // 15; right square paren ]\n    Token[Token[\"RSParen\"] = 15] = \"RSParen\";\n    // 16; right curly bracket }\n    Token[Token[\"RCParen\"] = 16] = \"RCParen\";\n    // 17; assignment operator (=)\n    Token[Token[\"EqualsAssmt\"] = 17] = \"EqualsAssmt\";\n    // 18; arrow (->) used in measurement operations\n    Token[Token[\"Arrow\"] = 18] = \"Arrow\";\n    // 19; quantum register declaration\n    Token[Token[\"QReg\"] = 19] = \"QReg\";\n    // 20; quantum register declaration (functionally equivalent to QReg but for OpenQASM version 3)\n    Token[Token[\"Qubit\"] = 20] = \"Qubit\";\n    // 21; classical register declaration\n    Token[Token[\"CReg\"] = 21] = \"CReg\";\n    // 22; classical register declaration (functionally equivalent to Creg but for OpenQASM version 3)\n    Token[Token[\"Bit\"] = 22] = \"Bit\";\n    // 23; barrier operation\n    Token[Token[\"Barrier\"] = 23] = \"Barrier\";\n    // 24; gate declaration or application\n    Token[Token[\"Gate\"] = 24] = \"Gate\";\n    // 25; measurement operation\n    Token[Token[\"Measure\"] = 25] = \"Measure\";\n    // 26; qubit reset operation\n    Token[Token[\"Reset\"] = 26] = \"Reset\";\n    // 27; string literal\n    Token[Token[\"String\"] = 27] = \"String\";\n    // 28; opaque keyword\n    Token[Token[\"Opaque\"] = 28] = \"Opaque\";\n    // 29; defcalgrammar keyword\n    Token[Token[\"DefcalGrammar\"] = 29] = \"DefcalGrammar\";\n    // 30; float type keyword\n    Token[Token[\"Float\"] = 30] = \"Float\";\n    // 31; bool type keyword,\n    Token[Token[\"Bool\"] = 31] = \"Bool\";\n    // 32; int type keyword\n    Token[Token[\"Int\"] = 32] = \"Int\";\n    // 33; uint type keyword\n    Token[Token[\"UInt\"] = 33] = \"UInt\";\n    // 34; mathematical constant pi\n    Token[Token[\"Pi\"] = 34] = \"Pi\";\n    // 35; euler constant\n    Token[Token[\"Euler\"] = 35] = \"Euler\";\n    // 36; tau constant\n    Token[Token[\"Tau\"] = 36] = \"Tau\";\n    // 37; binary literal\n    Token[Token[\"BinaryLiteral\"] = 37] = \"BinaryLiteral\";\n    // 38; octal literal\n    Token[Token[\"OctalLiteral\"] = 38] = \"OctalLiteral\";\n    // 39; hex literal\n    Token[Token[\"HexLiteral\"] = 39] = \"HexLiteral\";\n    // 40; arithmetic operators\n    Token[Token[\"ArithmeticOp\"] = 40] = \"ArithmeticOp\";\n    // 41; compound arithmetic operators\n    Token[Token[\"CompoundArithmeticOp\"] = 41] = \"CompoundArithmeticOp\";\n    // 42; boolean literal value\n    Token[Token[\"BoolLiteral\"] = 42] = \"BoolLiteral\";\n    // 43; duration keyword\n    Token[Token[\"Duration\"] = 43] = \"Duration\";\n    // 44; unary operator\n    Token[Token[\"UnaryOp\"] = 44] = \"UnaryOp\";\n    // 45; binary operator\n    Token[Token[\"BinaryOp\"] = 45] = \"BinaryOp\";\n    // 46; let keyword for aliasing\n    Token[Token[\"Let\"] = 46] = \"Let\";\n    // 47; quantum gate modifier\n    Token[Token[\"QuantumModifier\"] = 47] = \"QuantumModifier\";\n    // 48; delay keyword\n    Token[Token[\"Delay\"] = 48] = \"Delay\";\n    // 49; return keyword\n    Token[Token[\"Return\"] = 49] = \"Return\";\n    // 50; def keyword for subroutines\n    Token[Token[\"Def\"] = 50] = \"Def\";\n    // 51; for loop keyword\n    Token[Token[\"For\"] = 51] = \"For\";\n    // 52; in keyword\n    Token[Token[\"In\"] = 52] = \"In\";\n    // 53; while loop keyword\n    Token[Token[\"While\"] = 53] = \"While\";\n    // 54; break keyword\n    Token[Token[\"Break\"] = 54] = \"Break\";\n    // 55; continue keyword\n    Token[Token[\"Continue\"] = 55] = \"Continue\";\n    // 56; input keyword\n    Token[Token[\"Input\"] = 56] = \"Input\";\n    // 57; output keyword\n    Token[Token[\"Output\"] = 57] = \"Output\";\n    // 58; switch statement keyword\n    Token[Token[\"Switch\"] = 58] = \"Switch\";\n    // 59; switch case keyword\n    Token[Token[\"Case\"] = 59] = \"Case\";\n    // 60; switch default keyword\n    Token[Token[\"Default\"] = 60] = \"Default\";\n    // 61; defcal keyword\n    Token[Token[\"Defcal\"] = 61] = \"Defcal\";\n    // 62; constant keywork\n    Token[Token[\"Const\"] = 62] = \"Const\";\n    // 63; if statement conditional\n    Token[Token[\"If\"] = 63] = \"If\";\n    // 64; else keyword\n    Token[Token[\"Else\"] = 64] = \"Else\";\n    // 65; end keyword\n    Token[Token[\"End\"] = 65] = \"End\";\n    // 66; inverse cosine\n    Token[Token[\"Arccos\"] = 66] = \"Arccos\";\n    // 67; inverse sine\n    Token[Token[\"Arcsin\"] = 67] = \"Arcsin\";\n    // 68; inverse tangent\n    Token[Token[\"Arctan\"] = 68] = \"Arctan\";\n    // 69; ceiling function\n    Token[Token[\"Ceiling\"] = 69] = \"Ceiling\";\n    // 70; cosine function\n    Token[Token[\"Cos\"] = 70] = \"Cos\";\n    // 71; exp keyword\n    Token[Token[\"Exp\"] = 71] = \"Exp\";\n    // 72; floor function\n    Token[Token[\"Floor\"] = 72] = \"Floor\";\n    // 73; logarithm base e\n    Token[Token[\"Log\"] = 73] = \"Log\";\n    // 74; modulus\n    Token[Token[\"Mod\"] = 74] = \"Mod\";\n    // 75; popcount function\n    Token[Token[\"Popcount\"] = 75] = \"Popcount\";\n    // 76; power function\n    Token[Token[\"Pow\"] = 76] = \"Pow\";\n    // 77; rotate bits left function\n    Token[Token[\"Rotl\"] = 77] = \"Rotl\";\n    // 78; rotate bits right function\n    Token[Token[\"Rotr\"] = 78] = \"Rotr\";\n    // 79; sine\n    Token[Token[\"Sin\"] = 79] = \"Sin\";\n    // 80; sqaure root\n    Token[Token[\"Sqrt\"] = 80] = \"Sqrt\";\n    // 81; tangent\n    Token[Token[\"Tan\"] = 81] = \"Tan\";\n    // 82; angle type\n    Token[Token[\"Angle\"] = 82] = \"Angle\";\n    // 83; ctrl gate modifier\n    Token[Token[\"Ctrl\"] = 83] = \"Ctrl\";\n    // 84; negctrl gate modifier\n    Token[Token[\"NegCtrl\"] = 84] = \"NegCtrl\";\n    // 85; inv gate modifier\n    Token[Token[\"Inv\"] = 85] = \"Inv\";\n    // 86; pow gate modifier\n    Token[Token[\"PowM\"] = 86] = \"PowM\";\n    // 87; @ symbol\n    Token[Token[\"At\"] = 87] = \"At\";\n    // 88; complex number keyword\n    Token[Token[\"Complex\"] = 88] = \"Complex\";\n    // 89; $ symbol\n    Token[Token[\"Dollar\"] = 89] = \"Dollar\";\n    // 90; array keyword\n    Token[Token[\"Array\"] = 90] = \"Array\";\n    // 91; durationof function keyword\n    Token[Token[\"DurationOf\"] = 91] = \"DurationOf\";\n    // 92; stretch type keyword\n    Token[Token[\"Stretch\"] = 92] = \"Stretch\";\n    // 93; box keyword\n    Token[Token[\"Box\"] = 93] = \"Box\";\n    // 94; readonly keyword\n    Token[Token[\"ReadOnly\"] = 94] = \"ReadOnly\";\n    // 95; mutable keyword\n    Token[Token[\"Mutable\"] = 95] = \"Mutable\";\n    // 96; #dim array dimensions\n    Token[Token[\"Dim\"] = 96] = \"Dim\";\n    // 97; scientific notation literal\n    Token[Token[\"ScientificNotation\"] = 97] = \"ScientificNotation\";\n    // 98; sizeof function\n    Token[Token[\"SizeOf\"] = 98] = \"SizeOf\";\n    // 99; extern keyword\n    Token[Token[\"Extern\"] = 99] = \"Extern\";\n    // 100; compound binary operators\n    Token[Token[\"CompoundBinaryOp\"] = 100] = \"CompoundBinaryOp\";\n})(Token || (Token = {}));\n/**\n * Mapping of string keywords to their corresponding token types.\n *\n * This lookup table enables the lexer to quickly determine if a string\n * represents a reserved keyword or should be treated as an identifier.\n *\n * @internal\n */\nconst lookupMap = {\n    pi: Token.Pi,\n    π: Token.Pi,\n    qreg: Token.QReg,\n    qubit: Token.Qubit,\n    creg: Token.CReg,\n    bit: Token.Bit,\n    barrier: Token.Barrier,\n    gate: Token.Gate,\n    measure: Token.Measure,\n    reset: Token.Reset,\n    include: Token.Include,\n    if: Token.If,\n    opaque: Token.Opaque,\n    defcalgrammar: Token.DefcalGrammar,\n    float: Token.Float,\n    bool: Token.Bool,\n    true: Token.BoolLiteral,\n    false: Token.BoolLiteral,\n    int: Token.Int,\n    uint: Token.UInt,\n    euler: Token.Euler,\n    ℇ: Token.Euler,\n    tau: Token.Tau,\n    τ: Token.Tau,\n    duration: Token.Duration,\n    let: Token.Let,\n    delay: Token.Delay,\n    return: Token.Return,\n    def: Token.Def,\n    for: Token.For,\n    in: Token.In,\n    while: Token.While,\n    break: Token.Break,\n    continue: Token.Continue,\n    input: Token.Input,\n    output: Token.Output,\n    switch: Token.Switch,\n    case: Token.Case,\n    default: Token.Default,\n    defcal: Token.Defcal,\n    const: Token.Const,\n    else: Token.Else,\n    end: Token.End,\n    \"!\": Token.UnaryOp,\n    \"~\": Token.UnaryOp,\n    \"**\": Token.ArithmeticOp,\n    \"*\": Token.ArithmeticOp,\n    \"/\": Token.ArithmeticOp,\n    \"%\": Token.ArithmeticOp,\n    \"+\": Token.ArithmeticOp,\n    \"++\": Token.ArithmeticOp,\n    \"&\": Token.BinaryOp,\n    \"|\": Token.BinaryOp,\n    \"^\": Token.BinaryOp,\n    \"&&\": Token.BinaryOp,\n    \"||\": Token.BinaryOp,\n    \"<\": Token.BinaryOp,\n    \"<=\": Token.BinaryOp,\n    \">\": Token.BinaryOp,\n    \">=\": Token.BinaryOp,\n    \"==\": Token.BinaryOp,\n    \"!=\": Token.BinaryOp,\n    \"<<\": Token.BinaryOp,\n    \">>\": Token.BinaryOp,\n    \"**=\": Token.CompoundArithmeticOp,\n    \"/=\": Token.CompoundArithmeticOp,\n    \"%=\": Token.CompoundArithmeticOp,\n    \"+=\": Token.CompoundArithmeticOp,\n    \"-=\": Token.CompoundArithmeticOp,\n    \"*=\": Token.CompoundArithmeticOp,\n    \"^=\": Token.CompoundArithmeticOp,\n    arccos: Token.Arccos,\n    arcsin: Token.Arcsin,\n    arctan: Token.Arctan,\n    ceiling: Token.Ceiling,\n    cos: Token.Cos,\n    exp: Token.Exp,\n    floor: Token.Floor,\n    log: Token.Log,\n    mod: Token.Mod,\n    popcount: Token.Popcount,\n    pow: Token.Pow,\n    rotl: Token.Rotl,\n    rotr: Token.Rotr,\n    sin: Token.Sin,\n    sqrt: Token.Sqrt,\n    tan: Token.Tan,\n    angle: Token.Angle,\n    \"@\": Token.At,\n    complex: Token.Complex,\n    $: Token.Dollar,\n    array: Token.Array,\n    durationof: Token.DurationOf,\n    stretch: Token.Stretch,\n    box: Token.Box,\n    readonly: Token.ReadOnly,\n    mutable: Token.Mutable,\n    sizeof: Token.SizeOf,\n    extern: Token.Extern,\n};\n/**\n * Returns the token type that corresponds to a given string.\n *\n * This function is used by the lexer to classify identifiers and keywords.\n * If the string is a reserved keyword, it returns the appropriate token type.\n * Otherwise, it returns Token.Id to indicate a user-defined identifier.\n *\n * @param ident - The string to look up\n * @returns The corresponding token type\n *\n * @example Keyword lookup\n * ```typescript\n * lookup('qubit');     // Returns Token.Qubit\n * lookup('measure');   // Returns Token.Measure\n * lookup('myVar');     // Returns Token.Id\n * lookup('π');         // Returns Token.Pi\n * ```\n */\nfunction lookup(ident) {\n    return ident in lookupMap ? lookupMap[ident] : Token.Id;\n}\n/**\n * Returns the string representation of a token type.\n *\n * This is useful for debugging and error reporting, allowing you to\n * convert token enum values back to their string representations.\n *\n * @param token - The token type to convert\n * @returns The string representation of the token, or undefined if not found\n *\n * @example Token to string conversion\n * ```typescript\n * inverseLookup(Token.Qubit);   // Returns 'qubit'\n * inverseLookup(Token.If);      // Returns 'if'\n * inverseLookup(Token.Pi);      // Returns 'pi'\n * ```\n */\nfunction inverseLookup(token) {\n    return Object.keys(lookupMap).find((ident) => lookupMap[ident] == token);\n}\n/**\n * Determines whether a token can be used as a parameter in expressions.\n *\n * This function helps the parser validate parameter lists by checking if\n * a token type is allowed in parameter contexts. Parameters can include\n * identifiers, numbers, and other value-bearing tokens, but not structural\n * tokens like semicolons or braces.\n *\n * @param token - The token type to check\n * @returns true if the token CANNOT be used as a parameter, false otherwise\n *\n * @example Parameter validation\n * ```typescript\n * notParam(Token.Id);         // false - identifiers can be parameters\n * notParam(Token.NNInteger);  // false - numbers can be parameters\n * notParam(Token.Semicolon);  // true - semicolons cannot be parameters\n * notParam(Token.LParen);     // true - parentheses cannot be parameters\n * ```\n */\nfunction notParam(token) {\n    if (token == Token.NNInteger ||\n        token == Token.Real ||\n        token == Token.Id ||\n        inverseLookup(token)) {\n        return false;\n    }\n    return true;\n}\n\n\n\n//# sourceURL=webpack://qasm-quantum-simulator/./node_modules/qasm-ts/dist/qasm3/token.js?\n}");

/***/ }),

/***/ "./node_modules/qasm-ts/dist/version.js":
/*!**********************************************!*\
  !*** ./node_modules/qasm-ts/dist/version.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OpenQASMMajorVersion: () => (/* binding */ OpenQASMMajorVersion),\n/* harmony export */   OpenQASMVersion: () => (/* binding */ OpenQASMVersion)\n/* harmony export */ });\n/**\n * OpenQASM version detection and management utilities\n *\n * Handles version detection from QASM source code and provides utilities\n * for working with different OpenQASM versions. Supports automatic version\n * detection from OPENQASM statements and manual version specification.\n *\n * @module Version Management\n *\n * @example Version detection\n * ```typescript\n * const version = new OpenQASMVersion(3, 0);\n * console.log(version.toString()); // \"3.0\"\n * console.log(version.isVersion3()); // true\n * ```\n */\n/** Enum representing the major OpenQASM versions. */\nvar OpenQASMMajorVersion;\n(function (OpenQASMMajorVersion) {\n    OpenQASMMajorVersion[OpenQASMMajorVersion[\"Version2\"] = 2] = \"Version2\";\n    OpenQASMMajorVersion[OpenQASMMajorVersion[\"Version3\"] = 3] = \"Version3\";\n})(OpenQASMMajorVersion || (OpenQASMMajorVersion = {}));\n/** Class representing the OpenQASM version. */\nclass OpenQASMVersion {\n    /**\n     * Creates an OpenQASMVersion instance.\n     * @param major - The OpenQASM major version. (optional)\n     * @param minor - The OpenQASM minor version (optional)\n     */\n    constructor(major, minor) {\n        this.major = major ? major : OpenQASMMajorVersion.Version3;\n        this.minor = minor ? minor : 0;\n    }\n    /** Returns the version as a formatted string. */\n    toString() {\n        return `${this.major}.${this.minor}`;\n    }\n    /** Returns whether the version is 3.x */\n    isVersion3() {\n        if (this.major === OpenQASMMajorVersion.Version3) {\n            return true;\n        }\n        return false;\n    }\n    /** Returns whether the version is 2.x */\n    isVersion2() {\n        if (this.major === OpenQASMMajorVersion.Version2) {\n            return true;\n        }\n        return false;\n    }\n}\n\n\n\n//# sourceURL=webpack://qasm-quantum-simulator/./node_modules/qasm-ts/dist/version.js?\n}");

/***/ }),

/***/ "./node_modules/qulacs-wasm/lib/bundle/index.js":
/*!******************************************************!*\
  !*** ./node_modules/qulacs-wasm/lib/bundle/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./main/init */ \"./node_modules/qulacs-wasm/lib/bundle/main/init.js\"), exports);\n__exportStar(__webpack_require__(/*! ./main/type/common */ \"./node_modules/qulacs-wasm/lib/bundle/main/type/common.js\"), exports);\n__exportStar(__webpack_require__(/*! ./main/instance */ \"./node_modules/qulacs-wasm/lib/bundle/main/instance.js\"), exports);\n\n\n//# sourceURL=webpack://qasm-quantum-simulator/./node_modules/qulacs-wasm/lib/bundle/index.js?\n}");

/***/ }),

/***/ "./node_modules/qulacs-wasm/lib/bundle/main/init.js":
/*!**********************************************************!*\
  !*** ./node_modules/qulacs-wasm/lib/bundle/main/init.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.initQulacs = void 0;\nvar module_1 = __importDefault(__webpack_require__(/*! ../wasm/module */ \"./node_modules/qulacs-wasm/lib/bundle/wasm/module.js\"));\nvar instance_1 = __webpack_require__(/*! ./instance */ \"./node_modules/qulacs-wasm/lib/bundle/main/instance.js\");\nfunction initQulacs(option) {\n    if (option === void 0) { option = {}; }\n    return __awaiter(this, void 0, void 0, function () {\n        var qulacsModule;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!option.module) return [3 /*break*/, 2];\n                    return [4 /*yield*/, _initQulacsFromModule(option.module)];\n                case 1:\n                    qulacsModule = _a.sent();\n                    return [3 /*break*/, 4];\n                case 2: return [4 /*yield*/, _initQulacs()];\n                case 3:\n                    qulacsModule = _a.sent();\n                    _a.label = 4;\n                case 4:\n                    (0, instance_1.applyModule)(qulacsModule);\n                    return [2 /*return*/, qulacsModule];\n            }\n        });\n    });\n}\nexports.initQulacs = initQulacs;\nfunction _initQulacs() {\n    return Promise.resolve((0, module_1.default)());\n}\nfunction _initQulacsFromModule(compiledModule) {\n    return new Promise(function (resolve, reject) {\n        function onInstantiateWasm(importObject, successCallback) {\n            WebAssembly.instantiate(compiledModule, importObject)\n                .then(function (instance) {\n                successCallback(instance);\n            })\n                .catch(function (e) { return reject(e); });\n            return undefined; // NOTE: @types/emscriptenでは不要なnon-null assertionかもしれない\n        }\n        (0, module_1.default)({ instantiateWasm: onInstantiateWasm })\n            .then(function (emscriptenModule) {\n            resolve(emscriptenModule);\n        })\n            .catch(function (e) { return reject(e); });\n    });\n}\n\n\n//# sourceURL=webpack://qasm-quantum-simulator/./node_modules/qulacs-wasm/lib/bundle/main/init.js?\n}");

/***/ }),

/***/ "./node_modules/qulacs-wasm/lib/bundle/main/instance.js":
/*!**************************************************************!*\
  !*** ./node_modules/qulacs-wasm/lib/bundle/main/instance.js ***!
  \**************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PauliRotation = exports.Pauli = exports.FREDKIN = exports.TOFFOLI = exports.SWAP = exports.CZ = exports.CNOT = exports.RotZ = exports.RotY = exports.RotX = exports.RotInvZ = exports.RotInvY = exports.RotInvX = exports.RZ = exports.RY = exports.RX = exports.U3 = exports.U2 = exports.U1 = exports.P1 = exports.P0 = exports.sqrtYdag = exports.sqrtY = exports.sqrtXdag = exports.sqrtX = exports.Tdag = exports.T = exports.Sdag = exports.S = exports.H = exports.Z = exports.Y = exports.X = exports.Identity = exports.CausalConeSimulator = exports.NoiseSimulator = exports.QuantumCircuitSimulator = exports.GradCalculator = exports.QuantumCircuitOptimizer = exports.PauliOperator = exports.Observable = exports.HermitianQuantumOperator = exports.GeneralQuantumOperator = exports.DensityMatrix = exports.ParametricQuantumCircuit = exports.QuantumCircuit = exports.QuantumState = exports.removeFunction = exports.addFunction = exports.getExceptionMessage = void 0;\nexports.applyModule = exports.create_quantum_operator_from_openfermion_text = exports.from_json = exports.ParametricRZ = exports.ParametricRY = exports.ParametricRX = exports.Adaptive = exports.Instrument = exports.CP = exports.CPTP = exports.Probabilistic = exports.add = exports.merge = exports.permutate_qubit = exports.make_mixture = exports.make_superposition = exports.drop_qubit = exports.tensor_product = exports.inner_product = exports.to_matrix_gate = exports.partial_trace = exports.NoisyEvolution_fast = exports.Measurement = exports.AmplitudeDampingNoise = exports.TwoQubitDepolarizingNoise = exports.DepolarizingNoise = exports.IndependentXZNoise = exports.DephasingNoise = exports.BitFlipNoise = exports.StateReflection = exports.ReversibleBoolean = exports.RandomUnitary = exports.DiagonalMatrix = exports.SparseMatrix = exports.DenseMatrix = void 0;\nfunction applyModule(qulacsModule) {\n    Object.keys(module.exports).forEach(function (key) {\n        var wasmExportedImpl = qulacsModule[key];\n        if (wasmExportedImpl)\n            module.exports[key] = wasmExportedImpl;\n    });\n    applayAlias();\n    applyQuantumStateOverload(qulacsModule);\n    applyDensityMatrixOverload();\n    applyQuantumCircuitSimulatorOverload();\n    applyFunctionOverload(qulacsModule);\n}\nexports.applyModule = applyModule;\nfunction applayAlias() {\n    exports.Observable = exports.HermitianQuantumOperator;\n}\nfunction applyQuantumStateOverload(qulacsModule) {\n    exports.QuantumState.prototype.load = function (arg) {\n        if (Array.isArray(arg))\n            return exports.QuantumState.prototype.load_Vector.call(this, arg);\n        return exports.QuantumState.prototype.load_QuantumStateBase.call(this, arg);\n    };\n    exports.QuantumState.prototype.multiply_elementwise_function = function (func) {\n        // NOTE: EM_JSで使うdyncallは入出力にvijfd型のみ利用できるため、funcが返すComplexをdyncall元に返すことができない\n        // そのため、funcの返り値をcomplexRegeneratorでdoubleに分解し、dyncallが渡すポインタに先に書き込み、\n        // complexRegenerator自体はvoidを返す\n        // dyncall側にはポインタから返り値を読みだすことを期待する\n        var complexRegenerator = function (intNum, complexArrPointer) {\n            // eslint-disable-next-line no-undef\n            var setValueFunc = qulacsModule[\"setValue\"];\n            var c = func(intNum);\n            setValueFunc(complexArrPointer, c.real, \"double\");\n            setValueFunc(complexArrPointer + 8, c.imag, \"double\");\n        };\n        var fnPointer = (0, exports.addFunction)(complexRegenerator, \"vii\");\n        return exports.QuantumState.prototype.multiply_elementwise_function_wrapper.call(this, fnPointer);\n    };\n}\nfunction applyDensityMatrixOverload() {\n    exports.DensityMatrix.prototype.load = function (arg) {\n        if (Array.isArray(arg)) {\n            if (Array.isArray(arg[0])) {\n                return exports.DensityMatrix.prototype.load_Matrix.call(this, arg);\n            }\n            else {\n                return exports.DensityMatrix.prototype.load_Vector.call(this, arg);\n            }\n        }\n        return exports.DensityMatrix.prototype.load_QuantumStateBase.call(this, arg);\n    };\n}\nfunction applyQuantumCircuitSimulatorOverload() {\n    exports.QuantumCircuitSimulator.prototype.initialize_state = function (computationl_basis) {\n        return exports.QuantumCircuitSimulator.prototype.initialize_state_itype_wrapper.call(this, computationl_basis);\n    };\n}\nfunction applyFunctionOverload(qulacsModule) {\n    exports.partial_trace = function (state, target_traceout) {\n        // NOTE: 暫定。より確実な判定方法を検討する\n        var names = getPtrNames(state);\n        if ((names === null || names === void 0 ? void 0 : names.ptrTypeName) === \"QuantumState*\") {\n            return qulacsModule[\"partial_trace_QuantumState\"](state, target_traceout);\n        }\n        else {\n            return qulacsModule[\"partial_trace_DensityMatrix\"](state, target_traceout);\n        }\n    };\n    exports.tensor_product = function (state_left, state_right) {\n        // NOTE: 暫定。より確実な判定方法を検討する\n        var names_left = getPtrNames(state_left);\n        var names_right = getPtrNames(state_right);\n        if ((names_left === null || names_left === void 0 ? void 0 : names_left.ptrTypeName) === \"QuantumState*\" && (names_right === null || names_right === void 0 ? void 0 : names_right.ptrTypeName) === \"QuantumState*\") {\n            return qulacsModule[\"tensor_product_QuantumState\"](state_left, state_right);\n        }\n        else {\n            return qulacsModule[\"tensor_product_DensityMatrix\"](state_left, state_right);\n        }\n    };\n    exports.permutate_qubit = function (state, qubit_order) {\n        // NOTE: 暫定。より確実な判定方法を検討する\n        var names = getPtrNames(state);\n        if ((names === null || names === void 0 ? void 0 : names.ptrTypeName) === \"QuantumState*\") {\n            return qulacsModule[\"permutate_qubit_QuantumState\"](state, qubit_order);\n        }\n        else {\n            return qulacsModule[\"permutate_qubit_DensityMatrix\"](state, qubit_order);\n        }\n    };\n    exports.ReversibleBoolean = function (target_qubit_index_list, function_ptr) {\n        var fnPointer = (0, exports.addFunction)(function_ptr, \"iii\");\n        var gate = qulacsModule[\"ReversibleBoolean\"](target_qubit_index_list, fnPointer);\n        //removeFunction(fnPointer); // NOTE: return後もC++側クロージャが参照する可能性が残るので、いつ消せるか検討。ReversibleBooleanのdeleteまで？\n        return gate;\n    };\n    exports.DenseMatrix = function (target_qubit_index_list, matrix) {\n        if (Array.isArray(target_qubit_index_list)) {\n            return qulacsModule[\"DenseMatrix_vector_UINT\"](target_qubit_index_list, matrix);\n        }\n        else {\n            return qulacsModule[\"DenseMatrix_UINT\"](target_qubit_index_list, matrix);\n        }\n    };\n    exports.merge = function (gate1OrGateList, gate2) {\n        if (Array.isArray(gate1OrGateList)) {\n            var pointerList = gate1OrGateList.map(function (gate) { return qulacsModule[\"_getAbstractQuantumGateBasePointer\"](gate); });\n            return qulacsModule[\"merge_QuantumGateBase_pointer\"](pointerList);\n        }\n        else {\n            return qulacsModule[\"merge\"](gate1OrGateList, gate2);\n        }\n    };\n    exports.add = function (gate1OrGateList, gate2) {\n        if (Array.isArray(gate1OrGateList)) {\n            var pointerList = gate1OrGateList.map(function (gate) { return qulacsModule[\"_getAbstractQuantumGateBasePointer\"](gate); });\n            return qulacsModule[\"add_QuantumGateBase_pointer\"](pointerList);\n        }\n        else {\n            return qulacsModule[\"add\"](gate1OrGateList, gate2);\n        }\n    };\n    exports.Probabilistic = function (distribution, gate_list) {\n        var pointerList = gate_list.map(function (gate) { return qulacsModule[\"_getAbstractQuantumGateBasePointer\"](gate); });\n        return qulacsModule[\"Probabilistic_QuantumGateBase_pointer\"](distribution, pointerList);\n    };\n    exports.NoisyEvolution_fast = function (hamiltonian, c_ops, time) {\n        var pointerList = c_ops.map(function (op) { return qulacsModule[\"_getAbstractGeneralQuantumOperatorPointer\"](op); });\n        return qulacsModule[\"NoisyEvolution_fast_pointer\"](hamiltonian, pointerList, time);\n    };\n    exports.CPTP = function (gate_list) {\n        var pointerList = gate_list.map(function (gate) { return qulacsModule[\"_getAbstractQuantumGateBasePointer\"](gate); });\n        return qulacsModule[\"CPTP_QuantumGate_pointer\"](pointerList);\n    };\n    exports.CP = function (gate_list, state_normalize, probability_normalize, assign_zero_if_not_matched) {\n        var pointerList = gate_list.map(function (gate) { return qulacsModule[\"_getAbstractQuantumGateBasePointer\"](gate); });\n        return qulacsModule[\"CPTP_QuantumGate_pointer\"](pointerList, state_normalize, probability_normalize, assign_zero_if_not_matched);\n    };\n    exports.Instrument = function (gate_list, classical_register_address) {\n        var pointerList = gate_list.map(function (gate) { return qulacsModule[\"_getAbstractQuantumGateBasePointer\"](gate); });\n        return qulacsModule[\"Instrument_QuantumGate_pointer\"](pointerList, classical_register_address);\n    };\n    exports.Adaptive = function (gate, func) {\n        // NOTE: dyncallは入出力にvijfd型のみ利用できるため、dyncall元からfuncにvector/arrayを渡すことができない\n        // そのため、listRegeneratorでポインタから配列要素を復元してからfuncに渡す\n        // funcの返り値はboolをそのまま返す\n        // dyncall側にはJSで扱いたい配列のポインタを渡すことを期待する\n        var listRegenerator = function (listPointer, size) {\n            var list = [];\n            var nByte = 4;\n            // eslint-disable-next-line no-undef\n            var getValueFunc = qulacsModule[\"getValue\"];\n            for (var i = 0; i < size; i++) {\n                var n = getValueFunc(listPointer + i * nByte, \"i32\"); // NOTE: intのバイト数は環境依存の改善が必要かもしれない。sizeofする？\n                list.push(n);\n            }\n            return func(list);\n        };\n        var fnPointer = (0, exports.addFunction)(listRegenerator, \"iii\");\n        return qulacsModule[\"Adaptive\"](gate, fnPointer);\n    };\n    exports.from_json = function (json) {\n        var data = JSON.parse(json);\n        switch (data.name) {\n            case \"GeneralQuantumOperator\":\n                return qulacsModule[\"from_json_GeneralQuantumOperator\"](json);\n            case \"HermitianQuantumOperator\":\n                return qulacsModule[\"from_json_HermitianQuantumOperator\"](json);\n            case \"QuantumState\":\n                return qulacsModule[\"from_json_QuantumState\"](json);\n            case \"DensityMatrix\":\n                return qulacsModule[\"from_json_DensityMatrix\"](json);\n            case \"QuantumStateBase\":\n                return qulacsModule[\"from_json_QuantumStateBase\"](json);\n            case \"QuantumGateBase\":\n                return qulacsModule[\"from_json_QuantumGateBase\"](json);\n            case \"QuantumCircuit\":\n                return qulacsModule[\"from_json_QuantumCircuit\"](json);\n            default:\n                // TODO: DenseMatrixGateやXGate、CNOTGate、ParametricQuantumCircuitなどの暗黙の命名規則に依存している。型名をすべて列挙するなどの修正が必要\n                if (data.name.includes(\"Gate\"))\n                    return qulacsModule[\"from_json_QuantumGateBase\"](json);\n                if (data.name.includes(\"QuantumCircuit\"))\n                    return qulacsModule[\"from_json_QuantumCircuit\"](json);\n                throw new Error(\"unknown json data, type name: \".concat(data.name, \" is cannot use from_json.\"));\n        }\n    };\n}\nfunction getPtrNames(instance) {\n    if (!instance || !instance.$$.ptrType)\n        return null;\n    var ptrTypeName = instance.$$.ptrType.name;\n    var registeredClassNames = [instance.$$.ptrType.registeredClass.name];\n    var targetClass = instance.$$.ptrType.registeredClass;\n    while (targetClass.baseClass) {\n        registeredClassNames.push(targetClass.baseClass.name);\n        targetClass = targetClass.baseClass;\n    }\n    return {\n        ptrTypeName: ptrTypeName,\n        registeredClassNames: registeredClassNames\n    };\n}\n\n\n//# sourceURL=webpack://qasm-quantum-simulator/./node_modules/qulacs-wasm/lib/bundle/main/instance.js?\n}");

/***/ }),

/***/ "./node_modules/qulacs-wasm/lib/bundle/main/type/common.js":
/*!*****************************************************************!*\
  !*** ./node_modules/qulacs-wasm/lib/bundle/main/type/common.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CMath = void 0;\n/**\n * 複素数の四則演算ラッパー\n */\nexports.CMath = {\n    add: function (a, b) {\n        a = translateNumberOrComplexToCPPCTYPE(a);\n        b = translateNumberOrComplexToCPPCTYPE(b);\n        return { real: a.real + b.real, imag: a.imag + b.imag };\n    },\n    mul: function (a, b) {\n        a = translateNumberOrComplexToCPPCTYPE(a);\n        b = translateNumberOrComplexToCPPCTYPE(b);\n        return {\n            real: a.real * b.real - a.imag * b.imag,\n            imag: a.real * b.imag + a.imag * b.real\n        };\n    },\n    div: function (a, b) {\n        a = translateNumberOrComplexToCPPCTYPE(a);\n        b = translateNumberOrComplexToCPPCTYPE(b);\n        var r2 = b.real * b.real + b.imag * b.imag;\n        return {\n            real: (a.real * b.real + a.imag * b.imag) / r2,\n            imag: (-a.real * b.imag + a.imag * b.real) / r2\n        };\n    }\n};\nfunction translateNumberOrComplexToCPPCTYPE(n) {\n    if (typeof n === \"number\") {\n        return { real: n, imag: 0 };\n    }\n    else {\n        return n;\n    }\n}\n\n\n//# sourceURL=webpack://qasm-quantum-simulator/./node_modules/qulacs-wasm/lib/bundle/main/type/common.js?\n}");

/***/ }),

/***/ "./node_modules/qulacs-wasm/lib/bundle/wasm/module.js":
/*!************************************************************!*\
  !*** ./node_modules/qulacs-wasm/lib/bundle/wasm/module.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{var __filename = \"/index.js\";\nvar __dirname = \"/\";\n\nvar ModuleQulacsWasm = (() => {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n  if (true) _scriptDir = _scriptDir || __filename;\n  return (\nfunction(ModuleQulacsWasm) {\n  ModuleQulacsWasm = ModuleQulacsWasm || {};\n\n\n\n// The Module object: Our interface to the outside world. We import\n// and export values on it. There are various ways Module can be used:\n// 1. Not defined. We create it here\n// 2. A function parameter, function(Module) { ..generated code.. }\n// 3. pre-run appended it, var Module = {}; ..generated code..\n// 4. External script tag defines var Module.\n// We need to check if Module already exists (e.g. case 3 above).\n// Substitution will be replaced with actual code on later stage of the build,\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\n// Note that if you want to run closure, and also to use Module\n// after the generated code, you will need to define   var Module = {};\n// before the code. Then that object will be used in the code, and you\n// can continue to use Module afterwards as well.\nvar Module = typeof ModuleQulacsWasm != 'undefined' ? ModuleQulacsWasm : {};\n\n// See https://caniuse.com/mdn-javascript_builtins_object_assign\n\n// See https://caniuse.com/mdn-javascript_builtins_bigint64array\n\n// Set up the promise that indicates the Module is initialized\nvar readyPromiseResolve, readyPromiseReject;\nModule['ready'] = new Promise(function(resolve, reject) {\n  readyPromiseResolve = resolve;\n  readyPromiseReject = reject;\n});\n\n// --pre-jses are emitted after the Module integration code, so that they can\n// refer to Module (if they choose; they can also define Module)\n// {{PRE_JSES}}\n\n// Sometimes an existing Module object exists with properties\n// meant to overwrite the default module functionality. Here\n// we collect those properties and reapply _after_ we configure\n// the current environment's defaults to avoid having to be so\n// defensive during initialization.\nvar moduleOverrides = Object.assign({}, Module);\n\nvar arguments_ = [];\nvar thisProgram = './this.program';\nvar quit_ = (status, toThrow) => {\n  throw toThrow;\n};\n\n// Determine the runtime environment we are in. You can customize this by\n// setting the ENVIRONMENT setting at compile time (see settings.js).\n\n// Attempt to auto-detect the environment\nvar ENVIRONMENT_IS_WEB = typeof window == 'object';\nvar ENVIRONMENT_IS_WORKER = typeof importScripts == 'function';\n// N.b. Electron.js environment is simultaneously a NODE-environment, but\n// also a web environment.\nvar ENVIRONMENT_IS_NODE = typeof process == 'object' && typeof process.versions == 'object' && typeof process.versions.node == 'string';\nvar ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n\n// `/` should be present at the end if `scriptDirectory` is not empty\nvar scriptDirectory = '';\nfunction locateFile(path) {\n  if (Module['locateFile']) {\n    return Module['locateFile'](path, scriptDirectory);\n  }\n  return scriptDirectory + path;\n}\n\n// Hooks that are implemented differently in different runtime environments.\nvar read_,\n    readAsync,\n    readBinary,\n    setWindowTitle;\n\n// Normally we don't log exceptions but instead let them bubble out the top\n// level where the embedding environment (e.g. the browser) can handle\n// them.\n// However under v8 and node we sometimes exit the process direcly in which case\n// its up to use us to log the exception before exiting.\n// If we fix https://github.com/emscripten-core/emscripten/issues/15080\n// this may no longer be needed under node.\nfunction logExceptionOnExit(e) {\n  if (e instanceof ExitStatus) return;\n  let toLog = e;\n  err('exiting due to exception: ' + toLog);\n}\n\nif (ENVIRONMENT_IS_NODE) {\n  if (ENVIRONMENT_IS_WORKER) {\n    scriptDirectory = (__webpack_require__(/*! path */ \"./node_modules/path/path.js\").dirname)(scriptDirectory) + '/';\n  } else {\n    scriptDirectory = __dirname + '/';\n  }\n\n// include: node_shell_read.js\n\n\nvar fs;\nvar nodePath;\n\nvar requireNodeFS = () => {\n  // Use nodePath as the indicator for these not being initialized,\n  // since in some environments a global fs may have already been\n  // created.\n  if (!nodePath) {\n    fs = __webpack_require__(/*! fs */ \"?2e5e\");\n    nodePath = __webpack_require__(/*! path */ \"./node_modules/path/path.js\");\n  }\n};\n\nread_ = (filename, binary) => {\n  var ret = tryParseAsDataURI(filename);\n  if (ret) {\n    return binary ? ret : ret.toString();\n  }\n  requireNodeFS();\n  filename = nodePath['normalize'](filename);\n  return fs.readFileSync(filename, binary ? undefined : 'utf8');\n};\n\nreadBinary = (filename) => {\n  var ret = read_(filename, true);\n  if (!ret.buffer) {\n    ret = new Uint8Array(ret);\n  }\n  return ret;\n};\n\nreadAsync = (filename, onload, onerror) => {\n  var ret = tryParseAsDataURI(filename);\n  if (ret) {\n    onload(ret);\n  }\n  requireNodeFS();\n  filename = nodePath['normalize'](filename);\n  fs.readFile(filename, function(err, data) {\n    if (err) onerror(err);\n    else onload(data.buffer);\n  });\n};\n\n// end include: node_shell_read.js\n  if (process['argv'].length > 1) {\n    thisProgram = process['argv'][1].replace(/\\\\/g, '/');\n  }\n\n  arguments_ = process['argv'].slice(2);\n\n  // MODULARIZE will export the module in the proper place outside, we don't need to export here\n\n  process['on']('uncaughtException', function(ex) {\n    // suppress ExitStatus exceptions from showing an error\n    if (!(ex instanceof ExitStatus)) {\n      throw ex;\n    }\n  });\n\n  // Without this older versions of node (< v15) will log unhandled rejections\n  // but return 0, which is not normally the desired behaviour.  This is\n  // not be needed with node v15 and about because it is now the default\n  // behaviour:\n  // See https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode\n  process['on']('unhandledRejection', function(reason) { throw reason; });\n\n  quit_ = (status, toThrow) => {\n    if (keepRuntimeAlive()) {\n      process['exitCode'] = status;\n      throw toThrow;\n    }\n    logExceptionOnExit(toThrow);\n    process['exit'](status);\n  };\n\n  Module['inspect'] = function () { return '[Emscripten Module object]'; };\n\n} else\n\n// Note that this includes Node.js workers when relevant (pthreads is enabled).\n// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\n// ENVIRONMENT_IS_NODE.\nif (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled\n    scriptDirectory = self.location.href;\n  } else if (typeof document != 'undefined' && document.currentScript) { // web\n    scriptDirectory = document.currentScript.src;\n  }\n  // When MODULARIZE, this JS may be executed later, after document.currentScript\n  // is gone, so we saved it, and we use it here instead of any other info.\n  if (_scriptDir) {\n    scriptDirectory = _scriptDir;\n  }\n  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\n  // otherwise, slice off the final part of the url to find the script directory.\n  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\n  // and scriptDirectory will correctly be replaced with an empty string.\n  // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),\n  // they are removed because they could contain a slash.\n  if (scriptDirectory.indexOf('blob:') !== 0) {\n    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf('/')+1);\n  } else {\n    scriptDirectory = '';\n  }\n\n  // Differentiate the Web Worker from the Node Worker case, as reading must\n  // be done differently.\n  {\n// include: web_or_worker_shell_read.js\n\n\n  read_ = (url) => {\n    try {\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', url, false);\n      xhr.send(null);\n      return xhr.responseText;\n    } catch (err) {\n      var data = tryParseAsDataURI(url);\n      if (data) {\n        return intArrayToString(data);\n      }\n      throw err;\n    }\n  }\n\n  if (ENVIRONMENT_IS_WORKER) {\n    readBinary = (url) => {\n      try {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, false);\n        xhr.responseType = 'arraybuffer';\n        xhr.send(null);\n        return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));\n      } catch (err) {\n        var data = tryParseAsDataURI(url);\n        if (data) {\n          return data;\n        }\n        throw err;\n      }\n    };\n  }\n\n  readAsync = (url, onload, onerror) => {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'arraybuffer';\n    xhr.onload = () => {\n      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0\n        onload(xhr.response);\n        return;\n      }\n      var data = tryParseAsDataURI(url);\n      if (data) {\n        onload(data.buffer);\n        return;\n      }\n      onerror();\n    };\n    xhr.onerror = onerror;\n    xhr.send(null);\n  }\n\n// end include: web_or_worker_shell_read.js\n  }\n\n  setWindowTitle = (title) => document.title = title;\n} else\n{\n}\n\nvar out = Module['print'] || console.log.bind(console);\nvar err = Module['printErr'] || console.warn.bind(console);\n\n// Merge back in the overrides\nObject.assign(Module, moduleOverrides);\n// Free the object hierarchy contained in the overrides, this lets the GC\n// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\nmoduleOverrides = null;\n\n// Emit code to handle expected values on the Module object. This applies Module.x\n// to the proper local x. This has two benefits: first, we only emit it if it is\n// expected to arrive, and second, by using a local everywhere else that can be\n// minified.\n\nif (Module['arguments']) arguments_ = Module['arguments'];\n\nif (Module['thisProgram']) thisProgram = Module['thisProgram'];\n\nif (Module['quit']) quit_ = Module['quit'];\n\n// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\n\n\n\n\nvar STACK_ALIGN = 16;\nvar POINTER_SIZE = 4;\n\nfunction getNativeTypeSize(type) {\n  switch (type) {\n    case 'i1': case 'i8': case 'u8': return 1;\n    case 'i16': case 'u16': return 2;\n    case 'i32': case 'u32': return 4;\n    case 'i64': case 'u64': return 8;\n    case 'float': return 4;\n    case 'double': return 8;\n    default: {\n      if (type[type.length - 1] === '*') {\n        return POINTER_SIZE;\n      }\n      if (type[0] === 'i') {\n        const bits = Number(type.substr(1));\n        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);\n        return bits / 8;\n      }\n      return 0;\n    }\n  }\n}\n\n// include: runtime_debug.js\n\n\n// end include: runtime_debug.js\n\n\n// === Preamble library stuff ===\n\n// Documentation for the public APIs defined in this file must be updated in:\n//    site/source/docs/api_reference/preamble.js.rst\n// A prebuilt local version of the documentation is available at:\n//    site/build/text/docs/api_reference/preamble.js.txt\n// You can also build docs locally as HTML or other formats in site/\n// An online HTML version (which may be of a different version of Emscripten)\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n\nvar wasmBinary;\nif (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];\nvar noExitRuntime = Module['noExitRuntime'] || true;\n\nif (typeof WebAssembly != 'object') {\n  abort('no native wasm support detected');\n}\n\n// Wasm globals\n\nvar wasmMemory;\n\n//========================================\n// Runtime essentials\n//========================================\n\n// whether we are quitting the application. no code should run after this.\n// set in exit() and abort()\nvar ABORT = false;\n\n// set by exit() and abort().  Passed to 'onExit' handler.\n// NOTE: This is also used as the process return code code in shell environments\n// but only when noExitRuntime is false.\nvar EXITSTATUS;\n\n/** @type {function(*, string=)} */\nfunction assert(condition, text) {\n  if (!condition) {\n    // This build was created without ASSERTIONS defined.  `assert()` should not\n    // ever be called in this configuration but in case there are callers in\n    // the wild leave this simple abort() implemenation here for now.\n    abort(text);\n  }\n}\n\n// include: runtime_strings.js\n\n\n// runtime_strings.js: Strings related runtime functions that are part of both MINIMAL_RUNTIME and regular runtime.\n\nvar UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;\n\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns\n// a copy of that string as a Javascript String object.\n/**\n * heapOrArray is either a regular array, or a JavaScript typed array view.\n * @param {number} idx\n * @param {number=} maxBytesToRead\n * @return {string}\n */\nfunction UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {\n  var endIdx = idx + maxBytesToRead;\n  var endPtr = idx;\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)\n  while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n\n  if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n    return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n  }\n  var str = '';\n  // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that\n  while (idx < endPtr) {\n    // For UTF8 byte structure, see:\n    // http://en.wikipedia.org/wiki/UTF-8#Description\n    // https://www.ietf.org/rfc/rfc2279.txt\n    // https://tools.ietf.org/html/rfc3629\n    var u0 = heapOrArray[idx++];\n    if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }\n    var u1 = heapOrArray[idx++] & 63;\n    if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }\n    var u2 = heapOrArray[idx++] & 63;\n    if ((u0 & 0xF0) == 0xE0) {\n      u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n    } else {\n      u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);\n    }\n\n    if (u0 < 0x10000) {\n      str += String.fromCharCode(u0);\n    } else {\n      var ch = u0 - 0x10000;\n      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n    }\n  }\n  return str;\n}\n\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a\n// copy of that string as a Javascript String object.\n// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit\n//                 this parameter to scan the string until the first \\0 byte. If maxBytesToRead is\n//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the\n//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will\n//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)\n//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may\n//                 throw JS JIT optimizations off, so it is worth to consider consistently using one\n//                 style or the other.\n/**\n * @param {number} ptr\n * @param {number=} maxBytesToRead\n * @return {string}\n */\nfunction UTF8ToString(ptr, maxBytesToRead) {\n  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\n}\n\n// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',\n// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   heap: the array to copy to. Each index in this array is assumed to be one 8-byte element.\n//   outIdx: The starting offset in the array to begin the copying.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array.\n//                    This count should include the null terminator,\n//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\n  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.\n    return 0;\n\n  var startIdx = outIdx;\n  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n    var u = str.charCodeAt(i); // possibly a lead surrogate\n    if (u >= 0xD800 && u <= 0xDFFF) {\n      var u1 = str.charCodeAt(++i);\n      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);\n    }\n    if (u <= 0x7F) {\n      if (outIdx >= endIdx) break;\n      heap[outIdx++] = u;\n    } else if (u <= 0x7FF) {\n      if (outIdx + 1 >= endIdx) break;\n      heap[outIdx++] = 0xC0 | (u >> 6);\n      heap[outIdx++] = 0x80 | (u & 63);\n    } else if (u <= 0xFFFF) {\n      if (outIdx + 2 >= endIdx) break;\n      heap[outIdx++] = 0xE0 | (u >> 12);\n      heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n      heap[outIdx++] = 0x80 | (u & 63);\n    } else {\n      if (outIdx + 3 >= endIdx) break;\n      heap[outIdx++] = 0xF0 | (u >> 18);\n      heap[outIdx++] = 0x80 | ((u >> 12) & 63);\n      heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n      heap[outIdx++] = 0x80 | (u & 63);\n    }\n  }\n  // Null-terminate the pointer to the buffer.\n  heap[outIdx] = 0;\n  return outIdx - startIdx;\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\n  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);\n}\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.\nfunction lengthBytesUTF8(str) {\n  var len = 0;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var c = str.charCodeAt(i); // possibly a lead surrogate\n    if (c <= 0x7F) {\n      len++;\n    } else if (c <= 0x7FF) {\n      len += 2;\n    } else if (c >= 0xD800 && c <= 0xDFFF) {\n      len += 4; ++i;\n    } else {\n      len += 3;\n    }\n  }\n  return len;\n}\n\n// end include: runtime_strings.js\n// Memory management\n\nvar HEAP,\n/** @type {!ArrayBuffer} */\n  buffer,\n/** @type {!Int8Array} */\n  HEAP8,\n/** @type {!Uint8Array} */\n  HEAPU8,\n/** @type {!Int16Array} */\n  HEAP16,\n/** @type {!Uint16Array} */\n  HEAPU16,\n/** @type {!Int32Array} */\n  HEAP32,\n/** @type {!Uint32Array} */\n  HEAPU32,\n/** @type {!Float32Array} */\n  HEAPF32,\n/** @type {!Float64Array} */\n  HEAPF64;\n\nfunction updateGlobalBufferAndViews(buf) {\n  buffer = buf;\n  Module['HEAP8'] = HEAP8 = new Int8Array(buf);\n  Module['HEAP16'] = HEAP16 = new Int16Array(buf);\n  Module['HEAP32'] = HEAP32 = new Int32Array(buf);\n  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);\n  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);\n  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);\n  Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);\n  Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);\n}\n\nvar TOTAL_STACK = 5242880;\n\nvar INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 16777216;\n\n// include: runtime_init_table.js\n// In regular non-RELOCATABLE mode the table is exported\n// from the wasm module and this will be assigned once\n// the exports are available.\nvar wasmTable;\n\n// end include: runtime_init_table.js\n// include: runtime_stack_check.js\n\n\n// end include: runtime_stack_check.js\n// include: runtime_assertions.js\n\n\n// end include: runtime_assertions.js\nvar __ATPRERUN__  = []; // functions called before the runtime is initialized\nvar __ATINIT__    = []; // functions called during startup\nvar __ATEXIT__    = []; // functions called during shutdown\nvar __ATPOSTRUN__ = []; // functions called after the main() is called\n\nvar runtimeInitialized = false;\n\nfunction keepRuntimeAlive() {\n  return noExitRuntime;\n}\n\nfunction preRun() {\n\n  if (Module['preRun']) {\n    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\n    while (Module['preRun'].length) {\n      addOnPreRun(Module['preRun'].shift());\n    }\n  }\n\n  callRuntimeCallbacks(__ATPRERUN__);\n}\n\nfunction initRuntime() {\n  runtimeInitialized = true;\n\n  \nif (!Module[\"noFSInit\"] && !FS.init.initialized)\n  FS.init();\nFS.ignorePermissions = false;\n\nTTY.init();\n  callRuntimeCallbacks(__ATINIT__);\n}\n\nfunction postRun() {\n\n  if (Module['postRun']) {\n    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\n    while (Module['postRun'].length) {\n      addOnPostRun(Module['postRun'].shift());\n    }\n  }\n\n  callRuntimeCallbacks(__ATPOSTRUN__);\n}\n\nfunction addOnPreRun(cb) {\n  __ATPRERUN__.unshift(cb);\n}\n\nfunction addOnInit(cb) {\n  __ATINIT__.unshift(cb);\n}\n\nfunction addOnExit(cb) {\n}\n\nfunction addOnPostRun(cb) {\n  __ATPOSTRUN__.unshift(cb);\n}\n\n// include: runtime_math.js\n\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc\n\n// end include: runtime_math.js\n// A counter of dependencies for calling run(). If we need to\n// do asynchronous work before running, increment this and\n// decrement it. Incrementing must happen in a place like\n// Module.preRun (used by emcc to add file preloading).\n// Note that you can add dependencies in preRun, even though\n// it happens right before run - run will be postponed until\n// the dependencies are met.\nvar runDependencies = 0;\nvar runDependencyWatcher = null;\nvar dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\n\nfunction getUniqueRunDependency(id) {\n  return id;\n}\n\nfunction addRunDependency(id) {\n  runDependencies++;\n\n  if (Module['monitorRunDependencies']) {\n    Module['monitorRunDependencies'](runDependencies);\n  }\n\n}\n\nfunction removeRunDependency(id) {\n  runDependencies--;\n\n  if (Module['monitorRunDependencies']) {\n    Module['monitorRunDependencies'](runDependencies);\n  }\n\n  if (runDependencies == 0) {\n    if (runDependencyWatcher !== null) {\n      clearInterval(runDependencyWatcher);\n      runDependencyWatcher = null;\n    }\n    if (dependenciesFulfilled) {\n      var callback = dependenciesFulfilled;\n      dependenciesFulfilled = null;\n      callback(); // can add another dependenciesFulfilled\n    }\n  }\n}\n\n/** @param {string|number=} what */\nfunction abort(what) {\n  {\n    if (Module['onAbort']) {\n      Module['onAbort'](what);\n    }\n  }\n\n  what = 'Aborted(' + what + ')';\n  // TODO(sbc): Should we remove printing and leave it up to whoever\n  // catches the exception?\n  err(what);\n\n  ABORT = true;\n  EXITSTATUS = 1;\n\n  what += '. Build with -sASSERTIONS for more info.';\n\n  // Use a wasm runtime error, because a JS error might be seen as a foreign\n  // exception, which means we'd run destructors on it. We need the error to\n  // simply make the program stop.\n  // FIXME This approach does not work in Wasm EH because it currently does not assume\n  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from\n  // a trap or not based on a hidden field within the object. So at the moment\n  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that\n  // allows this in the wasm spec.\n\n  // Suppress closure compiler warning here. Closure compiler's builtin extern\n  // defintion for WebAssembly.RuntimeError claims it takes no arguments even\n  // though it can.\n  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.\n  /** @suppress {checkTypes} */\n  var e = new WebAssembly.RuntimeError(what);\n\n  readyPromiseReject(e);\n  // Throw the error whether or not MODULARIZE is set because abort is used\n  // in code paths apart from instantiation where an exception is expected\n  // to be thrown when abort is called.\n  throw e;\n}\n\n// {{MEM_INITIALIZER}}\n\n// include: memoryprofiler.js\n\n\n// end include: memoryprofiler.js\n// include: URIUtils.js\n\n\n// Prefix of data URIs emitted by SINGLE_FILE and related options.\nvar dataURIPrefix = 'data:application/octet-stream;base64,';\n\n// Indicates whether filename is a base64 data URI.\nfunction isDataURI(filename) {\n  // Prefix of data URIs emitted by SINGLE_FILE and related options.\n  return filename.startsWith(dataURIPrefix);\n}\n\n// Indicates whether filename is delivered via file protocol (as opposed to http/https)\nfunction isFileURI(filename) {\n  return filename.startsWith('file://');\n}\n\n// end include: URIUtils.js\nvar wasmBinaryFile;\n  wasmBinaryFile = 'data:application/octet-stream;base64,AGFzbQEAAAAB54iAgACHAWABfwF/YAJ/fwBgAn9/AX9gAX8AYAN/f38AYAN/f38Bf2AEf39/fwBgBH9/f38Bf2AFf39/f38Bf2AGf39/f39/AX9gAAF/YAAAYAZ/f39/f38AYAF/AXxgA39/fgBgBX9/f39/AGADf398AGAIf39/f39/f38Bf2ACf3wBf2AEf39/fgBgB39/f39/f38AYAJ/fABgAn9/AXxgBX9/f39+AGAHf39/f39/fwF/YAN/f3wBf2ABfAF8YAR/f398AGACf34AYAN/f38BfmADf39/AXxgBH98f34AYAV/fn5+fgBgBX9/f39+AX9gBX9/fn9/AGAFf39/f34BfGAAAX5gCn9/f39/f39/f38AYAR/f398AX9gC39/f39/f39/f39/AGACf34BfGAHf39/f39/fgBgAXwBfmADf35/AX5gAn9+AX9gCH9/f39/f39/AGAKf39/f39/f39/fwF/YAV/f39/fABgCH9/f39/f398AGACfHwBfGABfAF/YAV/f39/fAF/YAR/f39/AX5gBn9/f39+fwF/YAd/f39/f35+AX9gC39/f39/f39/f39/AX9gDH9/f39/f39/f39/fwF/YAx/f39/f39/f39/f38AYAF/AX5gAX4Bf2AGf39/f39+AGAIf39/f39/f34AYAN8f34AYAR/fn5/AGAGf39/f35+AX9gBH9/fHwBf2ADf3x8AX9gBH98fHwBf2AEf398fABgBX9/fHx8AGAJf39/f39/f39/AX9gA398fwF/YAl/f39/f39/f38AYAp/f39/f39/fHx/AXxgCX9/f39/f398fAF8YAV/f398fAF8YAN/fn8AYAV/fn9+fwBgA39/fgF8YAZ+fn9/f34BfGAGf39/fH9+AGAGfn5/f39+AGADfH5+AXxgAAF8YAF8AGACfH8BfGACf38BfmACf38BfWADf39/AX1gBH9/f34BfmAEfn5+fgF/YAZ/fH9/f38Bf2ACfn8Bf2AGf39/f3x/AX9gB39/f39+fn8Bf2APf39/f39/f39/f39/f39/AGAGf39/f39+AXxgA39/fgF/YAZ/f39/f34Bf2AFf39/f38BfmAHf39/f39/fwF8YAR/f39/AXxgAnx8AX9gBX9/f39/AXxgDX9/f39/f39/f39/f38AYAZ/f39/f3wBf2ANf39/f39/f39/f39/fwF/YAR/f39/AX1gEH9/f39/f39/f39/f39/f38AYAV/f3x8fAF/YAV/f398fABgBn9/f3x8fABgBH9/fH8AYAR/fHx8AGAFf39/fHwBf2AIf35+f39/f34AYAV/fn9/fgBgB35+f398f34AYAR+fH9+AGACfH8Bf2ADfHx/AXxgAn98AXxgAn5+AX9gA39+fgBgAn99AGACfn4BfGACfn4BfWADfn9/AX9gBX9/fH9+AGAGf39/fn9/AGAEf39+fwF+YAh/f39/f39+fgF/YAZ/f3x/f38AYAV/f39+fgBgBH9+f38BfwKykoCAAF0DZW52El9lbXZhbF9uZXdfY3N0cmluZwAAA2VudhNfZW12YWxfZ2V0X3Byb3BlcnR5AAIDZW52Cmludm9rZV9paWkABQNlbnYNX2VtdmFsX2RlY3JlZgADA2VudglpbnZva2VfdmkAAQNlbnYbX19jeGFfZmluZF9tYXRjaGluZ19jYXRjaF8zAAADZW52G19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2hfMgAKA2VudglfZW12YWxfYXMAHgNlbnYLaW52b2tlX2RpaWkAZQNlbnYWX2VtdmFsX3J1bl9kZXN0cnVjdG9ycwADA2VudglpbnZva2VfaWkAAgNlbnYRX19yZXN1bWVFeGNlcHRpb24AAwNlbnYRX2VtdmFsX2dldF9nbG9iYWwAAANlbnYMaW52b2tlX2lpaWlpAAgDZW52DV9lbXZhbF9pbmNyZWYAAwNlbnYKaW52b2tlX3ZpaQAEA2VudghpbnZva2VfdgADA2VudhFfZW12YWxfdGFrZV92YWx1ZQACA2Vudg1fX2Fzc2VydF9mYWlsAAYDZW52DGludm9rZV92aWlpaQAPA2VudhhfX2N4YV9hbGxvY2F0ZV9leGNlcHRpb24AAANlbnYLX19jeGFfdGhyb3cABANlbnYLaW52b2tlX3ZpaWkABgNlbnYYY29udmVydEludEFycmF5VG9KU0FycmF5AAIDZW52ImNvbnZlcnREb3VibGVBcnJheVRvSlNDb21wbGV4QXJyYXkAAgNlbnYaY29udmVydENQUENUWVBFVG9KU0NvbXBsZXgAZgNlbnYNY29udmVydE1hdHJpeAACA2VudhhfZW12YWxfZ2V0X21ldGhvZF9jYWxsZXIAAgNlbnYSX2VtdmFsX2NhbGxfbWV0aG9kAGcDZW52GV9lbWJpbmRfcmVnaXN0ZXJfZnVuY3Rpb24ADANlbnYdX2VtYmluZF9yZWdpc3Rlcl92YWx1ZV9vYmplY3QADANlbnYdX2VtYmluZF9maW5hbGl6ZV92YWx1ZV9vYmplY3QAAwNlbnYWX2VtYmluZF9yZWdpc3Rlcl9jbGFzcwBoA2VudiJfZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2NvbnN0cnVjdG9yAAwDZW52H19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfZnVuY3Rpb24ALQNlbnYfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19wcm9wZXJ0eQAlA2VudhRfX2N4YV9mcmVlX2V4Y2VwdGlvbgADA2Vudg1pbnZva2VfaWlpaWlpAAkDZW52C2ludm9rZV9paWlpAAcDZW52Dmludm9rZV9paWlpaWlpABgDZW52EV9fY3hhX2JlZ2luX2NhdGNoAAADZW52D19fY3hhX2VuZF9jYXRjaAALA2Vudg1fX2N4YV9yZXRocm93AAsDZW52EWludm9rZV9paWlpaWlpaWlpAC4DZW52Cmludm9rZV9paWQAGQNlbnYKaW52b2tlX2RpaQAeA2Vudi5RdWFudHVtU3RhdGVNdWx0aXBseUVsZW1lbnR3aXNlRnVuY3Rpb25XcmFwcGVyAAQDZW52EF9lbXZhbF9uZXdfYXJyYXkACgNlbnYXX2VtdmFsX2NhbGxfdm9pZF9tZXRob2QABgNlbnYLaW52b2tlX2lpaWQAJgNlbnYLaW52b2tlX3ZpaWQAGwNlbnYYUmV2ZXJzaWJsZUJvb2xlYW5XcmFwcGVyAAUDZW52DGludm9rZV92aWlpZAAvA2Vudg1pbnZva2VfdmlpaWlpAAwDZW52D0FkYXB0aXZlV3JhcHBlcgAFA2VudgRleGl0AAMDZW52FV9lbWJpbmRfcmVnaXN0ZXJfdm9pZAABA2VudhVfZW1iaW5kX3JlZ2lzdGVyX2Jvb2wADwNlbnYYX2VtYmluZF9yZWdpc3Rlcl9pbnRlZ2VyAA8DZW52Fl9lbWJpbmRfcmVnaXN0ZXJfZmxvYXQABANlbnYbX2VtYmluZF9yZWdpc3Rlcl9zdGRfc3RyaW5nAAEDZW52HF9lbWJpbmRfcmVnaXN0ZXJfc3RkX3dzdHJpbmcABANlbnYWX2VtYmluZF9yZWdpc3Rlcl9lbXZhbAABA2VudhxfZW1iaW5kX3JlZ2lzdGVyX21lbW9yeV92aWV3AAQDZW52FWVtc2NyaXB0ZW5fbWVtY3B5X2JpZwAEFndhc2lfc25hcHNob3RfcHJldmlldzEIZmRfY2xvc2UAABZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxCGZkX3dyaXRlAAcDZW52FmVtc2NyaXB0ZW5fcmVzaXplX2hlYXAAAANlbnYZX19jeGFfdW5jYXVnaHRfZXhjZXB0aW9ucwAKA2Vudg1pbnZva2VfaWlpaWlkAGkWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MQdmZF9yZWFkAAcDZW52D2ludm9rZV9paWlpaWlpaQARA2VudhJpbnZva2VfaWlpaWlpaWlpaWkANwNlbnYUaW52b2tlX2lpaWlpaWlpaWlpaWkAagNlbnYLaW52b2tlX2ZpaWkAawNlbnYIaW52b2tlX2kAABZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxEWVudmlyb25fc2l6ZXNfZ2V0AAIWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MQtlbnZpcm9uX2dldAACA2Vudg9pbnZva2VfdmlpaWlpaWkALQNlbnYKc3RyZnRpbWVfbAAIA2VudhNpbnZva2VfaWlpaWlpaWlpaWlpADgDZW52Emludm9rZV92aWlpaWlpaWlpaQAnA2VudhdpbnZva2VfdmlpaWlpaWlpaWlpaWlpaQBsA2VudgpnZXRlbnRyb3B5AAIDZW52BWFib3J0AAsDZW52CWludm9rZV9pagAFA2VudgppbnZva2VfdmlqAAYDZW52DWludm9rZV9kaWlpaWoAZANlbnYKaW52b2tlX2lpagAHA2VudhdfZW1iaW5kX3JlZ2lzdGVyX2JpZ2ludAAUFndhc2lfc25hcHNob3RfcHJldmlldzEHZmRfc2VlawAIA2Vudg1pbnZva2VfaWlpaWlqABgDZW52DGludm9rZV9qaWlpaQAIA4CdgIAA9xwLAQIHAQEDCwABAQEGAQQAAwYAAAIABQABAwILAgMKAwADAAAAAwIAAQQBBB4eFhACAQQBBAIEAQEEBQYCBgcEBQECBAECAAIAAAADAgABAQQEHhYeAAIWEAIAAgEEAQQBAgQBAgYHBAUBAgECAAMEAgIBAgECAQUCAQIAAAADAAAAAwAAAAMAAAADAAAAAwAAAAMAAAADEBYAAAADAgIBBAYAAAADAAAAAwAAAAMAAAADAAAAAwAAAAMAAAADAAAAAwIZQW0ZBQUHBQUFAiYZBQIFAgUCAgUFAgIZJhkFJhkAAwIAAgIBBAQGLwQEDwIGG25vAQQEBgEbLwQGBAEEBAYbAQIAAAADAgACBAYbGy8CHgUEBQUBAAMCAAIFAgYPBgcBBAQGBg8EBQECAAAAAwIAAAMACgIBBQQGAQIBAQICAQQCBAUGBwADAAoGBAUAAwAKBgcPCAADBQIBBAEEBgQFAgADBQIEBQADBQIDAQECAQIBAgEFAgUCAgUEBQUFAgIHBQgHCAcFAgIAAgAFAgIACAcFAgUCGQIAAgACAAIAAgACAAIAAgIAAgAAAwAKAQICEAECAwICAwIDAwIAAwEBAQECBgMCAAADAAMDHAMBFhYNDQ0VFQAAAQQBAQEAAAAAAAEEBQQBAQQLAgQEAQQDAwYBBwcFAwABAAYCAAAAAwMDAwMCAwMJAgECAgUFAAQEAgQFAQEFAAUEAAABAwIDAAMAAwADAwMAAwAAAAAFAAAAAwIDAAMAAwMEBAUBAQQABgQIBAYFBQFGBQACAQMAAQMDBAIAAAIAAwMDHAMBFhYNDQ0VFQAAAQEBAQAAAAAAAQQEAQEEBgEHAQIBAQMEBAUABAMCAgIQAQEAAwABAwMdAgABAwMAAQADAwADAQAAAAEBAwADAwADAAEABQAABQAFAwMAAQMDAgICAAACAQAEBgEBAgALDwYCAgIEAgABAwQBBAAWAhABAgIBAgEEAQQBARAQEBsEAgQBBwIAAgIAAwMDBAQFAAMAAAQAEgESEhkCRwAWAwECAAIBAQcHAAEAFQ0DBAQEBAQEAAMAAQEAAwABAQADAAMBAAEDAQcAAAQEBAEGAgIAAgEEBQEEGwQCGwEAAwABAQEBAQEBAQEBAQEBAQEEBAQQEBAQEBAQEBAQREUEARsBAhACcAQCBAEEAQcAAAMDAwMDBAQFAgQBBQMCAgAAAAAAAAIBAAEBAwMAASIOAAEAAQABAAEEAAEAAQABAAEAAQABAAEAAQABAAESEBIQEhASEhISEhJxEkJDAgIEAQIEAgQCAhlHAgICAgAGBgICAgUAEgUCBgYCEhISGQESAgYGAgVBAhkABQICFgAAAQICCAECBgYDAAMBAAEBBQEAAAMBAAEBAAADAQABAQQEAAMBAAEBBAAEAAMBAAEAAwEAAQEHBAQAAwEAAQEHBwABAQEBAwMGBAMIBAYFCAQGBQQECAkHBgUAAwEAAQEHAQgEBgUIBAYFBAQAAwEAAQEHAQgEBgUIBAYFBAYGBgQEAgYGBgMUDwYGSBRIFAYGBicDFBQ5BAYnFBQ5AgYnJwMUBAQGBgMGDw8UBAcHBwEEAQEHAAADAAEBAQQEBwIHAQQBAQcAAwABAAEBBAQHBwEEAQIBAAMAAQQBAgECAgYGBwMGAgQEBAAAAAIEBAAEAgAHAgIFBgYHBgYAAwEAAQgEBgUIBAYFCAQGBQgEBgUHCAkGBQcCBwIEBgY5AwcCBwIAAAADAQABAQADAQABAUlKMHIAAwEBSxAmBQEAAgUBAQcAAwABAQABFQABAQABAgUVAQQHAgEBBAYGBg8GDxQGBgQEBAICBAIDFhgFAQQPFBQDBgQBARQEBAIAAwIBAQEDBAYEBAYPAgYCAw8EAAABAQICBAQCBAEAAAAAAQAAOgACAgEDAwMCAwMFAAMCAgABBAIEAgQFBgEEBgMDAwcICQQGBQUHCAQCAQEBBAQBAAADAAUCBwcEBAAEBAYAAQEBAQQEAgEBAQMCAgICAwMCAgIFABwDAQMEBAADAwMEAgIFBwICAgIHAAEEAQAAAwEBAQEBAQEBAQcBAQEBAQEBAQEBAQYBBAQEAgYHAQAFBwEMAAMCAwADAAMDAAMGDwQAAAAAAAADAgUCAAICAgICAgIDAQEPAgICAgICAgICAgUCAgIBAQMCAgIDAAQCAgIBHExMOwM7HAMOKCgTTRc8KChOIw4TDiNNFxcXC08jTyNOIyhzdCk9KSkpPDw+EykXPQ4ODg4ODg4ODg4ODg4OExMTHx8fF1AXFxcXFwYTExc9ExMTEw4ODg4ODg4OExMTEw4OExMODg4ODg4+Pg4TEw5RdXYXUFEXHx8fDhcUAh0BAgIFBwALAwsLGioxKjEId3gaBQUFCnkaDQ0aMlJTVBoyUlNUGgADABoxKgAFBzEQAAIADRoaGjIyGioFBQIAAAIAAwMKCwYPARQBAAQAAAMKVRoaBQAABSsrAAAAABwAID96IHsGDBRWVwYWBFgeBgJZCgoKCwcABQIOBQUAAAMCAgIFAQIKACA/WlogAQMKFXwBAQoKPyAgIH1+AAEBBQEEBgUBCAkEBgcFBQUEBAYGAAMACgoFBQADAgABAQAAAwABBSIsBgAABQIFAQACAAoAAAIFAgIAAAMDBQAAAAAAAgACAAUAAgEAAAAAAgAAAQACAgEAAgIACQoKAgIJAgIJAAAAAgoKOgIAAAMDAgACAAIACAACCAgCAgIsITMSAAIAAgIAAAADAwMAAwADAAEFIgYAAAUFAQAACgAAAgUCAgAAAwMAAAAAAgAFAAIBAAAAAgAAAgICAAADAwIAAAIABQAAAAAAAAAAAgYEAQEFAwMAAAEAAAEDBwIABQQBAgAAAQEBAAAAAAAAAAIAAgICIgAAAAIRCwIRAAgAAwYDAAMAAwMAAwACAwADBQQEAAAABAAEAQEDAAAAAAAAAQAAAAAAAQEAAQEAAAoKAgACAAACAgAAAAIBAQECAAACCgoCAgAFAAQACgMFAAMBBAECAQIAAwMFAQEFBQUFAQABAAEAAQAAAAAAAAAAAAUFBQUAAAAAAAAAAAAAAAADAwEFAgICAgIAAAAAAAAAAAAAKwIAAAAAAAMLAwAFAgUCAgAFAgUCAgABAgEAAQAAAAADAAMBAAIAAgICAAMBAAUCAwEAAAIAAhERAwEACAUCAAsCBQILBQACAgAFBQIFAlUIGAQABn9cXA8FWwEqBwUAAgcFAwAKCggHCAUKBQAdWR0FAAADCAYFBAUAAwgGBQUEAwUJAAEBGAICBQECAgAACQkABQQCLgcGCQk0CQkHCQkHCQkHCQk0CQkPOFgJCR4JCQYJBwoHBQIACQABARgCAgACAAkJBQQuCQkJCQkJCQkJCQkJDzgJCQkJCQcFAAABBQUAAAEFBQgAAAIAAAICCAkGCAUUITUICSE1M10FAAUHARQAQF4IAAUCCAAAAgAAAAICCAkUCSE1CAkhNTNdBQEUAEBeCAUAAQEBAREFAAkJCQwJDAkMCBEMDAwMDAwPDAwMDA8RBQAJCQAAAAAAAAkMCQwJDAgRDAwMDAwMDwwMDAwPGAwFAgAABQIYDAUCCAMAAAUCAAoKAAEBAQEAAQEAAAEBAQEAAQEACgoAAQEAAwEBAAEBAAABAQEBAAEBAgMFAgADBQAAABgDNwAABQUAJQQABQIAAAICBQQEAAAAABgDBQMCAQUAAAEBAQAAAQEAAAEBAQAAAQEABQACAAUCAAACAAACAQEYNwAABSUEAAIFAgAAAgIFBAAYAwUDAAEBAAEAAgIABwEAAQECAQAAAQEAAAEBAQAAAQEABQACAAUCAAACATYCJV8AAQEAAgAFCgk2AiVfAAAAAQEAAgAFCQAFAgIKAgAFAgICBQwBBQwBAAICAgMLAQsBCwELAQsBCwELAQsBCwELAQsBCwELAQsBCwELAQsBCwELAQsBCwELAQsBCwELAQsBCwELAQsBCwEAAgUDAQEAAwEDAAQCAgICAgICAgICAgICAgICAgICAgICAgICAgMAAAQKAgMACgAAAAACAgACAQADAAMBAQACAgsKCgACAAICAwUBBQMDAAICAwoCAwUHBwcCCgUCCgUCBwUIBwAAAwIFAgUCBwUIAxERCAAACAACAAMRCQcRCQgIAAcAAAgHAAMRERERCAAACAgAAxERCAAACAADEREREQgAAAgIAAMREQgAAAgAAgIAAwADAAAAAAEBAQECAAEBAgIBAAsDAAsDAgALAwALAwALAwALAwADAAMAAwADAAMAAwADAAMBAAIDAwMDAAMAAwMAAwADAwMDAwMDAwMDAQEFAAAFAAAABQIFAgAAAAAAAAAAAQQEAAAAAAACAAADAgABBQABAAAAAAUAAAAPAAAAAAIAAAAAAAAAAAEEAQMDBAAAAAAAAAAAAAICAQIDAAcBAQAFAAAFAAYBAwACAAAAAQABAAIDAgMAAwMAAgIAAAIAAAACAQEDAAACAAAAAgAABQAAAgACBQQCAQEBBQECBQIdCgokJCQkHQoKJCRXFgQCAAACAAACAAAAAAIAAAADAAAEAgEDAAsAAAMDAgIBAwIAAAIAAgACAgAAAgICAgUFAgIAAgICAgICAgIFLQYFABQFBAQHBQIFCAUHBAUFBQEFBAgCBAUtABQFBAQFAgUEAQQFBwcDBQEBBgEBBgMVEAMEAwMCAgYAAgAGAAIFBAUFAgACAAUAAAQBAgAECgAEBAoBBAACAgIFAAMBAAMDAQACAAICAAADAwMDAgAAAwMACwoDCgsAAwMDAwMDAwUFAAUHBgYGBgIGBQUCAg8GDwwPDw8MDAwFAAADAAADAAADAAAAAAADAAAAAwADAwMAAAADAAoDACwOYGE0gAGBARMXVoIBYmM2gwEFBmQHB4QBFA8MAggYCEYuLA5gYYUBhgFiYwSFgICAAAFwAMYOBYeAgIAAAQGAAoCAAga0i4CAANwBfwFBsLXEAgt/AUEAC38AQbC1AQt/AEHwtQELfwBB+LYBC38AQajbAwt/AEEAC38AQYkEC38AQbTdAwt/AEHk3QMLfwBBmN4CC38AQdTeAgt/AEHA1wILfwBB+KYEC38AQaDOAQt/AEHM5AMLfwBB+LEBC38AQcDdAwt/AEGJBAt/AEGIxgELfwBBlMYBC38AQczdAwt/AEHg1AMLfwBB+N0DC38AQZnzAQt/AEHc4AILfwBBhOECC38AQei+AQt/AEGM3gMLfwBBtKkBC38AQZDiAgt/AEG44gILfwBBmOQDC38AQbzeAwt/AEH9Bgt/AEH+Bgt/AEGI8QMLfwBBsN8DC38AQf8GC38AQYAHC38AQfjfAwt/AEGBBwt/AEGCBwt/AEGw3gMLfwBBwOADC38AQdTgAwt/AEGo1QMLfwBBkN8DC38AQZzfAwt/AEHk8AMLfwBB+PQBC38AQar1AQt/AEHktQELfwBBlOEDC38AQajjAwt/AEGg4QMLfwBBiQQLfwBB8OIDC38AQbzjAwt/AEH84gMLfwBB0OMDC38AQYjjAwt/AEHk4wMLfwBBlOMDC38AQfjjAwt/AEHc9gELfwBB1OQDC38AQcTrAwt/AEEBC38AQbgHC38AQbkHC38AQboHC38AQbsHC38AQbwHC38AQb0HC38AQb4HC38AQb8HC38AQcAHC38AQcEHC38AQcIHC38AQcMHC38AQcQHC38AQcUHC38AQcYHC38AQccHC38AQcgHC38AQckHC38AQcoHC38AQcsHC38AQcwHC38AQc0HC38AQc4HC38AQc8HC38AQdAHC38AQdEHC38AQdIHC38AQdMHC38AQYTsAwt/AEHo5AMLfwBBiOUDC38AQfTkAwt/AEHUBwt/AEHVBwt/AEHWBwt/AEHXBwt/AEG85QMLfwBB2AcLfwBB2QcLfwBB8OUDC38AQaTmAwt/AEEPC38AQajYAwt/AEHY5gMLfwBBjOcDC38AQcDnAwt/AEGE6AMLfwBBkOgDC38AQaToAwt/AEGcsQELfwBBtLABC38AQdzoAwt/AEGM1AMLfwBBtfcBC38AQbv3AQt/AEHB9wELfwBBsJ8EC38AQfH3AQt/AEGkgAQLfwBBmIAEC38AQaDpAwt/AEGc+AELfwBB7OkDC38AQb74AQt/AEG46gMLfwBBhOsDC38AQeMFC38AQdjaAwt/AEHE7AMLfwBBjO0DC38AQc75AQt/AEHs7QMLfwBBpLUBC38AQczuAwt/AEHstgELfwBBnLMBC38AQeDuAwt/AEGg8AMLfwBBjOQDC38AQfTuAwt/AEGA7wMLfwBBiQQLfwBBuNoDC38AQZDaAwt/AEGU7wMLfwBB+NMBC38AQbTvAwt/AEHAxAELfwBB7NQDC38AQbTyAwt/AEGhCQt/AEHQ8QMLfwBBoLoBC38AQcjyAwt/AEHguQELfwBB+PEDC38AQYy6AQt/AEGiCQt/AEGjCQt/AEGkCQt/AEGlCQt/AEGmCQt/AEGnCQt/AEGoCQt/AEGpCQt/AEGqCQt/AEGrCQt/AEGsCQt/AEGtCQt/AEGuCQt/AEGvCQt/AEGwCQt/AEGxCQt/AEGyCQt/AEGzCQt/AEG0CQt/AEG1CQt/AEG2CQt/AEG3CQt/AEG4CQt/AEG5CQt/AEG6CQt/AEG7CQt/AEHA/AELfwBBvAkLfwBBvQkLfwBBvgkLfwBBsM8CC38AQbCABAt/AEGwggQLfwBB8IIEC38AQbCDBAt/AEHwgwQLfwBBsIQEC38AQfCEBAt/AEGwhQQLfwBB8IUEC38AQbCGBAt/AEGQ/gELfwBB0P4BC38AQZD/AQt/AEHQ/wELfwBBsPYDC38AQbj4Awt/AEGi+QMLfwBB+PsDC38AQar9Awt/AEGV/gMLfwBBh/8DC38AQbD2Awt/AEH6/wMLB72GgIAAKAZtZW1vcnkCABFfX3dhc21fY2FsbF9jdG9ycwBdC2dldFRlbXBSZXQwANoPBGZyZWUAyg8GbWFsbG9jAMkPK19fZW1fanNfX2NvbnZlcnREb3VibGVBcnJheVRvSlNDb21wbGV4QXJyYXkD0wEjX19lbV9qc19fY29udmVydENQUENUWVBFVG9KU0NvbXBsZXgD1AEWX19lbV9qc19fY29udmVydE1hdHJpeAPVASFfX2VtX2pzX19jb252ZXJ0SW50QXJyYXlUb0pTQXJyYXkD1gEhX19lbV9qc19fUmV2ZXJzaWJsZUJvb2xlYW5XcmFwcGVyA9cBGF9fZW1fanNfX0FkYXB0aXZlV3JhcHBlcgPYATdfX2VtX2pzX19RdWFudHVtU3RhdGVNdWx0aXBseUVsZW1lbnR3aXNlRnVuY3Rpb25XcmFwcGVyA9kBGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAA1fX2dldFR5cGVOYW1lAM8OG19lbWJpbmRfaW5pdGlhbGl6ZV9iaW5kaW5ncwDQDhBfX2Vycm5vX2xvY2F0aW9uAOAOCHNldFRocmV3ANgPC3NldFRlbXBSZXQwANkPCXN0YWNrU2F2ZQCrHQxzdGFja1Jlc3RvcmUArB0Kc3RhY2tBbGxvYwCtHQ9fX2N4YV9jYW5fY2F0Y2gAjh0VX19jeGFfaXNfcG9pbnRlcl90eXBlAI8dDV9fc3RhcnRfZW1fanMD2gEMX19zdG9wX2VtX2pzA9sBCmR5bkNhbGxfaWoAvR0LZHluQ2FsbF92aWoAvh0OZHluQ2FsbF9kaWlpaWoAvx0LZHluQ2FsbF9paWoAwB0MZHluQ2FsbF9qaWlpAMEdDWR5bkNhbGxfdmlkaWoAwh0OZHluQ2FsbF92aWlqaWkAwx0MZHluQ2FsbF92aWlqAMQdDWR5bkNhbGxfdmlpaWoAxR0KZHluQ2FsbF9qaQDGHQxkeW5DYWxsX2ppamkAxx0OZHluQ2FsbF9paWlpaWoAyB0NZHluQ2FsbF9qaWlpaQDJHQ9keW5DYWxsX2lpaWlpamoAyh0QZHluQ2FsbF9paWlpaWlqagDLHQnonICAAAEAQQELxQ4BAwcJAGAOXmNkzhtmEWeQHRIVaWFrbW6hBqIGowakBqUGeXV7fB99fn+AAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBuAG5AboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBxwHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHlB9QB5gfVAecH6AfpB+oH1gHXAdgB2QHaAdsB3AHdAd4B3wHgAeEB4gHjAeQB5QHmAecB6AHpAeoB6wHsAe0B7gHvAfAB8QHyAfMB9AH1AfYB9wH4AfkB+gH7AfwB/QH+Af8BgAKBAoICgwKEAoUChgKHAogCiQKKAosCjAKNAo4CjwKQApECkgKTApQClQKWApcCmAKZApoCmwKcAp0CngKfAvMH9wf5B/sH/QeACIIIhAiGCIgIigiMCI4IkAiSCKACoQihAqIIogKjCKMClAiWCJgImgibCJwInQieCJ8IpAKkCKgIpQKqCKYCpwKoAqkCqgKrAqwCrQKuAq8CsAKxArICswK0CLQCuAi1ArYCtwK7CLgCvAjCCMMIxAi5AsUIugLHCLsCywi8Ar0CvgK/AsACwQKZB8ICwwLEAsUCxgLHAqMHyALJApUHygKWB8sCpwfMAs0CzgLPAtAC0QLSAtMC1ALVAtYC1wLYAtkC2gLbAtwC3QLeAt8C4ALhAuIC4wLkAuUC5gLnAq8G6ALpAuoC6wLsAu0C7gLvAvAC8QLyAvMC9AL1AvYC9wL4AvkC+gL7AvwC/QL+Av8CgAOBA4IDgwOEA4UDhgOHA4gDiQOKA4sDjAONA44DjwOQA5EDkgOTA5QDlQOWA5cDmAOZA5oDmwOcA50DngOfA6ADoQOiA6MDpAOlA6YDpwOoA6kD4AeqA+EHqwPkB6wDrQOuA68DsAOxA7IDswO0A7UDtgO3A7gDuQO6A84MuwPPDLwD0AzRDL0DvgO/A9MMwAPUDNUM1gzBA8IDwwPEA8UDxgPHA8gDyQPKA8sDzAPNA84DzwPQA9ED0gPTA9QD1QPWA9cD2APACtkD2gPbA9gM3APcDN0D3gPfA+AD4QPiA+MD5APlA+YD5wPoA+kD6gPrA+wD7QPuA+8D8APxA/ID8wP0A/UD9gPeBuAG4Qb3A/gD+QP6A/sD/AP9A/4D/wOABIEEggSDBIQE8QuFBKgMhgSHBIgEiQSKBIsEjASNBI4EjwSQBJEEkgSTBKUErQVw/AzWBLcFlAR04gXlBZkd3RusCK4I5gWwCGixCGrnBbIIuQj1Bc8ImAeuBvcF0gv6G5sErAyVBHLPBKgGywyDDJYElwSYBJkEmgSdBJ4EnwSgBKEEjAaPBt4M3wzZDN0M2gyTBr8KwQr0BccKyArJCsoKywr0C6kM4QyeBp8G/xuJHOUG/gzQCM4G1gf6BaYEzQ3KDdYb2BvODXfZG+sNhBTZELsS5wS9EukSKfwP0ATTBNQE6QzVBOoM8ASaBegE6QTqBOsE7ATtBNoExATuEKkQ5BDnENsEwxHDEowQqQWqBeQEnAWdBfEEhByKHPME9ASFHLoSjgWPBfYE9wTiG3b+G/wE/gSTBZ4FnwUqogWGHIUQrAXqEM8N0A3RDdwN2QXfBdsF4QXjBRswzxvqBegF9gXIBI4GkQb4BPUEeKcEqASpBKoEqwSsBK0ErgSvBLAEsQSyBLMEtAS1BLYEtwS4BLoEuwS8BL0EvgS/BMAEwQTCBMMExQTGBMcEygTMBM0EzgTRBNIE2ATdBN4E3wTsHOAEnh3hBOIE5QTmBPsE/QT/BIAFgQWiHYIFgwWEBYUF+gSGBaAdhwWIBYkFigWLBZEFkgWUBZUFlgWXBZgFkAWZBbYFrgWvBbAFsQWyBbMFtAW1BbgFuQW6BbsFvAW9Bb4FvwXABcEFwgXDBcQFxQXGBccFyAXJBcoFywXMBc0FzgXPBdAF0QXSBdMF1AXVBdYF1wXYBdoF3AXdBd4F6wXsBe0F7gXvBfAF8QXyBfMF/AX9BYUGhgadBpQGlQaWBpcGmAaZBpsGnAbRBtIGvga/BsAGwQagB8IGuQapB6oHqwesB60HrgevB7AHsQeyB7MHtAe1B7YHtwe4B7kHuge7B7wHvQe+B78HwAfBB8IHwwfEB8UHxgfHB8gHyQfLB80HzgfQB9EH0gfLBtUHsAayBrMGtAa1BrYGuAa9BsMGxAbFBsYGxwbKBsgG0wbUBtgG2QbaBtsGjA7CDo0Oww6ODsQO/AbnBugG6gbsBu8H7QftBvAG8QbyBvMG9Ab1Bv0G/gb/BoAHgQeCB4MHhAeFB4YHhweIB4kHigeLB4wHjgeQB5EHpQemB5sHnAeeB58HpAeoB9MH1wfYB9kH2gfbB/EH8AfuB/IH9Qf2B/sNrw78DbAO/Q2yDoYOqw7+DZ8O/w2gDoAOoQ6BDqIOgg6jDoMOpA6EDqUOhQ6mDocOsw6IDrQOiQ6nDooOqQ6LDq0O3wjgCOEI4gjjCOQI5QjoCOkI6gjrCOwI7QjuCO8I8AjxCPII8wj0CPUI+Aj5CPoI+wj8CP0I/wiBCYIJgwmECYUJhgmHCYgJiQmKCYsJjwmQCZEJkgmTCZQJlwmYCZkJmgmbCZwJoAmwCbEJsgmzCbQJtQm3CcIJwwnECcUJxgnHCckJjAqNCoYKjgqPCogKiQqLCocKkAqRCpwKnQqXCp4KnwqZCpoKoAqYCqEKogqsCq0KpwquCq8KqQqrCqgKsQqzCtIK0wrUCtUK1gr7CvwK/Qr+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LCgCAAsMACABIAAoAgARAAALDQAgACgCAEF8aigCAAsEACAACwQAIAALFwACQCAARQ0AIAAgACgCACgCBBEDAAsLKQEBfyMAQRBrIgIkACACIAE2AgwgAkEMaiAAEQAAIQEgAkEQaiQAIAELWAECf0G4FBDOGyEBIAAoAgAhAEEAQQA2ArSMBEGEBCABIAAQAiECQQAoArSMBCEAQQBBADYCtIwEAkAgAEEBRg0AIAIPCxAGIQAQ2g8aIAEQ0BsgABALAAs5AQF/IAEgACgCBCICQQF1aiEBIAAoAgAhAAJAIAJBAXFFDQAgASgCACAAaigCACEACyABIAARAwALEgAgACABrSAAKAIAKAIUERwACw4AIAEgAiAAKAIAEQEACzsBAX8gASAAKAIEIgNBAXVqIQEgACgCACEAAkAgA0EBcUUNACABKAIAIABqKAIAIQALIAEgAiAAEQEACzsBAX8gASAAKAIEIgNBAXVqIQEgACgCACEAAkAgA0EBcUUNACABKAIAIABqKAIAIQALIAEgAiAAERYAC6MDAgR/AXwjAEEgayICJAAgAkEQaiABEK0FIAJBADYCCCACQgA3AwACQAJAAkACQCACKAIUIgEgAigCECIDRg0AAkAgASADayIEQX9KDQBBAEEANgK0jARBhQQgAhAEQQAoArSMBCEBQQBBADYCtIwEIAFBAUYNAgALQQBBADYCtIwEQQsgBBAKIQFBACgCtIwEIQVBAEEANgK0jAQgBUEBRg0BIAIgATYCACACIAE2AgQgAiABIARBAnVBAnRqIgU2AggCQAJAIARBAU4NACABIQUMAQsgASADIAQQ3Q4aCyACIAU2AgQLIAAoAgAoAiQhAUEAQQA2ArSMBCABIAAgAhAtIQZBACgCtIwEIQFBAEEANgK0jAQgAUEBRg0BAkAgAigCACIBRQ0AIAIgATYCBCABENAbCwJAIAIoAhAiAUUNACACIAE2AhQgARDQGwsgAkEgaiQAIAYPCxAGIQAQ2g8aDAELEAYhABDaDxogAigCACIBRQ0AIAIgATYCBCABENAbCwJAIAIoAhAiAUUNACACIAE2AhQgARDQGwsgABALAAvcAQIBfwF8IwBBEGsiAyQAIAAoAgAhAEEAQQA2ArSMBCADIAI2AgggACABIANBCGoQLSEEQQAoArSMBCEAQQBBADYCtIwE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aiQAIAELOQEBfyABIAAoAgQiAkEBdWohASAAKAIAIQACQCACQQFxRQ0AIAEoAgAgAGooAgAhAAsgASAAEQAAC00BAX8jAEEgayICJAAgAkEQaiABEF4gACgCACgCMCEBIAJBCGogAkEQakEIaikDADcDACACIAIpAxA3AwAgACACIAERAQAgAkEgaiQAC9YBAQF/IwBBEGsiAyQAIAAoAgAhAEEAQQA2ArSMBCADIAI2AgggACABIANBCGoQD0EAKAK0jAQhAEEAQQA2ArSMBAJAAkACQCAAQQFGDQBBAEEANgK0jARBAiADKAIIEARBACgCtIwEIQBBAEEANgK0jAQgAEEBRg0BIANBEGokAA8LEAYhABDaDxpBAEEANgK0jARBAiADKAIIEARBACgCtIwEIQNBAEEANgK0jAQgA0EBRg0BIAAQCwALQQAQBRoQ2g8aEOgcAAtBABAFGhDaDxoQ6BwACz0BAX8gASAAKAIEIgRBAXVqIQEgACgCACEAAkAgBEEBcUUNACABKAIAIABqKAIAIQALIAEgAiADIAARBAALDQAgACgCAEF8aigCAAsEACAACwQAIAALFwACQCAARQ0AIAAgACgCACgCBBEDAAsLDQAgACgCAEF8aigCAAsEACAACwQAIAALFwACQCAARQ0AIAAgACgCACgCBBEDAAsLDQAgACgCAEF8aigCAAsEACAACwQAIAALFwACQCAARQ0AIAAgACgCACgCBBEDAAsLDQAgACgCAEF8aigCAAsEACAACwQAIAALFwACQCAARQ0AIAAgACgCACgCBBEDAAsLDQAgACgCAEF8aigCAAsEACAACwQAIAALFwACQCAARQ0AIAAgACgCACgCBBEDAAsLDQAgACgCAEF8aigCAAsEACAACwQAIAALFwACQCAARQ0AIAAgACgCACgCBBEDAAsLDQAgACgCAEF8aigCAAsEACAACwQAIAALFwACQCAARQ0AIAAgACgCACgCBBEDAAsLDQAgACgCAEF8aigCAAsEACAACwQAIAALFwACQCAARQ0AIAAgACgCACgCBBEDAAsLCQAgASAAEQAACwsAIAEgAiAAERIACw0AIAEgAiADIAARQgALDwAgASACIAMgBCAAEUMACwsAIAEgAiAAERIACwsAIAEgAiAAEQIACwsAIAEgAiAAEQIACw0AIAEgAiADIAARBQALnAEBAX8CQAJAIAIQ9wciAw0AQQgQFCECQQBBADYCtIwEQYgEIAJB+4oBEAIhAUEAKAK0jAQhA0EAQQA2ArSMBCADQQFHDQEQBiEDENoPGiACECQgAxALAAsgAxDACiICIABBASACKAIAKAIsEQQAIAIgAUEBIAIoAgAoAiwRBAAgAyADKAIAKAIEEQMAIAIPCyABQdDZA0GJBBAVAAs2ACABIAIQqggiAhDACiIBIABBASABKAIAKAIsEQQAAkAgAkUNACACIAIoAgAoAgQRAwALIAEL0AIBAX8jAEEQayIDJAAgAyABNgIIQQBBADYCtIwEIAMgAjYCACAAIANBCGogAxACIQJBACgCtIwEIQFBAEEANgK0jAQCQAJAAkACQAJAIAFBAUYNAEEAQQA2ArSMBEECIAMoAgAQBEEAKAK0jAQhAUEAQQA2ArSMBCABQQFGDQFBAEEANgK0jARBAiADKAIIEARBACgCtIwEIQFBAEEANgK0jAQgAUEBRg0CIANBEGokACACDwsQBiECENoPGkEAQQA2ArSMBEECIAMoAgAQBEEAKAK0jAQhAUEAQQA2ArSMBCABQQFGDQJBAEEANgK0jARBAiADKAIIEARBACgCtIwEIQNBAEEANgK0jAQgA0EBRg0DIAIQCwALQQAQBRoQ2g8aEOgcAAtBABAFGhDaDxoQ6BwAC0EAEAUaENoPGhDoHAALQQAQBRoQ2g8aEOgcAAu0BwEIfyMAQcAAayICJAAgAkEwaiAAEK0FQQBBADYCtIwEQYAEIAJBIGogARAPQQAoArSMBCEAQQBBADYCtIwEAkACQAJAAkACQAJAIABBAUYNACACKAI0IgMgAigCMCIEayIAQQJ1IgUgAigCJCIGIAIoAiAiB2siAUECdSIIRg0CQQgQFCEAQQBBADYCtIwEQYoEIABBmIMBEAIhAUEAKAK0jAQhA0EAQQA2ArSMBCADQQFGDQEgAUGk2QNBCGo2AgBBAEEANgK0jARBESABQdDZA0GJBBAWQQAoArSMBCEAQQBBADYCtIwEIABBAUcNBRAGIQEQ2g8aDAMLEAYhARDaDxoMAwsQBiEBENoPGiAAECQMAQsgAkEANgIYIAJCADcDEAJAAkACQAJAAkAgAyAERg0AAkAgAEF/Sg0AQQBBADYCtIwEQYUEIAJBEGoQBEEAKAK0jAQhAEEAQQA2ArSMBCAAQQFGDQIMCAtBAEEANgK0jARBCyAAEAohA0EAKAK0jAQhCUEAQQA2ArSMBCAJQQFGDQEgAiADNgIQIAIgAzYCFCACIAMgBUECdGoiBTYCGAJAAkAgAEEBTg0AIAMhBQwBCyADIAQgABDdDhoLIAIgBTYCFAsgAkEANgIIIAJCADcDAAJAIAYgB0YNAAJAIAFBf0oNAEEAQQA2ArSMBEGFBCACEARBACgCtIwEIQBBAEEANgK0jAQgAEEBRw0IDAQLQQBBADYCtIwEQQsgARAKIQBBACgCtIwEIQNBAEEANgK0jAQgA0EBRg0DIAIgADYCACACIAA2AgQgAiAAIAhBAnRqIgM2AggCQAJAIAFBAU4NACAAIQMMAQsgACAHIAEQ3Q4aCyACIAM2AgQLQQBBADYCtIwEQYsEIAJBEGogAhACIQFBACgCtIwEIQBBAEEANgK0jAQgAEEBRg0BAkAgAigCACIARQ0AIAIgADYCBCAAENAbCwJAIAIoAhAiAEUNACACIAA2AhQgABDQGwsCQCACKAIgIgBFDQAgAiAANgIkIAAQ0BsLAkAgAigCMCIARQ0AIAIgADYCNCAAENAbCyACQcAAaiQAIAEPCxAGIQEQ2g8aDAMLEAYhARDaDxogAigCACIARQ0BIAIgADYCBCAAENAbDAELEAYhARDaDxoLIAIoAhAiAEUNACACIAA2AhQgABDQGwsgAigCICIARQ0AIAIgADYCJCAAENAbCwJAIAIoAjAiAEUNACACIAA2AjQgABDQGwsgARALAAsAC9ICAQF/IwBBEGsiBCQAIAQgATYCCEEAQQA2ArSMBCAEIAI2AgAgACAEQQhqIAQgAxAxIQJBACgCtIwEIQFBAEEANgK0jAQCQAJAAkACQAJAIAFBAUYNAEEAQQA2ArSMBEECIAQoAgAQBEEAKAK0jAQhAUEAQQA2ArSMBCABQQFGDQFBAEEANgK0jARBAiAEKAIIEARBACgCtIwEIQFBAEEANgK0jAQgAUEBRg0CIARBEGokACACDwsQBiECENoPGkEAQQA2ArSMBEECIAQoAgAQBEEAKAK0jAQhAUEAQQA2ArSMBCABQQFGDQJBAEEANgK0jARBAiAEKAIIEARBACgCtIwEIQRBAEEANgK0jAQgBEEBRg0DIAIQCwALQQAQBRoQ2g8aEOgcAAtBABAFGhDaDxoQ6BwAC0EAEAUaENoPGhDoHAALQQAQBRoQ2g8aEOgcAAu2BwEIfyMAQcAAayIDJAAgA0EwaiAAEK0FQQBBADYCtIwEQYAEIANBIGogARAPQQAoArSMBCEAQQBBADYCtIwEAkACQAJAAkACQAJAIABBAUYNACADKAI0IgQgAygCMCIFayIAQQJ1IgYgAygCJCIHIAMoAiAiCGsiAUECdSIJRg0CQQgQFCEAQQBBADYCtIwEQYoEIABBmIMBEAIhAUEAKAK0jAQhBEEAQQA2ArSMBCAEQQFGDQEgAUGk2QNBCGo2AgBBAEEANgK0jARBESABQdDZA0GJBBAWQQAoArSMBCEAQQBBADYCtIwEIABBAUcNBRAGIQEQ2g8aDAMLEAYhARDaDxoMAwsQBiEBENoPGiAAECQMAQsgA0EANgIYIANCADcDEAJAAkACQAJAAkAgBCAFRg0AAkAgAEF/Sg0AQQBBADYCtIwEQYUEIANBEGoQBEEAKAK0jAQhAEEAQQA2ArSMBCAAQQFGDQIMCAtBAEEANgK0jARBCyAAEAohBEEAKAK0jAQhCkEAQQA2ArSMBCAKQQFGDQEgAyAENgIQIAMgBDYCFCADIAQgBkECdGoiBjYCGAJAAkAgAEEBTg0AIAQhBgwBCyAEIAUgABDdDhoLIAMgBjYCFAsgA0EANgIIIANCADcDAAJAIAcgCEYNAAJAIAFBf0oNAEEAQQA2ArSMBEGFBCADEARBACgCtIwEIQBBAEEANgK0jAQgAEEBRw0IDAQLQQBBADYCtIwEQQsgARAKIQBBACgCtIwEIQRBAEEANgK0jAQgBEEBRg0DIAMgADYCACADIAA2AgQgAyAAIAlBAnRqIgQ2AggCQAJAIAFBAU4NACAAIQQMAQsgACAIIAEQ3Q4aCyADIAQ2AgQLQQBBADYCtIwEQYwEIANBEGogAyACEDEhAUEAKAK0jAQhAEEAQQA2ArSMBCAAQQFGDQECQCADKAIAIgBFDQAgAyAANgIEIAAQ0BsLAkAgAygCECIARQ0AIAMgADYCFCAAENAbCwJAIAMoAiAiAEUNACADIAA2AiQgABDQGwsCQCADKAIwIgBFDQAgAyAANgI0IAAQ0BsLIANBwABqJAAgAQ8LEAYhARDaDxoMAwsQBiEBENoPGiADKAIAIgBFDQEgAyAANgIEIAAQ0BsMAQsQBiEBENoPGgsgAygCECIARQ0AIAMgADYCFCAAENAbCyADKAIgIgBFDQAgAyAANgIkIAAQ0BsLAkAgAygCMCIARQ0AIAMgADYCNCAAENAbCyABEAsACwAL0wEBAX8jAEEQayIDJABBAEEANgK0jAQgAyACNgIIIAAgASADQQhqEAIhAUEAKAK0jAQhAkEAQQA2ArSMBAJAAkACQCACQQFGDQBBAEEANgK0jARBAiADKAIIEARBACgCtIwEIQJBAEEANgK0jAQgAkEBRg0BIANBEGokACABDwsQBiECENoPGkEAQQA2ArSMBEECIAMoAggQBEEAKAK0jAQhA0EAQQA2ArSMBCADQQFGDQEgAhALAAtBABAFGhDaDxoQ6BwAC0EAEAUaENoPGhDoHAALqgQBAn8jAEEgayICJAAgAkEQaiABEGgCQAJAAkACQAJAIAIoAhRBAkcNACACKAIYQQJGDQELQQgQFCEBQQBBADYCtIwEQYoEIAFBn4sBEAIhAEEAKAK0jAQhA0EAQQA2ArSMBCADQQFGDQEgAEGk2QNBCGo2AgBBAEEANgK0jARBESAAQdDZA0GJBBAWQQAoArSMBCEBQQBBADYCtIwEIAFBAUcNAxAGIQAQ2g8aDAILQQBBADYCtIwEQY0EIAIgAkEQahACIQFBACgCtIwEIQNBAEEANgK0jAQCQAJAAkACQCADQQFGDQBBAEEANgK0jARBjgQgACABEAIhAEEAKAK0jAQhA0EAQQA2ArSMBCADQQFGDQECQCABKAIAIgFFDQAgAUF8aigCABDKDwsgAA0DQQgQFCEBQQBBADYCtIwEQYoEIAFB7e8AEAIhAEEAKAK0jAQhA0EAQQA2ArSMBCADQQFGDQIgAEGk2QNBCGo2AgBBAEEANgK0jARBESAAQdDZA0GJBBAWQQAoArSMBCEBQQBBADYCtIwEIAFBAUcNBgsQBiEAENoPGgwECxAGIQAQ2g8aIAEoAgAiAUUNAyABQXxqKAIAEMoPDAMLEAYhABDaDxogARAkDAILAkAgAigCECIBRQ0AIAFBfGooAgAQyg8LIAJBIGokACAADwsQBiEAENoPGiABECQLAkAgAigCECICRQ0AIAJBfGooAgAQyg8LIAAQCwsAC9ACAQF/IwBBEGsiAyQAIAMgATYCCEEAQQA2ArSMBCADIAI2AgAgACADQQhqIAMQAiECQQAoArSMBCEBQQBBADYCtIwEAkACQAJAAkACQCABQQFGDQBBAEEANgK0jARBAiADKAIAEARBACgCtIwEIQFBAEEANgK0jAQgAUEBRg0BQQBBADYCtIwEQQIgAygCCBAEQQAoArSMBCEBQQBBADYCtIwEIAFBAUYNAiADQRBqJAAgAg8LEAYhAhDaDxpBAEEANgK0jARBAiADKAIAEARBACgCtIwEIQFBAEEANgK0jAQgAUEBRg0CQQBBADYCtIwEQQIgAygCCBAEQQAoArSMBCEDQQBBADYCtIwEIANBAUYNAyACEAsAC0EAEAUaENoPGhDoHAALQQAQBRoQ2g8aEOgcAAtBABAFGhDaDxoQ6BwAC0EAEAUaENoPGhDoHAALqgYCBH8BfiMAQcAAayICJAAgAkEwaiAAEK0FQQBBADYCtIwEQY8EIAJBIGogARAPQQAoArSMBCEAQQBBADYCtIwEAkACQCAAQQFGDQACQAJAAkACQAJAAkACQAJAAkACQEIBIAIoAjQiASACKAIwIgNrIgBBAnUiBK2GIgYgAjQCJFINACAGIAI0AihRDQELQQgQFCEAQQBBADYCtIwEQYoEIABBlfAAEAIhAUEAKAK0jAQhA0EAQQA2ArSMBAJAIANBAUYNACABQaTZA0EIajYCAEEAQQA2ArSMBEERIAFB0NkDQYkEEBZBACgCtIwEIQBBAEEANgK0jAQgAEEBRw0CEAYhARDaDxoMCQsQBiEBENoPGiAAECQMCAsgAkEANgIYIAJCADcDECABIANGDQIgAEF/Sg0BQQBBADYCtIwEQYUEIAJBEGoQBEEAKAK0jAQhAEEAQQA2ArSMBCAAQQFGDQMLAAtBAEEANgK0jARBCyAAEAohAUEAKAK0jAQhBUEAQQA2ArSMBCAFQQFGDQEgAiABNgIQIAIgATYCFCACIAEgBEECdGoiBDYCGAJAAkAgAEEBTg0AIAEhBAwBCyABIAMgABDdDhoLIAIgBDYCFAtBAEEANgK0jARBjQQgAiACQSBqEAIhAEEAKAK0jAQhAUEAQQA2ArSMBCABQQFGDQFBAEEANgK0jARBkAQgAkEQaiAAEAIhA0EAKAK0jAQhAUEAQQA2ArSMBCABQQFGDQICQCAAKAIAIgBFDQAgAEF8aigCABDKDwsCQCACKAIQIgBFDQAgAiAANgIUIAAQ0BsLAkAgAigCICIARQ0AIABBfGooAgAQyg8LAkAgAigCMCIARQ0AIAIgADYCNCAAENAbCyACQcAAaiQAIAMPCxAGIQEQ2g8aDAMLEAYhARDaDxoMAQsQBiEBENoPGiAAKAIAIgBFDQAgAEF8aigCABDKDwsgAigCECIARQ0AIAIgADYCFCAAENAbCyACKAIgIgBFDQEgAEF8aigCABDKDwwBCxAGIQEQ2g8aCwJAIAIoAjAiAEUNACACIAA2AjQgABDQGwsgARALAAvQAgEBfyMAQRBrIgMkACADIAE2AghBAEEANgK0jAQgAyACNgIAIAAgA0EIaiADEAIhAkEAKAK0jAQhAUEAQQA2ArSMBAJAAkACQAJAAkAgAUEBRg0AQQBBADYCtIwEQQIgAygCABAEQQAoArSMBCEBQQBBADYCtIwEIAFBAUYNAUEAQQA2ArSMBEECIAMoAggQBEEAKAK0jAQhAUEAQQA2ArSMBCABQQFGDQIgA0EQaiQAIAIPCxAGIQIQ2g8aQQBBADYCtIwEQQIgAygCABAEQQAoArSMBCEBQQBBADYCtIwEIAFBAUYNAkEAQQA2ArSMBEECIAMoAggQBEEAKAK0jAQhA0EAQQA2ArSMBCADQQFGDQMgAhALAAtBABAFGhDaDxoQ6BwAC0EAEAUaENoPGhDoHAALQQAQBRoQ2g8aEOgcAAtBABAFGhDaDxoQ6BwAC/UHAgR/AX4jAEHwAGsiAiQAIAJB4ABqIAAQrQVBAEEANgK0jARBkQQgAkE4aiABEA9BACgCtIwEIQBBAEEANgK0jAQCQAJAIABBAUYNAAJAAkACQAJAAkACQAJAAkACQAJAQgEgAigCZCIBIAIoAmAiA2siAEECdSIErYYiBiACNAJAUg0AIAYgAjQCPFENAQtBCBAUIQFBAEEANgK0jARBigQgAUGV8AAQAiEAQQAoArSMBCEDQQBBADYCtIwEAkAgA0EBRg0AIABBpNkDQQhqNgIAQQBBADYCtIwEQREgAEHQ2QNBiQQQFkEAKAK0jAQhAEEAQQA2ArSMBCAAQQFHDQIQBiEAENoPGgwJCxAGIQAQ2g8aIAEQJAwICyACQQA2AjAgAkIANwMoIAEgA0YNAiAAQX9KDQFBAEEANgK0jARBhQQgAkEoahAEQQAoArSMBCEAQQBBADYCtIwEIABBAUYNAwsAC0EAQQA2ArSMBEELIAAQCiEBQQAoArSMBCEFQQBBADYCtIwEIAVBAUYNASACIAE2AiggAiABNgIsIAIgASAEQQJ0aiIENgIwAkACQCAAQQFODQAgASEEDAELIAEgAyAAEN0OGgsgAiAENgIsCyACQQxqQgA3AgAgAkEUakIANwIAIAJBHGpCADcCACACQgA3AgQgAkEAOgAAQQBBADYCtIwEQZIEIAIgAkE4ahACGkEAKAK0jAQhAEEAQQA2ArSMBAJAIABBAUcNABAGIQAQ2g8aAkAgAigCFCIBRQ0AIAEQ0RsLIAJBGGooAgAiAQ0DDAQLQQBBADYCtIwEQZMEIAJBKGogAhACIQFBACgCtIwEIQBBAEEANgK0jAQgAEEBRg0BIAIoAgwQyg8gAigCEBDKDwJAIAIoAhQiAEUNACAAENEbCwJAIAJBGGooAgAiAEUNACAAENEbCwJAIAIoAigiAEUNACACIAA2AiwgABDQGwsgAigCRBDKDyACKAJIEMoPAkAgAigCTCIARQ0AIAAQ0RsLAkAgAkHQAGooAgAiAEUNACAAENEbCwJAIAIoAmAiAEUNACACIAA2AmQgABDQGwsgAkHwAGokACABDwsQBiEAENoPGgwDCxAGIQAQ2g8aIAIoAgwQyg8gAigCEBDKDwJAIAIoAhQiAUUNACABENEbCyACQRhqKAIAIgFFDQELIAEQ0RsLIAIoAigiAUUNACACIAE2AiwgARDQGwsgAigCRBDKDyACKAJIEMoPAkAgAigCTCIBRQ0AIAEQ0RsLIAJB0ABqKAIAIgFFDQEgARDRGwwBCxAGIQAQ2g8aCwJAIAIoAmAiAUUNACACIAE2AmQgARDQGwsgABALAAu8AgEBfyMAQSBrIgIkAEEAQQA2ArSMBCACIAE2AhhBgAQgAkEIaiACQRhqEA9BACgCtIwEIQFBAEEANgK0jAQCQAJAAkAgAUEBRg0AQQBBADYCtIwEQQIgAigCGBAEQQAoArSMBCEBQQBBADYCtIwEIAFBAUcNAUEAEAUaENoPGhDoHAALEAYhARDaDxpBAEEANgK0jARBAiACKAIYEARBACgCtIwEIQJBAEEANgK0jAQgAkEBRw0BQQAQBRoQ2g8aEOgcAAtBAEEANgK0jAQgACACQQhqEAohAEEAKAK0jAQhAUEAQQA2ArSMBAJAIAFBAUYNAAJAIAIoAggiAUUNACACIAE2AgwgARDQGwsgAkEgaiQAIAAPCxAGIQEQ2g8aIAIoAggiAEUNACACIAA2AgwgABDQGwsgARALAAu+AgEBfyMAQSBrIgMkAEEAQQA2ArSMBCADIAE2AhhBgAQgA0EIaiADQRhqEA9BACgCtIwEIQFBAEEANgK0jAQCQAJAAkAgAUEBRg0AQQBBADYCtIwEQQIgAygCGBAEQQAoArSMBCEBQQBBADYCtIwEIAFBAUcNAUEAEAUaENoPGhDoHAALEAYhARDaDxpBAEEANgK0jARBAiADKAIYEARBACgCtIwEIQNBAEEANgK0jAQgA0EBRw0BQQAQBRoQ2g8aEOgcAAtBAEEANgK0jAQgACADQQhqIAIQAiECQQAoArSMBCEBQQBBADYCtIwEAkAgAUEBRg0AAkAgAygCCCIBRQ0AIAMgATYCDCABENAbCyADQSBqJAAgAg8LEAYhARDaDxogAygCCCICRQ0AIAMgAjYCDCACENAbCyABEAsAC9MBAQF/IwBBEGsiAyQAQQBBADYCtIwEIAMgATYCCCAAIANBCGogAhACIQJBACgCtIwEIQFBAEEANgK0jAQCQAJAAkAgAUEBRg0AQQBBADYCtIwEQQIgAygCCBAEQQAoArSMBCEBQQBBADYCtIwEIAFBAUYNASADQRBqJAAgAg8LEAYhARDaDxpBAEEANgK0jARBAiADKAIIEARBACgCtIwEIQNBAEEANgK0jAQgA0EBRg0BIAEQCwALQQAQBRoQ2g8aEOgcAAtBABAFGhDaDxoQ6BwAC6wEAQR/IwBBwABrIgIkACACQTBqIAAQrQUgAkEANgIoIAJCADcDIAJAAkACQAJAIAIoAjQiACACKAIwIgNGDQACQCAAIANrIgRBf0oNAEEAQQA2ArSMBEGFBCACQSBqEARBACgCtIwEIQBBAEEANgK0jAQgAEEBRg0CAAtBAEEANgK0jARBCyAEEAohAEEAKAK0jAQhBUEAQQA2ArSMBCAFQQFGDQEgAiAANgIgIAIgADYCJCACIAAgBEECdUECdGoiBTYCKAJAAkAgBEEBTg0AIAAhBQwBCyAAIAMgBBDdDhoLIAIgBTYCJAsgAiABNgIMIAJBhNkBNgIIQQBBADYCtIwEIAIgAkEIajYCGEGUBCACQSBqIAJBCGoQAiEEQQAoArSMBCEAQQBBADYCtIwEIABBAUYNAQJAAkACQCACKAIYIgAgAkEIakcNAEEEIQMMAQtBBSEDIABFDQELIAAgACgCACADQQJ0aigCABEDAAsCQCACKAIgIgBFDQAgAiAANgIkIAAQ0BsLAkAgAigCMCIARQ0AIAIgADYCNCAAENAbCyACQcAAaiQAIAQPCxAGIQQQ2g8aDAELEAYhBBDaDxpBBCEDAkACQCACKAIYIgAgAkEIakYNAEEFIQMgAEUNAQsgACAAKAIAIANBAnRqKAIAEQMACyACKAIgIgBFDQAgAiAANgIkIAAQ0BsLAkAgAigCMCIARQ0AIAIgADYCNCAAENAbCyAEEAsACwkAIAEgABEAAAsLACABIAIgABESAAsNACABIAIgAyAAERkACwsAIAEgAiAAERIACwsAIAEgAiAAEQIAC9UBAQF/IwBBEGsiBCQAQQBBADYCtIwEIAQgAjYCCCAAIAEgBEEIaiADEDEhAUEAKAK0jAQhAkEAQQA2ArSMBAJAAkACQCACQQFGDQBBAEEANgK0jARBAiAEKAIIEARBACgCtIwEIQJBAEEANgK0jAQgAkEBRg0BIARBEGokACABDwsQBiECENoPGkEAQQA2ArSMBEECIAQoAggQBEEAKAK0jAQhBEEAQQA2ArSMBCAEQQFGDQEgAhALAAtBABAFGhDaDxoQ6BwAC0EAEAUaENoPGhDoHAALpwcBCX8jAEEwayIDJAAgA0EgaiABEPQFIANBADYCGCADQgA3AxACQAJAAkACQAJAAkACQCADKAIkIgEgAygCICIERg0AIAEgBGtBAnUiAUEBIAFBAUsbIQVBACEBAkADQCADKAIgIAFBAnRqKAIAIQYCQAJAIAMoAhQiBCADKAIYIgdGDQAgBCAGNgIAIAMgBEEEajYCFAwBCwJAAkACQAJAIAQgAygCECIIayIJQQJ1IgpBAWoiBEGAgICABEkNAEEAQQA2ArSMBEGVBCADQRBqEARBACgCtIwEIQFBAEEANgK0jAQgAUEBRw0IDAELAkAgByAIayIHQQF1IgsgBCALIARLG0H/////AyAHQfz///8HSRsiBw0AQQAhBAwDCyAHQYCAgIAESQ0BQQBBADYCtIwEQQoQEEEAKAK0jAQhAUEAQQA2ArSMBCABQQFHDQcLEAYhARDaDxoMCwtBAEEANgK0jARBCyAHQQJ0EAohBEEAKAK0jAQhC0EAQQA2ArSMBCALQQFGDQMLIAQgCkECdGoiCyAGNgIAIAQgB0ECdGohBiALQQRqIQcCQCAJQQFIDQAgBCAIIAkQ3Q4aCyADIAY2AhggAyAHNgIUIAMgBDYCECAIRQ0AIAgQ0BsLIAFBAWoiASAFRw0ADAILAAsQBiEBENoPGgwGCyADQQA2AgggA0IANwMAIAMoAhQiASADKAIQIgZGDQIgASAGayIEQX9KDQFBAEEANgK0jARBlQQgAxAEQQAoArSMBCEBQQBBADYCtIwEIAFBAUYNAwsAC0EAQQA2ArSMBEELIAQQCiEBQQAoArSMBCEIQQBBADYCtIwEIAhBAUYNASADIAE2AgAgAyABNgIEIAMgASAEQQJ1QQJ0aiIINgIIAkACQCAEQQFODQAgASEIDAELIAEgBiAEEN0OGgsgAyAINgIEC0EAQQA2ArSMBEGWBCAAIAMgAhAxIQRBACgCtIwEIQFBAEEANgK0jAQgAUEBRg0BAkAgAygCACIBRQ0AIAMgATYCBCABENAbCwJAIAMoAhAiAUUNACADIAE2AhQgARDQGwsCQCADKAIgIgFFDQAgAyABNgIkIAEQ0BsLIANBMGokACAEDwsQBiEBENoPGgwBCxAGIQEQ2g8aIAMoAgAiBEUNACADIAQ2AgQgBBDQGwsCQCADKAIQIgRFDQAgAyAENgIUIAQQ0BsLAkAgAygCICIERQ0AIAMgBDYCJCAEENAbCyABEAsACw0AIAAoAgBBfGooAgALFwACQCAARQ0AIAAgACgCACgCBBEDAAsLKQEBfyMAQRBrIgIkACACIAE2AgwgAkEMaiAAEQAAIQEgAkEQaiQAIAELVwECf0EcEM4bIQEgACgCACEAQQBBADYCtIwEQZcEIAEgABACIQJBACgCtIwEIQBBAEEANgK0jAQCQCAAQQFGDQAgAg8LEAYhABDaDxogARDQGyAAEAsACzkBAX8gASAAKAIEIgJBAXVqIQEgACgCACEAAkAgAkEBcUUNACABKAIAIABqKAIAIQALIAEgABEAAAueAQEEfyMAQRBrIgIkACABIAAoAgQiA0EBdWohASAAKAIAIQACQCADQQFxRQ0AIAEoAgAgAGooAgAhAAsgAiABIAARAQAgAigCBCACLQALIgAgAEEYdEEYdSIDQQBIIgQbIgBBBGoQyQ8iASAANgIAIAFBBGogAigCACIFIAIgBBsgABDdDhoCQCADQX9KDQAgBRDQGwsgAkEQaiQAIAELEQAgACABIAAoAgAoAhARAQALDgAgASACIAAoAgARAQALEwAgACABIAIgACgCACgCFBEEAAsQACABIAIgAyAAKAIAEQQAC6MCAQR/IwBBEGsiBSQAIAEgACgCBCIGQQF1aiEHIAAoAgAhCAJAIAZBAXFFDQAgBygCACAIaigCACEICwJAIAMoAgAiAEFwTw0AAkACQCAAQQpLDQAgBSAAOgALIAUhAQwBCyAAQQ9yQQFqIgYQzhshASAFIAZBgICAgHhyNgIIIAUgATYCACAFIAA2AgQLAkAgAEUNACABIANBBGogABDdDhoLIAEgAGpBADoAAEEAQQA2ArSMBCAIIAcgAiAFIAQQNEEAKAK0jAQhAEEAQQA2ArSMBAJAIABBAUYNAAJAIAUsAAtBf0oNACAFKAIAENAbCyAFQRBqJAAPCxAGIQAQ2g8aAkAgBSwAC0F/Sg0AIAUoAgAQ0BsLIAAQCwALIAUQdgALOwEBfyABIAAoAgQiA0EBdWohASAAKAIAIQACQCADQQFxRQ0AIAEoAgAgAGooAgAhAAsgASACIAARAQALOwEBfyABIAAoAgQiA0EBdWohASAAKAIAIQACQCADQQFxRQ0AIAEoAgAgAGooAgAhAAsgASACIAARAQALPwEBfyABIAAoAgQiBUEBdWohASAAKAIAIQACQCAFQQFxRQ0AIAEoAgAgAGooAgAhAAsgASACIAMgBCAAEQYACzkBAX8gASAAKAIEIgJBAXVqIQEgACgCACEAAkAgAkEBcUUNACABKAIAIABqKAIAIQALIAEgABEAAAs9AQF/IAEgACgCBCIEQQF1aiEBIAAoAgAhAAJAIARBAXFFDQAgASgCACAAaigCACEACyABIAIgAyAAEQQACz0BAX8gASAAKAIEIgRBAXVqIQEgACgCACEAAkAgBEEBcUUNACABKAIAIABqKAIAIQALIAEgAiADIAAREAALPwEBfyABIAAoAgQiBUEBdWohASAAKAIAIQACQCAFQQFxRQ0AIAEoAgAgAGooAgAhAAsgASACIAMgBCAAEUQAC0EBAX8gASAAKAIEIgZBAXVqIQEgACgCACEAAkAgBkEBcUUNACABKAIAIABqKAIAIQALIAEgAiADIAQgBSAAEUUACxIAIAAgASAAKAIAKAKcAREBAAsOACABIAIgACgCABEBAAujBgEDfyMAQcAAayIDJAAgA0EwaiABEK0FQQBBADYCtIwEQYAEIANBIGogAhAPQQAoArSMBCEBQQBBADYCtIwEAkACQAJAAkACQAJAAkACQCABQQFGDQAgA0EANgIYIANCADcDEAJAIAMoAjQiASADKAIwIgRGDQACQCABIARrIgJBf0oNAEEAQQA2ArSMBEGFBCADQRBqEARBACgCtIwEIQFBAEEANgK0jAQgAUEBRg0DDAkLQQBBADYCtIwEQQsgAhAKIQFBACgCtIwEIQVBAEEANgK0jAQgBUEBRg0CIAMgATYCECADIAE2AhQgAyABIAJBAnVBAnRqIgU2AhgCQAJAIAJBAU4NACABIQUMAQsgASAEIAIQ3Q4aCyADIAU2AhQLIANBADYCCCADQgA3AwACQCADKAIkIgEgAygCICIERg0AAkAgASAEayICQX9KDQBBAEEANgK0jARBhQQgAxAEQQAoArSMBCEBQQBBADYCtIwEIAFBAUcNCQwFC0EAQQA2ArSMBEELIAIQCiEBQQAoArSMBCEFQQBBADYCtIwEIAVBAUYNBCADIAE2AgAgAyABNgIEIAMgASACQQJ1QQJ0aiIFNgIIAkACQCACQQFODQAgASEFDAELIAEgBCACEN0OGgsgAyAFNgIECyAAKAIAKAKYASEBQQBBADYCtIwEIAEgACADQRBqIAMQFkEAKAK0jAQhAUEAQQA2ArSMBCABQQFGDQICQCADKAIAIgFFDQAgAyABNgIEIAEQ0BsLAkAgAygCECIBRQ0AIAMgATYCFCABENAbCwJAIAMoAiAiAUUNACADIAE2AiQgARDQGwsCQCADKAIwIgFFDQAgAyABNgI0IAEQ0BsLIANBwABqJAAPCxAGIQEQ2g8aDAULEAYhARDaDxoMAwsQBiEBENoPGiADKAIAIgBFDQEgAyAANgIEIAAQ0BsMAQsQBiEBENoPGgsgAygCECIARQ0AIAMgADYCFCAAENAbCyADKAIgIgBFDQAgAyAANgIkIAAQ0BsLAkAgAygCMCIARQ0AIAMgADYCNCAAENAbCyABEAsACwAL1QIBAX8jAEEQayIEJAAgACgCACEAIAQgAjYCCEEAQQA2ArSMBCAEIAM2AgAgACABIARBCGogBBAWQQAoArSMBCEAQQBBADYCtIwEAkACQAJAAkACQCAAQQFGDQBBAEEANgK0jARBAiAEKAIAEARBACgCtIwEIQBBAEEANgK0jAQgAEEBRg0BQQBBADYCtIwEQQIgBCgCCBAEQQAoArSMBCEAQQBBADYCtIwEIABBAUYNAiAEQRBqJAAPCxAGIQIQ2g8aQQBBADYCtIwEQQIgBCgCABAEQQAoArSMBCEAQQBBADYCtIwEIABBAUYNAkEAQQA2ArSMBEECIAQoAggQBEEAKAK0jAQhBEEAQQA2ArSMBCAEQQFGDQMgAhALAAtBABAFGhDaDxoQ6BwAC0EAEAUaENoPGhDoHAALQQAQBRoQ2g8aEOgcAAtBABAFGhDaDxoQ6BwACxIAIAAgASAAKAIAKAKkAREBAAulBgEDfyMAQcAAayIEJAAgBEEwaiABEK0FQQBBADYCtIwEQYAEIARBIGogAhAPQQAoArSMBCEBQQBBADYCtIwEAkACQAJAAkACQAJAAkACQCABQQFGDQAgBEEANgIYIARCADcDEAJAIAQoAjQiASAEKAIwIgVGDQACQCABIAVrIgJBf0oNAEEAQQA2ArSMBEGFBCAEQRBqEARBACgCtIwEIQFBAEEANgK0jAQgAUEBRg0DDAkLQQBBADYCtIwEQQsgAhAKIQFBACgCtIwEIQZBAEEANgK0jAQgBkEBRg0CIAQgATYCECAEIAE2AhQgBCABIAJBAnVBAnRqIgY2AhgCQAJAIAJBAU4NACABIQYMAQsgASAFIAIQ3Q4aCyAEIAY2AhQLIARBADYCCCAEQgA3AwACQCAEKAIkIgEgBCgCICIFRg0AAkAgASAFayICQX9KDQBBAEEANgK0jARBhQQgBBAEQQAoArSMBCEBQQBBADYCtIwEIAFBAUcNCQwFC0EAQQA2ArSMBEELIAIQCiEBQQAoArSMBCEGQQBBADYCtIwEIAZBAUYNBCAEIAE2AgAgBCABNgIEIAQgASACQQJ1QQJ0aiIGNgIIAkACQCACQQFODQAgASEGDAELIAEgBSACEN0OGgsgBCAGNgIECyAAKAIAKAKgASEBQQBBADYCtIwEIAEgACAEQRBqIAQgAxA0QQAoArSMBCEBQQBBADYCtIwEIAFBAUYNAgJAIAQoAgAiAUUNACAEIAE2AgQgARDQGwsCQCAEKAIQIgFFDQAgBCABNgIUIAEQ0BsLAkAgBCgCICIBRQ0AIAQgATYCJCABENAbCwJAIAQoAjAiAUUNACAEIAE2AjQgARDQGwsgBEHAAGokAA8LEAYhARDaDxoMBQsQBiEBENoPGgwDCxAGIQEQ2g8aIAQoAgAiAEUNASAEIAA2AgQgABDQGwwBCxAGIQEQ2g8aCyAEKAIQIgBFDQAgBCAANgIUIAAQ0BsLIAQoAiAiAEUNACAEIAA2AiQgABDQGwsCQCAEKAIwIgBFDQAgBCAANgI0IAAQ0BsLIAEQCwALAAvXAgEBfyMAQRBrIgUkACAAKAIAIQAgBSACNgIIQQBBADYCtIwEIAUgAzYCACAAIAEgBUEIaiAFIAQQNEEAKAK0jAQhAEEAQQA2ArSMBAJAAkACQAJAAkAgAEEBRg0AQQBBADYCtIwEQQIgBSgCABAEQQAoArSMBCEAQQBBADYCtIwEIABBAUYNAUEAQQA2ArSMBEECIAUoAggQBEEAKAK0jAQhAEEAQQA2ArSMBCAAQQFGDQIgBUEQaiQADwsQBiECENoPGkEAQQA2ArSMBEECIAUoAgAQBEEAKAK0jAQhAEEAQQA2ArSMBCAAQQFGDQJBAEEANgK0jARBAiAFKAIIEARBACgCtIwEIQVBAEEANgK0jAQgBUEBRg0DIAIQCwALQQAQBRoQ2g8aEOgcAAtBABAFGhDaDxoQ6BwAC0EAEAUaENoPGhDoHAALQQAQBRoQ2g8aEOgcAAuSAQEBfyMAQRBrIgMkACADIAIQaCAAKAIAKAKwASECQQBBADYCtIwEIAIgACABIAMQFkEAKAK0jAQhAEEAQQA2ArSMBAJAIABBAUYNAAJAIAMoAgAiAEUNACAAQXxqKAIAEMoPCyADQRBqJAAPCxAGIQAQ2g8aAkAgAygCACIDRQ0AIANBfGooAgAQyg8LIAAQCwAL2AEBAX8jAEEQayIEJAAgACgCACEAQQBBADYCtIwEIAQgAzYCCCAAIAEgAiAEQQhqEBZBACgCtIwEIQBBAEEANgK0jAQCQAJAAkAgAEEBRg0AQQBBADYCtIwEQQIgBCgCCBAEQQAoArSMBCEAQQBBADYCtIwEIABBAUYNASAEQRBqJAAPCxAGIQAQ2g8aQQBBADYCtIwEQQIgBCgCCBAEQQAoArSMBCEEQQBBADYCtIwEIARBAUYNASAAEAsAC0EAEAUaENoPGhDoHAALQQAQBRoQ2g8aEOgcAAuOBAEDfyMAQTBrIgMkACADQSBqIAEQrQVBAEEANgK0jARBjwQgA0EQaiACEA9BACgCtIwEIQFBAEEANgK0jAQCQAJAAkACQAJAIAFBAUYNACADQQA2AgggA0IANwMAAkAgAygCJCIBIAMoAiAiBEYNAAJAIAEgBGsiAkF/Sg0AQQBBADYCtIwEQYUEIAMQBEEAKAK0jAQhAUEAQQA2ArSMBCABQQFGDQMAC0EAQQA2ArSMBEELIAIQCiEBQQAoArSMBCEFQQBBADYCtIwEIAVBAUYNAiADIAE2AgAgAyABNgIEIAMgASACQQJ1QQJ0aiIFNgIIAkACQCACQQFODQAgASEFDAELIAEgBCACEN0OGgsgAyAFNgIECyAAKAIAKAK0ASEBQQBBADYCtIwEIAEgACADIANBEGoQFkEAKAK0jAQhAUEAQQA2ArSMBCABQQFGDQICQCADKAIAIgFFDQAgAyABNgIEIAEQ0BsLAkAgAygCECIBRQ0AIAFBfGooAgAQyg8LAkAgAygCICIBRQ0AIAMgATYCJCABENAbCyADQTBqJAAPCxAGIQEQ2g8aDAMLEAYhARDaDxoMAQsQBiEBENoPGiADKAIAIgBFDQAgAyAANgIEIAAQ0BsLIAMoAhAiAEUNACAAQXxqKAIAEMoPCwJAIAMoAiAiAEUNACADIAA2AiQgABDQGwsgARALAAueAwEEfyMAQSBrIgIkACACQRBqIAEQrQUgAkEANgIIIAJCADcDAAJAAkACQAJAIAIoAhQiASACKAIQIgNGDQACQCABIANrIgRBf0oNAEEAQQA2ArSMBEGFBCACEARBACgCtIwEIQFBAEEANgK0jAQgAUEBRg0CAAtBAEEANgK0jARBCyAEEAohAUEAKAK0jAQhBUEAQQA2ArSMBCAFQQFGDQEgAiABNgIAIAIgATYCBCACIAEgBEECdUECdGoiBTYCCAJAAkAgBEEBTg0AIAEhBQwBCyABIAMgBBDdDhoLIAIgBTYCBAsgACgCACgCuAEhAUEAQQA2ArSMBCABIAAgAhAPQQAoArSMBCEBQQBBADYCtIwEIAFBAUYNAQJAIAIoAgAiAUUNACACIAE2AgQgARDQGwsCQCACKAIQIgFFDQAgAiABNgIUIAEQ0BsLIAJBIGokAA8LEAYhABDaDxoMAQsQBiEAENoPGiACKAIAIgFFDQAgAiABNgIEIAEQ0BsLAkAgAigCECIBRQ0AIAIgATYCFCABENAbCyAAEAsAC9YBAQF/IwBBEGsiAyQAIAAoAgAhAEEAQQA2ArSMBCADIAI2AgggACABIANBCGoQD0EAKAK0jAQhAEEAQQA2ArSMBAJAAkACQCAAQQFGDQBBAEEANgK0jARBAiADKAIIEARBACgCtIwEIQBBAEEANgK0jAQgAEEBRg0BIANBEGokAA8LEAYhABDaDxpBAEEANgK0jARBAiADKAIIEARBACgCtIwEIQNBAEEANgK0jAQgA0EBRg0BIAAQCwALQQAQBRoQ2g8aEOgcAAtBABAFGhDaDxoQ6BwAC6ADAQR/IwBBIGsiAyQAIANBEGogARCtBSADQQA2AgggA0IANwMAAkACQAJAAkAgAygCFCIBIAMoAhAiBEYNAAJAIAEgBGsiBUF/Sg0AQQBBADYCtIwEQYUEIAMQBEEAKAK0jAQhAUEAQQA2ArSMBCABQQFGDQIAC0EAQQA2ArSMBEELIAUQCiEBQQAoArSMBCEGQQBBADYCtIwEIAZBAUYNASADIAE2AgAgAyABNgIEIAMgASAFQQJ1QQJ0aiIGNgIIAkACQCAFQQFODQAgASEGDAELIAEgBCAFEN0OGgsgAyAGNgIECyAAKAIAKAK8ASEBQQBBADYCtIwEIAEgACADIAIQFkEAKAK0jAQhAUEAQQA2ArSMBCABQQFGDQECQCADKAIAIgFFDQAgAyABNgIEIAEQ0BsLAkAgAygCECIBRQ0AIAMgATYCFCABENAbCyADQSBqJAAPCxAGIQAQ2g8aDAELEAYhABDaDxogAygCACIBRQ0AIAMgATYCBCABENAbCwJAIAMoAhAiAUUNACADIAE2AhQgARDQGwsgABALAAvYAQEBfyMAQRBrIgQkACAAKAIAIQBBAEEANgK0jAQgBCACNgIIIAAgASAEQQhqIAMQFkEAKAK0jAQhAEEAQQA2ArSMBAJAAkACQCAAQQFGDQBBAEEANgK0jARBAiAEKAIIEARBACgCtIwEIQBBAEEANgK0jAQgAEEBRg0BIARBEGokAA8LEAYhABDaDxpBAEEANgK0jARBAiAEKAIIEARBACgCtIwEIQRBAEEANgK0jAQgBEEBRg0BIAAQCwALQQAQBRoQ2g8aEOgcAAtBABAFGhDaDxoQ6BwACz0BAX8gASAAKAIEIgRBAXVqIQEgACgCACEAAkAgBEEBcUUNACABKAIAIABqKAIAIQALIAEgAiADIAAREAALpgIBAn8jAEEQayICJAAgAiABIAEoAgAoAsABEQEAQQBBADYCtIwEQYIEIAAgAhAPQQAoArSMBCEBQQBBADYCtIwEAkACQAJAIAFBAUYNAEEAQQA2ArSMBEGDBCACKAIMIgFBCGoQBEEAKAK0jAQhAEEAQQA2ArSMBCAAQQFGDQEgASgCBBDQGyABENAbAkAgAiwAC0F/Sg0AIAIoAgAQ0BsLIAJBEGokAA8LEAYhAxDaDxpBAEEANgK0jARBgwQgAigCDCIAQQhqEARBACgCtIwEIQFBAEEANgK0jAQgAUEBRg0BIAAoAgQQ0BsgABDQGwJAIAIsAAtBf0oNACACKAIAENAbCyADEAsAC0EAEAUaENoPGhDoHAALQQAQBRoQ2g8aEOgcAAtzAQR/IwBBEGsiAiQAIAIgASAAKAIAEQEAIAIoAgQgAi0ACyIAIABBGHRBGHUiA0EASCIEGyIAQQRqEMkPIgEgADYCACABQQRqIAIoAgAiBSACIAQbIAAQ3Q4aAkAgA0F/Sg0AIAUQ0BsLIAJBEGokACABCw0AIAAoAgBBfGooAgALBAAgAAsEACAACxcAAkAgAEUNACAAIAAoAgAoAgQRAwALCykBAX8jAEEQayICJAAgAiABNgIMIAJBDGogABEAACEBIAJBEGokACABC1cBAn9BNBDOGyEBIAAoAgAhAEEAQQA2ArSMBEGYBCABIAAQAiECQQAoArSMBCEAQQBBADYCtIwEAkAgAEEBRg0AIAIPCxAGIQAQ2g8aIAEQ0BsgABALAAs5AQF/IAEgACgCBCICQQF1aiEBIAAoAgAhAAJAIAJBAXFFDQAgASgCACAAaigCACEACyABIAARAAALOwEBfyABIAAoAgQiA0EBdWohASAAKAIAIQACQCADQQFxRQ0AIAEoAgAgAGooAgAhAAsgASACIAARAQALPQEBfyABIAAoAgQiBEEBdWohASAAKAIAIQACQCAEQQFxRQ0AIAEoAgAgAGooAgAhAAsgASACIAMgABEEAAs9AQF/IAEgACgCBCIEQQF1aiEBIAAoAgAhAAJAIARBAXFFDQAgASgCACAAaigCACEACyABIAIgAyAAERAAC6UGAQN/IwBBwABrIgQkACAEQTBqIAEQrQVBAEEANgK0jARBgAQgBEEgaiACEA9BACgCtIwEIQFBAEEANgK0jAQCQAJAAkACQAJAAkACQAJAIAFBAUYNACAEQQA2AhggBEIANwMQAkAgBCgCNCIBIAQoAjAiBUYNAAJAIAEgBWsiAkF/Sg0AQQBBADYCtIwEQYUEIARBEGoQBEEAKAK0jAQhAUEAQQA2ArSMBCABQQFGDQMMCQtBAEEANgK0jARBCyACEAohAUEAKAK0jAQhBkEAQQA2ArSMBCAGQQFGDQIgBCABNgIQIAQgATYCFCAEIAEgAkECdUECdGoiBjYCGAJAAkAgAkEBTg0AIAEhBgwBCyABIAUgAhDdDhoLIAQgBjYCFAsgBEEANgIIIARCADcDAAJAIAQoAiQiASAEKAIgIgVGDQACQCABIAVrIgJBf0oNAEEAQQA2ArSMBEGFBCAEEARBACgCtIwEIQFBAEEANgK0jAQgAUEBRw0JDAULQQBBADYCtIwEQQsgAhAKIQFBACgCtIwEIQZBAEEANgK0jAQgBkEBRg0EIAQgATYCACAEIAE2AgQgBCABIAJBAnVBAnRqIgY2AggCQAJAIAJBAU4NACABIQYMAQsgASAFIAIQ3Q4aCyAEIAY2AgQLIAAoAgAoAvgBIQFBAEEANgK0jAQgASAAIARBEGogBCADEDRBACgCtIwEIQFBAEEANgK0jAQgAUEBRg0CAkAgBCgCACIBRQ0AIAQgATYCBCABENAbCwJAIAQoAhAiAUUNACAEIAE2AhQgARDQGwsCQCAEKAIgIgFFDQAgBCABNgIkIAEQ0BsLAkAgBCgCMCIBRQ0AIAQgATYCNCABENAbCyAEQcAAaiQADwsQBiEBENoPGgwFCxAGIQEQ2g8aDAMLEAYhARDaDxogBCgCACIARQ0BIAQgADYCBCAAENAbDAELEAYhARDaDxoLIAQoAhAiAEUNACAEIAA2AhQgABDQGwsgBCgCICIARQ0AIAQgADYCJCAAENAbCwJAIAQoAjAiAEUNACAEIAA2AjQgABDQGwsgARALAAsAC9cCAQF/IwBBEGsiBSQAIAAoAgAhACAFIAI2AghBAEEANgK0jAQgBSADNgIAIAAgASAFQQhqIAUgBBA0QQAoArSMBCEAQQBBADYCtIwEAkACQAJAAkACQCAAQQFGDQBBAEEANgK0jARBAiAFKAIAEARBACgCtIwEIQBBAEEANgK0jAQgAEEBRg0BQQBBADYCtIwEQQIgBSgCCBAEQQAoArSMBCEAQQBBADYCtIwEIABBAUYNAiAFQRBqJAAPCxAGIQIQ2g8aQQBBADYCtIwEQQIgBSgCABAEQQAoArSMBCEAQQBBADYCtIwEIABBAUYNAkEAQQA2ArSMBEECIAUoAggQBEEAKAK0jAQhBUEAQQA2ArSMBCAFQQFGDQMgAhALAAtBABAFGhDaDxoQ6BwAC0EAEAUaENoPGhDoHAALQQAQBRoQ2g8aEOgcAAtBABAFGhDaDxoQ6BwACzkBAX8gASAAKAIEIgJBAXVqIQEgACgCACEAAkAgAkEBcUUNACABKAIAIABqKAIAIQALIAEgABEAAAs7AQF/IAEgACgCBCIDQQF1aiEBIAAoAgAhAAJAIANBAXFFDQAgASgCACAAaigCACEACyABIAIgABEWAAs7AQF/IAEgACgCBCIDQQF1aiEBIAAoAgAhAAJAIANBAXFFDQAgASgCACAAaigCACEACyABIAIgABECAAs7AQF/IAEgACgCBCIDQQF1aiEBIAAoAgAhAAJAIANBAXFFDQAgASgCACAAaigCACEACyABIAIgABEBAAu9AQECfyMAQRBrIgMkACABIAAoAgQiBEEBdWohASAAKAIAIQACQCAEQQFxRQ0AIAEoAgAgAGooAgAhAAsgAyABIAIgABEEAEEAQQA2ArSMBEGZBCADEAohAUEAKAK0jAQhAEEAQQA2ArSMBAJAIABBAUYNAAJAIAMoAgAiAEUNACADIAA2AgQgABDQGwsgA0EQaiQAIAEPCxAGIQEQ2g8aAkAgAygCACIARQ0AIAMgADYCBCAAENAbCyABEAsAC70BAQJ/IwBBEGsiAyQAIAEgACgCBCIEQQF1aiEBIAAoAgAhAAJAIARBAXFFDQAgASgCACAAaigCACEACyADIAEgAiAAEQQAQQBBADYCtIwEQZkEIAMQCiEBQQAoArSMBCEAQQBBADYCtIwEAkAgAEEBRg0AAkAgAygCACIARQ0AIAMgADYCBCAAENAbCyADQRBqJAAgAQ8LEAYhARDaDxoCQCADKAIAIgBFDQAgAyAANgIEIAAQ0BsLIAEQCwALpgIBAn8jAEEQayICJAAgAiABIAEoAgAoAsABEQEAQQBBADYCtIwEQYIEIAAgAhAPQQAoArSMBCEBQQBBADYCtIwEAkACQAJAIAFBAUYNAEEAQQA2ArSMBEGDBCACKAIMIgFBCGoQBEEAKAK0jAQhAEEAQQA2ArSMBCAAQQFGDQEgASgCBBDQGyABENAbAkAgAiwAC0F/Sg0AIAIoAgAQ0BsLIAJBEGokAA8LEAYhAxDaDxpBAEEANgK0jARBgwQgAigCDCIAQQhqEARBACgCtIwEIQFBAEEANgK0jAQgAUEBRg0BIAAoAgQQ0BsgABDQGwJAIAIsAAtBf0oNACACKAIAENAbCyADEAsAC0EAEAUaENoPGhDoHAALQQAQBRoQ2g8aEOgcAAsNACAAKAIAQXxqKAIACxcAAkAgAEUNACAAIAAoAgAoAgQRAwALCykBAX8jAEEQayICJAAgAiABNgIMIAJBDGogABEAACEBIAJBEGokACABC1gBAn9BkBQQzhshASAAKAIAIQBBAEEANgK0jARBmgQgASAAEAIhAkEAKAK0jAQhAEEAQQA2ArSMBAJAIABBAUYNACACDwsQBiEAENoPGiABENAbIAAQCwALOQEBfyABIAAoAgQiAkEBdWohASAAKAIAIQACQCACQQFxRQ0AIAEoAgAgAGooAgAhAAsgASAAEQAACzsBAX8gASAAKAIEIgNBAXVqIQEgACgCACEAAkAgA0EBcUUNACABKAIAIABqKAIAIQALIAEgAiAAEQIACzkBAX8gASAAKAIEIgJBAXVqIQEgACgCACEAAkAgAkEBcUUNACABKAIAIABqKAIAIQALIAEgABEAAAsNACAAIAEgAiADEOELCxIAIAEgAiADIAQgACgCABEGAAs4AQF/IwBBEGsiBCQAIAQgASACIAMgASgCACgCRBEGACAAIAQrAwAgBCsDCBAZNgIAIARBEGokAAvdAQEBfyMAQRBrIgQkACAEQQhqIAEgAiADIAAoAgARBgBBAEEANgK0jARBByAEKAIIEARBACgCtIwEIQBBAEEANgK0jAQCQAJAAkAgAEEBRg0AQQBBADYCtIwEQQIgBCgCCCIDEARBACgCtIwEIQBBAEEANgK0jAQgAEEBRg0BIARBEGokACADDwsQBiEAENoPGkEAQQA2ArSMBEECIAQoAggQBEEAKAK0jAQhBEEAQQA2ArSMBCAEQQFGDQEgABALAAtBABAFGhDaDxoQ6BwAC0EAEAUaENoPGhDoHAALEQAgACABIAAoAgAoAgwRAQALDgAgASACIAAoAgARAQAL+wIBAX8jAEHQAGsiAyQAIANBwABqIAEQXiADQTBqIAIQ+AUgA0EgakEIaiADQcAAakEIaikDADcDACADIAMpA0A3AyACQAJAAkACQAJAIAMsADtBAEgNACADQRBqQQhqIANBMGpBCGooAgA2AgAgAyADKQMwNwMQDAELQQBBADYCtIwEQZsEIANBEGogAygCMCADKAI0EBZBACgCtIwEIQFBAEEANgK0jAQgAUEBRg0BCyAAKAIAKAIYIQEgA0EIaiADQSBqQQhqKQMANwMAQQBBADYCtIwEIAMgAykDIDcDACABIAAgAyADQRBqEBZBACgCtIwEIQBBAEEANgK0jAQgAEEBRg0BAkAgAywAG0F/Sg0AIAMoAhAQ0BsLAkAgAywAO0F/Sg0AIAMoAjAQ0BsLIANB0ABqJAAPCxAGIQAQ2g8aDAELEAYhABDaDxogAywAG0F/Sg0AIAMoAhAQ0BsLAkAgAywAO0F/Sg0AIAMoAjAQ0BsLIAAQCwAL1QIBAX8jAEEQayIEJAAgACgCACEAIAQgAjYCCEEAQQA2ArSMBCAEIAM2AgAgACABIARBCGogBBAWQQAoArSMBCEAQQBBADYCtIwEAkACQAJAAkACQCAAQQFGDQBBAEEANgK0jARBAiAEKAIAEARBACgCtIwEIQBBAEEANgK0jAQgAEEBRg0BQQBBADYCtIwEQQIgBCgCCBAEQQAoArSMBCEAQQBBADYCtIwEIABBAUYNAiAEQRBqJAAPCxAGIQIQ2g8aQQBBADYCtIwEQQIgBCgCABAEQQAoArSMBCEAQQBBADYCtIwEIABBAUYNAkEAQQA2ArSMBEECIAQoAggQBEEAKAK0jAQhBEEAQQA2ArSMBCAEQQFGDQMgAhALAAtBABAFGhDaDxoQ6BwAC0EAEAUaENoPGhDoHAALQQAQBRoQ2g8aEOgcAAtBABAFGhDaDxoQ6BwAC9gCAQF/IwBBwABrIgQkACAEQTBqIAEQrQVBAEEANgK0jARBgAQgBEEgaiACEA9BACgCtIwEIQFBAEEANgK0jAQCQAJAAkAgAUEBRg0AQQBBADYCtIwEQQggBEEQaiADEA9BACgCtIwEIQFBAEEANgK0jAQgAUEBRg0BIAAoAgAoAhwhASAEQQhqIARBEGpBCGopAwA3AwBBAEEANgK0jAQgBCAEKQMQNwMAIAEgACAEQTBqIARBIGogBBATQQAoArSMBCEAQQBBADYCtIwEIABBAUYNAQJAIAQoAiAiAEUNACAEIAA2AiQgABDQGwsCQCAEKAIwIgBFDQAgBCAANgI0IAAQ0BsLIARBwABqJAAPCxAGIQEQ2g8aDAELEAYhARDaDxogBCgCICIARQ0AIAQgADYCJCAAENAbCwJAIAQoAjAiAEUNACAEIAA2AjQgABDQGwsgARALAAvaAwEBfyMAQSBrIgUkACAAKAIAIQAgBSACNgIYIAUgAzYCEEEAQQA2ArSMBCAFIAQ2AgggACABIAVBGGogBUEQaiAFQQhqEBNBACgCtIwEIQBBAEEANgK0jAQCQAJAAkACQAJAAkACQCAAQQFGDQBBAEEANgK0jARBAiAFKAIIEARBACgCtIwEIQBBAEEANgK0jAQgAEEBRg0BQQBBADYCtIwEQQIgBSgCEBAEQQAoArSMBCEAQQBBADYCtIwEIABBAUYNAkEAQQA2ArSMBEECIAUoAhgQBEEAKAK0jAQhAEEAQQA2ArSMBCAAQQFGDQMgBUEgaiQADwsQBiECENoPGkEAQQA2ArSMBEECIAUoAggQBEEAKAK0jAQhAEEAQQA2ArSMBCAAQQFGDQNBAEEANgK0jARBAiAFKAIQEARBACgCtIwEIQBBAEEANgK0jAQgAEEBRg0EQQBBADYCtIwEQQIgBSgCGBAEQQAoArSMBCEFQQBBADYCtIwEIAVBAUYNBSACEAsAC0EAEAUaENoPGhDoHAALQQAQBRoQ2g8aEOgcAAtBABAFGhDaDxoQ6BwAC0EAEAUaENoPGhDoHAALQQAQBRoQ2g8aEOgcAAtBABAFGhDaDxoQ6BwACzYBAX8jAEEQayIDJAAgAyABIAIgASgCACgCPBEEACAAIAMrAwAgAysDCBAZNgIAIANBEGokAAvbAQEBfyMAQRBrIgMkACADQQhqIAEgAiAAKAIAEQQAQQBBADYCtIwEQQcgAygCCBAEQQAoArSMBCEAQQBBADYCtIwEAkACQAJAIABBAUYNAEEAQQA2ArSMBEECIAMoAggiAhAEQQAoArSMBCEAQQBBADYCtIwEIABBAUYNASADQRBqJAAgAg8LEAYhABDaDxpBAEEANgK0jARBAiADKAIIEARBACgCtIwEIQNBAEEANgK0jAQgA0EBRg0BIAAQCwALQQAQBRoQ2g8aEOgcAAtBABAFGhDaDxoQ6BwAC6UCAQJ/IwBBEGsiAiQAIAIgASABKAIAKAJUEQEAQQBBADYCtIwEQYIEIAAgAhAPQQAoArSMBCEBQQBBADYCtIwEAkACQAJAIAFBAUYNAEEAQQA2ArSMBEGDBCACKAIMIgFBCGoQBEEAKAK0jAQhAEEAQQA2ArSMBCAAQQFGDQEgASgCBBDQGyABENAbAkAgAiwAC0F/Sg0AIAIoAgAQ0BsLIAJBEGokAA8LEAYhAxDaDxpBAEEANgK0jARBgwQgAigCDCIAQQhqEARBACgCtIwEIQFBAEEANgK0jAQgAUEBRg0BIAAoAgQQ0BsgABDQGwJAIAIsAAtBf0oNACACKAIAENAbCyADEAsAC0EAEAUaENoPGhDoHAALQQAQBRoQ2g8aEOgcAAtzAQR/IwBBEGsiAiQAIAIgASAAKAIAEQEAIAIoAgQgAi0ACyIAIABBGHRBGHUiA0EASCIEGyIAQQRqEMkPIgEgADYCACABQQRqIAIoAgAiBSACIAQbIAAQ3Q4aAkAgA0F/Sg0AIAUQ0BsLIAJBEGokACABCw0AIAAoAgBBfGooAgALBAAgAAsEACAACxcAAkAgAEUNACAAIAAoAgAoAgQRAwALCykBAX8jAEEQayICJAAgAiABNgIMIAJBDGogABEAACEBIAJBEGokACABC2QBAn9BkBQQzhshASAAKAIAIQBBAEEANgK0jARBmgQgASAAEAIhAEEAKAK0jAQhAkEAQQA2ArSMBAJAIAJBAUYNACAAQbTvA0EIajYCACAADwsQBiEAENoPGiABENAbIAAQCwALDQAgACgCAEF8aigCAAsXAAJAIABFDQAgACAAKAIAKAIQEQMACwsHACAAEQoAC2oBAX9BwAAQzhsiAEKAgICAgICA+D83AxAgAEIANwIEIABBoPADQQhqNgIAIABBGGpCADcDACAAQQxqQQA2AgAgAEEgakIANwMAIABBKGpCADcDACAAQTBqQgA3AwAgAEE4akIANwMAIAAL6AIBAn8jAEHQAGsiAiQAIAIgATYCCEEAQQA2ArSMBCAAIAJBEGogAkEIahAPQQAoArSMBCEBQQBBADYCtIwEAkACQAJAAkACQAJAIAFBAUYNAEEAQQA2ArSMBEELQcAAEAohAUEAKAK0jAQhAEEAQQA2ArSMBCAAQQFGDQFBAEEANgK0jARBnAQgASACQRBqEAIhA0EAKAK0jAQhAEEAQQA2ArSMBAJAIABBAUcNABAGIQAQ2g8aIAEQ0BsMAwsgAkEQahCcBBpBAEEANgK0jARBAiACKAIIEARBACgCtIwEIQFBAEEANgK0jAQgAUEBRg0EIAJB0ABqJAAgAw8LEAYhABDaDxoMAgsQBiEAENoPGgsgAkEQahCcBBoLQQBBADYCtIwEQQIgAigCCBAEQQAoArSMBCECQQBBADYCtIwEIAJBAUYNASAAEAsAC0EAEAUaENoPGhDoHAALQQAQBRoQ2g8aEOgcAAt2AQF/IwBBEGsiAiQAIAIgARBeIABBGGogAkEIaikDADcDACAAIAIpAwA3AxAgAEIANwMgIABBDGpBADYCACAAQgA3AgQgAEGg8ANBCGo2AgAgAEEoakIANwMAIABBMGpCADcDACAAQThqQgA3AwAgAkEQaiQAC5UEAQR/IwBB4ABrIgMkAAJAAkACQCABKAIAIgRBcE8NAAJAAkAgBEEKSw0AIAMgBDoAGyADQRBqIQUMAQsgBEEPckEBaiIGEM4bIQUgAyAGQYCAgIB4cjYCGCADIAU2AhAgAyAENgIUCwJAIARFDQAgBSABQQRqIAQQ3Q4aCyAFIARqQQA6AABBAEEANgK0jAQgAyACNgIIIAAgA0EgaiADQRBqIANBCGoQFkEAKAK0jAQhBEEAQQA2ArSMBAJAAkACQAJAIARBAUYNAEEAQQA2ArSMBEELQcAAEAohBUEAKAK0jAQhBEEAQQA2ArSMBCAEQQFGDQFBAEEANgK0jARBnAQgBSADQSBqEAIhAUEAKAK0jAQhBEEAQQA2ArSMBAJAIARBAUcNABAGIQEQ2g8aIAUQ0BsMAwsgA0EgahCcBBpBAEEANgK0jARBAiADKAIIEARBACgCtIwEIQRBAEEANgK0jAQgBEEBRg0FAkAgAywAG0F/Sg0AIAMoAhAQ0BsLIANB4ABqJAAgAQ8LEAYhARDaDxoMAgsQBiEBENoPGgsgA0EgahCcBBoLQQBBADYCtIwEQQIgAygCCBAEQQAoArSMBCEEQQBBADYCtIwEIARBAUYNAgJAIAMsABtBf0oNACADKAIQENAbCyABEAsACyADQRBqEHYAC0EAEAUaENoPGhDoHAALQQAQBRoQ2g8aEOgcAAvnAQEBfyMAQTBrIgMkACADQSBqIAIQXgJAAkAgASwAC0EASA0AIANBEGpBCGogAUEIaigCADYCACADIAEpAgA3AxAMAQsgA0EQaiABKAIAIAEoAgQQ+hsLIANBCGogA0EgakEIaikDADcDAEEAQQA2ArSMBCADIAMpAyA3AwBBnQQgACADQRBqIAMQJhpBACgCtIwEIQFBAEEANgK0jAQCQCABQQFGDQACQCADLAAbQX9KDQAgAygCEBDQGwsgA0EwaiQADwsQBiEBENoPGgJAIAMsABtBf0oNACADKAIQENAbCyABEAsACz0BAX8gASAAKAIEIgRBAXVqIQEgACgCACEAAkAgBEEBcUUNACABKAIAIABqKAIAIQALIAEgAiADIAARBAALvQEBA38jAEEQayICJAAgAEEANgIIIABCADcCACABQQhqKAIAIQMgASgCBCEBIAIgADYCCAJAAkAgASADRg0AA0AgASgCACEEQQBBADYCtIwEIAIgBDYCBEGeBCACQQhqIAJBBGoQAhpBACgCtIwEIQRBAEEANgK0jAQgBEEBRg0CIAFBCGoiASADRw0ACwsgAkEQaiQADwsQBiECENoPGgJAIAAoAgAiAUUNACAAIAE2AgQgARDQGwsgAhALAAu7AQECfyMAQRBrIgIkACABIAAoAgQiA0EBdWohASAAKAIAIQACQCADQQFxRQ0AIAEoAgAgAGooAgAhAAsgAiABIAARAQBBAEEANgK0jARBhwQgAhAKIQFBACgCtIwEIQBBAEEANgK0jAQCQCAAQQFGDQACQCACKAIAIgBFDQAgAiAANgIEIAAQ0BsLIAJBEGokACABDwsQBiEBENoPGgJAIAIoAgAiAEUNACACIAA2AgQgABDQGwsgARALAAu9AQEDfyMAQRBrIgIkACAAQQA2AgggAEIANwIAIAFBCGooAgAhAyABKAIEIQEgAiAANgIIAkACQCABIANGDQADQCABKAIEIQRBAEEANgK0jAQgAiAENgIEQZ4EIAJBCGogAkEEahACGkEAKAK0jAQhBEEAQQA2ArSMBCAEQQFGDQIgAUEIaiIBIANHDQALCyACQRBqJAAPCxAGIQIQ2g8aAkAgACgCACIBRQ0AIAAgATYCBCABENAbCyACEAsACzQBAX8jAEEQayICJAAgAiABIAEoAgAoAgARAQAgACACKwMAIAIrAwgQGTYCACACQRBqJAAL2QEBAX8jAEEQayICJAAgAkEIaiABIAAoAgARAQBBAEEANgK0jARBByACKAIIEARBACgCtIwEIQBBAEEANgK0jAQCQAJAAkAgAEEBRg0AQQBBADYCtIwEQQIgAigCCCIBEARBACgCtIwEIQBBAEEANgK0jAQgAEEBRg0BIAJBEGokACABDwsQBiEAENoPGkEAQQA2ArSMBEECIAIoAggQBEEAKAK0jAQhAkEAQQA2ArSMBCACQQFGDQEgABALAAtBABAFGhDaDxoQ6BwAC0EAEAUaENoPGhDoHAALOQEBfyABIAAoAgQiAkEBdWohASAAKAIAIQACQCACQQFxRQ0AIAEoAgAgAGooAgAhAAsgASAAEQAAC00BAX8jAEEgayICJAAgAkEQaiABEF4gACgCACgCKCEBIAJBCGogAkEQakEIaikDADcDACACIAIpAxA3AwAgACACIAERAQAgAkEgaiQAC9YBAQF/IwBBEGsiAyQAIAAoAgAhAEEAQQA2ArSMBCADIAI2AgggACABIANBCGoQD0EAKAK0jAQhAEEAQQA2ArSMBAJAAkACQCAAQQFGDQBBAEEANgK0jARBAiADKAIIEARBACgCtIwEIQBBAEEANgK0jAQgAEEBRg0BIANBEGokAA8LEAYhABDaDxpBAEEANgK0jARBAiADKAIIEARBACgCtIwEIQNBAEEANgK0jAQgA0EBRg0BIAAQCwALQQAQBRoQ2g8aEOgcAAtBABAFGhDaDxoQ6BwAC54BAQR/IwBBEGsiAiQAIAEgACgCBCIDQQF1aiEBIAAoAgAhAAJAIANBAXFFDQAgASgCACAAaigCACEACyACIAEgABEBACACKAIEIAItAAsiACAAQRh0QRh1IgNBAEgiBBsiAEEEahDJDyIBIAA2AgAgAUEEaiACKAIAIgUgAiAEGyAAEN0OGgJAIANBf0oNACAFENAbCyACQRBqJAAgAQs2AQF/IwBBEGsiAyQAIAMgASACIAEoAgAoAhgRBAAgACADKwMAIAMrAwgQGTYCACADQRBqJAAL2wEBAX8jAEEQayIDJAAgA0EIaiABIAIgACgCABEEAEEAQQA2ArSMBEEHIAMoAggQBEEAKAK0jAQhAEEAQQA2ArSMBAJAAkACQCAAQQFGDQBBAEEANgK0jARBAiADKAIIIgIQBEEAKAK0jAQhAEEAQQA2ArSMBCAAQQFGDQEgA0EQaiQAIAIPCxAGIQAQ2g8aQQBBADYCtIwEQQIgAygCCBAEQQAoArSMBCEDQQBBADYCtIwEIANBAUYNASAAEAsAC0EAEAUaENoPGhDoHAALQQAQBRoQ2g8aEOgcAAs4AQF/IwBBEGsiBCQAIAQgASACIAMgASgCACgCIBEGACAAIAQrAwAgBCsDCBAZNgIAIARBEGokAAvdAQEBfyMAQRBrIgQkACAEQQhqIAEgAiADIAAoAgARBgBBAEEANgK0jARBByAEKAIIEARBACgCtIwEIQBBAEEANgK0jAQCQAJAAkAgAEEBRg0AQQBBADYCtIwEQQIgBCgCCCIDEARBACgCtIwEIQBBAEEANgK0jAQgAEEBRg0BIARBEGokACADDwsQBiEAENoPGkEAQQA2ArSMBEECIAQoAggQBEEAKAK0jAQhBEEAQQA2ArSMBCAEQQFGDQEgABALAAtBABAFGhDaDxoQ6BwAC0EAEAUaENoPGhDoHAALDQAgACgCAEF8aigCAAsXAAJAIABFDQAgACAAKAIAKAIEEQMACwsHACAAEQoACxcBAX9BCBDOGyIAQYDnAUEIajYCACAACz0BAX8gASAAKAIEIgRBAXVqIQEgACgCACEAAkAgBEEBcUUNACABKAIAIABqKAIAIQALIAEgAiADIAARBAALOwEBfyABIAAoAgQiA0EBdWohASAAKAIAIQACQCADQQFxRQ0AIAEoAgAgAGooAgAhAAsgASACIAARAQALOwEBfyABIAAoAgQiA0EBdWohASAAKAIAIQACQCADQQFxRQ0AIAEoAgAgAGooAgAhAAsgASACIAARAgALBgBBzOcBCw8AAkAgAEUNACAAENAbCwsHACAAEQoACwcAQQEQzhsLlAEBAX8jAEEQayIEJAAgBCABIAIgAxCpBkEAQQA2ArSMBEGfBCAEEAohAkEAKAK0jAQhA0EAQQA2ArSMBAJAIANBAUYNACAAIAI2AgACQCAEKAIAIgNFDQAgBCADNgIEIAMQ0BsLIARBEGokAA8LEAYhAhDaDxoCQCAEKAIAIgNFDQAgBCADNgIEIAMQ0BsLIAIQCwAL3QEBAX8jAEEQayIEJAAgBEEIaiABIAIgAyAAKAIAEQYAQQBBADYCtIwEQQcgBCgCCBAEQQAoArSMBCEAQQBBADYCtIwEAkACQAJAIABBAUYNAEEAQQA2ArSMBEECIAQoAggiAxAEQQAoArSMBCEAQQBBADYCtIwEIABBAUYNASAEQRBqJAAgAw8LEAYhABDaDxpBAEEANgK0jARBAiAEKAIIEARBACgCtIwEIQRBAEEANgK0jAQgBEEBRg0BIAAQCwALQQAQBRoQ2g8aEOgcAAtBABAFGhDaDxoQ6BwAC44EAQR/IwBBMGsiBSQAIAVBIGogBBD+BSAFQQA2AgggBUIANwMAAkACQAJAAkACQCAFKAIkIgQgBSgCICIGRg0AAkAgBCAGayIHQX9KDQBBAEEANgK0jARBoAQgBRAEQQAoArSMBCEEQQBBADYCtIwEIARBAUYNAgALQQBBADYCtIwEQQsgBxAKIQRBACgCtIwEIQhBAEEANgK0jAQgCEEBRg0BIAUgBDYCACAFIAQ2AgQgBSAEIAdBA3VBA3RqIgg2AggCQAJAIAdBAU4NACAEIQgMAQsgBCAGIAcQ3Q4aCyAFIAg2AgQLQQBBADYCtIwEQaEEIAVBEGogASACIAMgBRA1QQAoArSMBCEEQQBBADYCtIwEIARBAUYNAQJAIAUoAgAiBEUNACAFIAQ2AgQgBBDQGwtBAEEANgK0jARBnwQgBUEQahAKIQdBACgCtIwEIQRBAEEANgK0jAQgBEEBRg0CIAAgBzYCAAJAIAUoAhAiBEUNACAFIAQ2AhQgBBDQGwsCQCAFKAIgIgRFDQAgBSAENgIkIAQQ0BsLIAVBMGokAA8LEAYhBBDaDxoMAgsQBiEEENoPGiAFKAIAIgdFDQEgBSAHNgIEIAcQ0BsMAQsQBiEEENoPGiAFKAIQIgdFDQAgBSAHNgIUIAcQ0BsLAkAgBSgCICIHRQ0AIAUgBzYCJCAHENAbCyAEEAsAC4wDAQF/IwBBEGsiBSQAIAAoAgAhAEEAQQA2ArSMBCAFIAQ2AgAgACAFQQhqIAEgAiADIAUQNUEAKAK0jAQhAEEAQQA2ArSMBAJAAkACQAJAAkAgAEEBRg0AQQBBADYCtIwEQQcgBSgCCBAEQQAoArSMBCEAQQBBADYCtIwEAkAgAEEBRg0AQQBBADYCtIwEQQIgBSgCCCIEEARBACgCtIwEIQBBAEEANgK0jAQgAEEBRg0DQQBBADYCtIwEQQIgBSgCABAEQQAoArSMBCEAQQBBADYCtIwEIABBAUYNBCAFQRBqJAAgBA8LEAYhABDaDxpBAEEANgK0jARBAiAFKAIIEARBACgCtIwEIQRBAEEANgK0jAQgBEEBRw0BQQAQBRoQ2g8aEOgcAAsQBiEAENoPGgtBAEEANgK0jARBAiAFKAIAEARBACgCtIwEIQVBAEEANgK0jAQgBUEBRg0CIAAQCwALQQAQBRoQ2g8aEOgcAAtBABAFGhDaDxoQ6BwAC0EAEAUaENoPGhDoHAALBgBB6OgBCxIAAkAgAEUNACAAEMwMENAbCws1AQF/IwBBEGsiAyQAIAMgATYCDCADIAI2AgggA0EMaiADQQhqIAARAgAhASADQRBqJAAgAQtgAQF/QRAQzhshAiABKAIAIQEgACgCACEAQQBBADYCtIwEQaIEIAIgACABECYhAEEAKAK0jAQhAUEAQQA2ArSMBAJAIAFBAUYNACAADwsQBiEBENoPGiACENAbIAEQCwALCgAgACABrBDNDAsOACABIAIgACgCABEBAAs5AQF/IAEgACgCBCICQQF1aiEBIAAoAgAhAAJAIAJBAXFFDQAgASgCACAAaigCACEACyABIAARAwALOwEBfyABIAAoAgQiA0EBdWohASAAKAIAIQACQCADQQFxRQ0AIAEoAgAgAGooAgAhAAsgASACIAARAQALPQEBfyABIAAoAgQiBEEBdWohASAAKAIAIQACQCAEQQFxRQ0AIAEoAgAgAGooAgAhAAsgASACIAMgABEEAAsuAQF/IwBBEGsiAyQAIAMgASACENIMIAAgAysDACADKwMIEBk2AgAgA0EQaiQAC9sBAQF/IwBBEGsiAyQAIANBCGogASACIAAoAgARBABBAEEANgK0jARBByADKAIIEARBACgCtIwEIQBBAEEANgK0jAQCQAJAAkAgAEEBRg0AQQBBADYCtIwEQQIgAygCCCICEARBACgCtIwEIQBBAEEANgK0jAQgAEEBRg0BIANBEGokACACDwsQBiEAENoPGkEAQQA2ArSMBEECIAMoAggQBEEAKAK0jAQhA0EAQQA2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Rg0AIAAoAgQQ0BsgABDQGwJAIAEsADtBf0oNACABKAIwENAbCyADEAsAC0EAEAUaENoPGhDoHAAL8wEBBH8jAEEQayICJAACQCABKAIAIgNBcE8NAAJAAkAgA0EKSw0AIAIgAzoACyACIQQMAQsgA0EPckEBaiIFEM4bIQQgAiAFQYCAgIB4cjYCCCACIAQ2AgAgAiADNgIECwJAIANFDQAgBCABQQRqIAMQ3Q4aCyAEIANqQQA6AABBAEEANgK0jAQgACACEAohBEEAKAK0jAQhA0EAQQA2ArSMBAJAIANBAUYNAAJAIAIsAAtBf0oNACACKAIAENAbCyACQRBqJAAgBA8LEAYhAxDaDxoCQCACLAALQX9KDQAgAigCABDQGwsgAxALAAsgAhB2AAsJACABIAARAAALBAAgAAsJACABIAARAAALBAAgAAsGAEHUqQELDwACQCAARQ0AIAAQ0BsLCwcAIAARCgALHAEBf0EQEM4bIgBCADcDACAAQQhqQgA3AwAgAAsuAQF/IwBBEGsiAiQAIAIgASsDADkDCCAAQajVAyACQQhqEBE2AgAgAkEQaiQACw4AIAAgASsDADkDAEEBC9kBAQF/IwBBEGsiAiQAIAJBCGogASAAKAIAEQEAQQBBADYCtIwEQQcgAigCCBAEQQAoArSMBCEAQQBBADYCtIwEAkACQAJAIABBAUYNAEEAQQA2ArSMBEECIAIoAggiARAEQQAoArSMBCEAQQBBADYCtIwEIABBAUYNASACQRBqJAAgAQ8LEAYhABDaDxpBAEEANgK0jARBAiACKAIIEARBACgCtIwEIQJBAEEANgK0jAQgAkEBRg0BIAAQCwALQQAQBRoQ2g8aEOgcAAtBABAFGhDaDxoQ6BwACy8BAX8jAEEQayIDJAAgACgCACEAIAMgAjkDCCABIANBCGogABECABogA0EQaiQACy4BAX8jAEEQayICJAAgAiABKwMIOQMIIABBqNUDIAJBCGoQETYCACACQRBqJAALDgAgACABKwMAOQMIQQELCQBByygQ4wQAC4cCAQd/AkAgACgCACICKAIEIgMgAigCCCIETw0AIAMgASgCADYCACACIANBBGo2AgQgAA8LAkACQCADIAIoAgAiBWsiBkECdSIHQQFqIgNBgICAgARPDQACQAJAIAQgBWsiBEEBdSIIIAMg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fyMAQdAAayIBJAAgAUEAOgAcIAFB7sK1qwY2AhggAUGE3AA7ACMgASABQRhqNgIoIAAgAUEYahCeBiECIAFBADoAQCABQcAAakEEciEDAkACQCACLAALQQBIDQAgAyACKQIANwIAIANBCGogAkEIaigCADYCAAwBCyADIAIoAgAgAigCBBD6GwsgAUEBOgBAAkACQCABQc8AaiwAAEEASA0AIAFBMGpBCGogA0EIaigCADYCACABIAMpAgA3AzAMAQsgAUEwaiABKAJEIAFByABqKAIAEPobIAEtAEBFDQAgASwAT0F/Sg0AIAEoAkQQ0BsLAkAgASwAI0F/Sg0AIAEoAhgQ0BsLAkACQCABKAI0IAEsADsiAkH/AXEgAkEASBtBGEcNACABQTBqQQBBfyMGQfMkakEYEIkcDQAgAUEQEM4bIgI2AhggAUKLgICAgIKAgIB/NwIcIAIjBkGaGWoiAykAADcAACACQQA6AAsgAkEHaiADQQdqKAAANgAAIAEgAjYCKCABQS46ACQgACABQRhqEJ4GIAFBwABqIAFBCGoQ1hgiAhDXGCIDEM8GIQQgAxDYGBogAhDYGBoCQCABLAAjQX9KDQAgASgCGBDQGwtBNBDOGyIFIAQQrgYaIAFBGGpBCGojBkHRDmoiAkEIai0AADoAACABQYncADsAIyABIAIpAAA3AxggAUEAOgAhIAEgAUEYajYCKCAAIAFBGGoQngYhAgJAIAEsACNBf0oNACABKAIYENAbCyACKAIMKAIEIgYoAiwiAkFYakEAIAIbIgAgBkYNASABQcAAakEEciEDA0AgAUEAOgAcIAFB7sK1qwY2AhggAUGE3AA7ACMgASABQRhqNgIoIABBDGoiByABQRhqEJ4GIQIgAUEAOgBAAkACQCACLAALQQBIDQAgAyACKQIANwIAIANBCGogAkEIaigCADYCAAwBCyADIAIoAgAgAigCBBD6GwsgAUEBOgBAAkACQCABLABPQQBIDQAgAUEIakEIaiADQQhqKAIANgIAIAEgAykCADcDCAwBCyABQQhqIAEoAkQgASgCSBD6GyABLQBARQ0AIAEsAE9Bf0oNACABKAJEENAbC0EAIQIgAUHAAGogAUEIakEAQQogAUEIahD/GyEIAkAgASgCRCABLQBLIgQgBMAiBEEASBtBCkcNACAIQQBBfyMGQYzjAGpBChCJHEUhAiABLQBLIQQLAkAgBMBBf0oNACAIKAIAENAbCwJAIAEsABNBf0oNACABKAIIENAbCwJAIAEsACNBf0oNACABKAIYENAbCwJAAkAgAkUNAEEyIQIgBxDlBiEEDAELQQIhAiAHENAIIQQLIAUgBCAFKAIAIAJBAnRqKAIAEQEAIAAoAiwiAkFYakEAIAIbIgAgBkcNAAwCCwALIwYhAkEIEBQhACABQRhqIAJBzesAaiABQTBqEJgcIxIhAiMVIQMgACABQRhqENAGIAMgAhAVAAsCQCABLAA7QX9KDQAgASgCMBDQGwsgAUHQAGokACAFC70BAQJ/IwBB4ABrIgIkACACQQhqIAJB2ABqIAEQ1xgiASAAENwGIAEQ2BgaAkAgAi0ACA0AIwYhASMWKAIEIQMgAkEoaiACQRhqIAFB75oBahB3IAMQrQYgAkE4aiACQShqIAFB4OEAahCtBiACQcgAaiACQThqIAAQ1wYhACACQqCFgIDwBjcDECACIAFBo8IAajYCDCACIAFB3DFqNgIIIAAgAkEIahD0BAALIAIoAgwhACACQeAAaiQAIAALGwEBfyMXIQIgACABENkbIgEgAkEIajYCACABC0sBAX8gACMFQQhqNgIAAkAgACgCKCIBRQ0AIABBLGogATYCACABENAbCwJAIAAoAhwiAUUNACAAQSBqIAE2AgAgARDQGwsgABClBwtOAQF/IAAjBUEIajYCAAJAIAAoAigiAUUNACAAQSxqIAE2AgAgARDQGwsCQCAAKAIcIgFFDQAgAEEgaiABNgIAIAEQ0BsLIAAQpQcQ0BsLCgAgABCZHRDQGwsKACAAEJkdENAbC/MCAQJ/IwBB8ABrIgMkACADQeAAaiACIAEQ1gYCQCADLQBgRQ0AAkACQAJAIANB4ABqQQRyIgEgAEYNACADQe8Aai0AACIEwCECAkACQCAALAALQQBIDQACQCACQQBIDQAgACABKQIANwIAIABBCGogAUEIaigCADYCAAwCCyAAIAMoAmQgA0HoAGooAgAQhRwaDAELIAAgAygCZCABIAJBAEgiAhsgA0HoAGooAgAgBCACGxCEHBoLIAMtAGBFDQIgA0HvAGosAABBAEgNAQwCCyADQe8AaiwAAEF/Sg0BCyADKAJkENAbCyADQfAAaiQADwsjBiEAIxghASADQTBqIANBIGogAEGMmwFqEHcgARCtBiADQcAAaiADQTBqIABBz+EAahCtBiADQQA2AhggA0HQAGogA0HAAGogA0EYahDzBCEBIANCvIaAgLAGNwMQIAMgAEGZwgBqNgIMIAMgAEHcMWo2AgggASADQQhqEPQEAAv1AwEFfyMAQbABayIDJAAgAyMZIgRBIGoiBTYCWCADIxoiBigCBCIHNgIgIANBIGogB0F0aigCAGogBigCCDYCACADQSBqIAMoAiBBdGooAgBqIgYgA0EgakEEciIHEMMSIAZCgICAgHA3AkggAyAFNgJYIAMgBEEMajYCICMMIQUgBxCMECIEIAVBCGo2AgAgA0HMAGpCADcCACADQcQAakIANwIAIANB1ABqQRA2AgAgA0EYaiADQSBqIAMoAiBBdGooAgBqIgUQuxIgA0EIaiAFIAEQuhIgA0EIahDYGBoCQCAFKAIYIgVFDQAgBSABIAUoAgAoAggRAQAgA0GoAWogBUEEaiIFENcYIQYgBSABENkYGiAGENgYGgsgA0EYahDYGBogA0EgaiACIAIQpg8QxAQaAkACQCADQSBqIAMoAiBBdGooAgBqLQAQQQVxDQAgA0EIaiAEEMMRIABBDGogA0EQaigCADYCACAAIAMpAwg3AgQgAEEBOgAADAELIABBADoAAAsgA0HYAGohASADIxoiAigCACIFNgIgIANBIGogBUF0aigCAGogAigCDDYCACAEIwxBCGo2AgACQCADLABPQX9KDQAgAygCRBDQGwsgBBCKEBogA0EgaiMaQQRqENQQGiABEIMQGiADQbABaiQAC3wBAX8jGyEDIAAgARDiGyIBIANBCGo2AgAjHCEDQRAQzhsiACADQQhqNgIAIABBBGohAwJAIAIsAAtBAEgNACADIAIpAgA3AgAgA0EIaiACQQhqKAIANgIAIAEgADYCCCABDwsgAyACKAIAIAIoAgQQ+hsgASAANgIIIAELGQACQCAALAAPQX9KDQAgACgCBBDQGwsgAAscAAJAIAAsAA9Bf0oNACAAKAIEENAbCyAAENAbCwQAIx0LYQECfyMcIQFBEBDOGyICIAFBCGo2AgAgAkEEaiEBAkAgACwAD0EASA0AIAEgAEEEaiIAKQIANwIAIAFBCGogAEEIaigCADYCACACDwsgASAAKAIEIABBCGooAgAQ+hsgAgulBAEFfyMAQbABayIDJAAgAyMeIgRBIGoiBTYCTCADIx8iBigCBCIHNgIQIANBEGogB0F0aigCAGogBigCCDYCACADQQA2AhQgA0EQaiADKAIQQXRqKAIAaiIGIANBEGpBCGoiBxDDEiAGQoCAgIBwNwJIIAMgBTYCTCADIARBDGo2AhAjDCEFIAcQjBAiBCAFQQhqNgIAIANBwABqQgA3AwAgA0E4akIANwMAIANByABqQQg2AgAgBCACEMoRIANBCGogA0EQaiADKAIQQXRqKAIAaiICELsSIANBqAFqIAIgARC6EiADQagBahDYGBoCQCACKAIYIgJFDQAgAiABIAIoAgAoAggRAQAgA0GgAWogAkEEaiICENcYIQUgAiABENkYGiAFENgYGgsgA0EIahDYGBogA0EQaiADQagBahDHEBoCQCADQRBqIAMoAhBBdGooAgBqKAIQIgFBAnENACADQRBqEN0GGiADQRBqIAMoAhBBdGooAgBqKAIQIQELAkACQAJAIAFBBXENACADQRBqEM0QQX9GDQELIABBADoAAAwBCyAAQQE6AAAgACADKAKoATYCBAsgA0HMAGohASADIx8iAigCACIANgIQIANBEGogAEF0aigCAGogAigCDDYCACAEIwxBCGo2AgACQCADLABDQX9KDQAgAygCOBDQGwsgBBCKEBogA0EQaiMfQQRqEKEQGiABEIMQGiADQbABaiQAC58CAQR/IwBBEGsiASQAAkAgAUEIaiAAQQEQphAtAABFDQAgASAAIAAoAgBBdGooAgBqELsSIAEjDRCEFCECIAEQ2BgaA0ACQAJAAkACQCAAIAAoAgBBdGooAgBqKAIYIgMoAgwiBCADKAIQRg0AIAQtAAAhAwwBCyADIAMoAgAoAiQRAAAiA0F/Rw0AQQIhBAwBC0EAIQQgA0GAAXENACACKAIIIANB/wFxQQJ0ai0AAEEBcQ0BCyAAIAAoAgBBdGooAgBqIgMgAygCECAEchC9EgwCCwJAIAAgACgCAEF0aigCAGooAhgiAygCDCIEIAMoAhBHDQAgAyADKAIAKAIoEQAAGgwBCyADIARBAWo2AgwMAAsACyABQRBqJAAgAAvVAgEHfyMAQRBrIgIkAEHQABDOGyIDQgA3AgQgAyMgQQhqNgIAIANBDGoiBEIANwIAIANB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OwALIAFBADoABSABIwZBjdYAaiICKAAANgIAIAEgAkEEai0AADoABCABIAE2AhAgACABEJ4GIAFBKGogAUE4ahDWGCICENcYIgMQ5gYhCCADENgYGiACENgYGgJAIAEsAAtBf0oNACABKAIAENAbCyABQYXcADsACyABQQA6AAUgASMGQag8aiICKAAANgIAIAEgAkEEai0AADoABCABIAE2AhAgACABEJ4GEPMLIQACQCABLAALQX9KDQAgASgCABDQGwtByAAQzhsgCCAAEOQGIQIgAEUNASAAIAAoAgAoAhARAwAMAQsjBiECQQgQFCEAIAEgAkHN6wBqIAFBGGoQmBwjEiECIxUhAyAAIAEQ0AYgAyACEBUACwJAIAEsACNBf0oNACABKAIYENAbCyABQcAAaiQAIAILwAECAn8BfCMAQeAAayICJAAgAkHQAGogAkHIAGogARDXGCIBIAAQlAcgARDYGBoCQCACLQBQDQAjBiEBIy4oAgQhAyACQRhqIAJBCGogAUHvmgFqEHcgAxCtBiACQShqIAJBGGogAUHg4QBqEK0GIAJBOGogAkEoaiAAENcGIQAgAkKghYCA8AY3A1ggAiABQaPCAGo2AlQgAiABQdwxajYCUCAAIAJB0ABqEPQEAAsgAisDWCEEIAJB4ABqJAAgBAvOAQEDfyAAIyBBCGo2AgACQCAALAArQX9KDQAgACgCIBDQGwsCQCAAKAIQIgFFDQAgASECAkAgAEEUaigCACIDIAFGDQADQCADQXRqIgMgAygCACgCABEAABogAyABRw0ACyAAKAIQIQILIAAgATYCFCACENAbCwJAIAAoAgQiAUUNACABIQICQCAAQQhqKAIAIgMgAUYNAANAIANBdGoiAyADKAIAKAIAEQAAGiADIAFHDQALIAAoAgQhAgsgACABNgIIIAIQ0BsLIAAQ0BsLtQEBA38jAEEQayICJAACQAJAIAEgASgCACgCCBEAAEUNACAAKAJEIgMNASMGIQFBCBAUIQAjEiEDIy8hBCAAIAIgAUGU4ABqEHcQ6QYgBCADEBUACyAAKAJIIgMNACMGIQFBCBAUIQAjEiEDIy8hBCAAIAIgAUGU4ABqEHcQ6QYgBCADEBUACyAAKAIEKAIEIAArAzggASABKAIAKAJcEQAAIAEoAjApAwAgAxEfACACQRBqJAAL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BUEBdCIEIAMgBCADSxtB1arVqgEgBUGq1arVAEkbIgVB1qrVqgFPDQAgACAFQQxsIgQQzhsiBTYCACAAIAUgBGo2AggCQCABIAJGDQADQCMxIQQgASgCBCEHIAUgBEEIajYCACAFIAc2AgQgBSABKAIINgIIIAVBDGohBSABQQxqIgEgAkcNAAsLIAAgBTYCBA8LIAAQhwYAC/MCAQJ/IwBB8ABrIgMkACADQeAAaiACIAEQ+QYCQCADLQBgRQ0AAkACQAJAIANB4ABqQQRyIgEgAEYNACADQe8Aai0AACIEwCECAkACQCAALAALQQBIDQACQCACQQBIDQAgACABKQIANwIAIABBCGogAUEIaigCADYCAAwCCyAAIAMoAmQgA0HoAGooAgAQhRwaDAELIAAgAygCZCABIAJBAEgiAhsgA0HoAGooAgAgBCACGxCEHBoLIAMtAGBFDQIgA0HvAGosAABBAEgNAQwCCyADQe8AaiwAAEF/Sg0BCyADKAJkENAbCyADQfAAaiQADwsjBiEAIzIhASADQTBqIANBIGogAEGMmwFqEHcgARCtBiADQcAAaiADQTBqIABBz+EAahCtBiADQQA2AhggA0HQAGogA0HAAGogA0EYahDzBCEBIANCvIaAgLAGNwMQIAMgAEGZwgBqNgIMIAMgAEHcMWo2AgggASADQQhqEPQEAAv1AwEFfyMAQbABayIDJAAgAyMZIgRBIGoiBTYCWCADIxoiBigCBCIHNgIgIANBIGogB0F0aigCAGogBigCCDYCACADQSBqIAMoAiBBdGooAgBqIgYgA0EgakEEciIHEMMSIAZCgICAgHA3AkggAyAFNgJYIAMgBEEMajYCICMMIQUgBxCMECIEIAVBCGo2AgAgA0HMAGpCADcCACADQcQAakIANwIAIANB1ABqQRA2AgAgA0EYaiADQSBqIAMoAiBBdGooAgBqIgUQuxIgA0EIaiAFIAEQuhIgA0EIahDYGBoCQCAFKAIYIgVFDQAgBSABIAUoAgAoAggRAQAgA0GoAWogBUEEaiIFENcYIQYgBSABENkYGiAGENgYGgsgA0EYahDYGBogA0EgaiACIAIQpg8QxAQaAkACQCADQSBqIAMoAiBBdGooAgBqLQAQQQVxDQAgA0EIaiAEEMMRIABBDGogA0EQaigCADYCACAAIAMpAwg3AgQgAEEBOgAADAELIABBADoAAAsgA0HYAGohASADIxoiAigCACIFNgIgIANBIGogBUF0aigCAGogAigCDDYCACAEIwxBCGo2AgACQCADLABPQX9KDQAgAygCRBDQGwsgBBCKEBogA0EgaiMaQQRqENQQGiABEIMQGiADQbABaiQAC/YCAQJ/IwBB8ABrIgMkACADQeAAaiACIAEQ+wYCQCADLQBgRQ0AAkACQAJAIANB4ABqQQRyIgEgAEYNACADQe8Aai0AACIEwCECAkACQCAALAALQQBIDQACQCACQQBIDQAgACABKQIANwIAIABBCGogAUEIaigCADYCAAwCCyAAIAMoAmQgA0HoAGooAgAQhRwaDAELIAAgAygCZCABIAJBAEgiAhsgA0HoAGooAgAgBCACGxCEHBoLIAMtAGBFDQIgA0HvAGosAABBAEgNAQwCCyADQe8AaiwAAEF/Sg0BCyADKAJkENAbCyADQfAAaiQADwsjBiEAIy4oAgQhASADQTBqIANBIGogAEGMmwFqEHcgARCtBiADQcAAaiADQTBqIABBz+EAahCtBiADQQA2AhggA0HQAGogA0HAAGogA0EYahDzBCEBIANCvIaAgLAGNwMQIAMgAEGZwgBqNgIMIAMgAEHcMWo2AgggASADQQhqEPQEAAuJBAEFfyMAQbABayIDJAAgAyMZIgRBIGoiBTYCWCADIxoiBigCBCIHNgIgIANBIGogB0F0aigCAGogBigCCDYCACADQSBqIAMoAiBBdGooAgBqIgYgA0EgakEEciIHEMMSIAZCgICAgHA3AkggAyAFNgJYIAMgBEEMajYCICMMIQUgBxCMECIEIAVBCGo2AgAgA0HMAGpCADcCACADQcQAakIANwIAIANB1ABqQRA2AgAgA0EYaiADQSBqIAMoAiBBdGooAgBqIgUQuxIgA0EIaiAFIAEQuhIgA0EIahDYGBoCQCAFKAIYIgVFDQAgBSABIAUoAgAoAggRAQAgA0GoAWogBUEEaiIFENcYIQYgBSABENkYGiAGENgYGgsgA0EYahDYGBogA0EgaiADKAIgQXRqKAIAakERNgIIIANBIGogAisDABDqEBoCQAJAIANBIGogAygCIEF0aigCAGotABBBBXENACADQQhqIAQQwxEgAEEMaiADQRBqKAIANgIAIAAgAykDCDcC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AigCCBDQGwsgAkEwaiQAC+4CAgd/AXwjAEEQayIBJABB0AAQzhshAiAAKAIsKAIAKAIEIQMgACsDOCEIIAJCADcCBCACIyBBCGo2AgAgAkEMaiIEQgA3AgAgAkEUakIANwIAIAJBHGoiBUEANgIAIAJBEBDOGyIANgIgIAJBJGpCjICAgICCgICAfzcCACAAQQhqIwYiBkGVzwBqIgdBCGooAAA2AAAgACAHKQAANwAAIABBADoADCACIAiaOQM4IAIgAkEQajYCMCACQgA3A0AgBUEINgIAIAJByABqIgBCADcDACACIyVBCGo2AgAgAiACQQRqIgU2AiwgAkEgaiAGQdPkAGpBDBD8GxogACMmNgIAIAIjJzYCRCABQQI2AgggASMkQQhqNgIAIAEgAzYCBAJAAkAgAkEIaigCACIAIAQoAgBPDQAgAEECNgIIIAAgAzYCBCAAIyRBCGo2AgAgAiAAQQxqNgIIDAELIAUgARDfBgsgAUEQaiQAIAILzgEBA38gACMgQQhqNgIAAkAgACwAK0F/Sg0AIAAoAiAQ0BsLAkAgACgCECIBRQ0AIAEhAgJAIABBFGooAgAiAyABRg0AA0AgA0F0aiIDIAMoAgAoAgARAAAaIAMgAUcNAAsgACgCECECCyAAIAE2AhQgAhDQGwsCQCAAKAIEIgFFDQAgASECAkAgAEEIaigCACIDIAFGDQADQCADQXRqIgMgAygCACgCABEAABogAyABRw0ACyAAKAIEIQILIAAgATYCCCACENAbCyAAENAbC1MBAX9B0AAQzhsgABDrBiIBQcAAaiAAQcAAaigCADYCACABIAApAzg3AzggASAAKQJENwJEIAFBzABqIABBzABqKAIANgIAIAEjKEEIajYCACABC58FAgh/AnwCQAJAAkAgASgCBEECRw0AIAEoAghBAkcNACABKAIAIQJBBCEDDAELIAFBBEECQQIQaSABKAIAIQIgASgCCCABKAIEbCIDQQFIDQELIANBB3EhBEEAIQVBACEGAkAgA0F/akEHSQ0AIANBeHEhB0EAIQZBACEIA0AgAiAGQQR0IgNqIglCADcDACAJQQhqQgA3AwAgAiADQRByaiIJQQhqQgA3AwAgCUIANwMAIAIgA0EgcmoiCUEIakIANwMAIAlCADcDACACIANBMHJqIglBCGpCADcDACAJQgA3AwAgAiADQcAAcmoiCUEIakIANwMAIAlCADcDACACIANB0AByaiIJQQhqQgA3AwAgCUIANwMAIAIgA0HgAHJqIglBCGpCADcDACAJQgA3AwAgAiADQfAAcmoiA0EIakIANwMAIANCADcDACAGQQhqIQYgCEEIaiIIIAdHDQALCwJAIARFDQADQCACIAZBBHRqIgNCADcDACADQQhqQgA3AwAgBkEBaiEGIAVBAWoiBSAERw0ACwsgASgCACECCyACIAArAzhEAAAAAAAA4D+iIgoQnQ8iCzkDCCACIAoQ3A4gC0QAAAAAAAAAAKKgOQMAIAEoAgAgASgCCCIDQQFGIgIgA0EBR2pBBHRqIgNCADcDACADQQhqQgA3AwAgASgCAEECQQEgAhsgAkEBQQIgAhsiAyABKAIIIgZGIgUbIgIgBmxBACADIAUbIgNqQQR0aiIGQgA3AwAgBkEIakIANwMAIAEoAgAgAiADQQFqIgMgASgCCCIGRiIFaiAGbEEAIAMgBRtqQQR0aiICIAArAzhEAAAAAAAA4D+iIgoQnQ8iC5o5AwggAiAKENwOIAtEAAAAAAAAAACioTkDAAuBBAEFfyMAQTBrIgIkACAAQgA3AgAgAEEIakEANgIAQRAQzhsiA0EwEM4bIgQ2AgQgBCAEQShqIgU2AiwgBCAEQRxqIgY2AiQgBCAGNgIgIARBADYCHCAEIAU2AiggA0EANgIMIAAgAzYCDCACQQA6AAwgAkHuwrWrBjYCCCACQYTcADsAEyMGIQQgAiACQQhqNgIYIAAgAkEIaiAEQcLSAGogAkEoaiACQSBqENYYIgQQ1xgiAxDuBhogAxDYGBogBBDYGBoCQCACLAATQX9KDQAgAigCCBDQGwsgAkEQEM4bIgQ2AgggAkKMgICAgIKAgIB/NwIMIARBCGojBkGlJWoiA0EIaigAADYAACAEIAMpAAA3AAAgBEEAOgAMIAIgBDYCGCACQS46ABQgAiABKAIEKAIENgIEIAAgAkEIaiACQQRqIAJBKGogAkEgahDWGCIEENcYIgMQ1AQaIAMQ2BgaIAQQ2BgaAkAgAiwAE0F/Sg0AIAIoAggQ0BsLIAJBhdwAOwATIAJBADoADSACIwZBjdYAaiIEKAAANgIIIAIgBEEEai0AADoADCACIAJBCGo2AhggACACQQhqIAFBOGogAkEoaiACQSBqENYYIgQQ1xgiARDvBhogARDYGBogBBDYGBoCQCACLAATQX9KDQAgAigCCBDQGwsgAkEwaiQAC+4CAgd/AXwjAEEQayIBJABB0AAQzhshAiAAKAIsKAIAKAIEIQMgACsDOCEIIAJCADcCBCACIyBBCGo2AgAgAkEMaiIEQgA3AgAgAkEUakIANwIAIAJBHGoiBUEANgIAIAJBEBDOGyIANgIgIAJBJGpCjICAgICCgICAfzcCACAAQQhqIwYiBkGVzwBqIgdBCGooAAA2AAAgACAHKQAANwAAIABBADoADCACIAiaOQM4IAIgAkEQajYCMCACQgA3A0AgBUEINgIAIAJByABqIgBCADcDACACIyhBCGo2AgAgAiACQQRqIgU2AiwgAkEgaiAGQbDkAGpBDBD8GxogACMpNgIAIAIjKjYCRCABQQQ2AgggASMkQQhqNgIAIAEgAzYCBAJAAkAgAkEIaigCACIAIAQoAgBPDQAgAEEENgIIIAAgAzYCBCAAIyRBCGo2AgAgAiAAQQxqNgIIDAELIAUgARDfBgsgAUEQaiQAIAILCgAgABCZHRDQGwvvAQEDfyAAIy1BCGo2AgACQCAAKAJEIgFFDQAgASABKAIAKAIQEQMACyAAIyBBCGo2AgACQCAALAArQX9KDQAgACgCIBDQGwsCQCAAKAIQIgJFDQAgAiEDAkAgAEEUaigCACIBIAJGDQADQCABQXRqIgEgASgCACgCABEAABogASACRw0ACyAAKAIQIQMLIAAgAjYCFCADENAbCwJAIAAoAgQiAkUNACACIQMCQCAAQQhqKAIAIgEgAkYNAANAIAFBdGoiASABKAIAKAIAEQAAGiABIAJHDQALIAAoAgQhAwsgACACNgIIIAMQ0BsLIAALCgAgABCIBxDQGwuNAwMFfwF8AX4jAEEwayICJAAgACgCRCEDIAJBADYCICACQgA3AxggA0EIaigCACEEIAMoAgQhAyACIAJBGGo2AggCQAJAIAMgBEcNACACQQA2AhAgAkIANwMIDAELA0AgAiADKAIANgIoIAJBCGogAkEoahCVBBogA0EIaiIDIARHDQALIAAoAkQiA0EIaigCACEEIAMoAgQhAyACQQA2AhAgAkIANwMIIAIgAkEIajYCKCADIARGDQADQCACIAMoAgQ2AiQgAkEoaiAC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IgFBf0wNAiAEIAEQzhsiAjYCACAEIAIgAUECdUECdGo2AgggAiAFIAH8CgAAIAQgAiABajYCBAsgACAEQRBqIAQgAxCuCCAAKAIAKAIIEQEAAkAgBCgCACIBRQ0AIAQgATYCBCABENAbCwJAIAQoAhAiAUUNACAEIAE2AhQgARDQGwsgBEEgaiQADwsgBEEQahCUBAALIAQQlAQAC40DAQN/IwBBwABrIgIkACACQShqIAEgASgCACgCABEBAAJAIAIrAzCZRJsroYabhAY9ZA0AIAJBADYCICACQgA3AxggAUEIaigCACEDIAEoAgQhBCACIAJBGGo2AigCQAJAIAQgA0cNACACQQA2AhAgAkIANwMIDAELA0AgAiAEKAIANgI8IAJBKGogAkE8ahCVBBogBEEIaiIEIANHDQALIAEoAgghAyABKAIEIQQgAkEANgIQIAJCADcDCCACIAJBCGo2AiggBCADRg0AA0AgAiAEKAIENgI8IAJBKGogAkE8ahCVBBogBEEIaiIEIANHDQALCyACQShqIAEgASgCACgCABEBACAAIAJBGGogAkEIaiACKwMoEK4IIAAoAgAoAggRAQACQCACKAIIIgRFDQAgAiAENgIMIAQQ0BsLAkAgAigCGCIERQ0AIAIgBDYCHCAEENAbCyACQcAAaiQADwsjBiEEQQgQFCEDIxIhASM7IQAgAyACQShqIARBojlqEHcQygcgACABEBUACxsBAX8jPCECIAAgARDZGyIBIAJBCGo2AgAgAQu3BwEMfyMAQcAAayIDJAACQAJAAkACQAJAAkACQCABIAEoAgAoAggRAABFDQAgA0EwaiABIAEoAgAoAjARAQAgAygCMCIEIAMoAjQiBUYNBgNAIAQoAgAhBiADQQA2AiggA0IANwMgAkACQCAGKAIEIgEgBkEIaigCACIHRw0AIANBADYCGCADQgA3AxAMAQsDQCABKAIAIQgCQAJAIAMoAiQiCSADKAIoIgpPDQAgCSAINgIAIAMgCUEEajYCJAwBCyAJIAMoAiAiC2siDEECdSINQQFqIglBgICAgARPDQUCQAJAIAogC2siCkEBdSIOIAkgDiAJSxtB/////wMgCkH8////B0kbIgoNAEEAIQkMAQsgCkGAgICABE8NByAKQQJ0EM4bIQkLIAkgDUECdGoiDSAINgIAIAkg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IgpBCGpCADcDACAKQgA3AwAgAyABQSByaiIKQQhqQgA3AwAgCkIANwMAIAMgAUEwcmoiCkEIakIANwMAIApCADcDACADIAFBwAByaiIKQQhqQgA3AwAgCkIANwMAIAMgAUHQAHJqIgpBCGpCADcDACAKQgA3AwAgAyABQeAAcmoiCkEIakIANwMAIApCADcDACADIAFB8AByaiIBQQhqQgA3AwAgAUIANwMAIAdBCGohByAJQQhqIgkgCEcNAAsLAkAgBUUNAANAIAMgB0EEdGoiAUIANwMAIAFBCGpCADcDACAHQQFqIQcgBkEBaiIGIAVHDQALCyAEKAIAIQMLIANCADcDACADQQhqQgA3AwAgACgCQCAAKAJIIgFBAUYiAyABQQFHakEEdGoiAUKAgICAgICA+L9/NwMIIAFCgICAgICAgICAfzcDACAAKAJAQQJBASADGyADQQFBAiADGyIBIAAoAkgiB0YiBhsiAyAHbEEAIAEgBhsiAWpBBHRqIgdCgICAgICAgPg/NwMIIAdCADcDACAAKAJAIAMgAUEBaiIBIAAoAkgiB0YiBmogB2xBACABIAYbakEEdGoiA0IANwMAIANBCGpCADcDACACQRBqJAALuQEBA39BzAAQzhsiAUIANwIEIAEjIEEIajYCACABQQxqQgA3AgAgAUEUakIANwIAIAFBHGpBADYCACABQRAQzhsiAjYCICABQSRqQoyAgICAgoCAgH83AgAgAkEIaiMGQZXPAGoiA0EIaigAADYAACACIAMpAAA3AAAgAkEAOgAMIAEgAUEQajYCMCABQgA3AkAgAUHIAGpBADYCACABI0NBCGo2AgAgASABQQRqNgIsIAEgABD8ByABC7QGAQl/IwBBEGsiAiQAIAAjSTYCOCAAI0o2AjQCQAJAIAAsACtBf0oNACAAQSRqQQE2AgAgACgCICEDDAELIABBIGohAyAAQQE6ACsLIANB2gA7AAAgAkEENgIIIAIjJEEIajYCACACIAE2AgQCQAJAIABBCGooAgAiAyAAQQxqKAIATw0AIANBBDYCCCADIAE2AgQgAyMkQQhqNgIAIAAgA0EMajYCCAwBCyAAQQRqIAIQ3wYLIABBBzYCHCAAQcAAaiEEAkACQAJAIABBxABqKAIAQQJHDQAgAEHIAGooAgBBAkcNACAEKAIAIQNBBCEB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CwsgBCgCACEDCyADQgA3AwggA0KAgICAgICA+D83AwAgACgCQCAAKAJIIgFBAUYiAyABQQFHakEEdGoiAUIANwMAIAFBCGpCADcDACAAKAJAQQJBASADGyADQQFBAiADGyIBIAAoAkgiB0YiBhsiAyAHbEEAIAEgBhsiAWpBBHRqIgdCADcDACAHQQhqQgA3AwAgACgCQCADIAFBAWoiASAAKAJIIgdGIgZqIAdsQQAgASAGG2pBBHRqIgNCzPf8s+aTqPO/fzcDCCADQsz3/LPmk6jzPzcDACACQRBqJAALuQEBA39BzAAQzhsiAUIANwIEIAEjIEEIajYCACABQQxqQgA3AgAgAUEUakIANwIAIAFBHGpBADYCACABQRAQzhsiAjYCICABQSRqQoyAgICAgoCAgH83AgAgAkEIaiMGQZXPAGoiA0EIaigAADYAACACIAMpAAA3AAAgAkEAOgAMIAEgAUEQajYCMCABQgA3AkAgAUHIAGpBADYCACABI0NBCGo2AgAgASABQQRqNgIsIAEgABCJCCABC/8GAQl/IwBBEGsiAiQAIAAjVTYCOCAAI1Y2AjQCQAJAIAAsACtBf0oNACAAQSRqQQU2AgAgACgCICEDDAELIABBIGohAyAAQQU6ACsLIANBADoABSADIwZB/eQAaiIEKAAANgAAIANBBGogBEEEai0AADoAACACQQE2AgggAiMkQQhqNgIAIAIgATYCBAJAAkAgAEEIaigCACIDIABBDGooAgBPDQAgA0EBNgIIIAMgATYCBCADIyRBCGo2AgAgACADQQxqNgIIDAELIABBBGogAhDfBgsgAEECNgIcIABBwABqIQUCQAJAAkAgAEHEAGooAgBBAkcNACAAQcgAaigCAEECRw0AIAUoAgAhA0EEIQEMAQsgBUEEQQJBAhBpIAAoAkAhAyAAKAJIIAAoAkRsIgFBAUgNAQsgAUEHcSEGQQAhB0EAIQQCQCABQX9qQQdJDQAgAUF4cSEIQQAhBEEAIQkDQCADIARBBHQiAWoiCkIANwMAIApBCGpCADcDACADIAFBEHJqIgpBCGpCADcDACAKQgA3AwAgAyABQSByaiIKQQhqQgA3AwAgCkIANwMAIAMgAUEwcmoiCkEIakIANwMAIApCADcDACADIAFBwAByaiIKQQhqQgA3AwAgCkIANwMAIAMgAUHQAHJqIgpBCGpCADcDACAKQgA3AwAgAyABQeAAcmoiCkEIakIANwMAIApCADcDACADIAFB8AByaiIBQQhqQgA3AwAgAUIANwMAIARBCGohBCAJQQhqIgkgCEcNAAsLAkAgBkUNAANAIAMgBEEEdGoiAUIANwMAIAFBCGpCADcDACAEQQFqIQQgB0EBaiIHIAZHDQALCyAFKAIAIQMLIANCgICAgICAgPA/NwMIIANCgICAgICAgPA/NwMAIAAoAkAgACgCSCIBQQFGIgMgAUEBR2pBBHRqIgFCgICAgICAgPC/fzcDCCABQoCAgICAgIDwPzcDACAAKAJAQQJBASADGyADQQFBAiADGyIBIAAoAkgiBEYiBxsiAyAEbEEAIAEgBxsiAWpBBHRqIgRCgICAgICAgPC/fzcDCCAEQoCAgICAgIDwPzcDACAAKAJAIAMgAUEBaiIBIAAoAkgiBEYiB2ogBGxBACABIAcbakEEdGoiA0KAgICAgICA8D83AwggA0KAgICAgICA8D83AwAgAkEQaiQAC7kBAQN/QcwAEM4bIgFCADcCBCABIyBBCGo2AgAgAUEMakIANwIAIAFBFGpCADcCACABQRxqQQA2AgAgAUEQEM4bIgI2AiAgAUEkakKMgICAgIKAgIB/NwIAIAJBCGojBkGVzwBqIgNBCGooAAA2AAAgAiADKQAANwAAIAJBADoADCABIAFBEGo2AjAgAUIANwJAIAFByABqQQA2AgAgASNDQQhqNgIAIAEgAUEEajYCLCABIAAQiwggAQvuBgEJfyMAQRBrIgIkACAAI1c2AjggACNYNgI0AkACQCAALAArQX9KDQAgAEEkakEINgIAIAAoAiAhAwwBCyAAQSBqIQMgAEEIOgArCyADQQA6AAggA0Lz4smjh4vZsOcANwAAIAJBATYCCCACIyRBCGo2AgAgAiABNgIEAkACQCAAQQhqKAIAIgMgAEEMaigCAE8NACADQQE2AgggAyABNgIEIAMjJEEIajYCACAAIANBDGo2AggMAQsgAEEEaiACEN8GCyAAQQI2AhwgAEHAAGohBAJAAkACQCAAQcQAaigCAEECRw0AIABByABqKAIAQQJHDQAgBCgCACEDQQQhAQwBCyAEQQRBAkECEGkgACgCQCEDIAAoAkggACgCRGwiAUEBSA0BCyABQQdxIQVBACEGQQAhBwJAIAFBf2pBB0kNACABQXhxIQhBACEHQQAhCQNAIAMgB0EEdCIBaiIKQgA3AwAgCkEIakIANwMAIAMgAUEQcmoiCkEIakIANwMAIApCADcDACADIAFBIHJqIgpBCGpCADcDACAKQgA3AwAgAyABQTByaiIKQQhqQgA3AwAgCkIANwMAIAMgAUHAAHJqIgpBCGpCADcDACAKQgA3AwAgAyABQdAAcmoiCkEIakIANwMAIApCADcDACADIAFB4AByaiIKQQhqQgA3AwAgCkIANwMAIAMgAUHwAHJqIgFBCGpCADcDACABQgA3AwAgB0EIaiEHIAlBCGoiCSAIRw0ACwsCQCAFRQ0AA0AgAyAHQQR0aiIBQgA3AwAgAUEIakIANwMAIAdBAWohByAGQQFqIgYgBUcNAAsLIAQoAgAhAwsgA0KAgICAgICA8L9/NwMIIANCgICAgICAgPA/NwMAIAAoAkAgACgCSCIBQQFGIgMgAUEBR2pBBHRqIgFCgICAgICAgPA/NwMIIAFCgICAgICAgPA/NwMAIAAoAkBBAkEBIAMbIANBAUECIAMbIgEgACgCSCIHRiIGGyIDIAdsQQAgASAGGyIBakEEdGoiB0KAgICAgICA8D83AwggB0KAgICAgICA8D83AwAgACgCQCADIAFBAWoiASAAKAJIIgdGIgZqIAdsQQAgASAGG2pBBHRqIgNCgICAgICAgPC/fzcDCCADQoCAgICAgIDwPzcDACACQRBqJAALuQEBA39BzAAQzhsiAUIANwIEIAEjIEEIajYCACABQQxqQgA3AgAgAUEUakIANwIAIAFBHGpBADYCACABQRAQzhsiAjYCICABQSRqQoyAgICAgoCAgH83AgAgAkEIaiMGQZXPAGoiA0EIaigAADYAACACIAMpAAA3AAAgAkEAOgAMIAEgAUEQajYCMCABQgA3AkAgAUHIAGpBADYCACABI0NBCGo2AgAgASABQQRqNgIsIAEgABCNCCABC/8GAQl/IwBBEGsiAiQAIAAjWTYCOCAAI1o2AjQCQAJAIAAsACtBf0oNACAAQSRqQQU2AgAgACgCICEDDAELIABBIGohAyAAQQU6ACsLIANBADoABSADIwZByOQAaiIEKAAANgAAIANBBGogBEEEai0AADoAACACQQI2AgggAiMkQQhqNgIAIAIg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IgFCADcDACABQQhqQgA3AwAgACgCQEECQQEgAxsgA0EBQQIgAxsiASAAKAJIIgdGIgYbIgMgB2xBACABIAYbIgFqQQR0aiIHQgA3AwAgB0EIakIANwMAIAAoAkAgAyABQQFqIgEgACgCSCIHRiIGaiAHbEEAIAEgBhtqQQR0aiIDQgA3AwggA0KAgICAgICA+D83AwAgAkEQaiQAC7sBAQN/QdgAEM4bIgJCADcCBCACIyBBCGo2AgAgAkEMakIANwIAIAJBFGpCADcCACACQRxqQQA2AgAgAkEQEM4bIgM2AiAgAkEkakKMgICAgIKAgIB/NwIAIANBCGojBkGVzwBqIgRBCGooAAA2AAAgAyAEKQAANwAAIANBADoADCACIAJBEGo2AjAgAkIANwNAIAJByABqQQA2AgAgAiNhQQhqNgIAIAIgAkEEajYCLCACIAAgARCVCCACC5wHAQl/IwBBEGsiAyQAIAAjIjYCOCAAIyM2AjQgACACOQNQAkACQCAALAArQX9KDQAgAEEkakEKNgIAIAAoAiAhBAwBCyAAQSBqIQQgAEEKOgArCyAEQQA6AAogBCMGQcU3aiIFKQAANwAAIARBCGogBUEIai8AADsAACADQQE2AgggAyMkQQhqNgIAIAMgATYCBAJAAkAgAEEIaigCACIEIABBDGooAgBPDQAgBEEBNgIIIAQgATYCBCAEIyRBCGo2AgAgACAEQQxqNgIIDAELIABBBGogAxDfBgsgAEHAAGohBgJAAkACQCAAQcQAaigCAEECRw0AIABByABqKAIAQQJHDQAgBigCACEEQQQhAQwBCyAGQQRBAkECEGkgACgCQCEEIAAoAkggACgCRGwiAUEBSA0BCyABQQdxIQdBACEIQQAhBQJAIAFBf2pBB0kNACABQXhxIQlBACEFQQAhCgNAIAQgBUEEdCIBaiILQgA3AwAgC0EIakIANwMAIAQgAUEQcmoiC0EIakIANwMAIAtCADcDACAEIAFBIHJqIgtBCGpCADcDACALQgA3AwAgBCABQTByaiILQQhqQgA3AwAgC0IANwMAIAQgAUHAAHJqIgtBCGpCADcDACALQgA3AwAgBCABQdAAcmoiC0EIakIANwMAIAtCADcDACAEIAFB4AByaiILQQhqQgA3AwAgC0IANwMAIAQgAUHwAHJqIgFBCGpCADcD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DCACIAJBEGo2AjAgAkIANwNAIAJByABqQQA2AgAgAiNhQQhqNgIAIAIgAkEEajYCLCACIAAgARCVCCACC7sBAQN/QdgAEM4bIgJCADcCBCACIyBBCGo2AgAgAkEMakIANwIAIAJBFGpCADcCACACQRxqQQA2AgAgAkEQEM4bIgM2AiAgAkEkakKMgICAgIKAgIB/NwIAIANBCGojBkGVzwBqIgRBCGooAAA2AAAgAyAEKQAANwAAIANBADoADCACIAJBEGo2AjAgAkIANwNAIAJByABqQQA2AgAgAiNhQQhqNgIAIAIgAkEEajYCLCACIAAgARCXCCACC7sBAQN/QdgAEM4bIgJCADcCBCACIyBBCGo2AgAgAkEMakIANwIAIAJBFGpCADcCACACQRxqQQA2AgAgAkEQEM4bIgM2AiAgAkEkakKMgICAgIKAgIB/NwIAIANBCGojBkGVzwBqIgRBCGooAAA2AAAgAyAEKQAANwAAIANBADoADCACIAJBEGo2AjAgAkIANwNAIAJByABqQQA2AgAgAiNhQQhqNgIAIAIgAkEEajYCLCACIAAgARCZCCACC7wBAQN/QdgAEM4bIgJCADcCBCACIyBBCGo2AgAgAkEMakIANwIAIAJBFGpCADcCACACQRxqQQA2AgAgAkEQEM4bIgM2AiAgAkEkakKMgICAgIKAgIB/NwIAIANBCGojBkGVzwBqIgRBCGooAAA2AAAgAyAEKQAANwAAIANBADoADCACIAJBEGo2AjAgAkIANwNAIAJByABqQQA2AgAgAiNhQQhqNgIAIAIgAkEEajYCLCACIAAgAZoQlQggAgu8AQEDf0HYABDOGyICQgA3AgQgAiMgQQhqNgIAIAJBDGpCADcCACACQRRqQgA3AgAgAkEcakEANgIAIAJBEBDOGyIDNgIgIAJBJGpCjICAgICCgICAfzcCACADQQhqIwZBlc8AaiIEQQhqKAAANgAAIAMgBCkAADcAACADQQA6AAwgAiACQRBqNgIwIAJCADcDQCACQcgAakEANgIAIAIjYUEIajYCACACIAJBBGo2AiwgAiAAIAGaEJcIIAILvAEBA39B2AAQzhsiAkIANwIEIAIjIEEIajYCACACQQxqQgA3AgAgAkEUakIANwIAIAJBHGpBADYCACACQRAQzhsiAzYCICACQSRqQoyAgICA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CyAAEHYACz8BAn8jAEEQayICJAAgACABEJ4GIAJBCGogAhDWGCIBENcYIgAQzwYhAyAAENgYGiABENgYGiACQRBqJAAgAws6AQN/QQAhAgJAIAEQpg8iAyAAKAIEIAAtAAsiBCAEwEEASBtHDQAgAEEAQX8gASADEIkcRSECCyACC0ECAX8BfCMAQRBrIgIkACAAIAEQngYgAkEIaiACENYYIgEQ1xgiABDmBiEDIAAQ2BgaIAEQ2BgaIAJBEGokACADC1YBA38CQCAAKAIAIgFFDQAgASECAkAgACgCBCIDIAFGDQADQCADQXRqIgMgAygCACgCABEAABogAyABRw0ACyAAKAIAIQILIAAgATYCBCACENAbCyAAC1YBA38CQCAAKAIAIgFFDQAgASECAkAgACgCBCIDIAFGDQADQCADQXRqIgMgAygCACgCABEAABogAyABRw0ACyAAKAIAIQILIAAgATYCBCACENAbCyAAC/4BAQZ/AkAgACgCBCICIAAoAggiA08NACACIAErAwA5AwAgACACQQhqNgIEDwsCQAJAIAIgACgCACIEayIFQQN1IgZBAWoiAkGAgICAAk8NAAJAAkAgAyAEayIDQQJ1IgcgAiAHIAJLG0H/////ASADQfj///8HSRsiAw0AQQAhAgwBCyADQYCAgIACTw0CIANBA3QQzhshAgsgAiAGQQN0aiIGIAErAwA5AwAgAiADQQN0aiEBIAZBCGohAwJAIAVBAUgNACACIAQgBfwKAAALIAAgATYCCCAAIAM2AgQgACACNgIAAkAgBEUNACAEENAbCw8LIAAQzwQACxBkAAs/AQJ/IwBBEGsiAiQAIAAgARCeBiACQQhqIAIQ1hgiARDXGCIAENwIIQMgABDYGBogARDYGBogAkEQaiQAIAMLkAEBAn8gAEEANgIIIABCADcCAAJAAkAgASgCBCICIAEoAgAiA0YNACACIANrIgNBf0wNASAAIAMQzhsiAjYCACAAIAI2AgQgACACIANBAnVBAnRqNgIIAkAgASgCBCABKAIAIgNrIgFBAUgNACACIAMgAfwKAAAgAiABaiECCyAAIAI2AgQLIAAPCyAAEJMGAAvWBwEEfyMAQSBrIgUkACAAQgA3AgQgACMgQQhqNgIAIABBDGpCADcCACAAQRRqQgA3AgAgAEEcakEANgIAIABBEBDOGyIGNgIgIABBJGpCjICAgICCgICAfzcCACAGQQhqIwZBlc8AaiIHQQhqKAAANgAAIAYgBykAADcAACAGQQA6AAwgACAAQRBqIgc2AjAgACN4QQhqNgIAIAAgAEEEaiIINgIsIABBOGoQpgQaIAAgBDoAvhQgACADOgC9FCAAIAI6ALwUIABBuBRqQQA2AgAgAEIANwOwFCABKAIEIQQgASgCACEGIAUgAEGwFGo2AhACQCAGIARGDQADQCAFIAYoAgAiASABKAIAKAIMEQAANgIAIAVBEGogBRC+CBogBkEEaiIGIARHDQALCwJAAkAgACwAK0F/Sg0AIABBAjYCJCAAKAIgIQYMAQsgAEEgaiEGIABBAjoAKwsgBkEAOgACIAZBw6ABOwAAAkAgACgCtBQgACgCsBQiBkYNAEEAIQMDQCAFQQA2AhggBUIANwMQIAVBADYCCCAFQgA3AwAgACAGIANBAnRqKAIAIAVBEGogBRC2CgJAIAAoAgQiAUUNACABIQQCQCAAKAIIIgYgAUYNAANAIAZBdGoiBiAGKAIAKAIAEQAAGiAGIAFHDQALIAgoAgAhBAsgACABNgIIIAQQ0BsLIAAgBSgCEDYCBCAAIAUoAhQ2AgggACAFKAIYNgIMQQAhASAFQQA2AhggBUIANwMQAkAgACgCECIERQ0AIAQhAQJAIAAoAhQiBiAERg0AA0AgBkF0aiIGIAYoAgAoAgARAAAaIAYgBEcNAAsgBygCACEBCyAAIAQ2AhQgARDQGyAFKAIQIQELIAAgBSgCADYCECAAIAUoAgQ2AhQgACAFKAIINgIYAkAgAUUNACABIQQCQCAFKAIUIgYgAUYNAANAIAZBdGoiBiAGKAIAKAIAEQAAGiAGIAFHDQALIAUoAhAhBAsgBSABNgIUIAQQ0BsLIANBAWoiAyAAKAK0FCAAKAKwFCIGa0ECdUkNAAsLQQAhA0EAIQYCQCAAQQhqKAIAIgcgACgCBCIIayIBQQ1IDQAgAUEMbiEGQQAhAQNAIAFBAWohASAGQQNLIQQgBkEBdiEGIAQNAAsgAUEBdCEGCyAIIAcgBUEQaiAGEN0IAkAgAEEUaigCACIHIAAoAhAiCGsiBkENSA0AIAZBDG4hBkEAIQEDQCABQQFqIQEgBkEDSyEEIAZBAXYhBiAEDQALIAFBAXQhAwsgCCAHIAVBEGogAxDeCCAFQSBqJAAgAAv+AQEGfwJAIAAoAgQiAiAAKAIIIgNPDQAgAiABKAIANgIAIAAgAkEEajYCBA8LAkACQCACIAAoAgAiBGsiBUECdSIGQQFqIgJBgICAgARPDQACQAJAIAMgBGsiA0EBdSIHIAIgByACSxtB/////wMgA0H8////B0kbIgMNAEEAIQIMAQsgA0GAgICABE8NAiADQQJ0EM4bIQILIAIgBkECdGoiBiABKAIANgIAIAIgA0ECdGohASAGQQRqIQMCQCAFQQFIDQAgAiAEIAX8CgAACyAAIAE2AgggACADNgIEIAAgAjYCAAJAIARFDQAgBBDQGwsPCyAAEPUFAAsQZAALvQEBAn8jAEHgAGsiAiQAIAJBCGogAkHYAGogARDXGCIBIAAQggogARDYGBoCQCACLQAIDQAjBiEBI3koAgQhAyACQShqIAJBGGogAUHvmgFqEHcgAxCtBiACQThqIAJBKGogAUHg4QBqEK0GIAJByABqIAJBOGogABDXBiEAIAJCoIWAgPAGNwMQIAIgAUGjwgBqNgIMIAIgAUHcMWo2AgggACACQQhqEPQEAAsgAi0ACSEAIAJB4ABqJAAgAAvEEAENfwNAIAFBfGohBCABQXhqIQUgAUF0aiEGAkADQAJAAkACQAJAAkAgASAAayIHQQxtIggOBgYGAAECAwQLIAFBeGoiBygCACIIIAAoAgQiCU8NBSAAIAg2AgQgACgCCCEIIAAgAUF8aiIKKAIANgIIIAcgCTYCACAKIAg2AgAPCyABQXhqIgkoAgAhBwJAIABBEGooAgAiCCAAKAIEIgpJDQAgByAITw0FIAAgBzYCECAAQRRqIgcoAgAhCiAHIAFBfGoiCygCADYCACAJIAg2AgAgCyAKNgIAIAAoAhAiByAAKAIEIghPDQUgACAHNgIEIAAgCDYCECAAKAIUIQcgACAAKAIINgIUIAAgBzYCCA8LIAAoAgghCwJAIAcgCE8NACAAIAc2AgQgACABQXxqIgcoAgA2AgggCSAKNgIAIAcgCzYCAA8LIAAgCDYCBCAAIAo2AhAgAEEUaiIHKAIAIQggByALNgIAIAAgCDYCCCAJKAIAIgcgCk8NBCAAIAc2AhAgACABQXxqIgcoAgA2AhQgCSAKNgIAIAcgCzYCAA8LIAAgAEEMaiAAQRhqIAFBdGogAhDKCRoPCyAAIABBDGogAEEYaiAAQSRqIAIQygkaIAFBeGoiBygCACIIIABBKGooAgAiCU8NAiAAIAg2AiggAEEsaiIIKAIAIQogCCABQXxqIgsoAgA2AgAgByAJNgIAIAsgCjYCACAAKAIoIgcgAEEcaigCACIITw0CIAAgBzYCHCAAIAg2AiggACgCLCEIIAAgAEEgaiIJKAIANgIsIAkgCDYCACAHIABBEGooAgAiCU8NAiAAIAk2AhwgACAHNgIQIAAgAEEUaiIJKAIANgIgIAkgCDYCACAHIAAoAgQiCU8NAiAAIAk2AhAgACAHNgIEIAAgACgCCDYCFCAAIAg2AggMAgsCQCAHQdMASg0AIAAgASACEMsJDwsCQCADDQAgACABIAEgAhDMCQ8LIAAgCEEBdkEMbCIJaiEMAkACQCAHQdXdAEkNACAAIAAgCEECdkEMbCIHaiIIIAwgDCAHaiIHIAIQygkhDSAFKAIAIgkgBygCBCIKTw0BIAcgCTYCBCAHKAIIIQkgByAEKAIANgIIIAUgCjYCACAEIAk2AgACQCAHKAIEIgkgDCgCBCIKSQ0AIA1BAWohDQwCCyAMKAIIIQsgDCAJNgIEIAwgBygCCDYCCCAHIAs2AgggByAKNgIEAkAgDCgCBCIHIAgoAgQiCUkNACANQQJqIQ0MAgsgCCgCCCEKIAggBzYCBCAIIAxBCGoiBygCADYCCCAMIAk2AgQgByAKNgIAAkAgCCgCBCIHIAAoAgQiCUkNACANQQNqIQ0MAgsgACAHNgIEIAAoAgghByAAIAhBCGoiCigCADYCCCAIIAk2AgQgCiAHNgIAIA1BBGohDQwBCyAFKAIAIQcCQAJAIAwoAgQiCCAAKAIEIgpJDQBBACENIAcgCE8NAiAMKAIIIQkgDCAHNgIEIAwgBCgCADYCCCAFIAg2AgAgBCAJNgIAQQEhDSAMKAIEIgcgACgCBCIITw0CIAAgBzYCBCAAKAIIIQcgACAMQQhqIgkoAgA2AgggDCAINgIEIAkgBzYCAAwBCyAAKAIIIQsCQCAHIAhPDQAgACAHNgIEIAAgBCgCADYCCCAFIAo2AgAgBCALNgIAQQEhDQwCCyAAIAg2AgQgAEEIaiIHIAcgCWoiBygCADYCACAMIAo2AgQgByALNgIAQQEhDSAFKAIAIgggCk8NASAMIAg2AgQgByAEKAIANgIAIAUgCjYCACAEIAs2AgALQQIhDQsgA0F/aiEDIAYhCAJAAkACQAJAIAAoAgQiDiAMKAIEIglPDQAgBiEIDAELA0ACQCAAIAgiB0F0aiIIRw0AIABBDGohCCAOIAUoAgAiCUkNAyAIIAZGDQYDQAJAIA4gCCgCBCIHTw0AIAggCTYCBCAIKAIIIQkgCCAEKAIANgIIIAUgBzYCACAEIAk2AgAgCEEMaiEIDAULIAhBDGoiCCAGRg0HDAALAAsgB0F4aiIKKAIAIgsgCU8NAAsgACALNgIEIAAoAgghCSAAIAdBfGoiBygCADYCCCAKIA42AgAgByAJNgIAIA1BAWohDQsCQCAAQQxqIgogCE8NAANAIAwoAgQhCQNAIAoiB0EMaiEKIAcoAgQiCyAJSQ0ACwNAIAgiDkF0aiIIQQRqIg8oAgAiECAJTw0ACwJAIAcgCE0NACAHIQoMAgsgByAQNgIEIAcoAgghCSAHIA5BfGoiDigCADYCCCAPIAs2AgAgDiAJNgIAIAggDCAMIAdGGyEMIA1BAWohDQwACwALAkAgCiAMRg0AIAwoAgQiByAKKAIEIghPDQAgCiAHNgIEIAooAgghByAKIAwoAgg2AgggDCAHNgIIIAwgCDYCBCANQQFqIQ0LAkAgDQ0AIAAgCiACEM0JIQkCQCAKQQxqIgcgASACEM0JRQ0AIAohASAJRQ0GDAULQQIhCCAJDQILAkAgCiAAa0EMbSABIAprQQxtTg0AIAAgCiACIAMQ3QggCkEMaiEADAMLIApBDGogASACIAMQ3QggCiEBDAQLIAYhCSAIIAZGDQIDQCAAKAIEIQoDQCAIIgdBDGohCCAKIAcoAgQiC08NAAsDQCAKIAkiDkF0aiIJQQRqIg8oAgAiEEkNAAsCQCAHIAlJDQBBBCEIDAILIAcgEDYCBCAHKAIIIQogByAOQXxqIg4oAgA2AgggDyALNgIAIA4gCjYCAAwACwALIAchACAIQQRGDQAgByEAIAhBAkYNAAsLCwvEEAENfwNAIAFBfGohBCABQXhqIQUgAUF0aiEGAkADQAJAAkACQAJAAkAgASAAayIHQQxtIggOBgYGAAECAwQLIAFBeGoiBygCACIIIAAoAgQiCU8NBSAAIAg2AgQgACgCCCEIIAAgAUF8aiIKKAIANgIIIAcgCTYCACAKIAg2AgAPCyABQXhqIgkoAgAhBwJAIABBEGooAgAiCCAAKAIEIgpJDQAgByAITw0FIAAgBzYCECAAQRRqIgcoAgAhCiAHIAFBfGoiCygCADYCACAJIAg2AgAgCyAKNgIAIAAoAhAiByAAKAIEIghPDQUgACAHNgIEIAAgCDYCECAAKAIUIQcgACAAKAIINgIUIAAgBzYCCA8LIAAoAgghCwJAIAcgCE8NACAAIAc2AgQgACABQXxqIgcoAgA2AgggCSAKNgIAIAcgCzYCAA8LIAAgCDYCBCAAIAo2AhAgAEEUaiIHKAIAIQggByALNgIAIAAgCDYCCCAJKAIAIgcgCk8NBCAAIAc2AhAgACABQXxqIgcoAgA2AhQgCSAKNgIAIAcgCzYCAA8LIAAgAEEMaiAAQRhqIAFBdGogAhDOCRoPCyAAIABBDGogAEEYaiAAQSRqIAIQzgkaIAFBeGoiBygCACIIIABBKGooAgAiCU8NAiAAIAg2AiggAEEsaiIIKAIAIQogCCABQXxqIgsoAgA2AgAgByAJNgIAIAsgCjYCACAAKAIoIgcgAEEcaigCACIITw0CIAAgBzYCHCAAIAg2AiggACgCLCEIIAAgAEEgaiIJKAIANgIsIAkgCDYCACAHIABBEGooAgAiCU8NAiAAIAk2AhwgACAHNgIQIAAgAEEUaiIJKAIANgIgIAkgCDYCACAHIAAoAgQiCU8NAiAAIAk2AhAgACAHNgIEIAAgACgCCDYCFCAAIAg2AggMAgsCQCAHQdMASg0AIAAgASACEM8JDwsCQCADDQAgACABIAEgAhDQCQ8LIAAgCEEBdkEMbCIJaiEMAkACQCAHQdXdAEkNACAAIAAgCEECdkEMbCIHaiIIIAwgDCAHaiIHIAIQzgkhDSAFKAIAIgkgBygCBCIKTw0BIAcgCTYCBCAHKAIIIQkgByAEKAIANgIIIAUgCjYCACAEIAk2AgACQCAHKAIEIgkgDCgCBCIKSQ0AIA1BAWohDQwCCyAMKAIIIQsgDCAJNgIEIAwgBygCCDYCCCAHIAs2AgggByAKNgIEAkAgDCgCBCIHIAgoAgQiCUkNACANQQJqIQ0MAgsgCCgCCCEKIAggBzYCBCAIIAxBCGoiBygCADYCCCAMIAk2AgQgByAKNgIAAkAgCCgCBCIHIAAoAgQiCUkNACANQQNqIQ0MAgsgACAHNgIEIAAoAgghByAAIAhBCGoiCigCADYCCCAIIAk2AgQgCiAHNgIAIA1BBGohDQwBCyAFKAIAIQcCQAJAIAwoAgQiCCAAKAIEIgpJDQBBACENIAcgCE8NAiAMKAIIIQkgDCAHNgIEIAwgBCgCADYCCCAFIAg2AgAgBCAJNgIAQQEhDSAMKAIEIgcgACgCBCIITw0CIAAgBzYCBCAAKAIIIQcgACAMQQhqIgkoAgA2AgggDCAINgIEIAkgBzYCAAwBCyAAKAIIIQsCQCAHIAhPDQAgACAHNgIEIAAgBCgCADYCCCAFIAo2AgAgBCALNgIAQQEhDQwCCyAAIAg2AgQgAEEIaiIHIAcgCWoiBygCADYCACAMIAo2AgQgByALNgIAQQEhDSAFKAIAIgggCk8NASAMIAg2AgQgByAEKAIANgIAIAUgCjYCACAEIAs2AgALQQIhDQsgA0F/aiEDIAYhCAJAAkACQAJAIAAoAgQiDiAMKAIEIglPDQAgBiEIDAELA0ACQCAAIAgiB0F0aiIIRw0AIABBDGohCCAOIAUoAgAiCUkNAyAIIAZGDQYDQAJAIA4gCCgCBCIHTw0AIAggCTYCBCAIKAIIIQkgCCAEKAIANgIIIAUgBzYCACAEIAk2AgAgCEEMaiEIDAULIAhBDGoiCCAGRg0HDAALAAsgB0F4aiIKKAIAIgsgCU8NAAsgACALNgIEIAAoAgghCSAAIAdBfGoiBygCADYCCCAKIA42AgAgByAJNgIAIA1BAWohDQsCQCAAQQxqIgogCE8NAANAIAwoAgQhCQNAIAoiB0EMaiEKIAcoAgQiCyAJSQ0ACwNAIAgiDkF0aiIIQQRqIg8oAgAiECAJTw0ACwJAIAcgCE0NACAHIQoMAgsgByAQNgIEIAcoAgghCSAHIA5BfGoiDigCADYCCCAPIAs2AgAgDiAJNgIAIAggDCAMIAdGGyEMIA1BAWohDQwACwALAkAgCiAMRg0AIAwoAgQiByAKKAIEIghPDQAgCiAHNgIEIAooAgghByAKIAwoAgg2AgggDCAHNgIIIAwgCDYCBCANQQFqIQ0LAkAgDQ0AIAAgCiACENEJIQkCQCAKQQxqIgcgASACENEJRQ0AIAohASAJRQ0GDAULQQIhCCAJDQILAkAgCiAAa0EMbSABIAprQQxtTg0AIAAgCiACIAMQ3gggCkEMaiEADAMLIApBDGogASACIAMQ3gggCiEBDAQLIAYhCSAIIAZGDQIDQCAAKAIEIQoDQCAIIgdBDGohCCAKIAcoAgQiC08NAAsDQCAKIAkiDkF0aiIJQQRqIg8oAgAiEEkNAAsCQCAHIAlJDQBBBCEIDAILIAcgEDYCBCAHKAIIIQogByAOQXxqIg4oAgA2AgggDyALNgIAIA4gCjYCAAwACwALIAchACAIQQRGDQAgByEAIAhBAkYNAAsLCwsKACAAEJkdENAbC+0BAQN/IAAjY0EIajYCAAJAIAAoAkAiAUUNACABQXxqKAIAEMoPCyAAIyBBCGo2AgACQCAALAArQX9KDQAgACgCIBDQGwsCQCAAKAIQIgJFDQAgAiEDAkAgAEEUaigCACIBIAJGDQADQCABQXRqIgEgASgCACgCABEAABogASACRw0ACyAAKAIQIQMLIAAgAjYCFCADENAbCwJAIAAoAgQiAkUNACACIQMCQCAAQQhqKAIAIgEgAkYNAANAIAFBdGoiASABKAIAKAIAEQAAGiABIAJHDQALIAAoAgQhAwsgACACNgIIIAMQ0BsLIAAL8AEBA38gACNjQQhqNgIAAkAgACgCQCIBRQ0AIAFBfGooAgAQyg8LIAAjIEEIajYCAAJAIAAsACtBf0oNACAAKAIgENAbCwJAIAAoAhAiAkUNACACIQMCQCAAQRRqKAIAIgEgAkYNAANAIAFBdGoiASABKAIAKAIAEQAAGiABIAJHDQALIAAoAhAhAwsgACACNgIUIAMQ0BsLAkAgACgCBCICRQ0AIAIhAwJAIABBCGooAgAiASACRg0AA0AgAUF0aiIBIAEoAgAoAgARAAAaIAEgAkcNAAsgACgCBCEDCyAAIAI2AgggAxDQGwsgABDQGwtIAQF/IABBNEE4IAEgASgCACgCCBEAABtqKAIAIQIgACgCECgCBCAAKAIEKAIEIAEgASgCACgCXBEAACABKAIwKQMAIAIREwALSQECfyNjIQFBzAAQzhsgABDrBiICIAFBCGo2AgAgAiAAKQI0NwI0IAJBPGogAEE8aigCADYCACACQcAAaiAAQcAAahDmBRogAgvIAwEIfyAAQcgAaigCACECIAAoAkAhAwJAAkACQCABKAIEIABBxABqKAIAIgBHDQAgASgCCCACRg0BCwJAIABFDQAgAkUNAEH/////ByACbSAASA0CCyABIAIgAGwgACACEGkgASgCCCECIAEoAgQhAAsCQCAAIAJsIgBBAUgNACABKAIAIQIgAEEDcSEEQQAhBUEAIQECQCAAQX9qQQNJDQAgAEF8cSEGQQAhAUEAIQcDQCACIAFBBHQiAGoiCCADIABqIgkpAwA3AwAgCEEIaiAJQQhqKQMANwMAIAIgAEEQciIIaiIJQQhqIAMgCGoiCEEIaikDADcDACAJIAgpAwA3AwAgAiAAQSByIghqIglBCGogAyAIaiIIQQhqKQMANwMAIAkgCCkDADcDACACIABBMHIiAGoiCEEIaiADIABqIgBBCGopAwA3AwAgCCAAKQMANwMAIAFBBGohASAHQQRqIgcgBkcNAAsLIARFDQADQCACIAFBBHQiAGoiByADIABqIgApAwA3AwAgB0EIaiAAQQhqKQMANwMAIAFBAWohASAFQQFqIgUgBEcNAAsLDwsjbiEBI28hA0EEEBQQkx0gAyABEBUAC+QIAQh/IwBB0ABrIgIkACAAQgA3AgAgAEEIakEANgIAQRAQzhsiA0EwEM4bIgQ2AgQgBCAEQShqIgU2AiwgBCAEQRxqIgY2AiQgBCAGNgIgIARBADYCHCAEIAU2AiggA0EANgIMIAAgAzYCDCACQQA6ACQgAkHuwrWrBjYCICACQYTcADsAKyACIAJBIGo2AjAgAkEQakEIakEANgIAIAJCADcDEAJAIAFBJGooAgAgAS0AKyIEIATAQQBIIgUbIgRBBGoiA0FwTw0AIAEoAiAhBgJAAkACQCADQQtJDQAgA0EPckEBaiIHEM4bIQMgAiAHQYCAgIB4cjYCGCACIAM2AhAgAiAENgIUDAELIAIgBDoAGyACQRBqIQMgBEUNAQsgAyAGIAFBIGogBRsgBPwKAAALIAMgBGpBADoAACACQRBqIwZB0dMAakEEEP4bGiACQcgAakEANgIAIAJCADcDQEEQEM4bIgNBMBDOGyIENgIEIAQgBEEoaiIFNgIsIAQgBEEcaiIGNgIkIAQgBjYCICAEQQA2AhwgBCAFNgIoIANBADYCDCACIAM2AkwgACACQSBqIAJBwABqEOYIIQQgAkHAAGoQ1wQaIAQgAkEQahDnCAJAIAIsABtBf0oNACACKAIQENAbCwJAIAIsACtBf0oNACACKAIgENAbCyACQRAQzhsiBDYCICACQo2AgICAgoCAgH83AiQgBEEFaiMGQcElaiIDQQVqKQAANwAAIAQgAykAADcAACAEQQA6AA0gAiAENgIwIAJBLjoALCACIAEoAhAoAgQ2AgwgAkEQaiACQThqENYYIgYQ1xghAyACQcAAakEIaiIHQQA2AgAgAkIANwNAQRAQzhsiBUEwEM4bIgQ2AgQgBCAEQShqIgg2AiwgBCAEQRxqIgk2AiQgBCAJNgIgIARBADYCHCAEIAg2AiggBUEANgIMIAIgBTYCTCAAIAJBIGogAkHAAGoQ5gghBCACQcAAahDXBBogBCACQQxqIAJBwABqIAMQ1xgiBRCaBSAFENgYGiADENgYGiAGENgYGgJAIAIsACtBf0oNACACKAIgENAbCyACQRAQzhsiBDYCICACQoyAgICAgoCAgH83AiQgBEEIaiMGQaUlaiIDQQhqKAAANgAAIAQgAykAADcAACAEQQA6AAwgAiAENgIwIAJBLjoALCACIAEoAgQoAgQ2AgwgAkEQaiACQThqENYYIgUQ1xghASAHQQA2AgAgAkIANwNAQRAQzhsiA0EwEM4bIgQ2AgQgBCAEQShqIgY2AiwgBCAEQRxqIgc2AiQgBCAHNgIgIARBADYCHCAEIAY2AiggA0EANgIMIAIgAzYCTCAAIAJBIGogAkHAAGoQ5gghBCACQcAAahDXBBogBCACQQxqIAJBwABqIAEQ1xgiABCaBSAAENgYGiABENgYGiAFENgYGgJAIAIsACtBf0oNACACKAIgENAbCyACQdAAaiQADwsgAkEQahB2AAv0BAEEfyMAQdAAayIDJAACQAJAIAEsAAsiBEEASA0AIANBOGpBCGogAUEIaigCADYCACADIAEpAgA3AzgMAQsgA0E4aiABKAIAIAEoAgQQ+hsgAS0ACyEECyADIAEtAAw6AEQgAyADKAI4IANBOGogAywAQ0EASBsgASgCECABKAIAIAEgBMBBAEgba2o2AkggACADQThqEOgEIQAgA0EoaiADQThqEOkEAkACQCADLAAzQQBIDQAgA0EIakEIaiADQShqQQhqKAIANgIAIAMgAykDKDcDCAwBCyADQQhqIAMoAiggAygCLBD6GwsgA0EUaiEEAkACQCACLAALQQBIDQAgBCACKQIANwIAIARBCGogAkEIaigCADYCAAwBCyAEIAIoAgAgAigCBBD6GwtBEBDOGyEBIAIoAgwhAkEwEM4bIQUgAUEANgIMIAEgBTYCBCABIAIQnQUgA0EgaiABNgIAIAAoAgwiAigCBCEAIANBADYCTAJAIAJBCGogA0EIaiADQcwAahDtBCIBIAMoAkxHDQAgAigCBCIGKAIoIQUgASAGQShqNgIsIAEgBTYCKCAGIAFBKGoiBTYCKCABKAIoIAU2AgQgAiACKAIMQQFqNgIMIAIoAgQgAEYNACABKAIoIAEoAiw2AgQgASgCLCABKAIoNgIAIAAoAighAiABIABBKGo2AiwgASACNgIoIAAgBTYCKCABKAIoIAU2AgQLIAQQ1wQaAkAgAywAE0F/Sg0AIAMoAggQ0BsLAkAgAywAM0F/Sg0AIAMoAigQ0BsLAkAgAywAQ0F/Sg0AIAMoAjgQ0BsLIANB0ABqJAAgAUEMaguaAgEDfyMAQRBrIgIkACACQQA6AAAgAkEEciEDAkACQCABLAALQQBIDQAgAyABKQIANwIAIANBCGogAUEIaigCADYCAAwBCyADIAEoAgAgASgCBBD6GwsgAkEBOgAAAkACQAJAIAMgAEYNACACQQ9qLQAAIgTAIQECQAJAIAAsAAtBAEgNAAJAIAFBAEgNACAAIAMpAgA3AgAgAEEIaiADQQhqKAIANgIADAILIAAgAigCBCACQQhqKAIAEIUcGgwBCyAAIAIoAgQgAyABQQBIIgEbIAJBCGooAgAgBCABGxCEHBoLIAItAABFDQIgAkEPaiwAAEEASA0BDAILIAJBD2osAABBf0oNAQsgAigCBBDQGwsgAkEQaiQAC+ABAQV/IwBBIGsiASQAIABBIGohAgJAAkACQCAAQSRqKAIAIgMgAC0AKyIEIATAIgVBAEgbQQJHDQAgAkEAQX8jBkG95ABqQQIQiRxFDQEgACgCJCEDIAAtACsiBCEFCyADIAQgBcBBAEgbQQRHDQEgAkEAQX8jBkHO5QBqQQQQiRwNAQsgACAAKAIAKAIMEQAAIQAgAUEgaiQAIAAPCyMGIQBBCBAUIQQgASAAQZWiAWogAhCYHCABQRBqIAEgAEG83wBqEK0GIxIhACMTIQIgBCABQRBqEMkGIAIgABAVAAvtAQEDfyAAI2lBCGo2AgACQCAAKAJAIgFFDQAgAUF8aigCABDKDwsgACMgQQhqNgIAAkAgACwAK0F/Sg0AIAAoAiAQ0BsLAkAgACgCECICRQ0AIAIhAwJAIABBFGooAgAiASACRg0AA0AgAUF0aiIBIAEoAgAoAgARAAAaIAEgAkcNAAsgACgCECEDCyAAIAI2AhQgAxDQGwsCQCAAKAIEIgJFDQAgAiEDAkAgAEEIaigCACIBIAJGDQADQCABQXRqIgEgASgCACgCABEAABogASACRw0ACyAAKAIEIQMLIAAgAjYCCCADENAbCyAAC/ABAQN/IAAjaUEIajYCAAJAIAAoAkAiAUUNACABQXxqKAIAEMoPCyAAIyBBCGo2AgACQCAALAArQX9KDQAgACgCIBDQGwsCQCAAKAIQIgJFDQAgAiEDAkAgAEEUaigCACIBIAJGDQADQCABQXRqIgEgASgCACgCABEAABogASACRw0ACyAAKAIQIQMLIAAgAjYCFCADENAbCwJAIAAoAgQiAkUNACACIQMCQCAAQQhqKAIAIgEgAkYNAANAIAFBdGoiASABKAIAKAIAEQAAGiABIAJHDQALIAAoAgQhAwsgACACNgIIIAMQ0BsLIAAQ0BsLSgEBfyAAQTRBOCABIAEoAgAoAggRAAAbaigCACECIAAoAgQiACgCBCAAQRBqKAIAIAEgASgCACgCXBEAACABKAIwKQMAIAIREwALSQECfyNpIQFBzAAQzhsgABDrBiICIAFBCGo2AgAgAiAAKQI0NwI0IAJBPGogAEE8aigCADYCACACQcAAaiAAQcAAahDmBRogAgvIAwEIfyAAQcgAaigCACECIAAoAkAhAwJAAkACQCABKAIEIABBxABqKAIAIgBHDQAgASgCCCACRg0BCwJAIABFDQAgAkUNAEH/////ByACbSAASA0CCyABIAIgAGwgACACEGkgASgCCCECIAEoAgQhAAsCQCAAIAJsIgBBAUgNACABKAIAIQIgAEEDcSEEQQAhBUEAIQECQCAAQX9qQQNJDQAgAEF8cSEGQQAhAUEAIQcDQCACIAFBBHQiAGoiCCADIABqIgkpAwA3AwAgCEEIaiAJQQhqKQMANwMAIAIgAEEQciIIaiIJQQhqIAMgCGoiCEEIaikDADcDACAJIAgpAwA3AwAgAiAAQSByIghqIglBCGogAyAIaiIIQQhqKQMANwMAIAkgCCkDADcDACACIABBMHIiAGoiCEEIaiADIABqIgBBCGopAwA3AwAgCCAAKQMANwMAIAFBBGohASAHQQRqIgcgBkcNAAsLIARFDQADQCACIAFBBHQiAGoiByADIABqIgApAwA3AwAgB0EIaiAAQQhqKQMANwMAIAFBAWohASAFQQFqIgUgBEcNAAsLDwsjbiEBI28hA0EEEBQQkx0gAyABEBUAC5sGAQZ/IwBBwABrIgIkACAAQgA3AgAgAEEIakEANgIAQRAQzhsiA0EwEM4bIgQ2AgQgBCAEQShqIgU2AiwgBCAEQRxqIgY2AiQgBCAGNgIgIARBADYCHCAEIAU2AiggA0EANgIMIAAgAzYCDCACQQA6ABwgAkHuwrWrBjYCGCACQYTcADsAIyACIAJBGGo2AiggAkEIakEIakEANgIAIAJCADcDCAJAIAFBJGooAgAgAS0AKyIEIATAQQBIIgUbIgRBBGoiA0FwTw0AIAEoAiAhBgJAAkACQCADQQtJDQAgA0EPckEBaiIHEM4bIQMgAiAHQYCAgIB4cjYCECACIAM2AgggAiAENgIMDAELIAIgBDoAEyACQQhqIQMgBEUNAQsgAyAGIAFBIGogBRsgBPwKAAALIAMgBGpBADoAACACQQhqIwZB0dMAakEEEP4bGiACQThqQQA2AgAgAkIANwMwQRAQzhsiA0EwEM4bIgQ2AgQgBCAEQShqIgU2AiwgBCAEQRxqIgY2AiQgBCAGNgIgIARBADYCHCAEIAU2AiggA0EANgIMIAIgAzYCPCAAIAJBGGogAkEwahDmCCEEIAJBMGoQ1wQaIAQgAkEIahDnCAJAIAIsABNBf0oNACACKAIIENAbCwJAIAIsACNBf0oNACACKAIYENAbCyACQQA2AhAgAkIANwMIIAFBCGooAgAhAyABKAIEIQQgAiACQQhqNgIYAkAgBCADRg0AA0AgAiAEKAIENgIwIAJBGGogAkEwahCVBBogBEEMaiIEIANHDQALCyACQSAQzhsiBDYCGCACQpGAgICAhICAgH83AhwgBEEQaiMGQfsNaiIDQRBqLQAAOgAAIARBCGogA0EIaikAADcAACAEIAMpAAA3AAAgBEEAOgARIAIgBDYCKCACQS46ACQgAkEwaiACQQhqEOkMIAAgAkEYaiACQTBqEOYIGiACQTBqENcEGgJAIAIsACNBf0oNACACKAIYENAbCwJAIAIoAggiBEUNACACIAQ2AgwgBBDQGwsgAkHAAGokAA8LIAJBCGoQdgALoQEBA38jAEEgayIBJAAgAEEgaiECAkAgAEEkaigCACAALQArIgMgA8BBAEgbQQRHDQAgAkEAQX8jBkGW5gBqQQQQiRwNACAAIAAoAgAoAgwRAAAhACABQSBqJAAgAA8LIwYhAEEIEBQhAyABIABBlaIBaiACEJgcIAFBEGogASAAQbzfAGoQrQYjEiEAIxMhAiADIAFBEGoQyQYgAiAAEBUAC+8BAQN/IAAjbEEIajYCAAJAIAAoAjQiAUUNACABIAEoAgAoAhARAwALIAAjIEEIajYCAAJAIAAsACtBf0oNACAAKAIgENAbCwJAIAAoAhAiAkUNACACIQMCQCAAQRRqKAIAIgEgAkYNAANAIAFBdGoiASABKAIAKAIAEQAAGiABIAJHDQALIAAoAhAhAwsgACACNgIUIAMQ0BsLAkAgACgCBCICRQ0AIAIhAwJAIABBCGooAgAiASACRg0AA0AgAUF0aiIBIAEoAgAoAgARAAAaIAEgAkcNAAsgACgCBCEDCyAAIAI2AgggAxDQGwsgAAsKACAAEPAIENAbC4ADAgV/AX4jAEEwayICJAAgACgCNCEDIAJBADYCICACQgA3AxggA0EIaigCACEEIAMoAgQhAyACIAJBGGo2AggCQAJAIAMgBEcNACACQQA2AhAgAkIANwMIDAELA0AgAiADKAIANgIoIAJBCGogAkEoahCVBBogA0EIaiIDIARHDQALIAAoAjQiA0EIaigCACEEIAMoAgQhAyACQQA2AhAgAkIANwMIIAIgAkEIajYCKCADIARGDQADQCACIAMoAgQ2AiQgAkEoaiACQSRqEJUEGiADQQhqIgMgBEcNAAsLIAEgASgCACgCCBEAACEDIAIoAhwgAigCGCIEa0ECdSEAIAIoAgghBSABIAEoAgAoAlwRAAAhBiABKAIwKQMAIQcCQAJAIANFDQAgBCAFIAAgBiAHEL4ODAELIAQgBSAAIAYgBxCPDgsCQCACKAIIIgNFDQAgAiADNgIMIAMQ0BsLAkAgAigCGCIDRQ0AIAIgAzYCHCADENAbCyACQTBqJAALHABBOBDOGyAAKAI0IgAgACgCACgCJBEAABCtCAuYAQECfyMAQSBrIgIkACAAKAI0IQAgAkEANgIQIAJCADcDCCAAQQhqKAIAIQMgACgCBCEAIAIgAkEIajYCGAJAIAAgA0YNAANAIAIgACgCBDYCFCACQRhqIAJBFGoQlQQaIABBCGoiACADRw0ACwsgASACQQhqEOIMAkAgAigCCCIARQ0AIAIgADYCDCAAENAbCyACQSBqJAAL5QMBB38jAEHAAGsiAiQAIABCADcCACAAQQhqQQA2AgBBEBDOGyIDQTAQzhsiBDYCBCAEIARBKGoiBTYCLCAEIARBHGoiBjYCJCAEIAY2AiAgBEEANgIcIAQgBTYCKCADQQA2AgwgACADNgIMIAJBADoADCACQe7CtasGNgIIIAJBhNwAOwATIAIgAkEIajYCGCACQShqIAJBIGoQ1hgiBhDXGCEDIAJBMGpBCGpBADYCACACQgA3AzBBEBDOGyIFQTAQzhsiBDYCBCAEIARBKGoiBzYCLCAEIARBHGoiCDYCJCAEIAg2AiAgBEEANgIcIAQgBzYCKCAFQQA2AgwgAiAFNgI8IwYhBCAAIAJBCGogAkEwahDmCCEFIAJBMGoQ1wQaIAUgBEH60QBqIAJBMGogAxDXGCIEEPYIIAQQ2BgaIAMQ2BgaIAYQ2BgaAkAgAiwAE0F/Sg0AIAIoAggQ0BsLIAJBhdwAOwATIAJBADoADSACIwZBqDxqIgQoAAA2AgggAiAEQQRqLQAAOgAMIAIgAkEIajYCGCACQTBqIAEoAjQiBCAEKAIAKAIwEQEAIAAgAkEIaiACQTBqEOYIGiACQTBqENcEGgJAIAIsABNBf0oNACACKAIIENAbCyACQcAAaiQAC/MCAQJ/IwBB8ABrIgMkACADQeAAaiACIAEQ9wgCQCADLQBgRQ0AAkACQAJAIANB4ABqQQRyIgEgAEYNACADQe8Aai0AACIEwCECAkACQCAALAALQQBIDQACQCACQQBIDQAgACABKQIANwIAIABBCGogAUEIaigCADYCAAwCCyAAIAMoAmQgA0HoAGooAgAQhRwaDAELIAAgAygCZCABIAJBAEgiAhsgA0HoAGooAgAgBCACGxCEHBoLIAMtAGBFDQIgA0HvAGosAABBAEgNAQwCCyADQe8AaiwAAEF/Sg0BCyADKAJkENAbCyADQfAAaiQADwsjBiEAI3ohASADQTBqIANBIGogAEGMmwFqEHcgARCtBiADQcAAaiADQTBqIABBz+EAahCtBiADQQA2AhggA0HQAGogA0HAAGogA0EYahDzBCEBIANCvIaAgLAGNwMQIAMgAEGZwgBqNgIMIAMgAEHcMWo2AgggASADQQhqEPQEAAv1AwEFfyMAQbABayIDJAAgAyMZIgRBIGoiBTYCWCADIxoiBigCBCIHNgIgIANBIGogB0F0aigCAGogBigCCDYCACADQSBqIAMoAiBBdGooAgBqIgYgA0EgakEEciIHEMMSIAZCgICAgHA3AkggAyAFNgJYIAMgBEEMajYCICMMIQUgBxCMECIEIAVBCGo2AgAgA0HMAGpCADcCACADQcQAakIANwIAIANB1ABqQRA2AgAgA0EYaiADQSBqIAMoAiBBdGooAgBqIgUQuxIgA0EIaiAFIAEQuhIgA0EIahDYGBoCQCAFKAIYIgVFDQAgBSABIAUoAgAoAggRAQAgA0GoAWogBUEEaiIFENcYIQYgBSABENkYGiAGENgYGgsgA0EYahDYGBogA0EgaiACIAIQpg8QxAQaAkACQCADQSBqIAMoAiBBdGooAgBqLQAQQQVxDQAgA0EIaiAEEMMRIABBDGogA0EQaigCADYCACAAIAMpAwg3AgQgAEEBOgAADAELIABBADoAAAsgA0HYAGohASADIxoiAigCACIFNgIgIANBIGogBUF0aigCAGogAigCDDYCACAEIwxBCGo2AgACQCADLABPQX9KDQAgAygCRBDQGwsgBBCKEBogA0EgaiMaQQRqENQQGiABEIMQGiADQbABaiQAC+8BAQN/IAAjbUEIajYCAAJAIAAoAkAiAUUNACABIAEoAgAoAhARAwALIAAjIEEIajYCAAJAIAAsACtBf0oNACAAKAIgENAbCwJAIAAoAhAiAkUNACACIQMCQCAAQRRqKAIAIgEgAkYNAANAIAFBdGoiASABKAIAKAIAEQAAGiABIAJHDQALIAAoAhAhAwsgACACNgIUIAMQ0BsLAkAgACgCBCICRQ0AIAIhAwJAIABBCGooAgAiASACRg0AA0AgAUF0aiIBIAEoAgAoAgARAAAaIAEgAkcNAAsgACgCBCEDCyAAIAI2AgggAxDQGwsgAAsKACAAEPgIENAbC40DAwV/AXwBfiMAQTBrIgIkACAAKAJAIQMgAkEANgIgIAJCADcDGCADQQhqKAIAIQQg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AgggASADQQhqEPQEAAsjAEHIABDOGyAAKwM4miAAKAJAIgAgACgCACgCJBEAABCvCAv1AwEFfyMAQbABayIDJAAgAyMZIgRBIGoiBTYCWCADIxoiBigCBCIHNgIgIANBIGogB0F0aigCAGogBigCCDYCACADQSBqIAMoAiBBdGooAgBqIgYgA0EgakEEciIHEMMSIAZCgICAgHA3AkggAyAFNgJYIAMgBEEMajYCICMMIQUgBxCMECIEIAVBCGo2AgAgA0HMAGpCADcCACADQcQAakIANwIAIANB1ABqQRA2AgAgA0EYaiADQSBqIAMoAiBBdGooAgBqIgUQuxIgA0EIaiAFIAEQuhIgA0EIahDYGBoCQCAFKAIYIgVFDQAgBSABIAUoAgAoAggRAQAgA0GoAWogBUEEaiIFENcYIQYgBSABENkYGiAGENgYGgsgA0EYahDYGBogA0EgaiACIAIQpg8QxAQaAkACQCADQSBqIAMoAiBBdGooAgBqLQAQQQVxDQAgA0EIaiAEEMMRIABBDGogA0EQaigCADYCACAAIAMpAwg3AgQgAEEBOgAADAELIABBADoAAAsgA0HYAGohASADIxoiAigCACIFNgIgIANBIGogBUF0aigCAGogAigCDDYCACAEIwxBCGo2AgACQCADLABPQX9KDQAgAygCRBDQGwsgBBCKEBogA0EgaiMaQQRqENQQGiABEIMQGiADQbABaiQAC5wCAQN/IAAjcEEIajYCAAJAAkACQCAAQcgAaigCACIBIABBOGoiAkcNACACKAIAQRBqIQMMAQsgAUUNASABKAIAQRRqIQMgASECCyACIAMoAgARAwALIAAjIEEIajYCAAJAIAAsACtBf0oNACAAKAIgENAbCwJAIAAoAhAiAUUNACABIQMCQCAAQRRqKAIAIgIgAUYNAANAIAJBdGoiAiACKAIAKAIAEQAAGiACIAFHDQALIAAoAhAhAwsgACABNgIUIAMQ0BsLAkAgACgCBCIBRQ0AIAEhAwJAIABBCGooAgAiAiABRg0AA0AgAkF0aiICIAIoAgAoAgARAAAaIAIgAUcNAAsgACgCBCEDCyAAIAE2AgggAxDQGwsgAAufAgEDfyAAI3BBCGo2AgACQAJAAkAgAEHIAGooAgAiASAAQThqIgJHDQAgAigCAEEQaiEDDAELIAFFDQEg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NwIAAkACQCABQbQUaigCACICIAEoArAUIgNGDQAgAiADayIBQX9MDQEgACABEM4bIgI2AgAgACACIAFBA3VBA3RqNgIIIAIgAyAB/AoAACAAIAIgAWo2AgQLDwsgABDPBAALcQECfyAAQQA2AgggAEIANwIAAkACQCABQcwUaigCACICIAEoAsgUIgNGDQAgAiADayIBQX9MDQEgACABEM4bIgI2AgAgACACIAFBAnVBAnRqNgIIIAIgAyAB/AoAACAAIAIgAWo2AgQLDwsgABCTBgAL3woCDH8BfCMAQSBrIgEkACAAQcwUaigCACECIAAoAsgUIQNBACEEIAFBADYCGCABQgA3AxAgAiADayIFQQJ1IQZBACEHQQAhAgJAAkACQAJAIAVBAUgNACAGQQEgBkEBShshCEEAIQJBACEDAkACQANAIAAoArAUIANBA3RqKwMAIQ0CQAJAIAIgASgCGCIJTw0AIAIgAzYCCCACIA05AwAgASACQRBqIgI2AhQMAQsgAiABKAIQIgprIgtBBHUiB0EBaiICQYCAgIABTw0CAkACQCAJIAprIglBA3UiDCACIAwgAksbQf////8AIAlB8P///wdJGyICDQBBACEJDAELIAJBgICAgAFPDQYgAkEEdBDOGyEJCyAJIAdBBHRqIgcgAzYCCCAHIA05AwAgCSACQQR0aiEMIAdBEGohAgJAIAtBAUgNACAJIAogC/wKAAALIAEgDDYCGCABIAI2AhQgASAJNgIQIApFDQAgChDQGwsgA0EBaiIDIAhGDQIMAAsACyABQRBqEJ0JAAsgASgCECEHCwJAIAIgB2siA0ERSA0AIANBBHYhA0EAIQkDQCAJQQFqIQkgA0EDSyEKIANBAXYhAyAKDQALIAlBAXQhBAsgAiAHIAEgBBCeCUEAIQIgAUEANgIIIAFCADcDAAJAIAVBAUgNACAGQQEgBkEBShshCEEAIQJBACEDAkADQCAAKAKwFCADQQN0aiABKAIQIANBBHRqIgkrAwA5AwAgACgCyBQgCSgCCEECdGohCQJAAkAgAiABKAIIRg0AIAIgCSgCADYCACABIAJBBGoiAjYCBAwBCyACIAEoAgAiC2siCkECdSIMQQFqIgJBgICAgARPDQICQAJAIApBAXUiByACIAcgAksbQf////8DIApB/P///wdJGyICDQBB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AhAgAyAPIBMgFWsiE0EEdGogEiANIBBrIhBsQQR0ajYCCCAKQRhqIAwoAgA2AgAgCkEQaiAUKQIANwIAIApBCGogDikCADcCACAKIAApAgA3AgAgAyATNgI0IAMgEDYCMCADIAMoAiw2AjggDCgCACEQIAMgDTYCeCADIBc2AmwgAyAPIBFqIgw2AnQgAyAMIBAgDSAXayINbEEEdGo2AmggCUEQaiAUKQIANwIAIAlBCGogDikCADcCACAJIAApAgA3AgAgA0EBNgKwASADIA02AqgBIANBATYCpAEgAyAHNgKgASADQQA2ApwBIAMgEDYCmAEgA0EIaiADQegAaiABKAIAIBFqIAggEWoQ1QkgB0EBaiIHIAZHDQALIAMoAmAhBwsCQCAHRQ0AIAdBfGooAgAQyg8LIANB0AFqJAAL6QQBA38jAEGQAWsiBCQAIAEoAgghBSAEQQA2AnggBEIANwNwAkACQCAFRQ0AQf////8HIAVtIAVIDQELIARB8ABqIAUgBWwgBSAFEGkCQAJAIANFDQAgBEHwAGogASACENYJDAELIAQgAikCADcDACAEIAIpAgw3AgwgBCACKAIYNgIYIARB8ABqIAEgBBDXCQsgBEHQAGpBGGogAUEYaiIFKAIANgIAIARB0ABqQRBqIAFBEGoiAikCADcDACAEQdAAakEIaiABQQhqIgYpAgA3AwAgBCABKQIANwNQIARBGGogBSgCADYCACAEQRBqIAIpAgA3AwAgBEEIaiAGKQIANwMAIAQgASkCADcDACAEQShqIABBCGopAgA3AwAgBEEwaiAAQRBqKQIANwMAIARBOGogAEEYaigCADYCACAEIAApAgA3AyAgBEHAAGogBBDYCSEBAkACQCADRQ0AIAQgATYCBCAEIARB8ABqNgIAIAEgBCAEQYABakEAENkJDAELIAQgATYCCCAEIARB8ABqNgIAIAEgBCAEQYABakEAENoJCyAEQRhqIARB0ABqQRhqKAIANgIAIARBEGogBEHQAGpBEGopAwA3AwAgBEEIaiAEQdAAakEIaikDADcDACAEIAQpA1A3AwAgBCABNgIcIARCADcDiAEgBEKAgICAgICA+L9/NwOAASAAIAQgASAEQYABahDbCQJAIAEoAgAiAUUNACABQXxqKAIAEMoPCwJAIAQoAnAiAUUNACABQXxq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CwsgA0GwAmokAAvtCgMXfwJ8AX4jAEGwAmsiAyQAAkAgASgCCCIEQQFIDQAgA0GAAWohBSADQcwBaiEGIANBGGpBBGohB0EAIQggBCEJA0AgCUF/aiEKAkAgBCAJRg0AIAhBf2ohCyABKAIEIQwgAigCACAKQQR0Ig1qIg4rAwAhGiAOKwMIIRsgAUEIaiIOKAIAIQ8gASgCACEQIAEoAhghESADQRBqIhIgAUEQaiITKQIANwMAIANBCGoiFCAOKQIANwMAIAMgASkCADcDACAHQRBqIhUgEykCADcCACAHQQhqIhYgDikCADcCACAHIAEpAgA3AgAgACgCACAAKAIIIhMgCmxBBHRqIhcgEyAEIAlrIg5rIhhBBHRqIhlBACAOQQR0/AsAIANCADcDQCADQoCAgICAgID4PzcDOCADIBOtQiCGIBithDcCpAIgAyATNgKcAiADQQA2ApgCIAMgCjYClAIgAyAANgKQAiADIBM2AowCIAMgFzYChAIgAyAONgKAAiADIBk2AvgBIAMgDjYCyAEgAyAMIAlrIhM2AsQBIAMgECAPIA5rIg9BBHRqIBEgCWxBBHQiF2o2AsABIAZBEGogEikDADcCACAGQQhqIBQpAwA3AgAgBiADKQMANwIAIAMgETYC8AEgAyAPNgLsASADIAk2AugBIAMgETYC5AEgAyAMrUIghiAQIA1qIgythDcCdCADIBOtQiCGIAwgF2qthDcDaCADIBs5A2AgAyAamjkDWCADIBM2AlQgBUEQaiAVKQIANwIAIAVBCGogFikCADcCACAFIAcpAgA3AgAgA0EBNgKwASADIAk2AqgBIANBATYCpAEgAyAKNgKgASADQQA2ApwBIAMgETYCmAEgA0HAAWogA0HIAGogA0H4AWogA0E4ahDfCSAAKAIAIREgACgCBCEQIAAoAgghEyADQgA3AxggA0EYaiAOQQEgDhC1CCATrUIghiATIA5rIgythCEcIBEgDEEEdCINaiATIBAgDmsiEGxBBHRqIQ8gESATIApsQQR0aiISIA1qIRECQCADKAIcIg1BAUgNACADKAIYQQAgDUEEdPwLAAsgA0IANwPIASADQoCAgICAgID4PzcDwAEgAyADQRhqNgIAIAMgEzYCkAIgAyAMNgKMAiADIBA2AogCIAMgADYChAIgAyAONgKAAiADIA42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IAIgEDYCGAJAIAhFDQAgCBDQGwsgECEICwJAAkAgCiAJTw0AIAogDDYCACACIApBBGoiCjYCDAwBCyAKIARrIg1BAnUiDkEBaiIKQYCAgIAETw0EAkACQCAJIARrIhBBAXUiCSAKIAkgCksbQf////8DIBBB/P///wdJGyIKDQBBACEQDAELIApBgICAgARPDQQgCkECdBDOGyEQCyAQIA5BAnRqIg4gDDYCACAQIApBAnRqIQkgDkEEaiEKAkAgDUEBSA0AIBAgBCAN/AoAAAsgAiAJNgIQIAIgCjYCDCACIBA2AggCQCAERQ0AIAQQ0BsLIBAhBAsgBUEMaiIFIAdGDQQMAAsACyACQRhqEJQEAAsQZAALIAJBCGoQlAQAC0IBIBGGIRECQAJAAkACQCABIAEoAgAoAggRAABFDQAgACgCFCAAKAIQa0EMbSEFAkAgACgCCCAAKAIEa0EMRw0AAkACQAJAIAUOAgABAgsgAigCKCgCACADIAEgASgCACgCXBEAACAREJcODAQLIAgoAgAgBCgCACACKAIoKAIAIAMgASABKAIAKAJcEQAAIBEQ9A0MBAsgCCAEIAYgCGtBAnUgAigCKCgCACADIAEgASgCACgCXBEAACAREPENDAILAkACQAJAIAUOAgABAgsgAigCKCIGIAIoAiwgBmtBAnUgAyABIAEoAgAoAlwRAAAgERCTDgwDCyAIKAIAIAQoAgAgAigCKCIGIAIoAiwgBmtBAnUgAyABIAEoAgAoAlwRAAAgERDzDQwDCyAIIAQgBiAIa0ECdSACKAIoIgYgAigCLCAGa0ECdSADIAEgASgCACgCXBEAACAREPANDAELIAAoAgggACgCBGshBQJAIAAoAhQgACgCEEcNACACKAIoIQYCQCAFQQxHDQAgBigCACADIAEgASgCACgCXBEAACAREPcNDAILIAYgAigCLCAGa0ECdSADIAEgASgCACgCXBEAACAREPkNDAELIAYgCGtBAnUhCiACKAIoIQYCQCAFQQxHDQAgCCAEIAogBigCACADIAEgASgCACgCXBEAACAREPgNDAELIAggBCAKIAYgAigCLCAGa0ECdSADIAEgASgCACgCXBEAACAREPoNCyAERQ0BCyAEENAbCwJAIAhFDQAgCBDQGwsCQCACKAIoIgZFDQAgAiAGNgIsIAYQ0BsLIAJBwABqJAALggEBAn8jAEEQayIDJAAgAyACNgIIIAMgATYCBCADIzFBCGo2AgACQAJAIABBFGooAgAiBCAAQRhqKAIATw0AIAQgAjYCCCAEIAE2AgQgBCMxQQhqNgIAIAAgBEEMajYCFAwBCyAAQRBqIAMQpwgLIAAgACgCHEF6cTYCHCADQRBqJAAL7gQBCH8jAEGgAWsiAiQAIAIjCiIDQSBqIgQ2AhggAiADQTRqIgU2AlAgAiMLIgYoAggiBzYCECACQRBqIAdBdGooAgBqIAYoAgw2AgAgAigCECEHIAJBADYCFCACQRBqIAdBdGooAgBqIgcgAkEQakEMaiIIEMMSIAdCgICAgHA3AkggAiAGKAIQIgk2AhggAkEQakEIaiIHIAlBdGooAgBqIAYoAhQ2AgAgAiAGKAIEIgk2AhAgAkEQaiAJQXRqKAIAaiAGKAIYNgIAIAIgBTYCUCACIANBDGo2AhAgAiAENgIYIwwhAyAIEIwQIgYgA0EIajYCACACQRBqQTRqQgA3AgAgAkE8akIANwIAIAJBzABqQRg2AgAgAiABEO0HIAcgAigCACACIAItAAsiA8BBAEgiBBsgAigCBCADIAQbEMQEGgJAIAIsAAtBf0oNACACKAIAENAbCyACQdAAaiEEIAIgByMGQfkLakEJEMQEIgMgAygCAEF0aigCAGoQuxIgAiMNIgUQhBQiCEEKIAgoAgAoAhwRAgAhCCACENgYGiADIAgQ7hAaIAMQqRAaIAIgByABQTRqENsFIgcgBygCAEF0aigCAGoQuxIgAiAFEIQUIgNBCiADKAIAKAIcEQIAIQMgAhDYGBogByADEO4QGiAHEKkQGiAAIAYQwxEgAiMLIgcoAgAiAzYCECACQRBqIANBdGooAgBqIAcoAiA2AgAgAiAHKAIkNgIYIAYjDEEIajYCAAJAIAIsAEdBf0oNACACKAI8ENAbCyAGEIoQGiACQRBqIwtBBGoQ7xAaIAQQgxAaIAJBoAFqJAAL7QQBBX8jAEEwayICJAAgAEIANwIAIABBCGpBADYCAEEQEM4bIgNBMBDOGyIENgIEIAQgBEEoaiIFNgIsIAQgBEEcaiIGNgIkIAQgBjYCICAEQQA2AhwgBCAFNgIoIANBADYCDCAAIAM2AgwgAkEAOgAUIAJB7sK1qwY2AhAgAkGE3AA7ABsjBiEEIAIgAkEQajYCICAAIAJBEGogBEHGzwBqIAIgAkEoahDWGCIEENcYIgMQigoaIAMQ2BgaIAQQ2BgaAkAgAiwAG0F/Sg0AIAIoAhAQ0BsLIAJBIBDOGyIENgIQIAJCkYCAgICEgICAfzcCFCAEQRBqIwZB+w1qIgNBEGotAAA6AAAgBEEIaiADQQhqKQAANwAAIAQgAykAADcAACAEQQA6ABEgAiAENgIgIAJBLjoAHCACIAFBBGoQ7AwgACACQRBqIAIQ1QQaIAIQ1wQaAkAgAiwAG0F/Sg0AIAIoAhAQ0BsLIAJBIBDOGyIENgIQIAJCkoCAgICEgICAfzcCFCAEQRBqIwZBjQ5qIgNBEGovAAA7AAAgBEEIaiADQQhqKQAANwAAIAQgAykAADcAACAEQQA6ABIgAiAENgIgIAJBLjoAHCACIAFBEGoQ7QwgACACQRBqIAIQ1QQaIAIQ1wQaAkAgAiwAG0F/Sg0AIAIoAhAQ0BsLIAJBhtwAOwAbIAJBADoAFiACIwZBmQpqIgQoAAA2AhAgAiAEQQRqLwAAOwEUIAIgAkEQajYCICACIAFBNGoQ7wwgACACQRBqIAIQ1QQaIAIQ1wQaAkAgAiwAG0F/Sg0AIAIoAhAQ0BsLIAJBMGokAAvgAgEFfyMAQTBrIgQkAAJAAkAgASwACyIFQQBIDQAgBEEYakEIaiABQQhqKAIANgIAIAQgASkCADcDGAwBCyAEQRhqIAEoAgAgASgCBBD6GyABLQALIQULIAQgAS0ADDoAJCAEIAQoAhggBEEYaiAELAAjQQBIGyABKAIQIAEoAgAgASAFwEEASBtrajYCKCAAIARBGGoQ8QQhBQJAIAQsACNBf0oNACAEKAIYENAbCwJAAkAgBUUNACAEQRBqIAMQ1xghAQwBCyAEQSBqQQA2AgAgBEIANwMYQRAQzhsiBkEwEM4bIgU2AgQgBSAFQShqIgc2AiwgBSAFQRxqIgg2AiQgBSAINgIgIAVBADYCHCAFIAc2AiggBkEANgIMIAQgBjYCJCAAIAEgBEEYahDVBCEFIARBGGoQ1wQaIARBCGogAxDXGCEBCyAFIAIgARCSCiABENgYGiAEQTBqJAAgBQsHACAAEMUKC+4BAQN/IAAjgQFBCGo2AgACQCAAKAI0IgFFDQAgAUF8aigCABDKDwsgACMgQQhqNgIAAkAgACwAK0F/Sg0AIAAoAiAQ0BsLAkAgACgCECICRQ0AIAIhAwJAIABBFGooAgAiASACRg0AA0AgAUF0aiIBIAEoAgAoAgARAAAaIAEgAkcNAAsgACgCECEDCyAAIAI2AhQgAxDQGwsCQCAAKAIEIgJFDQAgAiEDAkAgAEEIaigCACIBIAJGDQADQCABQXRqIgEgASgCACgCABEAABogASACRw0ACyAAKAIEIQMLIAAgAjYCCCADENAbCyAACwoAIAAQjAoQ0BsLLgECfyOBASEBQcAAEM4bIAAQ6wYiAiABQQhqNgIAIAJBNGogAEE0ahDmBRogAgvGAwEIfyAAQTxqKAIAIQIgACgCNCEDAkACQAJAIAEoAgQgAEE4aigCACIARw0AIAEoAgggAkYNAQsCQCAARQ0AIAJFDQBB/////wcgAm0gAEgNAgsgASACIABsIAAgAhBpIAEoAgghAiABKAIEIQALAkAgACACbCIAQQFIDQAgASgCACECIABBA3EhBEEAIQVBACEBAkAgAEF/akEDSQ0AIABBfHEhBkEAIQFBACEHA0AgAiABQQR0IgBqIgggAyAAaiIJKQMANwMAIAhBCGogCUEIaikDADcDACACIABBEHIiCGoiCUEIaiADIAhqIghBCGopAwA3AwAgCSAIKQMANwMAIAIgAEEgciIIaiIJQQhqIAMgCGoiCEEIaikDADcDACAJIAgpAwA3AwAgAiAAQTByIgBqIghBCGogAyAAaiIAQQhqKQMANwMAIAggACkDADcDACABQQRqIQEgB0EEaiIHIAZHDQALCyAERQ0AA0AgAiABQQR0IgBqIgcgAyAAaiIAKQMANwMAIAdBCGogAEEIaikDADcDACABQQFqIQEgBUEBaiIFIARHDQALCw8LI24hASNvIQNBBBAUEJMdIAMgARAVAAuYAQIDfwJ8IwBBIGsiAiQAAkAgAEE8aigCACAAQThqKAIAbCIDQQFIDQAgACgCNCEEIAErAwghBSABKwMAIQZBACEAA0AgAiAFOQMIIAIgBjkDACACQRBqIAQgAEEEdGoiASACEMgEIAFBCGogAkEQakEIaikDADcDACABIAIpAxA3AwAgAEEBaiIAIANHDQALCyACQSBqJAALCQAgACABNgIcC/QCAQJ/IwBB8ABrIgMkACADQeAAaiACIAEQkwoCQCAD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IAILjwECA38CfCMAQSBrIgIkAAJAIABBOGooAgAiA0EBSA0AIAAoAjQhBCABKwMIIQUgASsDACEGQQAhAANAIAIgBTkDCCACIAY5AwAgAkEQaiAEIABBBHRqIgEgAhDIBCABQQhqIAJBEGpBCGopAwA3AwAgASACKQMQNwMAIABBAWoiACADRw0ACwsgAkEgaiQACwkAIAAgATYCHAv0AgECfyMAQfAAayIDJAAgA0HgAGogAiABEKQKAkAgAy0AYEUNAAJAAkACQCADQeAAakEEciIBIABGDQAgA0HvAGotAAAiBMAhAgJAAkAgACwAC0EASA0AAkAgAkEASA0AIAAgASkCADcCACAAQQhqIAFBCGooAgA2AgAMAgsgACADKAJkIANB6ABqKAIAEIUcGgwBCyAAIAMoAmQgASACQQBIIgIbIANB6ABqKAIAIAQgAhsQhBwaCyADLQBgRQ0CIANB7wBqLAAAQQBIDQEMAgsgA0HvAGosAABBf0oNAQsgAygCZBDQGwsgA0HwAGokAA8LIwYhACOEASEBIANBMGogA0EgaiAAQYybAWoQdyABEK0GIANBwABqIANBMGogAEHP4QBqEK0GIANBADYCGCADQdAAaiADQcAAaiADQRhqEPMEIQEgA0K8hoCAsAY3AxAgAyAAQZnCAGo2AgwgAyAAQdwxajYCCCABIANBCGoQ9AQAC/UDAQV/IwBBsAFrIgMkACADIxkiBEEgaiIFNgJYIAMjGiIGKAIEIgc2AiAgA0EgaiAHQXRqKAIAaiAGKAIINgIAIANBIGogAygCIEF0aigCAGoiBiADQSBqQQRyIgcQwxIgBkKAgICAcDcCSCADIAU2AlggAyAEQQxqNgIgIwwhBSAHEIwQIgQgBUEIajYCACADQcwAakIANwIAIANBxABqQgA3AgAgA0HUAGpBEDYCACADQRhqIANBIGogAygCIEF0aigCAGoiBRC7EiADQQhqIAUgARC6EiADQQhqENgYGgJAIAUoAhgiBUUNACAFIAEgBSgCACgCCBEBACADQagBaiAFQQRqIgUQ1xghBiAFIAEQ2RgaIAYQ2BgaCyADQRhqENgYGiADQSBqIAIgAhCmDxDEBBoCQAJAIANBIGogAygCIEF0aigCAGotABBBBXENACADQQhqIAQQwxEgAEEMaiADQRBqKAIANgIAIAAg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CiIMQXRqIgpBBGoiDygCACINSQ0ACwJAIAggCkkNAEEEIQkMAgsgByANNgIAIAgoAgghCyAIIAxBfGoiBygCADYCCCAPIAY2AgAgByALNgIADAALAAsgCCEAIAlBBEYNACAIIQAgCUECRg0ACwsLC/gBAQN/IwBBMGsiASQAIAFBADYCICABQgA3AxggACABQRhqIAAoAgAoAhARAQAgAUEANgIQIAFCADcDCCABIAFBGGo2AgAgASgCHCECAkACQCABKAIgIgNFDQAgAkUNAEH/////ByACbSADSA0BCyABQQhqIAIgA2wgAyACEGkgAUEIaiABIAFBKGoQxgpBwAAQzhsgACgCLCABQQhqIAAoAjAQhQohAAJAIAEoAggiAkUNACACQXxqKAIAEMoPCwJAIAEoAhgiAkUNACACQXxqKAIAEMoPCyABQTBqJAAgAA8LI24hASNvIQBBBBAUEJMdIAAgARAVAAufAgIIfwF8IAEoAgAiASgCBCEDIAEoAgAhBAJAAkACQCAAKAIEIAEoAggiBUcNACAAKAIIIANHDQAgBSEBDAELAkAgBUUNACADRQ0AQf////8HIANtIAVIDQILIAAgAyAFbCAFIAMQaSAAKAIEIQEgACgCCCEDCwJAIAFBAUgNACADQQFIDQAgACgCACEGQQAhByADIQgDQAJAIAhBAUgNACAHIANsIQlBACEBA0AgBCABIAVsIAdqQQR0aiIIKwMIIQsgBiABIAlqQQR0aiIKIAgrAwA5AwAgCiALmjkDCCABQQFqIgEgACgCCCIISA0ACyAAKAIEIQELIAdBAWoiByABSA0ACwsPCyNuIQEjbyEIQQQQFBCTHSAIIAEQFQALDwBB4BQQzhsgACABEL0IC6gBAQR/IwBBEGsiASQAQcgUEM4bIQIgAUEANgIIIAFCADcDAAJAAkAgACgCBCIDIAAoAgAiBEYNACADIARrIgBBf0wNASABIAAQzhsiAzYCACABIAMgAEECdUECdGo2AgggAyAEIAD8CgAAIAEgAyAAajYCBAsgAiABEMgIIQMCQCABKAIAIgBFDQAgASAANgIEIAAQ0BsLIAFBEGokACADDwsgARCTBgALrgEBBH8jAEEQayIEJABBwBQQzhshBSAEQQA2AgggBEIANwMAAkACQCAAKAIEIgYgACgCACIHRg0AIAYgB2siAEF/TA0BIAQgABDOGyIGNgIAIAQgBiAAQQJ1QQJ0ajYCCCAGIAcgAPwKAAAgBCAGIABqNgIECyAFIAQgASACIAMQ2gghBgJAIAQoAgAiAEUNACAEIAA2AgQgABDQGwsgBEEQaiQAIAYPCyAEEJMGAAuWAgEFfyMAQSBrIgIkAEEAIQNByBQQzhshBCACQQA2AgggAkIANwMAAkACQAJAAkAgACgCBCIFIAAoAgAiBkcNACACQQA2AhggAkIANwMQDAELIAUgBmsiAEF/TA0BIAAQzhsiAyAGIAD8CgAAIAJBADYCGCACQgA3AxAgBSAGRg0AIABBf0wNAiACIAAQzhsiBjYCECACIAYgAEECdUECdGo2AhggBiADIAD8CgAAIAIgBiAAajYCFAsgBCACQRBqEMgIIQACQCACKAIQIgZFDQAgAiAGNgIUIAYQ0BsLIAAgATYCwBQgAEEBOgC8FAJAIANFDQAgAxDQGwsgAkEgaiQAIAAPCyACEJMGAAsgAkEQahCTBgALwgEBA38jAEEgayICJABB8AAQzhshAwJAAkAgASgCECIEDQAgAkEANgIYDAELAkAgBCABRw0AIAIgAkEIajYCGCABIAJBCGogASgCACgCDBEBAAwBCyACIAQgBCgCACgCCBEAADYCGAsgAyAAIAJBCGoQzAohBAJAAkACQCACKAIYIgEgAkEIakcNACACKAIIQRBqIQAgAkEIaiEBDAELIAFFDQEgASgCAEEUaiEACyABIAAoAgARAwALIAJBIGokACAEC44IAQV/IwBBMGsiAyQAIABCADcCBCAAIyBBCGo2AgAgAEEMakIANwIAIABBFGpCADcCACAAQRxqQQA2AgAgAEEQEM4bIgQ2AiAgAEEkakKMgICAgIKAgIB/NwIAIARBCGojBkGVzwBqIgVBCGooAAA2AAAgBCAFKQAANwAAIARBADoADCAAIABBEGoiBjYCMCAAI4YBQQhqNgIAIAAgAEEEaiIFNgIsIAAgASABKAIAKAIMEQAANgI0AkACQCACKAIQIgQNACAAQcgAakEANgIADAELAkAgBCACRw0AIABByABqIABBOGoiBDYCACACKAIQIgEgBCABKAIAKAIMEQEADAELIABByABqIAQgBCgCACgCCBEAADYCAAsgAEF/NgJoIABB4ABqQQA2AgACQAJAIAAsACtB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AWogAyAGQQR0IgVqEMgEIAcgBWoiBSAFKwMAIAQrA9ABoTkDACAFIAUrAwggBCsD2AGhOQMIIAZBAWoiBiAARw0ACwsgASgCKCEFIAEoAjAhBiABKQIAIREgASkCDCESIAQgASgCBDYCGCAJIAIpAwA3AwAgBEEoaiALKQMANwMAIARBPGogEjcCACAEIBE3AzAgBEHIAGogDCkCADcDACAEQdAAaiAMQQhqKQIANwMAIARB8ABqIAo2AgAgBEHgAGogBjYCACAEQdgAaiAFNgIAIAQgAzYCaCAEQfgAaiAEQRBqIARB6ABqIARB4AFqIARB0AFqELQLCyAEQfABaiQAC8AKAwt/AnwEfiMAQZACayIEJAAgAisDCCEPIAIrAwAhEAJAAkAgACgCCCIFQQFHDQAgBEQAAAAAAAAAACAPoTkDCCAERAAAAAAAAPA/IBChOQMAIAQgACgCADYCgAEgBCAAKAIYNgKIASAEIAA2AuQBIAQgBEHoAGo2AuABIAQgBDYC3AEgBCAEQYABajYC2AEgBEHYAWoQ/QkMAQsCQCAQRAAAAAAAAAAAYg0AIA9EAAAAAAAAAABhDQELIAQgACgCBCIGNgK8ASAEIAM2ArgBIAAoAgAhByAEIAVBf2o2AogBIAQgBjYChAEgBCAHQRBqNgKAASAEQZQBaiAAQQhqKQIANwIAIARBgAFqQRxqIABBEGopAgA3AgAgBEGAAWpBJGogAEEYaigCACIFNgIAIAQgACkCADcCjAEgBEKAgICAEDcDqAEgBCAFNgKwASABKAIwIQcgASgCKCEIIAEpAgwhESABKQIAIRIgBEH0AGogAUEgaikCADcCACAEIAFBGGoiCSkCADcCbCAEQegAakEEaiEFAkAgBkEBSA0AIANBACAGQQR0/AsACyAEQgA3A9ABIARCgICAgICAgPg/NwPIASAEQdgBakEwaiAEQYABakEwaigCADYCACAEQdgBakEoaiAEQYABakEoaikDADcDACAEQdgBakEgaiAEQYABakEgaikDADcDACAEQdgBakEYaiAEQYABakEYaikDADcDACAEQdgBakEQaiAEQYABakEQaikDADcDACAEQdgBakEIaiAEQYABakEIaikDADcDACAEIAQpA4ABNwPYASAEQRBqIBE3AwAgBCASNwIEIARBHGogBSkCADcCACAE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aiIBKQMANwMAIAMgBCkDADcDUCADQcAAaiADIANB4ABqEMgEIAMgCzkDKCADIAo5AyAgA0EwaiADQSBqIANB0ABqEMgEIAMrAzAhCSADKwNAIQwgACADKwNIIAMrAzigOQMAIAUgDCAJoDkDACADIAs5AzggAyANOQMwIANBwABqIANBMGogA0HgAGoQyAQgAyADKwMImjkDGCADIAMrAwA5AxAgA0EgaiADQRBqIANB0ABqEMgEIAMrAyAhCSADKwNAIQwgASADKwNIIAMrAyigOQMAIAQgDCAJoDkDACAEIAdqIQQgBSAIaiEFIAJBAWoiAiAGRw0ACwsgA0HwAGokAAuuAQECfyABKAIIIQIgASgCBCEDIABBADYCCCAAQgA3AwACQCADRQ0AIAJFDQBB/////wcgAm0gA04NACNuIQAjbyEBQQQQFBCTHSABIAAQFQALIAAgAiADbCADIAIQaSABKAIEIQMgAEIANwIMIABBDGogAyADQQEQogYgASgCBCEDIABCADcCFCAAQRRqIAMgA0EBEKIGIABBADsBKCAAQgA3AyAgACABEMALGiAAC6cBAQN/AkACQAJAAkAgASgCBCICDQBBACEDDAELIAJBgICAgARPDQEgAkECdEEQahDJDyIDRQ0CIANBcHEiBCADNgIMIARBEGohAwsgACACNgIEIAAgAzYCAAJAIAEoAgQiAkUNACADIAEoAgAgAkECdPwKAAALIAAPCyNuIQAjbyEBQQQQFBCTHSABIAAQFQALI24hACNvIQFBBBAUEJMdIAEgABAVAAuOAQEDfyMAQRBrIgMkACABKAIEIQQgAyABKAIIIgU2AgQgAyAENgIAAkACQAJAIAUgACgCBEcNACAAKAIIIAVGDQELAkAgBUUNAEH/////ByAFbSAFSA0CCyAAIAUgBWwgBSAFEGkLIAEgAyAAEMwLIANBEGokAA8LI24hBSNvIQNBBBAUEJMdIAMgBRAVAAvHAwEJfyABKAIIIQIgASgCACEDAkACQAJAIAAoAgQgASgCBCIBRw0AIAAoAgggAkYNAQsCQCABRQ0AIAJFDQBB/////wcgAm0gAUgNAgsgACACIAFsIAEgAhBpIAAoAgghAiAAKAIEIQELAkAgASACbCIEQQFIDQAgACgCACEBIARBA3EhBUEAIQZBACECAkAgBEF/akED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AiQAIAEoAgghAyABKAIEIQQgAiAAKAIEIgU2AhAgAiAENgIMIAIgAzYCCCACQgA3AwAgAiAENgIcIAJBEGogAkEIaiACQRxqQQEQ5wkgAiACKAIQIgQgAigCCGw2AhQgAiAEIAIoAgxsNgIYIAUgAyAAKAIAIAAoAjwgASgCACABKAI8IAIQyAsCQCACKAIAIgFFDQAgAUF8aigCABDKDwsCQCACKAIEIgFFDQAgAUF8aigCABDKDwsgAkEgaiQAC50EAgN/AX4jAEHQAWsiAyQAAkACQCAAKAIEIAIoAgQiBGogACgCCGpBE0oNACAEQQFIDQAgASkCACEGIAMgASgCCCIENgI4IAMgBjcDMCADQTBqQRRqIAFBFGooAgA2AgAgAyABKQIMNwI8IANBMGpBIGogAUEgaigCADYCACADQTBqQRhqIAFBGGopAgA3AwAgA0EwakEwaiABQTBqKAIANgIAIANBMGpBKGogAUEoaikCADcDACADQTBqQTxqIgUgAUE8aigCADYCACADIAEpAjQ3AmQgA0H4AGogAkEIaigCADYCACADIAIpAgA3A3AgA0GEAWogAkEUaigCADYCACADQfwAaiACKQIMNwIAIANBkAFqIAJBIGooAgA2AgAgA0GIAWogAkEYaikCADcDACADQaABaiACQTBqKAIANgIAIANBmAFqIAJBKGopAgA3AwAgA0GsAWoiASACQTxqKAIANgIAIANBpAFqIAIpAjQ3AgAgAyAGPgKwASADQbgBaiAFKAIANgIAIAMgAygCcDYCvAEgA0HEAWogASgCADYCACADIAQ2AsgBIAMgACgCADYCICADIAAoAjw2AiggAyAANgIcIAMgA0EIajYCGCADIANBMGo2AhQgAyADQSBqNgIQIANBEGoQygsMAQsgA0IANwM4IANCgICAgICAgPi/fzcDMCAAIAEgAiADQTBqEMsLCyADQdABaiQAC/EFAgp/D3wCQCAAKAIEIgVBAUgNACAAKAIIIgZBAUgNACABQTxqKAIAIQcgAigCACEIIAEoAgAhCSAAKAI8IQogACgCACELQQAhDANAIAkgDCAHbEEEdGoiACsDACIPmUQAAAAAAADwf2EiASAAKwMIIhCZRAAAAAAAAPB/YSIAciENRAAAAAAAAPA/RAAAAAAAAAAAIAAbIBCmIRFEAAAAAAAA8D9EAAAAAAAAAAAgARsgD6YhEiALIAogDGxBBHRqIQ5BACEBA0AgECAIIAFBBHQiAGoiAisDACIToiIUIA8gAisDCCIVoiIWoCEXIA4gAGohAAJAIA8gE6IiGCAQIBWiIhmhIhogGmENACAXIBdhDQACQAJAIA0NACAQIRsgDyEcDAELRAAAAAAAAAAAIBWmIBUgFSAVYhshFUQAAAAAAAAAACATpiATIBMgE2IbIRMgESEbIBIhHAsgFZkhHQJAAkAgE5lEAAAAAAAA8H9hIgINACAdRAAAAAAAAPB/YQ0AIA0NAQJAIBiZRAAAAAAAAPB/YQ0AIBmZRAAAAAAAAPB/YQ0AIBaZRAAAAAAAAPB/YQ0AIBSZRAAAAAAAAPB/Yg0DC0QAAAAAAAAAACAVpiAVIBUgFWIbIRVEAAAAAAAAAAAgE6YgEyATIBNiGyETRAAAAAAAAAAAIBumIBsgGyAbYhshG0QAAAAAAAAAACAcpiAcIBwgHGIbIRwMAQtEAAAAAAAAAAAgG6YgGyAbIBtiGyEbRAAAAAAAAAAAIBymIBwgHCAcYhshHEQAAAAAAADwP0QAAAAAAAAAACAdRAAAAAAAAPB/YRsgFaYhFUQAAAAAAADwP0QAAAAAAAAAACACGyATpiETCyAcIBWiIBMgG6KgRAAAAAAAAPB/oiEXIBwgE6IgFSAboqFEAAAAAAAA8H+iIRoLIAAgACsDACAaoTkDACAAIAArAwggF6E5AwggAUEBaiIBIAZHDQALIAxBAWoiDCAFRw0ACwsLwxECI38PfCMAQYABayIHIQggByQAAkAgBigCCCIJIAEgCSABSBsiCiAGKAIQIgtsIgxBgICAgAFPDQAgBigCACINIQ4CQAJAIA0NACAMQQR0IQkCQCAMQYDAAEsNACAHIAlBD3JBD2pBcHFrIg4iByQAQQAhDQwBCyAJQRBqEMkPIglFDQEgCUFwcSIPIAk2AgwgD0EQaiEOIAYoAgAhDQsCQCALIABsIhBBgICAgAFPDQAgBigCBCIRIRICQAJAIBENACAQQQR0IQkCQCAQQYDAAEsNACAHIAlBD3JBD2pBcHFrIhIkAEEAIREMAQsgCUEQahDJDyIHRQ0BIAdBcHEiCSAHNgIMIAlBEGohEiAGKAIEIRELAkAgAEEBSA0AIAAhE0EAIRQDQCALIAAgFGsiBiALIAZIGyIVIBRqIQkgEiAVIBVsQQR0aiEWAkAgBiAVayIXQQFIDQAgCCADNgJcIAggAiAJIANsIBRqQQR0ajYCWCAIQfAAaiAWIAhB2ABqIBUgF0EAQQAQ8AkLQQQhBgJAIBVBBEwNAANAIAggAzYCXCAIIAIgBiAUaiADbCAUakEEdGo2AlggCEHoAGogEiAGIBVsQQR0aiAIQdgAaiAGIBUgBmsiB0EEIAdBBEgbIBVBABD4CSAVIAZBBGoiBkoNAAsLAkAgAUEBSA0AIAsgEyALIBNIGyEYIBVBBCAVQQRIGyEZIAkgBWwhGiAEIBQgBWxBBHRqIRtBACEcA0AgASAcayIGIAogBiAKSBshHQJAIBVBAUgNAAJAIB1BAUgNACAEIBxBBHRqIR5BACEfIBghIANAIBUgH2siBkEEIAZBBEgbISEgHyAUaiEiAkAgH0UNACAIQcgAakEIakIANwMAIAhBGGpBCGpCADcDACAIQoCAgICAgID4v383A0ggCEKAgICAgICA+L9/NwMYIAggBTYCXCAIIAQgIiAFbCAcakEEdGo2AlggCEH4AGogCEHYAGogDiASIB8gFWxBBHRqIB0gHyAhIAhBGGogFSAVQQBBABDyCQtBACEjAkAgBkEATA0AICBBBCAgQQRIGyIGQQEgBkEBShshJANAAkAgI0UNACAEICMgImoiBiAFbCAcakEEdGohJSAGIANsISZBACEnA0BEAAAAAAAAAAAgAiAnICJqIgYgJmpBBHRqIgcrAwgiKqYgKiAqICpiGyErRAAAAAAAAAAAIAcrAwAiLKYgLCAsICxiGyEtIAQgBiAFbCAcakEEdGohD0EAIQcDQCAqIA8gB0EEdCIGaiIJKwMAIi6iIi8gLCAJKwMIIjCiIjGgITICQCAsIC6iIjMgKiAwoiI0oSI1IDVhDQAgMiAyYQ0AAkACQCAumUQAAAAAAADwf2EiCSAwmUQAAAAAAADwf2EiKHIiKUEBRg0AICohNiAsITcMAQtEAAAAAAAA8D9EAAAAAAAAAAAgKBsgMKYhMEQAAAAAAADwP0QAAAAAAAAAACAJGyAupiEuICshNiAtITcLIDaZITgCQAJAIDeZRAAAAAAAAPB/YSIJDQAgOEQAAAAAAADwf2ENACApDQECQCAzmUQAAAAAAADwf2ENACA0mUQAAAAAAADwf2ENACAvmUQAAAAAAADwf2ENACAxmUQAAAAAAADwf2INAwtEAAAAAAAAAAAgNqYgNiA2IDZiGyE2RAAAAAAAAAAAIDemIDcgNyA3YhshN0QAAAAAAAAAACAwpiAwIDAgMGIbITBEAAAAAAAAAAAgLqYgLiAuIC5iGyEuDAELRAAAAAAAAAAAIDCmIDAgMCAwYhshMEQAAAAAAAAAACAupiAuIC4gLmIbIS5EAAAAAAAA8D9EAAAAAAAAAAAgOEQAAAAAAADwf2EbIDamITZEAAAAAAAA8D9EAAAAAAAAAAAgCRsgN6YhNwsgLiA2oiA3IDCioEQAAAAAAADwf6IhMiAuIDeiIDYgMKKhRAAAAAAAAPB/oiE1CyAlIAZqIgYgBisDACA1oTkDACAGIAYrAwggMqE5AwggB0EBaiIHIB1HDQALICdBAWoiJyAjRw0ACwsgI0EBaiIjICRHDQALCyAIIAU2AlwgCCAeICIgBWxBBHRqNgJYIAhB4ABqIA4gCEHYAGogISAdIBUgHxDJCyAgQXxqISAgFSAfQQRqIh9MDQIMAAsACyAIIAU2AlwgCCAbIBxBBHRqNgJYIAhB4ABqIA4gCEHYAGogGSAdIBVBABDJCyAVQQVJDQBBBCEGIAQgHEEEdGohDwNAIAhByABqQQhqQgA3AwAgCEEoakEIakIANwMAIAggBTYCXCAIQoCAgICAgID4v383A0ggCEKAgICAgICA+L9/NwMoIAggBCAGIBRqIAVsIgcgHGpBBHRqNgJYIAhB+ABqIAhB2ABqIA4gEiAGIBVsQQR0aiAdIAYgFSAGayIJQQQgCUEESBsiCSAIQShqIBUgFUEAQQAQ8gkgCCAFNgJcIAggDyAHQQR0ajYCWCAIQeAAaiAOIAhB2ABqIAkgHSAVIAYQyQsgFSAGQQRqIgZKDQALCwJAIBdBAEwNACAIQThqQQhqQgA3AwAgCEEIakEIakIANwMAIAggBTYCXCAIQoCAgICAgID4v383AzggCEKAgICAgICA+L9/NwMIIAggBCAcIBpqQQR0ajYCWCAIQfgAaiAIQdgAaiAOIBYgHSAVIBcgCEEIakF/QX9BAEEAEPIJCyAcIApqIhwgAUgNAAsLIBMgC2shEyAUIAtqIhQgAEgNAAsLAkAgEEGBwABJDQBBACASIBEbIgZFDQAgBkF8aigCABDKDwsCQCAMQYHAAEkNAEEAIA4gDRsiBkUNACAGQXxqKAIAEMoPCyAIQYABaiQADwsjbiEGI28hB0EEEBQQkx0gByAGEBUACyNuIQYjbyEHQQQQFBCTHSAHIAYQFQALI24hBiNvIQdBBBAUEJMdIAcgBhAVAAsjbiEGI28hB0EEEBQQkx0gByAGEBUAC68CAgh/AXwCQCAEQQFIDQAgA0EBSA0AIAUgAyAGamshByADQX5xIQggA0EBcSEJQQAhCkEAIQUDQCAFIAZqIQtBACEFQQAhDAJAIANBAUYNAANAIAIoAgAgAigCBCAFbCAKakEEdGoiDSsDACEPIAEgC0EEdGoiDiANKwMIOQMIIA4gDzkDACACKAIAIAIoAgQgBUEBcmwgCmpBBHRqIg0rAwAhDyAOQRhqIA0rAwg5AwAgDkEQaiAPOQMAIAVBAmohBSALQQJqIQsgDEECaiIMIAhHDQALCwJAIAlFDQAgAigCACACKAIEIAVsIApqQQR0aiIFKwMAIQ8gASALQQR0aiIOIAUrAwg5AwggDiAPOQMAIAtBAWohCwsgByALaiEFIApBAWoiCiAERw0ACwsL6woCE38NfAJAIAAoAgwiASgCBCICQQFIDQAgASgCCCIDQQFIDQAgACgCBCIEQcQAaigCACIFRQ0AIAQoAkAhBiAEKAI8IQcgBCgCACEIIAAoAgAiACgCCCEJIAAoAgAhCkEAIQsgBUECSCEMA0AgCSALbCENIAggByALbEEEdGohDkEAIQ8DQCAOKwMIIhQgBiAPQQR0aiIQKwMAIhWiIhYgDisDACIXIBArAwgiGKIiGaAhGgJAIBcgFaIiGyAUIBiiIhyhIh0gHWENACAaIBphDQACQCAXmUQAAAAAAADwf2EiACAUmUQAAAAAAADwf2EiAXIiEUEBRw0ARAAAAAAAAAAAIBimIBggGCAYYhshGEQAAAAAAAAAACAVpiAVIBUgFWIbIRVEAAAAAAAA8D9EAAAAAAAAAAAgARsgFKYhFEQAAAAAAADwP0QAAAAAAAAAACAAGyAXpiEXCyAYmSEeAkACQCAVmUQAAAAAAADwf2EiAA0AIB5EAAAAAAAA8H9hDQAgEQ0BAkAgG5lEAAAAAAAA8H9hDQAgHJlEAAAAAAAA8H9hDQAgGZlEAAAAAAAA8H9hDQAgFplEAAAAAAAA8H9iDQMLRAAAAAAAAAAAIBimIBggGCAYYhshGEQAAAAAAAAAACAVpiAVIBUgFWIbIRVEAAAAAAAAAAAgFKYgFCAUIBRiGyEURAAAAAAAAAAAIBemIBcgFyAXYhshFwwBC0QAAAAAAAAAACAUpiAUIBQgFGIbIRREAAAAAAAAAAAgF6YgFyAXIBdiGyEXRAAAAAAAAPA/RAAAAAAAAAAAIB5EAAAAAAAA8H9hGyAYpiEYRAAAAAAAAPA/RAAAAAAAAAAAIAAbIBWmIRULIBcgGKIgFSAUoqBEAAAAAAAA8H+iIRogFyAVoiAYIBSioUQAAAAAAADwf6IhHQsCQCAMDQAgBCgCfCESQQEhAANAIA4gAEEEdGoiASsDCCIUIBAgACASbEEEdGoiESsDACIVoiIfIAErAwAiFyARKwMIIhiiIiCgIRsCQCAXIBWiIhwgFCAYoiIWoSIeIB5hDQAgGyAbYQ0AAkAgF5lEAAAAAAAA8H9hIgEgFJlEAAAAAAAA8H9hIhFyIhNBAUcNAEQAAAAAAAAAACAYpiAYIBggGGIbIRhEAAAAAAAAAAAgFaYgFSAVIBViGyEVRAAAAAAAAPA/RAAAAAAAAAAAIBEbIBSmIRREAAAAAAAA8D9EAAAAAAAAAAAgARsgF6YhFwsgGJkhGQJAAkAgFZlEAAAAAAAA8H9hIgENACAZRAAAAAAAAPB/YQ0AIBMNAQJAIByZRAAAAAAAAPB/YQ0AIBaZRAAAAAAAAPB/YQ0AICCZRAAAAAAAAPB/YQ0AIB+ZRAAAAAAAAPB/Yg0DC0QAAAAAAAAAACAYpiAYIBggGGIbIRhEAAAAAAAAAAAgFaYgFSAVIBViGyEVRAAAAAAAAAAAIBSmIBQgFCAUYhshFEQAAAAAAAAAACAXpiAXIBcgF2IbIRcMAQtEAAAAAAAAAAAgFKYgFCAUIBRiGyEURAAAAAAAAAAAIBemIBcgFyAXYhshF0QAAAAAAADwP0QAAAAAAAAAACAZRAAAAAAAAPB/YRsgGKYhGEQAAAAAAADwP0QAAAAAAAAAACABGyAVpiEVCyAXIBiiIBUgFKKgRAAAAAAAAPB/oiEbIBcgFaIgGCAUoqFEAAAAAAAA8H+iIR4LIBogG6AhGiAdIB6gIR0gAEEBaiIAIAVHDQALCyAKIA0gD2pBBHRqIgAgACsDACAdoTkDACAAIAArAwggGqE5AwggD0EBaiIPIANHDQALIAtBAWoiCyACRw0ACwsLggMCBn8BfiMAQeAAayIEJAACQCABKAIIRQ0AIAEoAgRFDQAgAigCCEUNACAEQgA3A0ggBEKAgICAgICA+D83A0AgBEEQaiADIARBwABqEMgEIARCADcDOCAEQoCAgICAgID4PzcDMCAEQdAAaiAEQRBqIARBMGoQyAQgACkCBCEKIAQgASgCCDYCICAEQgA3AxAgBCAKQiCJNwMYIARBIGogBEEQakEIaiAEQRxqQQEQ8gogBCAEKAIgIgMgBCgCGGw2AiQgBCADIAQoAhxsNgIoIAEoAgQhAyACKAIIIQUgASgCCCEGIAEoAgAhByABKAI8IQEgAigCACEIIAIoAjwhAiAAKAIAIQkgACgCPCEAIARBCGogBEHQAGpBCGopAwA3AwAgBCAEKQNQNwMAIAUgAyAGIAggAiAHIAEgCSAAIAQgBEEQakEAEPMKAkAgBCgCECIBRQ0AIAFBfGooAgAQyg8LIAQoAhQiAUUNACABQXxqKAIAEMoPCyAEQeAAaiQAC70EAgF+CX8gASkCACIDQiCIpyEEAkACQAJAIAIoAgQgAEEQaigCACIBRw0AIAIoAgggBEYNAQsCQCABRQ0AIARFDQBB/////wcgBG0gAUgNAgsgAiABIARsIAEgBBBpIAIoAgghBAsCQCADpyIFQQFIDQAgBEEATA0AQQAhBgNAAkAgBEEBSA0AIAIoAgAgACgCDCAGQQJ0aigCACAEbEEEdGohByAEQQNxIQhBACEJQQAhAQJAIARBf2pBA0kNACAEQXxxIQpBACEBQQAhBANAIAcgAUEEdGoiC0IANwMIIAtEAAAAAAAA8D9EAAAAAAAAAAAgBiABRhs5AwAgByABQQFyIgtBBHRqIgxCADcDCCAMRAAAAAAAAPA/RAAAAAAAAAAAIAYgC0YbOQMAIAcgAUECciILQQR0aiIMQgA3AwggDEQAAAAAAADwP0QAAAAAAAAAACAGIAtGGzkDACAHIAFBA3IiC0EEdGoiDEIANwMIIAxEAAAAAAAA8D9EAAAAAAAAAAAgBiALRhs5AwAgAUEEaiEBIARBBGoiBCAKRw0ACwsgCEUNAANAIAcgAUEEdGoiBEIANwMIIAREAAAAAAAA8D9EAAAAAAAAAAAgBiABRhs5AwAgAUEBaiEBIAlBAWoiCSAIRw0ACwsgBkEBaiIGIAVGDQEgAigCCCEEDAALAAsCQCAAKAIIRQ0AIAAgAhDNCyAAKAIIRQ0AIAAgAhDOCwsPCyNuIQEjbyEGQQQQFBCTHSAGIAEQFQALygEBBH8jAEEgayICJAAgASgCCCEDIAEoAgQhBCACIAAoAgQiBTYCECACIAQ2AgwgAiADNgIIIAJCADcDACACIAQ2AhwgAkEQaiACQQhqIAJBHGpBARDnCSACIAIoAhAiBCACKAIIbDYCFCACIAQgAigCDGw2AhggBSADIAAoAgAgACgCCCABKAIAIAEoAgggAhDICwJAIAIoAgAiAUUNACABQXxqKAIAEMoPCwJAIAIoAgQiAUUNACABQXxqKAIAEMoPCyACQSBqJAALygEBBH8jAEEgayICJAAgASgCCCEDIAEoAgQhBCACIAAoAgQiBTYCECACIAQ2AgwgAiADNgIIIAJCADcDACACIAQ2AhwgAkEQaiACQQhqIAJBHGpBARDnCSACIAIoAhAiBCACKAIIbDYCFCACIAQgAigCDGw2AhggBSADIAAoAgAgACgCCCABKAIAIAEoAgggAhDPCwJAIAIoAgAiAUUNACABQXxqKAIAEMoPCwJAIAIoAgQiAUUNACABQXxqKAIAEMoPCyACQSBqJAALzhcCJX8PfCMAQfAAayIHIQggByQAAkACQCAGKAIIIgkgASAJIAFIGyIKIAYoAhAiC2wiDEGAgICAAU8NACAGKAIAIg0hDgJAAkAgDQ0AIAxBBHQhCQJAIAxBgMAASw0AIAcgCUEPckEPakFwcWsiDiIHJABBACENDAELIAlBEGoQyQ8iCUUNASAJQXBxIg8gCTYCDCAPQRBqIQ4gBigCACENCwJAIAsgAGwiEEGAgICAAU8NACAGKAIEIhEhEgJAAkAgEQ0AIBBBBHQhCQJAIBBBgMAASw0AIAcgCUEPckEPakFwcWsiEiQAQQAhEQwBCyAJQRBqEMkPIgdFDQEgB0FwcSIJIAc2AgwgCUEQaiESIAYoAgQhEQsgAEEBSA0EIANBAWohEwNAIBIgACALIAAgC0gbIhQgFGxBBHRqIRUCQCAAIBRrIhZBAUgNACAIIAM2AkwgCCACIBZBBHRqNgJIIAhB4ABqIBUgCEHIAGogFCAWQQBBABDwCQtBACEGAkAgFEEATA0AA0ACQCAUIAZrIgcgB0EEIAdBBEgbIgdrIglBAUgNACAIIAM2AkwgCCACIAYgFmogA2wgFmogByAGaiIPakEEdGo2AkggCEHYAGogEiAGIBRsQQR0aiAIQcgAaiAJIAcgFCAPEPgJCyAUIAZBBGoiBkoNAAsLAkAgAUEBSA0AIBQgFEEEbyIGQQQgBhsiF2shGEEAIRkgASEaA0AgASAZayIGIAogBiAKSBshGwJAIBhBAEgNACAKIBogCiAaSBshHCAEIBlBBHRqIR0gFyEeIBghHwNAIB8gFmohIAJAIBQgH2siBiAGQQQgBkEESBsiIWsiB0EBSA0AIAhBOGpBCGpCADcDACAIQRhqQQhqQgA3AwAgCEKAgICAgICA+L9/NwM4IAhCgICAgICAgPi/fzcDGCAIIAU2AkwgCCAEICAgBWwgGWpBBHRqNgJIIAhB6ABqIAhByABqIA4gEiAfIBRsQQR0aiAbIAcgISAIQRhqIBQgFCAhIB9qIgkgCRDyCQsCQCAGQQFIDQAgHkEEIB5BBEgbIgZBASAGQQFKGyEiICEgIGohI0EAISQDQCAEICMgJGsiJUF/aiImIAVsIBlqQQR0aiEPAkAgJEUNACAbQQFIDQAgJiADbCEnQQAhKANARAAAAAAAAAAAIAIgKCAlaiIGICdqQQR0aiIHKwMIIiymICwgLCAsYhshLUQAAAAAAAAAACAHKwMAIi6mIC4gLiAuYhshLyAEIAYgBWwgGWpBBHRqISlBACEHA0AgLCApIAdBBHQiBmoiCSsDACIwoiIxIC4gCSsDCCIyoiIzoCE0AkAgLiAwoiI1ICwgMqIiNqEiNyA3YQ0AIDQgNGENAAJAAkAgMJlEAAAAAAAA8H9hIgkgMplEAAAAAAAA8H9hIipyIitBAUYNACAsITggLiE5DAELRAAAAAAAAPA/RAAAAAAAAAAAICobIDKmITJEAAAAAAAA8D9EAAAAAAAAAAAgCRsgMKYhMCAtITggLyE5CyA4mSE6AkACQCA5mUQAAAAAAADwf2EiCQ0AIDpEAAAAAAAA8H9hDQAgKw0BAkAgNZlEAAAAAAAA8H9hDQAgNplEAAAAAAAA8H9hDQAgMZlEAAAAAAAA8H9hDQAgM5lEAAAAAAAA8H9iDQMLRAAAAAAAAAAAIDimIDggOCA4YhshOEQAAAAAAAAAACA5piA5IDkgOWIbITlEAAAAAAAAAAAgMqYgMiAyIDJiGyEyRAAAAAAAAAAAIDCmIDAgMCAwYhshMAwBC0QAAAAAAAAAACAypiAyIDIgMmIbITJEAAAAAAAAAAAgMKYgMCAwIDBiGyEwRAAAAAAAAPA/RAAAAAAAAAAAIDpEAAAAAAAA8H9hGyA4piE4RAAAAAAAAPA/RAAAAAAAAAAAIAkbIDmmITkLIDAgOKIgOSAyoqBEAAAAAAAA8H+iITQgMCA5oiA4IDKioUQAAAAAAADwf6IhNwsgDyAGaiIGIAYrAwAgN6E5AwAgBiAGKwMIIDShOQMIIAdBAWoiByAcRw0ACyAoQQFqIiggJEcNAAsLAkACQCACICYgE2xBBHRqIgYrAwAiMJkgBisDCCIymRD0DhCEDyI4mSI0RAAAAAAAAPB/ZCA0RAAAAAAAAPB/Y3JBAUYNAEEAIQYMAQsCQAJAIDREAAAAAAAA4EFjRQ0AIDiqIQYMAQtBgICAgHghBgsgMEEAIAZrIgcQnA8hMCAyIAcQnA8hMgsgMCAyRAAAAAAAAAAAoqAgMCAwoiAyIDKioCI3o0EAIAZrIgYQnA8hLCAwRAAAAAAAAAAAoiAyoSA3oyAGEJwPIS4CQCAsICxhDQAgLiAuYQ0AAkAgN0QAAAAAAAAAAGINAEQAAAAAAADwfyAwpiIsRAAAAAAAAAAAoiEuDAELIDhEAAAAAAAAAABkRQ0AIDREAAAAAAAA8H9iDQBEAAAAAAAA8D9EAAAAAAAAAAAgMJlEAAAAAAAA8H9hGyAwpiIwRAAAAAAAAAAAokQAAAAAAADwP0QAAAAAAAAAACAymUQAAAAAAADwf2EbIDKmIjKhRAAAAAAAAAAAoiEuIDAgMkQAAAAAAAAAAKKgRAAAAAAAAAAAoiEsCwJAIBtBAUgNAEQAAAAAAAAAACAupiAuIC4gLmIbIS1EAAAAAAAAAAAgLKYgLCAsICxiGyEvQQAhBwNAIC4gDyAHQQR0aiIGKwMAIjCiIjEgLCAGKwMIIjKiIjOgITQCQCAsIDCiIjogLiAyoiI2oSI3IDdhDQAgNCA0YQ0AAkACQCAwmUQAAAAAAADwf2EiCSAymUQAAAAAAADwf2EiKXIiKkEBRg0AIC4hOCAsITkMAQtEAAAAAAAA8D9EAAAAAAAAAAAgKRsgMqYhMkQAAAAAAADwP0QAAAAAAAAAACAJGyAwpiEwIC0hOCAvITkLIDiZITUCQAJAAkAgOZlEAAAAAAAA8H9hIgkNACA1RAAAAAAAAPB/Yg0BC0QAAAAAAAAAACAypiAyIDIgMmIbITJEAAAAAAAAAAAgMKYgMCAwIDBiGyEwRAAAAAAAAPA/RAAAAAAAAAAAIDVEAAAAAAAA8H9hGyA4piE4RAAAAAAAAPA/RAAAAAAAAAAAIAkbIDmmITkMAQsgKg0AAkAgOplEAAAAAAAA8H9hDQAgNplEAAAAAAAA8H9hDQAgMZlEAAAAAAAA8H9hDQAgM5lEAAAAAAAA8H9iDQILRAAAAAAAAAAAIDimIDggOCA4YhshOEQAAAAAAAAAACA5piA5IDkgOWIbITlEAAAAAAAAAAAgMqYgMiAyIDJiGyEyRAAAAAAAAAAAIDCmIDAgMCAwYhshMAsgMCA4oiA5IDKioEQAAAAAAADwf6IhNCAwIDmiIDggMqKhRAAAAAAAAPB/oiE3CyAGIDQ5AwggBiA3OQMAIAdBAWoiByAcRw0ACwsgJEEBaiIkICJHDQALCyAIIAU2AkwgCCAdICAgBWxBBHRqNgJIIAhB0ABqIA4gCEHIAGogISAbIBQgHxDJCyAeQQRqIR4gH0EDSiEGIB9BfGohHyAGDQALCwJAIBZBAEwNACAIQShqQQhqQgA3AwAgCEEIakEIakIANwMAIAggBTYCTCAIQoCAgICAgID4v383AyggCEKAgICAgICA+L9/NwMIIAggBCAZQQR0ajYCSCAIQegAaiAIQcgAaiAOIBUgGyAUIBYgCEEIakF/QX9BAEEAEPIJCyAaIAprIRogGSAKaiIZIAFIDQALCyAAIAtrIgBBAEoNAAwFCwALI24hBiNvIQdBBBAUEJMdIAcgBhAVAAsjbiEGI28hB0EEEBQQkx0gByAGEBUACyNuIQYjbyEHQQQQFBCTHSAHIAYQFQALI24hBiNvIQdBBBAUEJMdIAcgBhAVAAsCQCAQQYHAAEkNAEEAIBIgERsiBkUNACAGQXxqKAIAEMoPCwJAIAxBgcAASQ0AQQAgDiANGyIGRQ0AIAZBfGooAgAQyg8LIAhB8ABqJAAL9AIBAn8jAEHwAGsiAyQAIANB4ABqIAIgARDRCwJAIAMtAGBFDQACQAJAAkAgA0HgAGpBBHIiASAARg0AIANB7wBqLQAAIgTAIQICQAJAIAAsAAtBAEgNAAJAIAJBAEgNACAAIAEpAgA3AgAgAEEIaiABQQhqKAIANgIADAILIAAgAygCZCADQegAaigCABCFHBoMAQsgACADKAJkIAEgAkEASCICGyADQegAaigCACAEIAIbEIQcGgsgAy0AYEUNAiADQe8AaiwAAEEASA0BDAILIANB7wBqLAAAQX9KDQELIAMoAmQQ0BsLIANB8ABqJAAPCyMGIQAjiwEhASADQTBqIANBIGogAEGMmwFqEHcgARCtBiADQcAAaiADQTBqIABBz+EAahCtBiADQQA2AhggA0HQAGogA0HAAGogA0EYahDzBCEBIANCvIaAgLAGNwMQIAMgAEGZwgBqNgIMIAMgAEHcMWo2AgggASADQQhqEPQEAAv1AwEFfyMAQbABayIDJAAgAyMZIgRBIGoiBTYCWCADIxoiBigCBCIHNgIgIANBIGogB0F0aigCAGogBigCCDYCACADQSBqIAMoAiBBdGooAgBqIgYgA0EgakEEciIHEMMSIAZCgICAgHA3AkggAyAFNgJYIAMgBEEMajYCICMMIQUgBxCMECIEIAVBCGo2AgAgA0HMAGpCADcCACADQcQAakIANwIAIANB1ABqQRA2AgAgA0EYaiADQSBqIAMoAiBBdGooAgBqIgUQuxIgA0EIaiAFIAEQuhIgA0EIahDYGBoCQCAFKAIYIgVFDQAgBSABIAUoAgAoAggRAQAgA0GoAWogBUEEaiIFENcYIQYgBSABENkYGiAGENgYGgsgA0EYahDYGBogA0EgaiACIAIQpg8QxAQaAkACQCADQSBqIAMoAiBBdGooAgBqLQAQQQVxDQAgA0EIaiAEEMMRIABBDGogA0EQaigCADYCACAAIAMpAwg3AgQgAEEBOgAADAELIABBADoAAAsgA0HYAGohASADIxoiAigCACIFNgIgIANBIGogBUF0aigCAGogAigCDDYCACAEIwxBCGo2AgACQCADLABPQX9KDQAgAygCRBDQGwsgBBCKEBogA0EgaiMaQQRqENQQGiABEIMQGiADQbABaiQACzcAIABBAToAFCAAIAE2AhAgAEIANwIEIABBDGpBADYCACAAI4wBQQhqNgIAIABBGGoQpgQaIAALbAEDfyAAI4wBQQhqNgIAAkAgACgCBCIBIABBCGooAgAiAkYNAANAAkAg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BigCACADKAIARw0CIANBBGohAyAGQQRqIgYgCUcNAAsLIAJBIGogACgCBCAFaigCACIDIAMoAgAoAgARAQAgAkEQaiABIAEoAgAoAgARAQAgAkEwakEIaiIGIAJBIGpBCGopAwA3AwAgBiACKwMYIAYrAwCgOQMAIAIgAikDIDcDMCACIAIrAxAgAisDMKA5AzAgAygCACgCKCEJIAJBCGogBikDADcDACACIAIpAzA3AwAgAyACIAkRAQBBACEECyACKAJAIQMLAkAgA0UNACACIAM2AkQgAxDQGwsCQCACKAJQIgNFDQAgAiADNgJUIAMQ0BsLAkAgAigCYCIDRQ0AIAIgAzYCZCADENAbCwJAIAIoAnAiA0UNACACIAM2AnQgAxDQGwsgCkIBfCIKIAAoAgggACgCBCIDa0ECda1UDQALIARBAXFFDQELIAAgASAAKAIAKAIUEQEACyACQYABaiQAIAAL4wQBCn8CQCAAKAIIIgMgACgCBCIEa0ECdSABSQ0AAkAgAUUNACABQQJ0IQUgAUF/akH/////A3EhBiAEIQMCQCABQQdxIgFFDQBBACEHIAQhAwNAIAMgAigCADYCACADQQRqIQMgB0EBaiIHIAFHDQALCyAEIAVqIQQgBkEHSQ0AA0AgAyACKAIANgIAIAMgAigCADYCBCADIAIoAgA2AgggAyACKAIANgIMIAMgAigCADYCECADIAIoAgA2AhQgAyACKAIANgIYIAMgAigCADYCHCADQSBqIgMgBEcNAAsLIAAgBDYCBA8LAkACQCAEIAAoAgAiBmsiCEECdSIJIAFqIgRBgICAgARPDQBBACEHQQAhBQJAIAMgBmsiA0EBdSIKIAQgCiAESxtB/////wMgA0H8////B0kbIgpFDQAgCkGAgICABE8NAiAKQQJ0EM4bIQULIAFBAnQhCyABQX9qQf////8DcSEMIAUgCUECdGoiCSEDAkAgAUEHcSIERQ0AIAkhAwNAIAMgAigCADYCACADQQRqIQMgB0EBaiIHIARHDQALCyAJIAtqIQcCQCAMQQdJDQADQCADIAIoAgA2AgAgAyACKAIANgIEIAMgAigCADYCCCADIAIoAgA2AgwgAyACKAIANgIQIAMgAigCADYCFCADIAIoAgA2AhggAyACKAIANgIcIANBIGoiAyAHRw0ACwsgBSAK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AEEQajYCtAEMAQsgACABKAKwASILayIAQQR1IgxBAWoiCkGAgICAAU8NAQJAAkAgAEEDdSINIAogDSAKSxtB/////wAgAEHw////B0kbIg0NAEEAIQoMAQsgDUGAgICAAU8NBCANQQR0EM4bIQoLIAogDEEEdGoiDCAOOQMIIAwgDzkDACAKIA1BBHRqIQ0gDEEQaiEMAkAgAEEBSA0AIAogCyAA/AoAAAsgASANNgK4ASABIAw2ArQBIAEgCjYCsAEgC0UNACALENAbCwJAAkAgASgCpAEiACABKAKoAUYNAAJAAkAgASwAmwFBAEgNACAAIAEpA5ABNwIAIABBCGogAUGQAWpBCGooAgA2AgAMAQsgACABKAKQASABKAKUARD6GwsgASAAQQxqNgKkAQwBCyABQaABaiABQZABahDwCwsgAUEFOgA7IAFBADoANSABIwZB2qIBaiIAKAAANgIwIAEgAEEEai0AADoANCABQcAAaiABQZABaiABQTBqEOMMAkAgAkUNAAJAIAYgAkYNAANAIAZBdGohAAJAIAZBf2osAABBf0oNACAAKAIAENAbCyAAIQYgACACRw0ACwsgAhDQGwsgAUEANgJIIAEoAkQhBiABKAJAIQIgAUIANwNAAkAgASwAO0F/Sg0AIAEoAjAQ0BsLAkAgBiACRg0AIAYgAmtBDG0iAEEBIABBAUsbIQtBACEAA0AgByACIABBDGxqQQBBChCZHEEBaiIKIAcgCksbIQcgAEEBaiIAIAtHDQALCwJAIAEsAHtBf0oNACABKAJwENAbCwJAIAEsAIsBQX9KDQAgASgCgAEQ0BsLIAlBDGoiCSADRg0DDAELCyABQbABahBjAAsQZAALQZAUEM4bIgsgBxDSCxoCQCABKAKkASABKAKgASIARg0AQQAhBwJAA0AgAUEgakEIaiIJIAEoArABIAdBBHRqIgpBCGopAwA3AwAgASAKKQMANwMgIAAgB0EMbGoiACgCACAAIAAsAAtBAEgbIg0Qpg8iAEFwTw0BAkACQAJAIABBC0kNACAAQQ9yQQFqIggQzhshCiABIAhBgICAgHhyNgIYIAEgCjYCECABIAA2AhQMAQsgASAAOgAbIAFBEGohCiAARQ0BCyAKIA0gAPwKAAALIAogAGpBADoAACALKAIAKAIYIQAgAUEIaiAJKQMANwMA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AUsbIQtBACEAA0AgByAGIABBDGxqQQBBChCZHEEBaiIKIAcgCksbIQcgAEEBaiIAIAtHDQALCwJAIAEsAHtBf0oNACABKAJwENAbCwJAIAEsAIsBQX9KDQAgASgCgAEQ0BsLIAlBDGoiCSADRg0DDAELCyABQbABahBjAAsQZAALI5sBIQBBkBQQzhsgBxDSCyILIABBCGo2AgACQCABKAKkASABKAKgASIARg0AQQAhBwJAA0AgAUEgakEIaiIJIAEoArABIAdBBHRqIgpBCGopAwA3AwAgASAKKQMANwMgIAAgB0EMbGoiACgCACAAIAAsAAtBAEgbIg0Qpg8iAEFwTw0BAkACQAJAIABBC0kNACAAQQ9yQQFqIggQzhshCiABIAhBgICAgHhyNgIYIAEgCjYCECABIAA2AhQMAQsgASAAOgAbIAFBEGohCiAARQ0BCyAKIA0gAPwKAAALIAogAGpBADoAACALKAIAKAIYIQAgAUEIaiAJKQMANwMAIAEgASkDIDcDACALIAEgAUEQaiAAEQQAAkAgASwAG0F/Sg0AIAEoAhAQ0BsLIAdBAWoiByABKAKkASABKAKgASIAa0EMbUkNAAwCCwALIAFBEGoQdgALAkAgBkUNAAJAIAIgBkYNAANAIAJBdGohAAJAIAJBf2osAABBf0oNACAAKAIAENAbCyAAIQIgACAGRw0ACwsgBhDQGwsCQCABLACbAUF/Sg0AIAEoApABENAbCwJAIARFDQACQCAFDQADQCADQXRqIQACQCADQX9qLAAAQX9KDQAgACgCABDQGwsgACEDIAAgBEcNAAsLIAQQ0BsLAkAgASgCoAEiAkUNACACIQACQCABKAKkASIHIAJGDQADQCAHQXRqIQACQCAHQX9qLAAAQX9KDQAgACgCABDQGwsgACEHIAAgAkcNAAsgASgCoAEhAAsgASACNgKkASAAENAbCwJAIAEoArABIgBFDQAgABDQGwsgAUHAAWokACALC6QGAQR/IwBBwABrIgEkACABQQA6AAQgAUHuwrWrBjYCACABQYTcADsACyABIAE2AhAgACABEJ4GIQIgAUEAOgAoIAFBKGpBBHIhAwJAAkAgAiwAC0EASA0AIAMgAikCADcCACADQQhqIAJBCGooAgA2AgAMAQsgAyACKAIAIAIoAgQQ+hsLIAFBAToAKAJAAkAgAUE3aiwAAEEASA0AIAFBGGpBCGogA0EIaigCADYCACABIAMpAgA3AxgMAQsgAUEYaiABKAIsIAFBMGooAgAQ+hsgAS0AKEUNACABLAA3QX9KDQAgASgCLBDQGwsCQCABLAALQX9KDQAgASgCABDQGwsCQCABKAIcIAEsACMiAkH/AXEgAkEASBtBFkcNACABQRhqQQBBfyMGQZgpakEWEIkcDQAgAUEQEM4bIgI2AgAgAUKLgICAgIKAgIB/NwIEIAIjBkGaGWoiAykAADcAACACQQA6AAsgAkEHaiADQQdqKAAANgAAIAEgAjYCECABQS46AAwgACABEJ4GIAFBKGogAUE4ahDWGCICENcYIgMQzwYhBCADENgYGiACENgYGgJAIAEsAAtBf0oNACABKAIAENAbCyABQRAQzhsiAjYCACABQo2AgICAgoCAgH83AgQgAkEFaiMGQaoOaiIDQQVqKQAANwAAIAIgAykAADcAACACQQA6AA0gASACNgIQIAFBLjoADCABQShqIAAgARCeBhD2DAJAIAEsAAtBf0oNACABKAIAENAbCyObASECQZAUEM4bIAQQ0gsiACACQQhqNgIAAkAgASgCKCICIAEoAiwiA0YNAANAIAAgAhDzCyAAKAIAKAIQEQEAIAJBEGoiAiADRw0ACyABKAIoIQILAkAgAkUNACACIQQCQCABKAIsIgMgAkYNAANAIANBcGoQ1wQiAyACRw0ACyABKAIoIQQLIAEgAjYCLCAEENAbCwJAIAEsACNBf0oNACABKAIYENAbCyABQcAAaiQAIAAPCyMGIQJBCBAUIQAgASACQc3rAGogAUEYahCYHCMSIQIjFSEDIAAgARDQBiADIAIQFQALCgAgABDTCxDQGwuaAQEDfyMAQRBrIgEkACObASECQZAUEM4bIAAgACgCACgCIBEAABDSCyIDIAJBCGo2AgAgASAAIAAoAgAoAjARAQACQCABKAIAIgAgASgCBCICRg0AA0AgAyAAKAIAIAMoAgAoAhQRAQAgAEEEaiIAIAJHDQALIAEoAgAhAAsCQCAARQ0AIAEgADYCBCAAENAbCyABQRBqJAAgAwv0CgEGfyMAQcABayIDJAAgAEIANwIEIABBDGpBADYCACAAI5IBQQhqNgIAIAAgAikDADcDECAAQRhqIAJBCGopAwA3AwAg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AiQgAygCIGtBAnUhBwwCCyADQQA2AjggA0IANwMwC0EAIQEgA0EANgIoIANCADcDIEEAIQcLIAkgASAHIAIgAigCACgCXBEAACACKAIwKQMAEOcNIQsgACAKKQMANwMAIABBCGoiBiAKQQhqKQMANwMAIAAgCyAAKwMAojkDACAGIAsgBisDAKI5AwACQCADKAIgIgZFDQAgAyAGNgIkIAYQ0BsLAkAgAygCMCIGRQ0AIAMgBjYCNCAGENAbCyADKAJAIgZFDQEgAyAGNgJEIAYQ0BsMAQtBACEJIANBADYCSCADQgA3A0AgASgCCCEFIAEoAgQhBiADIANBwABqNgIwAkACQAJAIAYgBUYNAANAIAMgBigCADYCICADQTBqIANBIGoQlQQaIAZBCGoiBiAFRw0ACyABKAIIIQUgASgCBCEGIAMoAkAhCSADQQA2AjggA0IANwMwIAMgA0EwajYCICAGIAVGDQEDQCADIAYoAgQ2AhAgA0EgaiADQRBqEJUEGiAGQQhqIgYgBUcNAAsgASgCCCEFIAEoAgQhBiADKAIwIQFBACEHIANBADYCKCADQgA3AyAgAyADQSBqNgIQIAYgBUYNAgNAIAMgBigCADYCACADQRBqIAMQlQQaIAZBCGoiBiAFRw0ACyADKAIkIAMoAiBrQQJ1IQcMAgsgA0EANgI4IANCADcDMAtBACEBIANBADYCKCADQgA3AyBBACEHCyAJIAEgByACIAIoAgAoAlwRAAAgAigCMCkDABDgDSELIAAgCikDADcDACAAQQhqIgYgCkEIaikDADcDACAAIAsgACsDAKI5AwAgBiALIAYrAwCiOQMAAkAgAygCICIGRQ0AIAMgBjYCJCAGENAbCwJAIAMoAjAiBkUNACADIAY2AjQgBhDQGwsgAygCQCIGRQ0AIAMgBjYCRCAGENAbCyADQdAAaiQADwtBCBAUIQYgA0EQaiABELIMEJ4cIANBIGojBiIFQe2iAWogA0EQahChByADQTBqIANBIGogBUGepQFqEK0GIAMgAigCLCgCABCeHCADQcAAaiADQTBqIAMQswwjOCEFI5MBIQogBiADQcAAahDsByAKIAUQFQAL9gEBBn8jAEEgayIBJABBACECIAFBADYCECABQgA3AwggAEEIaigCACEDIAAoAgQhACABIAFBCGo2AhgCQCAAIANGDQADQCABIAAoAgA2AhQgAUEYaiABQRRqEJUEGiAAQQhqIgAgA0cNAAsCQAJAIAEoAgwiBCABKAIIIgVHDQBBACECDAELIAUhBgJAIAVBBGoiACAERg0AIAUoAgAhAyAFIQYDQCAAIAYgAyAAKAIAIgJJGyEGIAMgAiADIAJLGyEDIABBBGoiACAERw0ACwsgBigCAEEBaiECCyAFRQ0AIAEgBTYCDCAFENAbCyABQSBqJAAgAgtSAQJ/IAAgASACKAIAIAIgAi0ACyIDwEEASCIEGyACKAIEIAMgBBsQ/hsiAikCADcCACAAQQhqIAJBCGoiACgCADYCACACQgA3AgAgAEEANgIAC58IAgZ/AXwjAEHAAGsiAyQAIAFBEGohBAJAAkACQAJAIAIgAigCACgCCBEAAEUNAEEAIQUgA0EANgIwIANCADcDKCABQQhqKAIAIQYgASgCBCEHIAMgA0EoajYCGAJAIAcgBkcNACADQQA2AiAgA0IANwMYDAILA0AgAyAHKAIANgIIIANBGGogA0EIahCVBBogB0EIaiIHIAZHDQALIAEoAgghBiABKAIEIQcgAygCKCEFIANBADYCICADQgA3AxggAyADQRhqNgIIIAcgBkYNAQNAIAMgBygCBDYCOCADQQhqIANBOGoQlQQaIAdBCGoiByAGRw0ACyABKAIIIQYgASgCBCEHIAMoAhghCEEAIQEgA0EANgIQIANCADcDCCADIANBCGo2AjggByAGRg0CA0AgAyAHKAIANgI0IANBOGogA0E0ahCVBBogB0EIaiIHIAZHDQALIAMoAgwgAygCCGtBAnUhAQwCC0EAIQUgA0EANgIwIANCADcDKCABQQhqKAIAIQYgASgCBCEHIAMgA0EoajYCGAJAAkACQCAHIAZHDQAgA0EANgIgIANCADcDGAwBCwNAIAMgBygCADYCCCADQRhqIANBCGoQlQQaIAdBCGoiByAGRw0ACyABKAIIIQYgASgCBCEHIAMoAighBSADQQA2AiAgA0IANwMYIAMgA0EYajYCCCAHIAZGDQADQCADIAcoAgQ2AjggA0EIaiADQThqEJUEGiAHQQhqIgcgBkcNAAsgASgCCCEGIAEoAgQhByADKAIYIQhBACEBIANBADYCECADQgA3AwggAyADQQhqNgI4IAcgBkYNAQNAIAMgBygC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IgcgBygCAEF/IAZ0QX9zcTYCAAsgAygCdCEIIAMoAnAhByADQQA2AlACQCAEIAggB2tBAnUiCEYNAAJAIAQgCE0NACADQfAAaiAEIAhrIANB0ABqEOwLDAELIAQgCE8NACADIAcgBEECdGo2AnQLIAMgBTYCfAJAIAZFDQAgAygCdEF8aiIHIAcoAgBBfyAGdEF/c3E2AgALIAMoAmQhCCADKAJgIQcgA0EANgJQAkAgBCAIIAdrQQJ1IghGDQACQCAEIAhNDQAgA0HgAGogBCAIayADQdAAahDsCwwBCyAEIAhPDQAgAyAHIARBAnRqNgJkCyADIAU2AmwgBkUNACADKAJkQXxqIgQgBCgCAEF/IAZ0QX9zcTYCAAsCQCADKAKcAUUNAEIAIQkDQCADKAKAASAJpyIGQQV2QQJ0IgRqKAIAQQEgBnQiBnEhBQJAAkACQCADKAKQASAEaigCACAGcUUNACADKAJgIARqKAIAIAZxIQcgAygCcCAEaigCACAGcSEEIAUNAQJAIAQNACAHRQ0DIAMgAysDqAGaOQNIIAMgAysDoAGaOQNAIANB0ABqIANBsAFqIANBwABqEMgEIANBsAFqQQhqIANB0ABqQQhqKQMANwMAIAMgAykDUDcDsAEMAwsgB0UNAiADQdAAaiADQbABaiADQaABahDIBCADQbABakEIaiADQdAAakEIaikDADcDACADIAMpA1A3A7ABDAILIAVFDQEgAygCcCAEaigCACAGcUUNAQJAIAMoAmAgBGooAgAgBnENACADQdAAaiADQbABaiADQaABahDIBCADQbABakEIaiADQdAAakEIaikDADcDACADIAMpA1A3A7ABDAILIAMgAysDqAGaOQNIIAMgAysDoAGaOQNAIANB0ABqIANBsAFqIANBwABqEMgEIANBsAFqQQhqIANB0ABqQQhqKQMANwMAIAMgAykDUDcDsAEMAQsCQCAERQ0AIAcNASADIAMrA6gBmjkDSCADIAMrA6ABmjkDQCADQdAAaiADQbABaiADQcAAahDIBCADQbABakEIaiADQdAAakEIaikDADcDACADIAMpA1A3A7ABDAELIAdFDQAgA0HQAGogA0GwAWogA0GgAWoQyAQgA0GwAWpBCGogA0HQAGpBCGopAwA3AwAgAyADKQNQNwOwAQsgCUIBfCIJIAM1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fyMAQRBrIgIkAEEAIQMgAEEANgIIIABCADcCAAJAAkACQCABKAIMKAIEIgQoAiwiAUFYakEAIAEbIgUgBEYNAEEAIQZBACEBA0AgAiAFQQxqEPMMAkACQCABIAZPDQAgASACKQMANwMAIAFBCGogAkEIaikDADcDACAAIAFBEGoiATYCBAwBCyABIANrIgdBBHUiCEEBaiIBQYCAgIABTw0DAkACQCAGIANrIglBA3UiBiABIAYgAUsbQf////8AIAlB8P///wdJGyIBDQBBACEJDAELIAFBgICAgAFPDQUgAUEEdBDOGyEJCyAJIAhBBHRqIgggAikDADcDACAIQQhqIAJBCGopAwA3AwAgCSABQQR0aiEGIAhBEGohAQJAIAdBAUgNACAJIAMgB/wKAAALIAAgBjYCCCAAIAE2AgQgACAJNgIAAkAgA0UNACADENAbCyAJIQMLIAUoAiwiBUFYakEAIAUbIgUgBEcNAAsLIAJBEGokAA8LIAAQYwALEGQAC+0BAQV/IABBADYCCCAAQgA3AgACQCABKAIMKAIEIgIoAiwiAUFYakEAIAEbIgEgAkYNAANAIAFBDGohAwJAAkAgACgCBCIEIAAoAghGDQACQAJAIAEsABdBAEgNACAEIAMpAgA3AgAgBEEIaiADQQhqKAIANgIADAELIAQgASgCDCABQRBqKAIAEPobC0EQEM4bIQMgAUEYaigCACEFQTAQzhshBiADQQA2AgwgAyAGNgIEIAMgBRCdBSAEIAM2AgwgACAEQRBqNgIEDAELIAAgAxDyDAsgASgCLCIBQVhqQQAgARsiASACRw0ACwsLmgIBBX8jAEHAAGsiAiQAIABBADYCCCAAQgA3AgACQCABKAIMKAIEIgMoAiwiAUFYakEAIAEbIgEgA0YNAANAIAJBADoACCACQYDcADsAEyACIAJBCGo2AhggAUEMaiACQQhqEJ4GIAJBOGogAkEwahDWGCIEENcYIgUQzwYhBiAFENgYGiAEENgYGiACIAY2AiQgAkEANgIoIAIjJEEIajYCIAJAAkAgACgCBCIEIAAoAghPDQAgBEEANgIIIAQgBjYCBCAEIyRBCGo2AgAgACAEQQxqNgIEDAELIAAgAkEgahDfBgsCQCACLAATQX9KDQAgAigCCBDQGwsgASgCLCIBQVhqQQAgARsiASADRw0A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wEEASCIHGyIGIAQgBiAESRsiCkUNACAIIAIoAgAgAiAHGyAKEIcPIgcNAQsgBCAGSQ0BDAILIAdBf0oNAQsgASgCBCIBDQIMAwsgASgCCCIBDQALCyAJIQEgCyECDAELIAkhAQsgACACNgIEIAAgATYCAAvMBAEFfyMAQRBrIgEkACOjASECQcAAEM4bIgMgAkEIajYCACOiASECIANBBGogAEEEahDkGyIEIAJBCGo2AgAgA0EMaiECAkACQCAALAAXQQBIDQAgAiAAQQxqIgUpAgA3AgAgAkEIaiAFQQhqKAIANgIADAELIAIgACgCDCAAKAIQEPobCyADQRhqIQICQAJAIAAsACNBAEgNACACIABBGGoiBSkCADcCACACQQhqIAVBCGooAgA2AgAMAQsgAiAAKAIYIAAoAhwQ+hsLIAMgACgCJDYCJCAEI54BQQhqNgIAIAMjoQFBCGo2AiggAyAAKAIsIgI2AiwCQAJAIAINACOkASECIAAoAjAhBSADIAJBCGo2AgAgAyAFNgIwIAQgAkEgajYCACADIAJBNGo2AihBACECDAELIAIgAigCACgCDBEDACAAKAIsIQIgA0E4aiAAQThqKQIANwIAIAMgACkCMDcCMCADI6QBIgVBCGo2AgAgBCAFQSBqNgIAIAMgBUE0ajYCKAJAIAINAEEAIQIMAQsgAUEIaiACIAIoAgAoAhQRAQAgASgCCCICRQ0AIAIgAigCACgCDBEDACABKAIIIgRFDQAgBCAEKAIAKAIQEQAAGgsgAyAAKAI0NgI0IAMgACgCODYCOCADIAAoAjA2AjAgAyAAKAI8NgI8AkAgAygCLCIARQ0AIAAgACgCACgCEBEAABoLIAMgAjYCLAJAIAJFDQAgAiACKAIAKAIMEQMAIAIgAigCACgCEBEAABoLIAFBEGokACADCx8BAn8jnwEhASOgASECQcAAEBQgABCNDSACIAEQFQALtwIBA38gACOjAUEIajYCACOiASECIABBBGogAUEEahDkGyIDIAJBCGo2AgAgAEEMaiECAkACQCABLAAXQQBIDQAgAiABQQxqIgQpAgA3AgAgAkEIaiAEQQhqKAIANgIADAELIAIgASgCDCABKAIQEPobCyAAQRhqIQICQAJAIAEsACNBAEgNACACIAFBGGoiBCkCADcCACACQQhqIARBCGoo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ASkDMDcDACACIAEgAUEoahChDUUNAwJAAkAgACgCACIAKAIcIgQgAEEgaigCACICRg0AA0ACQCACQXhqIgIoAgAiBUEDRg0AIAVBAUcNAiACQQI2AgAgAEEQaiECAkAgACwAG0F/Sg0AIAAoAhBBADoAACAAQRRqQQA2AgAMBAsgAEEAOgAbIABBADoAEAwDCyAAIAI2AiAgBCACRw0ACwsgABCjDSECCwJAAkAgAiwAC0F/Sg0AIAJBBDYCBCACKAIAIQIMAQsgAkEEOgALCyACQQA6AAQgAkHu6rHjBjYAAAsgAUGAAWokACADDwsgAUHYAGogAUHIAGojBiICQYuRAWoQdyAAQRRqIABBIGooAgAQhA0hACABQq+AgIDwBjcDQCABIAJBjSpqNgI8IAEgAkGTMGo2AjggACABQThqEIUNAAsgAUHYAGogAUHIAGojBiICQYuRAWoQdyAAQRRqIABBIGooAgAQhA0hACABQq+AgIDwBjcDQCABIAJBjSpqNgI8IAEgAkGTMGo2AjggACABQThqEIUNAAsgAUHYAGogAUHIAGojBiICQYuRAWoQdyAAQRRqIABBIGooAgAQhA0hACABQq+AgIDwBjcDQCABIAJBjSpqNgI8IAEgAkGTMGo2AjggACABQThqEIUNAAuOAwIEfwF+IwBBgAFrIgEkACAAQQhqIQIDQCABQQA2AlwgASOmATYCWCABIAEpA1g3AyAgAiABQSBqIAFBOGoQoQ0NAAsgACkCACEFQQEhAyABQQE6ADAgASAFNwMoIAFBADYCXCABI7kBNgJYIAEgASkDWDcDGCACIAFBGGogAUEoahC5DSEEIAFBADYCXCABI7oBNgJYIAEgASkDWDcDEAJAAkACQCACIAFBEGogAUEoahC5DQ0AIAFBADYCXCABI7sBNgJYIAEgASkDWDcDCCACIAFBCGogAUEoahC5DUUNAQNAIAFBADYCXCABI7wBNgJYIAEgASkDWDcDACACIAEgAUEoahC5DQ0ACwsgACABQShqEL0NIAAgAUEoahC+DQwBC0EAIQMgBEUNACABQdgAaiABQcgAaiMGIgJBuosBahB3IABBFGogAEEgaigCABCEDSEAIAFCr4CAgPAGNwNAIAEgAkGNKmo2AjwgASACQZMwajYCOCAAIAFBOGoQhQ0ACyABQYABaiQAIAML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AUEANgJUIAEjvgE2AlAgASABKQNQNwM4AkAgAiABQThqIAFB2ABqEKENRQ0AAkACQCAAKAIAIgBBIGooAgAiAkF4aigCAEECRw0AIABBEGohAAwBCyACQXxqKAIAIQALIABBLxCGHAwBCyABQQA2AlQgASO/ATYCUCABIAEpA1A3AzACQCACIAFBMGogAUHYAGoQoQ1FDQACQAJAIAAoAgAiAEEgaigCACICQXhqKAIAQQJHDQAgAEEQaiEADAELIAJBfGooAgAhAAsgAEEIEIYcDAELIAFBADYCVCABI7QBNgJQIAEgASkDUDcDKAJAIAIgAUEoaiABQdgAahChDUUNAAJAAkAgACgCACIAQSBqKAIAIgJBeGooAgBBAkcNACAAQRBqIQAMAQsgAkF8aigCACEACyAAQQwQhhwMAQsgAUEANgJUIAEjuAE2AlAgASABKQNQNwMgAkAgAiABQSBqIAFB2ABqEKENRQ0AAkACQCAAKAIAIgBBIGooAgAiAkF4aigCAEECRw0AIABBEGohAAwBCyACQXxqKAIAIQALIABBChCGHAwBCyABQQA2AlQgASOxATYCUCABIAEpA1A3AxgCQCACIAFBGGogAUHYAGoQoQ1FDQACQAJAIAAoAgAiAEEgaigCACICQXhqKAIAQQJHDQAgAEEQaiEADAELIAJBfGooAgAhAAsgAEENEIYcDAELIAFBADYCVCABI7ABNgJQIAEgASkDUDcDEAJAIAIgAUEQaiABQdgAahChDUUNAAJAAkAgACgCACIAQSBqKAIAIgJBeGooAgBBAkcNACAAQRBqIQAMAQsgAkF8aigCACEACyAAQQkQhhwMAQsgAUEANgJUIAEjsgE2AlAgASABKQNQNwMIAkAgAiABQQhqIAFB2ABqEKENRQ0AIAAQww0MAQsgACMGQefZAGoQrQ0LIAFB4ABqJAALNAEBfwJAIABBIGooAgAiAkF4aigCAEECRw0AIABBEGogARCGHA8LIAJBfGooAgAgARCGHAtdAQF/IwBB0ABrIgIkACACQShqIAJBGGogARB3IABBFGogAEEgaigCABCEDSEAIAJCr4CAgPAGNwMQIAIjBiIBQY0qajYCDCACIAFBkzBqNgIIIAAgAkEIahCFDQALigcBCX8CQAJAIAEoAgAiBSgCDCIGIAUoAhAiB0cNACAFIAUo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ACABQRhqIAJBGGopAwA3AwAgAUEQaiACQRBqKQMANwMAIAFBCGogAkEIaikDADcDACABQcgAaiADQQhqKQMANwMAIAFB0ABqIANBEGopAwA3AwAgAUHYAGogA0EYaikDADcDACABQeAAaiADQSBqKQMANwMAIAFB6ABqIANBKGopAwA3AwAgAUHwAGogA0EwaikDADcDACABQfgAaiADQThqKQMANwMAIAFBiAFqQgA3AwAgAUIANwOAASABQZABakKAgICAgICAgIB/NwMAIAFBmAFqQoCAgICAgID4v383AwAgAUGgAWpCADcDACABQagBakKAgICAgICA+D83AwAgAUGwAWpCADcDACABQfgBaiAAQdD9AWoiAkE4aikDADcDACABQfABaiACQTBqKQMANwMAIAFB6AFqIAJBKGopAwA3AwAgAUHgAWogAkEgaikDADcDACABQdgBaiACQRhqKQMANwMAIAFB0AFqIAJBEGopAwA3AwAgAUHIAWogAkEIaikDADcDACABIAIpAwA3A8ABIAFBuAFqQgA3AwAjxgEiAUKAgICAgICA+D83AwAgAUKAgICAgICAgIB/NwMwIAFBKGpCADcDACABQSBqQgA3AwAgAUEYakIANwMAIAFBEGpCADcDACABQgA3AwggAUE4akKAgICAgICA+L9/NwMAI8cBIgFC59K6taq8n+y/fzcDCCABQsiayvm8jeT2PzcDACABQShqQgA3AwAgAUEYakIANwMAIAFBOGpC59K6taq8n+w/NwMAIAFCyJrK+byN5PY/NwMwIAFBIGpCADcDACABQgA3AxAjyAEiAUEYakIANwMAIAFBKGpCADcDACABQSBqQgA3AwAgAUIANwMQIAFCyJrK+byN5PY/NwMAIAFC59K6taq8n+w/NwMIIAFBOGpC59K6taq8n+y/fzcDACABQsiayvm8jeT2PzcDMCPJASIBQThqQoCAgICAgIDwPzcDACABQShqQoCAgICAgIDwv383AwAgAUEYakKAgICAgICA8L9/NwMAIAFCgICAgICAgPA/NwMIIAFCgICAgICAgPA/NwMAIAFCgICAgICAgPA/NwMQIAFCgICAgICAgPA/NwMgIAFCgICAgICAgPA/NwMwI8oBIgFBGGpCgICAgICAgPC/fzcDACABQoCAgICAgIDwPzcDACABQShqQoCAgICAgIDwPzcDACABQoCAgICAgIDwv383AxAgAUE4akKAgICAgICA8D83AwAgAUKAgICAgICA8D83AyAgAUKAgICAgICA8D83AzAgAUKAgICAgICA8D83AwgjywEiAUEYakKAgICAgICA8D83AwAgAUKAgICAgICA8L9/NwMIIAFCgICAgICAgPA/NwMAIAFBKGpCgICAgICAgPA/NwMAIAFCgICAgICAgPA/NwMQIAFBOGpCgICAgICAgPC/fzcDACABQoCAgICAgIDwPzcDICABQoCAgICAgIDwPzcDMCPMASIBQRhqQoCAgICAgIDwv383AwAgAUKAgICAgICA8L9/NwMIIAFCgICAgICAgPA/NwMAIAFBKGpCgICAgICAgPA/NwMAIAFCgICAgICAgPA/NwMQIAFBOGpCgICAgICAgPC/fzcDACABQoCAgICAgIDwv383AyAgAUKAgICAgICA8D83AzAjzQEiAUIANwMIIAFCgICAgICAgPg/NwMAIAFBEGpCADcDACABQRhqQoCAgICAgID4PzcDACABQoCAgICAgID4v383AyAgAUEoakIANwMAIAFCgICAgICAgICAfzcDMCABQThqQoCAgICAgID4v383AwAjzgEiAUKAgICAgICA+L9/NwMgIAFBGGpCgICAgICAgPi/fzcDACABQoCAgICAgICAgH83AxAgAUIANwMIIAFCgICAgICAgPg/NwMAIAFBKGpCADcDACABQTBqQgA3AwAgAUE4akKAgICAgICA+D83AwAL+QIDAX8CfAV+IwBBMGsiBiQARAAAAAAAAAAAIQcCQCAFQgJUDQAgBUIBiCEJQn8gA60iCoZCf4UhCyADQQFqrSEMRAAAAAAAAAAAIQdCACEFA0AgBCAFIAqIIAyGIAUgC4N8Ig0gAIWnQQR0aiIDKwMIIQggBiADKwMAOQMAIAYgCJo5AwggBkEQaiAEIA2nQQR0aiAGEMgEIAZBIGogBkEQaiPNASANIAGDIg1CAYhC1arVqtWq1arVAIMgDULVqtWq1arVqtUAg3wiDUICiEKz5syZs+bMmTODIA1Cs+bMmbPmzJkzg3wiDUIEiEKHjpy48ODBgweDIA1Ch46cuPDgwYMHg3wiDUIIiEKPgLyA8IHAB4MgDUKPgLyA8IHAB4N8Ig1CEIhCn4CAgPADgyANQp+A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AwA3AwAgBSAEKQMQNwMAIAArAwAhCiAEIAArAwg5AwggBCAKOQMAIARBEGogAiAGQRByaiIAIAQQyAQgAEEIaiAHKQMANwMAIAAgBCkDEDcDACAIQgJ8IgggA1QNAAsLIARBIGokAAs5AQF/IwBBEGsiBCQAIARBCGogAUEIaikDADcDACAEIAEpAwA3AwAgACAEIAIgAxCeDiAEQRBqJAAL3AIDAn8EfgJ8IwBBIGsiBCQAAkACQCAARQ0AIANCAlQNASADQgGIIQZCAEIBIACthiIDfSEHIANC/////w98IQggASsDCCEKIAErAwAhC0IAIQkDQCAEIAo5AwggBCALOQMAIARBEGogAiAJIAiDIAN8IAkgB4NCAYZ8p0EEdGoiACAEEMgEIABBCGogBEEQakEIaiIBKQMANwMAIAAgBCkDEDcDACAEIAo5AwggBCALOQMAIARBEGogAEEQaiIFIAQQyAQgAEEYaiABKQMANwMAIAUgBCkDEDcDACAJQgJ8IgkgBlQNAAwCCwALIANCAlQNACABKwMIIQogASsDACELQgEhCQNAIAQgCjkDCCAEIAs5AwAgBEEQaiACIAmnQQR0aiIAIAQQyAQgAEEIaiAEQRBqQQhqKQMANwMAIAAgBCkDEDcDACAJQgJ8IgkgA1QNAAsLIARBIGokAAtUAQF/IwBBIGsiAyQAIANBEGpBCGpCgICAgICAgPg/NwMAIANBCGpCgICAgICAgPg/NwMAIANCADcDECADQgA3AwAgACADIAEgAhCdDiADQSBqJAALaAEBfyMAQSBrIgMkACADQRBqQQhqQoCAgICAgID4v383AwAgA0EIakKAgICAgICA+L9/NwMAIANCgICAgICAgICAfzcDECADQoCAgICAgICAgH83AwAgACADIAEgAhCdDiADQSBqJAALZAEBfyMAQSBrIgMkACADQRBqQQhqQsz3/LPmk6jzPzcDACADQQhqQsz3/LPmk6jzPzcDACADQsz3/LPmk6jzPzcDECADQsz3/LPmk6jzPzcDACAAIAMgASACEJ0OIANBIGokAAtmAQF/IwBBIGsiAyQAIANBEGpBCGpCzPf8s+aTqPO/fzcDACADQQhqQsz3/LPmk6jzv383AwAgA0LM9/yz5pOo8z83AxAgA0LM9/yz5pOo8z83AwAgACADIAEgAhCdDiAD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BHRqIgAQyAQgBSADQRBqQQhqIggpAwA3AwAgBCADKQMQNwMAIAMgAysDSJo5AwggAyADKwNAmjkDACADQRBqIAMgAEEQaiIEEMgEIAcgCCkDADcDACAGIAMpAxA3AwAgA0EQaiADQcAAaiADQTBqEMgEIABBCGogCCkDADcDACAAIAMpAxA3AwAgA0EQaiADQcAAaiADQSBqEMgEIABBGGogCCkDADcDACAEIAMpAxA3AwAgDUICfCINIAlUDQAMAgsACyACUA0AQgAhDQNAIANBMGpBCGogASANp0EEdCIIaiIAQQhqIgQpAwA3AwAgAyAAKQMANwMwIAMgAysDSJo5AxggAyADKwNAmjkDECADQSBqIANBEGogASAIQRByaiIIEMgEIAQgA0EgakEIaiIGKQMANwMAIAAgAykDIDcDACADQSBqIANBwABqIANBMGoQyAQgCEEIaiAGKQMANwMAIAggAykDIDcDACANQgJ8Ig0gAlQNAAsLIANB0ABqJAAL0AICBH4BfwJAAkAgAEUNACACQgJUDQEgAkIBiCEDQgAhBEIAQgEgAK2GIgJ9IQUgAkL/////D3whBgNAIAEgBCAGgyACfCAEIAWDQgGGfKdBBHRqIgAgACsDAJo5AwAgACAAKwMImjkDCCAAQRhqIgcgBysDAJo5AwAgAEEQaiIAIAArAwCaOQMAIARCAnwiBCADVA0ADAILAAsgAkICVA0AQgEhBCACQn58IgJCAYhCAXwiA0IBgyEFQQEhAAJAIAJCAlQNACADQn6DIQNCACECA0AgASAEp0EEdGoiACAAKwMAmjkDACAAIAArAwiaOQMIIABBKGoiByAHKwMAmjkDACAAQSBqIgAgACsDAJo5AwAgBEIEfCEEIAJCAnwiAiADUg0ACyAEpyEACyAFUA0AIAEgAEEEdGoiACAAKwMAmjkDACAAIAArAwiaOQMICwvvAQEHfgJAIAJCAlQNAEIAIQNCAEIBIACthiIEfSEFIARC/////w98IQYCQCACQgGIIgdCAVENACAHQv7//////////wCDIQhCACEDQgAhBwNAIAEgAyAGgyAEfCADIAWDQgGGfKdBBHRqIgBCADcDACAAQQhqQgA3AwAgASADQgGEIgkgBoMgBHwgCSAFg0IBhnynQQR0aiIAQQhqQgA3AwAgAEIANwMAIANCAnwh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QTBqIAEgAkIAQoCAgICAgIA5EOIPIANB6IF9IANB6IF9ShtBmv4BaiEDIARBMGpBCGopAwAhAiAEKQMwIQELIAQgASACQgAgA0H//wBqrUIwhhDiDyAAIARBCGopAwA3AwggACAEKQMANwMAIARB0ABqJAALSwIBfgJ/IAFC////////P4MhAgJAAkAgAUIwiKdB//8BcSIDQf//AUYNAEEEIQQgAw0BQQJBAyACIACEUBsPCyACIACEUCEECyAEC9sGAgR/A34jAEGAAWsiBSQAAkACQAJAIAMgBEIAQgAQ1Q9FDQAgAyAEEK0PIQYgAkIwiKciB0H//wFxIghB//8BRg0AIAYNAQsgBUEQaiABIAIgAyAEEOIPIAUgBSkDECIEIAVBEGpBCGopAwAiAyAEIAMQ1w8gBUEIaikDACECIAUpAwAhBAwBCwJAIAEgCK1CMIYgAkL///////8/g4QiCSADIARCMIinQf//AXEiBq1CMIYgBEL///////8/g4QiChDVD0EASg0AAkAgASAJIAMgChDVD0UNACABIQQMAgsgBUHwAGogASACQgBCABDiDyAFQfgAaikDACECIAUpA3AhBAwBCwJAAkAgCEUNACABIQQMAQsgBUHgAGogASAJQgBCgICAgICAwLvAABDiDyAFQegAaikDACIJQjCIp0GIf2ohCCAFKQNgIQQLAkAgBg0AIAVB0ABqIAMgCkIAQoCAgICAgMC7wAAQ4g8gBUHYAGopAwAiCkIwiKdBiH9qIQYgBSkDUCEDCyAKQv///////z+DQoCAgICAgMAAhCELIAlC////////P4NCgICAgICAwACEIQkCQCAIIAZMDQADQAJAAkAgCSALfSAEIANUrX0iCkIAUw0AAkAgCiAEIAN9IgSEQgBSDQAgBUEgaiABIAJCAEIAEOIPIAVBKGopAwAhAiAFKQMgIQQMBQsgCkIBhiAEQj+IhCEJDAELIAlCAYYgBEI/iIQhCQsgBEIBhiEEIAhBf2oiCCAGSg0ACyAGIQgLAkACQCAJIAt9IAQgA1StfSIKQgBZDQAgCSEKDAELIAogBCADfSIEhEIAUg0AIAVBMGogASACQgBCABDiDyAFQThqKQMAIQIgBSkDMCEEDAELAkAgCkL///////8/Vg0AA0AgBEI/iCEDIAhBf2ohCCAEQgGGIQQgAyAK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4Q8gBSkDACAFKQMQIAVBEGpBCGopAwCEQgBSrYQhAiAFQQhqKQMAIQQLIAJCA4ggBEI9hoQhAyAHrUIwhiAEQgOIQv///////z+DhCAKhCEEIAKnQQdxIQYCQAJAAkACQAJAEN8PDgMAAQIDCyAEIAMgBkEES618IgogA1StfCEEAkAgBkEERg0AIAohAwwDCyAEIApCAYMiASAKfCIDIAFUrXwhBAwDCyAEIAMgCkIAUiAGQQBHca18IgogA1StfCEEIAohAwwBCyAEIAMgClAgBkEAR3GtfCIKIANUrXwhBCAKIQMLIAZFDQELEOAPGgsgACADNwMAIAAgBDcDCCAFQfAAaiQAC1MBAX4CQAJAIANBwABxRQ0AIAEgA0FAaq2GIQJCACEBDAELIANFDQAgAUHAACADa62IIAIgA60iBIaEIQIgASAEhiEBCyAAIAE3AwAgACACNwMIC+ABAgF/An5BASEEAkAgAEIAUiABQv///////////wCDIgVCgICAgICAwP//AFYgBUKAgICAgIDA//8AURsNACACQgBSIANC////////////AIMiBkKAgICAgIDA//8AViAGQoCAgICAgMD//wBRGw0AAkAgAiAAhCAGIAWEhFBFDQBBAA8LAkAgAyABg0IAUw0AQX8hBCAAIAJUIAEgA1MgASADURsNASAAIAKFIAEgA4WEQgBSDwtBfyEEIAAgAlYgASADVSABIANRGw0AIAAgAoUgASADhYRCAFIhBAsgBAvYAQIBfwJ+QX8hBAJAIABCAFIgAUL///////////8AgyIFQoCAgICAgMD//wBWIAVCgICAgICAwP//AFEbDQAgAkIAUiADQv///////////wCDIgZCgICAgICAwP//AFYgBkKAgICAgIDA//8AURsNAAJAIAIgAIQgBiAFhIRQRQ0AQQAPCwJAIAMgAYNCAFMNACAAIAJUIAEgA1MgASADURsNASAAIAKFIAEgA4WEQgBSDwsgACACViABIANVIAEgA1EbDQAgACAChSABIAOFhEIAUiEECyAEC+cQAgV/D34jAEHQAmsiBSQAIARC////////P4MhCiACQv///////z+DIQsgBCAChUKAgICAgICAgIB/gyEMIARCMIinQf//AXEhBgJAAkACQCACQjCIp0H//wFxIgdBgYB+akGCgH5JDQBBACEIIAZBgYB+akGBgH5LDQELAkAgAVAgAkL///////////8AgyINQoCAgICAgMD//wBUIA1CgICAgICAwP//AFEbDQAgAkKAgICAgIAghCEMDAILAkAgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbDQAgBEKAgICAgIAghCEMIAMhAQwCCwJAIAEgDUKAgICAgIDA//8AhYRCAFINAAJAIAMgAkKAgICAgIDA//8AhYRQRQ0AQgAhAUKAgICAgIDg//8AIQwMAwsgDEKAgICAgIDA//8AhCEMQgAhAQwCCwJAIAMgAkKAgICAgIDA//8AhYRCAFINAEIAIQEMAgsCQCABIA2EQgBSDQBCgICAgICA4P//ACAMIAMgAoRQGyEMQgAhAQwCCwJAIAMgAoRCAFINACAMQoCAgICAgMD//wCEIQxCACEBDAILQQAhCAJAIA1C////////P1YNACAFQcACaiABIAsgASALIAtQIggbeSAIQQZ0rXynIghBcWoQ1A9BECAIayEIIAVByAJqKQMAIQsgBSkDwAIhAQsgAkL///////8/Vg0AIAVBsAJqIAMgCiADIAogClAiCRt5IAlBBnStfKciCUFxahDUDyAJIAhqQXBqIQggBUG4AmopAwAhCiAFKQOwAiEDCyAFQaACaiADQjGIIApCgICAgICAwACEIg5CD4aEIgJCAEKAgICAsOa8gvUAIAJ9IgRCABDjDyAFQZACakIAIAVBoAJqQQhqKQMAfUIAIARCABDjDyAFQYACaiAFKQOQAkI/iCAFQZACakEIaikDAEIBhoQiBEIAIAJCABDjDyAFQfABaiAEQgBCACAFQYACakEIaikDAH1CABDjDyAFQeABaiAFKQPwAUI/iCAFQfABakEIaikDAEIBhoQiBEIAIAJCABDjDyAFQdABaiAEQgBCACAFQeABakEIaikDAH1CABDjDyAFQcABaiAFKQPQAUI/iCAFQdABakEIaikDAEIBhoQiBEIAIAJCABDjDyAFQbABaiAEQgBCACAFQcABakEIaikDAH1CABDjDyAFQaABaiACQgAgBSkDsAFCP4ggBUGwAWpBCGopAwBCAYaEQn98IgRCABDjDyAFQZABaiADQg+GQgAgBEIAEOMPIAVB8ABqIARCAEIAIAVBoAFqQQhqKQMAIAUpA6ABIgogBUGQAWpBCGopAwB8IgIgClStfCACQgFWrXx9QgAQ4w8gBUGAAWpCASACfUIAIARCABDjDyAIIAcgBmtqIQYCQAJAIAUpA3AiD0IBhiIQIAUpA4ABQj+IIAVBgAFqQQhqKQMAIhFCAYaEfCINQpmTf3wiEkIgiCICIAtCgICAgICAwACEIhNCAYYiFEIgiCIEfiIVIAFCAYYiFkIgiCIKIAVB8ABqQQhqKQMAQgGGIA9CP4iEIBFCP4h8IA0gEFStfCASIA1UrXxCf3wiD0IgiCINfnwiECAVVK0gECAPQv////8PgyIPIAFCP4giFyALQgGGhEL/////D4MiC358IhEgEFStfCANIAR+fCAPIAR+IhUgCyANfnwiECAVVK1CIIYgEEIgiIR8IBEgEEIghnwiECARVK18IBAgEkL/////D4MiEiALfiIVIAIgCn58IhEgFVStIBEgDyAWQv7///8PgyIVfnwiGCARVK18fCIRIBBUrXwgESASIAR+IhAgFSANfnwiBCACIAt+fCINIA8gCn58Ig9CIIggBCAQVK0gDSAEVK18IA8gDVStfEIghoR8IgQgEVStfCAEIBggAiAVfiICIBIgCn58IgpCIIggCiACVK1CIIaEfCICIBhUrSACIA9CIIZ8IAJUrXx8IgIgBFStfCIEQv////////8AVg0AIBQgF4QhEyAFQdAAaiACIAQgAyAOEOMPIAFCMYYgBUHQAGpBCGopAwB9IAUpA1AiAUIAUq19IQ0gBkH+/wBqIQZCACABfSEKDAELIAVB4ABqIAJCAYggBEI/hoQiAiAEQgGIIgQgAyAOEOMPIAFCMIYgBUHgAGpBCGopAwB9IAUpA2AiCkIAUq19IQ0gBkH//wBqIQZCACAKfSEKIAEhFgsCQCAGQf//AUgNACAMQoCAgICAgMD//wCEIQxCACEBDAELAkACQCAGQQFIDQAgDUIBhiAKQj+IhCENIAatQjCGIARC////////P4OEIQ8gCkIBhiEEDAELAkAgBkGPf0oNAEIAIQEMAgsgBUHAAGogAiAEQQEgBmsQ4Q8gBUEwaiAWIBMgBkHwAGoQ1A8gBUEgaiADIA4gBSkDQCICIAVBwABqQQhqKQMAIg8Q4w8gBUEwakEIaikDACAFQSBqQQhqKQMAQgGGIAUpAyAiAUI/iIR9IAUpAzAiBCABQgGGIgFUrX0hDSAEIAF9IQQLIAVBEGogAyAOQgNCABDjDyAFIAMgDkIFQgAQ4w8gDyACIAJCAYMiASAEfCIEIANWIA0gBCABVK18IgEgDlYgASAOURutfCIDIAJUrXwiAiADIAJCgICAgICAwP//AFQgBCAFKQMQViABIAVBEGpBCGopAwAiAlYgASACURtxrXwiAiADVK18IgMgAiADQoCAgICAgMD//wBUIAQgBSkDAFYgASAFQQhqKQMAIgRWIAEgBFEbca18IgEgAlStfCAMhCEMCyAAIAE3AwAgACAMNwMIIAVB0AJqJAALIAACQEEAKAK0jAQNAEG0jAQgADYCAEEAIAE2AriMBAsLBgAgACQBCwQAIwELjgICAn8DfiMAQRBrIgIkAAJAAkAgAb0iBEL///////////8AgyIFQoCAgICAgIB4fEL/////////7/8AVg0AIAVCPIYhBiAFQgSIQoCAgICAgICAPHwhBQwBCwJAIAVCgICAgICAgPj/AFQNACAEQjyGIQYgBEIEiEKAgICAgIDA//8AhCEFDAELAkAgBVBFDQBCACEGQgAhBQwBCyACIAVCACAEp2dBIGogBUIgiKdnIAVCgICAgBBUGyIDQTFqENQPIAJBCGopAwBCgICAgICAwACFQYz4ACADa61CMIaEIQUgAikDACEGCyAAIAY3AwAgACAFIARCgICAgICAgICAf4OENwMIIAJBEGokAAvhAQIDfwJ+IwBBEGsiAiQAAkACQCABvCIDQf////8HcSIEQYCAgHxqQf////cHSw0AIAStQhmGQoCAgICAgIDAP3whBUIAIQYMAQsCQCAEQYCAgPwHSQ0AIAOtQhmGQoCAgICAgMD//wCEIQVCACEGDAELAkAgBA0AQgAhBkIAIQUMAQsgAiAErUIAIARnIgRB0QBqENQPIAJBCGopAwBCgICAgICAwACFQYn/ACAEa61CMIaEIQUgAikDACEGCyAAIAY3AwAgACAFIANBgICAgHhxrUIghoQ3AwggAkEQaiQAC40BAgJ/An4jAEEQayICJAACQAJAIAENAEIAIQRCACEFDAELIAIgASABQR91IgNzIANrIgOtQgAgA2ciA0HRAGoQ1A8gAkEIaikDAEKAgICAgIDAAIVBnoABIANrrUIwhnwgAUGAgICAeHGtQiCGhCEFIAIpAwAhBAsgACAENwMAIAAgBTcDCCACQRBqJAALcgIBfwJ+IwBBEGsiAiQAAkACQCABDQBCACEDQgAhBAwBCyACIAGtQgAgAWciAUHRAGoQ1A8gAkEIaikDAEKAgICAgIDAAIVBnoABIAFrrUIwhnwhBCACKQMAIQMLIAAgAzcDACAAIAQ3AwggAkEQaiQACwQAQQALBABBAAtTAQF+AkACQCADQcAAcUUNACACIANBQGqtiCEBQgAhAgwBCyADRQ0AIAJBwAAgA2uthiABIAOtIgSIhCEBIAIgBIghAgsgACABNwMAIAAgAjcDCAucCwIFfw9+IwBB4ABrIgUkACAEQv///////z+DIQogBCAChUKAgICAgICAgIB/gyELIAJC////////P4MiDEIgiCENIARCMIinQf//AXEhBgJAAkACQCACQjCIp0H//wFxIgdBgYB+akGCgH5JDQBBACEIIAZBgYB+akGBgH5LDQELAkAgAVAgAkL///////////8AgyIOQoCAgICAgMD//wBUIA5CgICAgICAwP//AFEbDQAgAkKAgICAgIAghCELDAILAkAgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbDQAgBEKAgICAgIAghCELIAMhAQwCCwJAIAEgDkKAgICAgIDA//8AhYRCAFINAAJAIAMgAoRQRQ0AQoCAgICAgOD//wAhC0IAIQEMAwsgC0KAgICAgIDA//8AhCELQgAhAQwCCwJAIAMgAkKAgICAgIDA//8AhYRCAFINACABIA6EIQJCACEBAkAgAlBFDQBCgICAgICA4P//ACELDAMLIAtCgICAgICAwP//AIQhCwwCCwJAIAEgDoRCAFINAEIAIQEMAgsCQCADIAKEQgBSDQBCACEBDAILQQAhCAJAIA5C////////P1YNACAFQdAAaiABIAwgASAMIAxQIggbeSAIQQZ0rXynIghBcWoQ1A9BECAIayEIIAVB2ABqKQMAIgxCIIghDSAFKQNQIQELIAJC////////P1YNACAFQcAAaiADIAogAyAKIApQIgkbeSAJQQZ0rXynIglBcWoQ1A8gCCAJa0EQaiEIIAVByABqKQMAIQogBSkDQCEDCyADQg+GIg5CgID+/w+DIgIgAUIgiCIEfiIPIA5CIIgiDiABQv////8PgyIBfnwiEEIghiIRIAIgAX58IhIgEVStIAIgDEL/////D4MiDH4iEyAOIAR+fCIRIANCMYggCkIPhiIUhEL/////D4MiAyABfnwiCiAQQiCIIBAgD1StQiCGhHwiDyACIA1CgIAEhCIQfiIVIA4gDH58Ig0gFEIgiEKAgICACIQiAiABfnwiFCADIAR+fCIWQiCGfCIXfCEBIAcgBmogCGpBgYB/aiEGAkACQCACIAR+IhggDiAQfnwiBCAYVK0gBCADIAx+fCIOIARUrXwgAiAQfnwgDiARIBNUrSAKIBFUrXx8IgQgDlStfCADIBB+IgMgAiAMfnwiAiADVK1CIIYgAkIgiIR8IAQgAkIghnwiAiAEVK18IAIgFkIgiCANIBVUrSAUIA1UrXwgFiAUVK18QiCGhHwiBCACVK18IAQgDyAKVK0gFyAPVK18fCICIARUrXwiBEKAgICAgIDAAINQDQAgBkEBaiEGDAELIBJCP4ghAyAEQgGGIAJCP4iEIQQgAkIBhiABQj+IhCECIBJCAYYhEiADIAFCAYaEIQELAkAgBkH//wFIDQAgC0KAgICAgIDA//8AhCELQgAhAQwBCwJAAkAgBkEASg0AAkBBASAGayIHQYABSQ0AQgAhAQwDCyAFQTBqIBIgASAGQf8AaiIGENQPIAVBIGogAiAEIAYQ1A8gBUEQaiASIAEgBxDhDyAFIAIgBCAHEOEPIAUpAyAgBSkDEIQgBSkDMCAFQTBqQQhqKQMAhEIAUq2EIRIgBUEgakEIaikDACAFQRBqQQhqKQMAhCEBIAVBCGopAwAhBCAFKQMAIQIMAQsgBq1CMIYgBEL///////8/g4QhBAsgBCALhCELAkAgElAgAUJ/VSABQoCAgICAgICAgH9RGw0AIAsgAkIBfCIBIAJUrXwhCwwBCwJAIBIgAUKAgICAgICAgIB/hYRCAFENACACIQEMAQsgCyACIAJCAYN8IgEgAlStfCELCyAAIAE3AwAgACALNwMIIAVB4ABqJAALdQEBfiAAIAQgAX4gAiADfnwgA0IgiCICIAFCIIgiBH58IANC/////w+DIgMgAUL/////D4MiAX4iBUIgiCADIAR+fCIDQiCIfCADQv////8PgyACIAF+fCIBQiCIfDcDCCAAIAFCIIYgBUL/////D4OENwMAC0gBAX8jAEEQayIFJAAgBSABIAIgAyAEQoCAgICAgICAgH+FENMPIAUpAwAhBCAAIAVBCGopAwA3AwggACAENwMAIAVBEGokAAvkAwICfwJ+IwBBIGsiAiQAAkACQCABQv///////////wCDIgRCgICAgICAwP9DfCAEQoCAgICAgMCAvH98Wg0AIABCPIggAUIEhoQhBAJAIABC//////////8PgyIAQoGAgICAgICACFQNACAEQoGAgICAgICAwAB8IQUMAgsgBEKAgICAgICAgMAAfCEFIABCgICAgICAgIAIUg0BIAUgBEIBg3whBQwBCwJAIABQIARCgICAgICAwP//AFQgBEKAgICAgIDA//8AURsNACAAQjyIIAFCBIaEQv////////8Dg0KAgICAgICA/P8AhCEFDAELQoCAgICAgID4/wAhBSAEQv///////7//wwBWDQBCACEFIARCMIinIgNBkfcASQ0AIAJBEGogACABQv///////z+DQoCAgICAgMAAhCIEIANB/4h/ahDUDyACIAAgBEGB+AAgA2sQ4Q8gAikDACIEQjyIIAJBCGopAwBCBIaEIQUCQCAEQv//////////D4MgAikDECACQRBqQQhqKQMAhEIAUq2EIgRCgYCAgICAgIAIVA0AIAVCAXwhBQwBCyAEQoCAgICAgICACFINACAFQgGDIAV8IQULIAJBIGokACAFIAFCgICAgICAgICAf4OEvwvEAwIDfwF+IwBBIGsiAiQAAkACQCABQv///////////wCDIgVCgICAgICAwL9AfCAFQoCAgICAgMDAv398Wg0AIAFCGYinIQMCQCAAUCABQv///w+DIgVCgICACFQgBUKAgIAIURsNACADQYGAgIAEaiEEDAILIANBgICAgARqIQQgACAFQoCAgAiFhEIAUg0BIAQgA0EBcWohBAwBCwJAIABQIAVCgICAgICAwP//AFQgBUKAgICAgIDA//8AURsNACABQhmIp0H///8BcUGAgID+B3IhBAwBC0GAgID8ByEEIAVC////////v7/AAFYNAEEAIQQgBUIwiKciA0GR/gBJDQAgAkEQaiAAIAFC////////P4NCgICAgICAwACEIgUgA0H/gX9qENQPIAIgACAFQYH/ACADaxDhDyACQQhqKQMAIgVCGYinIQQCQCACKQMAIAIp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CwQAIAALEwAgACABIAIgACgCACgCMBEFAAtjAQJ/IwBBEGsiASQAQQBBADYCtIwEQeoJIAAgAUEIaiABECYhAEEAKAK0jAQhAkEAQQA2ArSMBAJAIAJBAUYNACAAELwRIAAQvREgAUEQaiQAIAAPC0EAEAUaENoPGhDoHAALCgAgABC+ERC/EQsHACAAKAIICwcAIAAoAgwLBwAgACgCEAsHACAAKAIUCwcAIAAoAhgLBwAgACgCHAsLACAAIAEQwBEgAAsXACAAIAM2AhAgACACNgIMIAAgATYCCAsXACAAIAI2AhwgACABNgIUIAAgATYCGAsPACAAIAAoAhggAWo2AhgLDQAgACABQQRqENcYGgsKACAAEIYSEIcSCwIACzQBAX8gABDBESEBQQAhAANAAkAgAEEDRw0ADwsgASAAQQJ0akEANgIAIABBAWohAAwACwALGAACQCAAENERRQ0AIAAQ/BEPCyAAEJISCwQAIAALfQECfyMAQRBrIgIkAAJAIAAQ0RFFDQAgABDCESAAEPwRIAAQ1hEQ+RELIAAgARCQEiABEMERIQMgABDBESIAQQhqIANBCGooAgA2AgAgACADKQIANwIAIAFBABCREiABEJISIQAgAkEAOgAPIAAgAkEPahCTEiACQRBqJAALBwAgABCFEgsHACAAEPsRC60BAQN/IwBBIGsiAiQAAkACQCABKAIwIgNBEHFFDQACQCABKAIsIAEQtBFPDQAgASABELQRNgIsCyABELMRIQMgASgCLCEEIAFBIGoQxBEgACADIAQgAkEYahDFERoMAQsCQCADQQhxRQ0AIAEQsBEhAyABELIRIQQgAUEgahDEESAAIAMgBCACQRBqEMURGgwBCyABQSBqEMQRIAAgAkEIahDGERoLIAJBIGokAAsIACAAEMcRGgswAQF/IwBBEGsiBCQAIAAgBEEIaiADEMgRIgMgASACEMkRIAMQvBEgBEEQaiQAIAMLYwEBfyMAQRBrIgIkAEEAQQA2ArSMBEHrCSAAIAJBCGogARAmIQFBACgCtIwEIQBBAEEANgK0jAQCQCAAQQFGDQAgARC8ESABEL0RIAJBEGokACABDwtBABAFGhDaDxoQ6BwACwcAIAAQnBILDAAgABCGEiACEJ4SC60BAQR/IwBBEGsiAyQAAkAgASACEJ8SIgQgABCgEksNAAJAAkAgBBChEkUNACAAIAQQkRIgABCSEiEFDAELIAQQohIhBSAAIAAQwhEgBUEBaiIGEKMSIgUQpBIgACAGEKUSIAAgBBCmEgsCQANAIAEgAkYNASAFIAEQkxIgBUEBaiEFIAFBAWohAQwACwALIANBADoADyAFIANBD2oQkxIgA0EQaiQADwsgABB2AAvMAQEBfyAAQSBqIgIgARDLERogAEEANgIsAkAgACgCMCIBQQhxRQ0AIAAgAhCvESACEMwRajYCLCAAIAIQrxEgAhCvESAAKAIsELcRIAAoAjAhAQsCQCABQRBxRQ0AIAAgAhDMESIBIAIQrxFqNgIsIAIgAhDNERDOESAAIAIQrxEgAhCvESACEMwRahC4ESAALQAwQQNxRQ0AAkADQCABQX9KDQEgAEH/////BxDPESABQYGAgIB4aiEBDAALAAsgAUUNACAAIAEQzxELC3UBAX8CQCAAIAFGDQAgACABENARAkAgABDREQ0AAkAgARDREQ0AIAEQ0hEhASAAEMERIgJBCGogAUEIaigCADYCACACIAEpAgA3AgAgAA8LIAAgARDTESABEMwREIUcDwsgACABENMRIAEQzBEQhBwhAAsgAAsYAAJAIAAQ0RFFDQAgABDUEQ8LIAAQ1RELHwEBf0EKIQECQCAAENERRQ0AIAAQ1hFBf2ohAQsgAQsLACAAIAFBABCLHAsPACAAIAAoAhggAWo2AhgLCQAgACABEIoSCw0AIAAQ0hEtAAtBB3YLBwAgABD9EQsKACAAEIsSEIwSCwoAIAAQ0hEoAgQLCgAgABDSES0ACwsRACAAENIRKAIIQf////8HcQtqAAJAIAAoAiwgABC0EU8NACAAIAAQtBE2AiwLAkAgAC0AMEEIcUUNAAJAIAAQshEgACgCLE8NACAAIAAQsBEgABCxESAAKAIsELcRCyAAELERIAAQshFPDQAgABCxESwAABCdEA8LEJsQC6oBAQF/AkAgACgCLCAAELQRTw0AIAAgABC0ETYCLAsCQCAAELARIAAQsRFPDQACQCABEJsQEL0QRQ0AIAAgABCwESAAELERQX9qIAAoAiwQtxEgARDZEQ8LAkAgAC0AMEEQcQ0AIAEQmBAgABCxEUF/aiwAABDQEEUNAQsgACAAELARIAAQsRFBf2ogACgCLBC3ESABEJgQIQIgABCxESACOgAAIAEPCxCbEAsaAAJAIAAQmxAQvRBFDQAQmxBBf3MhAAsgAAuAAwEJfyMAQRBrIgIkAAJAAkACQCABEJsQEL0QDQAgABCxESEDIAAQsBEhBAJAIAAQtBEgABC1EUcNAAJAIAAtADBBEHENABCbECEADAQLIAAQtBEhBSAAELMRIQYgACgCLCEHIAAQsxEhCEEAQQA2ArSMBEGOBSAAQSBqIglBABAPQQAoArSMBCEKQQBBADYCtIwEIApBAUYNAiAJEM0RIQpBAEEANgK0jARB7AkgCSAKEA9BACgCtIwEIQpBAEEANgK0jAQgCkEBRg0CIAAgCRCvESIKIAogCRDMEWoQuBEgACAFIAZrELkRIAAgABCzESAHIAhrajYCLAsgAiAAELQRQQFqNgIMIAAgAkEMaiAAQSxqENsRKAIANgIsAkAgAC0AMEEIcUUNACAAIABBIGoQrxEiCSAJIAMgBGtqIAAoAiwQtxELIAAgARCYEBC+ECEADAILIAEQ2REhAAwBC0EAEAUhABDaDxogABAoGhCbECEAECkLIAJBEGokACAACwkAIAAgARDcEQspAQJ/IwBBEGsiAiQAIAJBCGogACABEPgRIQMgAkEQaiQAIAEgACADGwu1AgIDfgF/AkAgASgCLCABELQRTw0AIAEgARC0ETYCLAtCfyEFAkAgBEEYcSIIRQ0AAkAgA0EBRw0AIAhBGEYNAQtCACEGQgAhBwJAIAEoAiwiCEUNACAIIAFBIGoQrxFrrCEHCwJAAkACQCADDgMCAAEDCwJAIARBCHFFDQAgARCxESABELARa6whBgwCCyABELQRIAEQsxFrrCEGDAELIAchBgsgBiACfCICQgBTDQAgByACUw0AIARBCHEhAwJAIAJQDQACQCADRQ0AIAEQsRFFDQILIARBEHFFDQAgARC0EUUNAQsCQCADRQ0AIAEgARCwESABELARIAKnaiABKAIsELcRCwJAIARBEHFFDQAgASABELMRIAEQtREQuBEgASACpxDPEQsgAiEFCyAAIAUQkBAaCwcAIAAQ0xELCwAgAEGApwQQhBQLDwAgACAAKAIAKAIcEQAACwkAIAAgARDkEQsdACAAIAEgAiADIAQgBSAGIAcgACgCACgCEBERAAsTAEEEEBQQpx1BnNsDQe0JEBUACykBAn8jAEEQayICJAAgAkEIaiABIAAQ9w8hAyACQRBqJAAgASAAIAMbCx0AIAAgASACIAMgBCAFIAYgByAAKAIAKAIMEREACw8AIAAgACgCACgCGBEAAAsXACAAIAEgAiADIAQgACgCACgCFBEIAAscACAAQcDXAkEIajYCACAAQSBqEPYbGiAAEIoQCwoAIAAQ6BEQ0BsLGgAgACABIAIQ0xBBACADIAEoAgAoAhARIgALCgAgABDcBBDQGwsKACAAQXhqENwECwoAIABBeGoQ6xELEwAgACAAKAIAQXRqKAIAahDcBAsTACAAIAAoAgBBdGooAgBqEOsRCwoAIAAQjQUQ0BsLEwAgACAAKAIAQXRqKAIAahCNBQsTACAAIAAoAgBBdGooAgBqEPARCxYAIABBuOICEPQRIgBBPGoQgxAaIAALNgEBfyAAIAEoAgAiAjYCACAAIAJBdGooAgBqIAEoAgw2AgAgAEEIahDoERogACABQQRqEKEQCwoAIAAQ8xEQ0BsLEwAgACAAKAIAQXRqKAIAahDzEQsTACAAIAAoAgBBdGooAgBqEPURCw0AIAEoAgAgAigCAEkLCwAgACABIAIQ+hELQABBAEEANgK0jARB7gkgASACQQEQFkEAKAK0jAQhAkEAQQA2ArSMBAJAIAJBAUYNAA8LQQAQBRoQ2g8aEOgcAAsHACAAEIQSCwoAIAAQwREoAgALBAAgAAseAAJAIAIQ/xFFDQAgACABIAIQgBIPCyAAIAEQgRILBwAgAEEISwsJACAAIAIQghILBwAgABCDEgsJACAAIAEQ1BsLBwAgABDQGwsEACAACwQAIAALBAAgAAsHACAAEIgSCwcAIAAQiRILBAAgAAsCAAsYAAJAIAAQ0RFFDQAgABCNEg8LIAAQjhILBAAgAAsKACAAENIRKAIACwoAIAAQ0hEQjxILBAAgAAsJACAAIAEQlBILDAAgABDBESABOgALCwoAIAAQwREQlRILDAAgACABLQAAOgAACw4AIAEQwhEaIAAQwhEaCwQAIAALMQEBfwJAIAAoAgAiAUUNAAJAIAEQuRAQmxAQvRANACAAKAIARQ8LIABBADYCAAtBAQsIAEGAgICAeAsIAEH/////BwsRACAAIAEgACgCACgCHBECAAsxAQF/AkAgACgCACIBRQ0AAkAgARCfERCGERChEQ0AIAAoAgBFDwsgAEEANgIAC0EBCxEAIAAgASAAKAIAKAIsEQIACwcAIAAQnRILBAAgAAsEACAACwkAIAAgARCnEgsNACAAEMcREKgSQXBqCwcAIABBC0kLLQEBf0EKIQECQCAAQQtJDQAgAEEBahCpEiIAIABBf2oiACAAQQtGGyEBCyABCwkAIAAgARCqEgsMACAAEMERIAE2AgALEwAgABDBESABQYCAgIB4cjYCCAsMACAAEMERIAE2AgQLBwAgASAAawsFABCrEgsKACAAQQ9qQXBxCxkAAkAgABCoEiABTw0AEGQACyABQQEQrRILBQAQrBILBABBfwsaAAJAIAEQ/xFFDQAgACABEK4SDwsgABCvEgsJACAAIAEQ0hsLBwAgABDOGwsEAEEACwUAQfs6Cx4AAkAgAkEBRg0AIAAgASACEL8cDwsgAEGZKhB3GgsHACAAEKYPCycAAkBBAC0AvIwEDQBBugpBAEGACBCwEhpBAEEBOgC8jAQLQfjzAwsKAEH48wMQ0xwaC0ACAX8BfiMAQRBrIgMkACADIAIpAgAiBDcDACADIAQ3AwggACADIAEQzxwiAkHo4wJBCGo2AgAgA0EQaiQAIAILBwAgABDQHAsNACAAELcSGiAAENAbC0ABAn8gACgCKCECA0ACQCACDQAPCyABIAAgACgCJCACQX9qIgJBAnQiA2ooAgAgACgCICADaigCABEEAAwACwALWwEBfyAAIAFBHGoiAxDXGCEAIAMgAhDZGBpBAEEANgK0jARBuwogAUEBEA9BACgCtIwEIQFBAEEANgK0jAQCQCABQQFHDQAQBiEBENoPGiAAENgYGiABEAsACwsNACAAIAFBHGoQ1xgaCwkAIAAgARC+EgsnACAAIAAoAhhFIAFyIgE2AhACQCAAKAIUIAFxRQ0AQcQvEMESAAsLKQECfyMAQRBrIgIkACACQQhqIAAgARD3DyEDIAJBEGokACABIAAgAxsLdwEBfyAAQfzjAkEIajYCAEEAQQA2ArSMBEG7CiAAQQAQD0EAKAK0jAQhAUEAQQA2ArSMBAJAIAFBAUYNACAAQRxqENgYGiAAKAIgEMoPIAAoAiQQyg8gACgCMBDKDyAAKAI8EMoPIAAPC0EAEAUaENoPGhDoHAALDQAgABC/EhogABDQGwtvAQJ/IwBBEGsiASQAQRAQFCECIAFBCGpBAUEAEMISIQFBAEEANgK0jARBvAogAiAAIAEQJhpBACgCtIwEIQBBAEEANgK0jAQCQCAAQQFGDQAgAkHE5AJBvQoQFQALEAYhABDaDxogAhAkIAAQCwALKgEBfyMAQRBrIgMkACADQQhqIAEQ6xIgACADKQMINwIAIANBEGokACAAC0EAIABBADYCFCAAIAE2AhggAEEANgIMIABCgqCAgOAANwIEIAAgAUU2AhAgAEEgakEAQSgQ3w4aIABBHGoQ1hgaC6cHAQh/IwBBMGsiAiQAIAJBvgo2AiAgAkEoakEAIAJBIGoQxRIhAyACQb4KNgIYIAJBIGpBACACQRhqEMYSIQQgAkG+CjYCECACQRhqQQAgAkEQahDHEiEFIAJBvgo2AgwgAkEQakEAIAJBDGoQyBIhBgJAAkACQCAAKAIsIAEoAigiB08NACADIAdBAnQQyQ8QyRICQCADEMoSDQBBAEEANgK0jARBvwoQEEEAKAK0jAQhAEEAQQA2ArSMBCAAQQFHDQIQBiEAENoPGgwDCyAEIAEoAihBAnQQyQ8QyxIgBBDMEg0AQQBBADYCtIwEQb8KEBBBACgCtIwEIQBBAEEANgK0jAQgAEEBRw0BEAYhABDaDxoMAgsCQCAAKAI4IAEoAjQiB08NACAFIAdBAnQQyQ8QzRIgBRDOEg0AQQBBADYCtIwEQb8KEBBBACgCtIwEIQBBAEEANgK0jAQgAEEBRw0BEAYhABDaDxoMAgsCQCAAKAJEIAEoAkAiB08NACAGIAdBAnQQyQ8QzxIgBhDQEg0AQQBBADYCtIwEQb8KEBBBACgCtIwEIQBBAEEANgK0jAQgAEEBRw0BEAYhABDaDxoMAgsgACABKAIENgIEIAAgASgCCDYCCCAAIAEoAgw2AgwgAEEcaiABQRxqENkYGgJAIAAoAiwgASgCKE8NACAAKAIgEMoPIAAgAxDREjYCICAAKAIkEMoPIAAgBBDSEjYCJCAAIAEoAig2AiwLQQAhBwJAA0AgACAHNgIoIAcgASgCKE8NASAAKAIgIAdBAnQiCGogASgCICAIaigCADYCACAAKAIkIAhqIAEoAiQgCGooAgA2AgAgB0EBaiEHDAALAAsgACgCMCEIAkAgACgCOCABKAI0Tw0AIAgQyg8gACAFENMSIgg2AjAgACABKAI0NgI4CyABKAIwIQlBACEHAkADQCAAIAc2AjQgByABKAI0Tw0BIAggB0ECdCIHaiAJIAdqKAIANgIAIAAoAjRBAWohBwwACwALAkAgACgCRCABKAJATw0AIAAoAjwQyg8gACAGENQSNgI8IAAgASgCQDYCRAtBACEHAkADQCAAIAc2AkAgByABKAJATw0BIAAoAjwgB0ECdCIIaiABKAI8IAhqKAIANgIAIAdBAWohBwwACwALIAYQ1RIaIAUQ1hIaIAQQ1xIaIAMQ2BIaIAJBMGokAA8LAAsgBhDVEhogBRDWEhogBBDXEhogAxDYEhogABALAAtgAQF/IwBBEGsiAyQAQQBBADYCtIwEIAMgATYCDEHACiAAIANBDGogAhAmIQJBACgCtIwEIQFBAEEANgK0jAQCQCABQQFGDQAgA0EQaiQAIAIPC0EAEAUaENoPGhDoHAALYAEBfyMAQRBrIgMkAEEAQQA2ArSMBCADIAE2AgxBwQogACADQQxqIAIQJiECQQAoArSMBCEBQQBBADYCtIwEAkAgAUEBRg0AIANBEGokACACDwtBABAFGhDaDxoQ6BwAC2ABAX8jAEEQayIDJABBAEEANgK0jAQgAyABNgIMQcIKIAAgA0EMaiACECYhAkEAKAK0jAQhAUEAQQA2ArSMBAJAIAFBAUYNACADQRBqJAAgAg8LQQAQBRoQ2g8aEOgcAAtgAQF/IwBBEGsiAyQAQQBBADYCtIwEIAMgATYCDEHDCiAAIANBDGogAhAmIQJBACgCtIwEIQFBAEEANgK0jAQCQCABQQFGDQAgA0EQaiQAIAIPC0EAEAUaENoPGhDoHAALYwEBfyAAEN0SKAIAIQIgABDdEiABNgIAAkACQCACRQ0AIAAQ3hIoAgAhAEEAQQA2ArSMBCAAIAIQBEEAKAK0jAQhAEEAQQA2ArSMBCAAQQFGDQELDwtBABAFGhDaDxoQ6BwACw0AIAAQ3xIoAgBBAEcLYwEBfyAAEOASKAIAIQIgABDgEiABNgIAAkACQCACRQ0AIAAQ4RIoAgAhAEEAQQA2ArSMBCAAIAIQBEEAKAK0jAQhAEEAQQA2ArSMBCAAQQFGDQELDwtBABAFGhDaDxoQ6BwACw0AIAAQ4hIoAgBBAEcLYwEBfyAAEOMSKAIAIQIgABDjEiABNgIAAkACQCACRQ0AIAAQ5BIoAgAhAEEAQQA2ArSMBCAAIAIQBEEAKAK0jAQhAEEAQQA2ArSMBCAAQQFGDQELDwtBABAFGhDaDxoQ6BwACw0AIAAQ5RIoAgBBAEcLYwEBfyAAEOYSKAIAIQIgABDmEiABNgIAAkACQCACRQ0AIAAQ5xIoAgAhAEEAQQA2ArSMBCAAIAIQBEEAKAK0jAQhAEEAQQA2ArSMBCAAQQFGDQELDwtBABAFGhDaDxoQ6BwACw0AIAAQ6BIoAgBBAEcLGgEBfyAAEN0SKAIAIQEgABDdEkEANgIAIAELGgEBfyAAEOASKAIAIQEgABDgEkEANgIAIAELGgEBfyAAEOMSKAIAIQEgABDjEkEANgIAIAELGgEBfyAAEOYSKAIAIQEgABDmEkEANgIAIAELCwAgAEEAEM8SIAALCwAgAEEAEM0SIAALCwAgAEEAEMsSIAALCwAgAEEAEMkSIAALFgAgACABEO0SIgFBBGogAhDuEhogAQsWACAAIAEQ7xIiAUEEaiACEO4SGiABCxYAIAAgARDwEiIBQQRqIAIQ7hIaIAELFgAgACABEPESIgFBBGogAhDuEhogAQsHACAAEPISCwoAIABBBGoQ8xILBwAgABD0EgsHACAAEPUSCwoAIABBBGoQ8xILBwAgABD2EgsHACAAEPcSCwoAIABBBGoQ8xILBwAgABD4EgsHACAAEPkSCwoAIABBBGoQ8xILBwAgABD6EgsgACAAIAAoAhBBAXI2AhACQCAALQAUQQFxRQ0AECoACwsKACAAENMcENAbCxIAELQSGiAAIAFB+PMDEOwSGgsSACAAIAI2AgQgACABNgIAIAALDgAgACABKAIANgIAIAALDgAgACABKAIANgIAIAALDgAgACABKAIANgIAIAALDgAgACABKAIANgIAIAALDgAgACABKAIANgIAIAALBAAgAAsEACAACwQAIAALBAAgAAsEACAACwQAIAALBAAgAAsEACAACwQAIAALBABBAAsEAEIAC50BAQN/QX8hAgJAIABBf0YNAEEAIQMCQCABKAJMQQBIDQAgARDwDiEDCwJAAkACQCABKAIEIgQNACABEKcPGiABKAIEIgRFDQELIAQgASgCLEF4aksNAQsgA0UNASABEPEOQX8PCyABIARBf2oiAjYCBCACIAA6AAAgASABKAIAQW9xNgIAAkAgA0UNACABEPEOCyAAQf8BcSECCyACCwcAIAAQ/xILWgEBfwJAAkAgACgCTCIBQQBIDQAgAUUNASABQf////97cRC/DygCEEcNAQsCQCAAKAIEIgEgACgCCEYNACAAIAFBAWo2AgQgAS0AAA8LIAAQqA8PCyAAEIATC2MBAn8CQCAAQcwAaiIBEIETRQ0AIAAQ8A4aCwJAAkAgACgCBCICIAAoAghGDQAgACACQQFqNgIEIAItAAAhAAwBCyAAEKgPIQALAkAgARCCE0GAgICABHFFDQAgARCDEwsgAAsbAQF/IAAgACgCACIBQf////8DIAEbNgIAIAELFAEBfyAAKAIAIQEgAEEANgIAIAELCgAgAEEBEIgPGgsWAEGAogQQmxMaQdEKQQBBgAgQsBIaCwoAQYCiBBCdExoLhQMBA39BhKIEQQAoAvzkAiIBQbyiBBCHExpB2JwEQYSiBBCIExpBxKIEQQAoAoDlAiICQfSiBBCJExpBiJ4EQcSiBBCKExpB/KIEQQAoArDPAiIDQayjBBCJExpBsJ8EQfyiBBCKExpB2KAEQbCfBEEAKAKwnwRBdGooAgBqELUQEIoTGkHYnARBACgC2JwEQXRqKAIAakGIngQQixMaQbCfBEEAKAKwnwRBdGooAgBqEIwTGkGwnwRBACgCsJ8EQXRqKAIAakGIngQQixMaQbSjBCABQeyjBBCNExpBsJ0EQbSjBBCOExpB9KMEIAJBpKQEEI8TGkHcngRB9KMEEJATGkGspAQgA0HcpAQQjxMaQYSgBEGspAQQkBMaQayhBEGEoARBACgChKAEQXRqKAIAahCbERCQExpBsJ0EQQAoArCdBEF0aigCAGpB3J4EEJETGkGEoARBACgChKAEQXRqKAIAahCMExpBhKAEQQAoAoSgBEF0aigCAGpB3J4EEJETGiAAC7IBAQF/IwBBEGsiAyQAIAAQjBAiACACNgIoIAAgATYCICAAQYTlAkEIajYCABCbECECIABBADoANCAAIAI2AjAgA0EIaiAAELoRIAAoAgAoAgghAkEAQQA2ArSMBCACIAAgA0EIahAPQQAoArSMBCECQQBBADYCtIwEAkAgAkEBRg0AIANBCGoQ2BgaIANBEGokACAADwsQBiECENoPGiADQQhqENgYGiAAEIoQGiACEAsAC3EBAX8gAEEIahCSEyECIABB6NQCQQxqNgIAIAJB6NQCQSBqNgIAIABBADYCBEEAQQA2ArSMBEHSCiACIAEQD0EAKAK0jAQhAUEAQQA2ArSMBAJAIAFBAUYNACAADwsQBiEAENoPGiACEIMQGiAAEAsAC6cBAQJ/IwBBEGsiAyQAIAAQjBAiACABNgIgIABB6OUCQQhqNgIAIANBCGogABC6EUEAQQA2ArSMBEHTCiADQQhqEAohAUEAKAK0jAQhBEEAQQA2ArSMBAJAIARBAUYNACADQQhqENgYGiAAIAI2AiggACABNgIkIAAgARDgEToALCADQRBqJAAgAA8LEAYhARDaDxogA0EIahDYGBogABCKEBogARALAAtqAQF/IABBBGoQkhMhAiAAQZjVAkEMajYCACACQZjVAkEgajYCAEEAQQA2ArSMBEHSCiACIAEQD0EAKAK0jAQhAUEAQQA2ArSMBAJAIAFBAUYNACAADwsQBiEAENoPGiACEIMQGiAAEAsACxQBAX8gACgCSCECIAAgATYCSCACCw4AIABBgMAAEJQTGiAAC7IBAQF/IwBBEGsiAyQAIAAQ+hAiACACNgIoIAAgATYCICAAQdDmAkEIajYCABCGESECIABBADoANCAAIAI2AjAgA0EIaiAAEJUTIAAoAgAoAgghAkEAQQA2ArSMBCACIAAgA0EIahAPQQAoArSMBCECQQBBADYCtIwEAkAgAkEBRg0AIANBCGoQ2BgaIANBEGokACAADwsQBiECENoPGiADQQhqENgYGiAAEPgQGiACEAsAC3EBAX8gAEEIahCWEyECIABB4NYCQQxqNgIAIAJB4NYCQSBqNgIAIABBADYCBEEAQQA2ArSMBEHUCiACIAEQD0EAKAK0jAQhAUEAQQA2ArSMBAJAIAFBAUYNACAADwsQBiEAENoPGiACEPYQGiAAEAsAC6cBAQJ/IwBBEGsiAyQAIAAQ+hAiACABNgIgIABBtOcCQQhqNgIAIANBCGogABCVE0EAQQA2ArSMBEHVCiADQQhqEAohAUEAKAK0jAQhBEEAQQA2ArSMBAJAIARBAUYNACADQQhqENgYGiAAIAI2AiggACABNgIkIAAgARCZEzoALCADQRBqJAAgAA8LEAYhARDaDxogA0EIahDYGBogABD4EBogARALAAtqAQF/IABBBGoQlhMhAiAAQZDXAkEMajYCACACQZDXAkEgajYCAEEAQQA2ArSMBEHU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AAsRACAAIAEgASgCACgCIBEBAAsLACAAIAEQpBcgAAsRACAAIAEgASgCACgCHBEBAAsPACAAIAAoAgAoAgwRAAALDwAgACAAKAIAKAIQEQAACxEAIAAgASABKAIAKAIUEQEACxEAIAAgASABKAIAKAIYEQEACw8AIAAgACgCACgCJBEAAAsLACAAQYymBBCEFAsRACAAIAEgASgCACgCLBEBAAsRACAAIAEgASgCACgCIBEBAAsRACAAIAEgASgCACgCHBEBAAsPACAAIAAoAgAoAgwRAAALDwAgACAAKAIAKAIQEQAACxEAIAAgASABKAIAKAIUEQEACxEAIAAgASABKAIAKAIYEQEACw8AIAAgACgCACgCJBEAAAsSACAAIAI2AgQgACABNgIAIAALBwAgACgCAAsNACAAEJ4XIAEQnBdGCwcAIAAoAgALcwEBfyMAQSBrIgMkACADIAE2AhAgAyAANgIYIAMgAjYCCAJAA0AgA0EYaiADQRBqEIoVIgFFDQEgAyADQRhqEIsVIANBCGoQixUQnRpFDQEgA0EYahCMFRogA0EIahCMFRoMAAsACyADQSBqJAAgAUEBcwsyAQF/IwBBEGsiAiQAIAIgACgCADYCCCACQQhqIAEQnhoaIAIoAgghACACQRBqJAAgAAsHACAAELcXCxoBAX8gABC2FygCACEBIAAQthdBADYCACABCyIAIAAgARCiFxCdFSABEKEXKAIAIQEgABC3FyABNgIAIAALfQECfyMAQRBrIgIkAAJAIAAQyhVFDQAgABCFFyAAEP0WIAAQqxoQqBoLIAAgARCfGyABEKUWIQMgABClFiIAQQhqIANBCGooAgA2AgAgACADKQIANwIAIAFBABCBFyABEIAXIQAgAkEANgIMIAAgAkEMahD+FiACQRBqJAALjgkBDH8jAEHQA2siByQAIAcgBTcDECAHIAY3AxggByAHQeACajYC3AIgB0HgAmpB5ABBwMEAIAdBEGoQ3RMhCCAHQb4KNgIwIAdB6AFqQQAgB0EwahD8FCEJIAdBvgo2AjAgB0HgAWpBACAHQTBqEPwUIQogB0HwAWohCwJAAkACQAJAAkAgCEHkAEkNAEEAQQA2ArSMBEGJCxBLIQxBACgCtIwEIQhBAEEANgK0jAQgCEEBRg0BIAcgBTcDAEEAQQA2ArSMBCAHIAY3AwhBngsgB0HcAmogDEHAwQAgBxANIQhBACgCtIwEIQxBAEEANgK0jAQgDEEBRg0BAkACQCAIQX9GDQAgCSAHKALcAhD+FCAKIAgQyQ8Q/hQgCkEAEKYXRQ0BC0EAQQA2ArSMBEG/ChAQQQAoArSMBCEHQQBBADYCtIwEIAdBAUYNAgwFCyAKEKoWIQsLQQBBADYCtIwEQdYEIAdB2AFqIAMQD0EAKAK0jAQhDEEAQQA2ArSMBAJAAkACQAJAAkACQAJAIAxBAUYNAEEAQQA2ArSMBEHRCSAHQdgBahAKIQ1BACgCtIwEIQxBAEEANgK0jAQgDEEBRg0BQQBBADYCtIwEQYULIA0gBygC3AIiDCAMIAhqIAsQDRpBACgCtIwEIQxBAEEANgK0jAQgDEEBRg0BQQAhDgJAIAhBAUgNACAHKALcAi0AAEEtRiEOCyAHQcABahCuESEPIAdBsAFqEK4RIQwgB0GgAWoQrhEhEEEAQQA2ArSMBEHCCyACIA4gB0HYAWogB0HQAWogB0HPAWogB0HOAWogDyAMIBAgB0GcAWoQUUEAKAK0jAQhAkEAQQA2ArSMBCACQQFGDQIgB0G+CjYCJCAHQShqQQAgB0EkahD8FCERAkACQCAIIAcoApwBIgJMDQAgEBDMESAIIAJrQQF0aiAMEMwRaiAHKAKcAWpBAWohEgwBCyAQEMwRIAwQzBFqIAcoApwBakECaiESCyAHQTBqIQIgEkHlAEkNAyARIBIQyQ8Q/hQgERCqFiICDQNBAEEANgK0jARBvwoQEEEAKAK0jAQhCEEAQQA2ArSMBCAIQQFHDQoQBiEIENoPGgwECxAGIQgQ2g8aDAgLEAYhCBDaDxoMBAsQBiEIENoPGgwCCyADEKoQIRJBAEEANgK0jARBwwsgAiAHQSRqIAdBIGogEiALIAsgCGogDSAOIAdB0AFqIAcsAM8BIAcsAM4BIA8gDCAQIAcoApwBEFJBACgCtIwEIQhBAEEANgK0jAQCQCAIQQFGDQBBAEEANgK0jARB1wQgASACIAcoAiQgBygCICADIAQQJyELQQAoArSMBCEIQQBBADYCtIwEIAhBAUcNBQsQBiEIENoPGgsgERCAFRoLIBAQ9hsaIAwQ9hsaIA8Q9hsaCyAHQdgBahDYGBoMAgsQBiEIENoPGgwBCyAREIAVGiAQEPYbGiAMEPYbGiAPEPYbGiAHQdgBahDYGBogChCAFRogCRCAFRogB0HQA2okACALDwsgChCAFRogCRCAFRogCBALAAsACwoAIAAQqRdBAXML8gIBAX8jAEEQayIKJAACQAJAIABFDQAgAhDHFiECAkACQCABRQ0AIAogAhDIFiADIAooAgA2AAAgCiACEMkWIAggChC2ERogChD2GxoMAQsgCiACEKoXIAMgCigCADYAACAKIAIQyhYgCCAKELYRGiAKEPYbGgsgBCACEMsWOgAAIAUgAhDMFjoAACAKIAIQzRYgBiAKELYRGiAKEPYbGiAKIAIQzhYgByAKELYRGiAKEPYbGiACEM8WIQIMAQsgAhDQFiECAkACQCABRQ0AIAogAhDRFiADIAooAgA2AAAgCiACENIWIAggChC2ERogChD2GxoMAQsgCiACEKsXIAMgCigCADYAACAKIAIQ0xYgCCAKELYRGiAKEPYbGgsgBCACENQWOgAAIAUgAhDVFjoAACAKIAIQ1hYgBiAKELYRGiAKEPYbGiAKIAIQ1xYgByAKELYRGiAKEPYbGiACENgWIQILIAkgAjYCACAKQRBqJAALnQYBCn8jAEEQayIPJAAgAiAANgIAIANBgARxIRBBACERA0ACQCARQQRHDQACQCANEMwRQQFNDQAgDyANEKwXNgIIIAIgD0EIakEBEK0XIA0QrhcgAigCABCvFzYCAAsCQCADQbABcSISQRBGDQACQCASQSBHDQAgAigCACEACyABIAA2AgALIA9BEGokAA8LAkACQAJAAkACQAJAIAggEWosAAAOBQABAwIEBQsgASACKAIANgIADAQLIAEgAigCADYCACAGQSAQmRIhEiACIAIoAgAiE0EBajYCACATIBI6AAAMAwsgDRCLFA0CIA1BABCJFC0AACESIAIgAigCACITQQFqNgIAIBMgEjoAAAwCCyAMEIsUIRIgEEUNASASDQEgAiAMEKwXIAwQrhcgAigCABCvFzYCAAwBCyACKAIAIRQgBCAHaiIEIRICQANAIBIgBU8NASAGQcAAIBIsAAAQsBBFDQEgEkEBaiESDAALAAsgDiETAkAgDkEBSA0AAkADQCASIARNDQEgE0UNASASQX9qIhItAAAhFSACIAIoAgAiFkEBajYCACAWIBU6AAAgE0F/aiETDAALAAsCQAJAIBMN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tIwEIQJBAEEANgK0jAQgAkEBRg0CQQBBADYCtIwEQcsLIAFBgLEEEA9BACgCtIwEIQJBAEEANgK0jAQgAkEBRg0CENwXQQBBADYCtIwEQcwLIAFBkLEEEA9BACgCtIwEIQJBAEEANgK0jAQgAkEBRg0CEN4XQQBBADYCtIwEQc0LIAFBmLEEEA9BACgCtIwEIQJBAEEANgK0jAQgAkEBRg0CQQBBADYCtIwEQc4LEBBBACgCtIwEIQJBAEEANgK0jAQgAkEBRg0CQQBBADYCtIwEQc8LIAFBoLEEEA9BACgCtIwEIQJBAEEANgK0jAQgAkEBRg0CEOIXQQBBADYCtIwEQdALIAFBsLEEEA9BACgCtIwEIQJBAEEANgK0jAQgAkEBRg0CEOQXQQBBADYCtIwEQdELIAFBuLEEEA9BACgCtIwEIQJBAEEANgK0jAQgAkEBRg0CEOYXQQBBADYCtIwEQdILIAFBwLEEEA9BACgCtIwEIQJBAEEANgK0jAQgAkEBRg0CEOgXQQBBADYCtIwEQdMLIAFByLEEEA9BACgCtIwEIQJBAEEANgK0jAQgAkEBRg0CQQBBADYCtIwEQdQLEBBBACgCtIwEIQJBAEEANgK0jAQgAkEBRg0CQQBBADYCtIwEQdULIAFB0LEEEA9BACgCtIwEIQJBAEEANgK0jAQgAkEBRg0CQQBBADYCtIwEQdYLEBBBACgCtIwEIQJBAEEANgK0jAQgAkEBRg0CQQBBADYCtIwEQdcLIAFB6LEEEA9BACgCtIwEIQJBAEEANgK0jAQgAkEBRg0CEO4XQQBBADYCtIwEQdgLIAFBiLIEEA9BACgCtIwEIQJBAEEANgK0jAQgAkEBRg0CEPAXQQBBADYCtIwEQdkLIAFBkLIEEA9BACgCtIwEIQJBAEEANgK0jAQgAkEBRg0CEPIXQQBBADYCtIwEQdoLIAFBmLIEEA9BACgCtIwEIQJBAEEANgK0jAQgAkEBRg0CEPQXQQBBADYCtIwEQdsLIAFBoLIEEA9BACgCtIwEIQJBAEEANgK0jAQgAkEBRg0CQQBBADYCtIwEQdwLEBBBACgCtIwEIQJBAEEANgK0jAQgAkEBRg0CQQBBADYCtIwEQd0LIAFBqLIEEA9BACgCtIwEIQJBAEEANgK0jAQgAkEBRg0CEPgXQQBBADYCtIwEQd4LIAFB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QdylBBCcGBCdGAsMAEH4sgRBARCzGBoLEAAgACABQeSlBBCcGBCdGAsMAEGIswRBARC0GBoLEAAgACABQeylBBCcGBCdGAsMAEGYswRBARC1GBoLEAAgACABQfSlBBCcGBCdGAsMAEGoswRBARC2GBoLEAAgACABQbymBBCcGBCdGAsMAEGwswRBARC3GBoLEAAgACABQcSmBBCcGBCdGAsrACAAELgYAkAgACgCAEUNACAAEJkYIAAQuRggACgCACAAELoYELsYCyAACxcAIAAgATYCBCAAQcC7A0EIajYCACAACxQAIAAgARCvGiIBQQhqELAaGiABCwIAC0YBAX8CQCAAELEaIAFPDQAgABCyGgALIAAgABC5GCABELMaIgI2AgAgACACNgIEIAAQtBogAiABQQJ0ajYCACAAQQAQtRoLmwEBBX8jAEEQayICJAAgAiAAIAEQthoiAygCBCEBIAMoAgghBAJAA0AgASAERg0BIAAQuRghBSABELcaIQZBAEEANgK0jARB8gsgBSAGEA9BACgCtIwEIQVBAEEANgK0jAQCQCAFQQFGDQAgAyABQQRqIgE2AgQMAQsLEAYhARDaDxogAxC5GhogARALAAsgAxC5GhogAkEQaiQACxAAIAAoAgQgACgCAGtBAnULDAAgACAAKAIAEM8aCzMAIAAgABDAGiAAEMAaIAAQuhhBAnRqIAAQwBogAUECdGogABDAGiAAEJgYQQJ0ahDBGgsCAAtKAQF/IwBBIGsiASQAIAFBADYCDCABQfMLNgIIIAEgASkDCDcDACAAIAFBEGogASAAENwYEN0YIAAoAgQhACABQSBqJAAgAEF/aguzAQECfyMAQRBrIgMkACABEL4YIANBCGogARDGGCEEAkACQCAAQQhqIgEQmBggAksNAEEAQQA2ArSMBEH0CyABIAJBAWoQD0EAKAK0jAQhAEEAQQA2ArSMBCAAQQFGDQELAkAgASACEL0YKAIARQ0AIAEgAhC9GCgCABC/GBoLIAQQyhghACABIAIQvRggADYCACAEEMcYGiADQRBqJAAPCxAGIQIQ2g8aIAQQxxgaIAIQCwALFwAgACABENMXIgFB7JsDQQhqNgIAIAELFwAgACABENMXIgFBjJwDQQhqNgIAIAELGgAgACABENMXEPcYIgFB0JMDQQhqNgIAIAELGgAgACABENMXEIsZIgFB5JQDQQhqNgIAIAELGgAgACABENMXEIsZIgFB+JUDQQhqNgIAIAELGgAgACABENMXEIsZIgFB4JcDQQhqNgIAIAELGgAgACABENMXEIsZIgFB7JYDQQhqNgIAIAELGgAgACABENMXEIsZIgFB1JgDQQhqNgIAIAELFwAgACABENMXIgFBrJwDQQhqNgIAIAELFwAgACABENMXIgFBoJ4DQQhqNgIAIAELFwAgACABENMXIgFB9J8DQQhqNgIAIAELFwAgACABENMXIgFB3KEDQQhqNgIAIAELGgAgACABENMXENUaIgFBtKkDQQhqNgIAIAELGgAgACABENMXENUaIgFByKoDQQhqNgIAIAELGgAgACABENMXENUaIgFBvKsDQQhqNgIAIAELGgAgACABENMXENUaIgFBsKwDQQhqNgIAIAELGgAgACABENMXENYaIgFBpK0DQQhqNgIAIAELGgAgACABENMXENcaIgFByK4DQQhqNgIAIAELGgAgACABENMXENgaIgFB7K8DQQhqNgIAIAELGgAgACABENMXENkaIgFBkLEDQQhqNgIAIAELLQAgACABENMXIgFBCGoQ2hohACABQaSjA0EIajYCACAAQaSjA0E4ajYCACABCy0AIAAgARDTFyIBQQhqENsaIQAgAUGspQNBCGo2AgAgAEGspQNBOGo2AgAgAQtdACAAIAEQ0xchAUEAQQA2ArSMBEH1CyABQQhqEAoaQQAoArSMBCEAQQBBADYCtIwEAkAgAEEBRg0AIAFBmKcDQQhqNgIAIAEPCxAGIQAQ2g8aIAEQ7xMaIAAQCwALXQAgACABENMXIQFBAEEANgK0jARB9QsgAUEIahAKGkEAKAK0jAQhAEEAQQA2ArSMBAJAIABBAUYNACABQbSoA0EIajYCACABDwsQBiEAENoPGiABEO8TGiAAEAsACxoAIAAgARDTFxDdGiIBQbSyA0EIajYCACABCxoAIAAgARDTFxDdGiIBQayzA0EIajYCACABCzYAIAAgABDAGiAAEMAaIAAQuhhBAnRqIAAQwBogABCYGEECdGogABDAGiAAELoYQQJ0ahDBGgsKACAAQQhqEL4aCxMAIAAQyxooAgAgACgCAGtBAnULCwAgACABIAIQ0BoLMwACQEEALQDcpgRFDQBBACgC2KYEDwsQ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JAAgAAseAAJAIAANAEEADwsgAEGU0QNBpNIDQQAQ+RxBAEcLBAAgAAsNACAAEJAdGiAAENAbCwUAQb81CxUAIAAQ2hsiAEGs1wNBCGo2AgAgAAsNACAAEJAdGiAAENAbCwYAQaziAAsVACAAEJMdIgBBwNcDQQhqNgIAIAALDQAgABCQHRogABDQGwsFAEHYPAscACAAQcDYA0EIajYCACAAQQRqEJodGiAAEJAdCysBAX8CQCAAEN8bRQ0AIAAoAgAQmx0iAUEIahCcHUF/Sg0AIAEQ0BsLIAALBwAgAEF0agsVAQF/IAAgACgCAEF/aiIBNgIAIAELDQAgABCZHRogABDQGwsKACAAQQRqEJ8dCwcAIAAoAgALHAAgAEHU2ANBCGo2AgAgAEEEahCaHRogABCQHQsNACAAEKAdGiAAENAbCwoAIABBBGoQnx0LDQAgABCZHRogABDQGwsNACAAEJkdGiAAENAbCw0AIAAQmR0aIAAQ0BsLBAAgAAsVACAAENobIgBB5NoDQQhqNgIAIAALBwAgABCQHQsNACAAEKgdGiAAENAbCwUAQYQPCwQAIwALBgAgACQACxIBAn8jACAAa0FwcSIBJAAgAQsJACABIAAROwALCwAgASACIAARHAALEQAgASACIAMgBCAFIAARIwALCwAgASACIAARLAALDQAgASACIAMgABEdAAsPACABIAIgAyAEIAARHwALEQAgASACIAMgBCAFIAARIgALDQAgASACIAMgABEOAAsPACABIAIgAyAEIAAREwALCQAgASAAEToACw0AIAEgAiADIAARKwALEQAgASACIAMgBCAFIAARIQALDwAgASACIAMgBCAAETQACxMAIAEgAiADIAQgBSAGIAARQAALFQAgASACIAMgBCAFIAYgByAAETYACxEAIAAgAa0gAq1CIIaEEK4dCxMAIAAgASACrSADrUIghoQQrx0LGQAgACABIAIgAyAEIAWtIAatQiCGhBCwHQsTACAAIAEgAq0gA61CIIaEELEdCx0BAX4gACABIAIgAxCyHSEEIARCIIinENkPIASnCxcAIAAgASACIAMgBK0gBa1CIIaEELMdCxkAIAAgASACIAOtIAStQiCGhCAFIAYQtB0LFQAgACABIAIgA60gBK1CIIaEELUdCxcAIAAgASACIAMgBK0gBa1CIIaEELYdCxkBAX4gACABELcdIQIgAkIgiKcQ2Q8gAqcLJQEBfiAAIAEgAq0gA61CIIaEIAQQuB0hBSAFQiCIpxDZDyAFpwsZACAAIAEgAiADIAQgBa0gBq1CIIaEELkdCx8BAX4gACABIAIgAyAEELodIQUgBUIgiKcQ2Q8gBacLIwAgACABIAIgAyAEIAWtIAatQiCGhCAHrSAIrUIghoQQux0LJQAgACABIAIgAyAEIAUgBq0gB61CIIaEIAitIAmtQiCGhBC8HQsPACAAIAGnIAFCIIinEFULEQAgACABIAKnIAJCIIinEFYLFwAgACABIAIgAyAEIAWnIAVCIIinEFcLEQAgACABIAKnIAJCIIinEFgLHAAgACABIAIgA6cgA0IgiKcgBKcgBEIgiKcQWQsTACAAIAGnIAFCIIinIAIgAxBaCxcAIAAgASACIAMgBCAFpyAFQiCIpxBbCxcAIAAgASACIAMgBBBcrRDaD61CIIaECwuT+IOAAAMAQYAIC6jTA3oAaGFzT3duUHJvcGVydHkASWRlbnRpdHkAaW5maW5pdHkAZ2V0X3plcm9fcHJvYmFiaWxpdHkAZ2V0X21hcmdpbmFsX3Byb2JhYmlsaXR5AEZlYnJ1YXJ5AEphbnVhcnkAUmFuZG9tVW5pdGFyeQBnZXRfZW50cm9weQBjb3B5AEp1bHkAVGh1cnNkYXkAVHVlc2RheQBXZWRuZXNkYXkAU2F0dXJkYXkAU3VuZGF5AE1vbmRheQBGcmlkYXkATWF5ACVtLyVkLyV5AGRlbnNpdHlfbWF0cml4AGdldF9tYXRyaXgAYXBwbHkgc2luZ2xlIHRocmVhZCBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIGRlbnNpdHkgbWF0cml4AHBlcm11dGF0ZV9xdWJpdF9EZW5zaXR5TWF0cml4AHRlbnNvcl9wcm9kdWN0X0RlbnNpdHlNYXRyaXgAZnJvbV9qc29uX0RlbnNpdHlNYXRyaXgAcGFydGlhbF90cmFjZV9EZW5zaXR5TWF0cml4AENvbXBsZXhNYXRyaXgAUXVhbnR1bUdhdGVEaWFnb25hbE1hdHJpeABRdWFudHVtR2F0ZU1hdHJpeABRdWFudHVtR2F0ZVNwYXJzZU1hdHJpeABEZW5zZU1hdHJpeABsb2FkX01hdHJpeAAgKiBNYXRyaXgAaW5kZXgALSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweAByb3cATm92AGdwdQBjcHUAVGh1AGNyZWF0ZV9xdWFudHVtX29wZXJhdG9yX2Zyb21fb3BlbmZlcm1pb25fdGV4dABjcmVhdGVfb2JzZXJ2YWJsZV9mcm9tX29wZW5mZXJtaW9uX3RleHQAdW5zdXBwb3J0ZWQgbG9jYWxlIGZvciBzdGFuZGFyZCBpbnB1dABBdWd1c3QAZ2V0X3RhcmdldF9pbmRleF9saXN0AGdldF9jb250cm9sX2luZGV4X2xpc3QAZ2V0X2NpcmN1aXRfbGlzdAB0YXJnZXRfcXViaXRfbGlzdABjb250cm9sX3F1Yml0X2xpc3QAZ2V0X3BhdWxpX29wZXJhdG9yX2xpc3QAcGF1bGlfbGlzdABnZXRfY29lZl9saXN0AGdhdGVfbGlzdABnZXRfcGF1bGlfaWRfbGlzdABDbHNOb2lzeUV2b2x1dGlvbl9mYXN0AHN0ZDo6YmFkX2Nhc3QAdW5zaWduZWQgc2hvcnQAZ2V0X3F1Yml0X2NvdW50AEVycm9yOiBEZW5zaXR5TWF0cml4Q3B1OjpzZXRfY29tcHV0YXRpb25hbF9iYXNpcyhJVFlQRSk6IGluZGV4IG9mIGNvbXB1dGF0aW9uYWwgYmFzaXMgbXVzdCBiZSBzbWFsbGVyIHRoYW4gMl5xdWJpdF9jb3VudABFcnJvcjogUXVhbnR1bVN0YXRlQ3B1OjpzZXRfY29tcHV0YXRpb25hbF9iYXNpcyhJVFlQRSk6IGluZGV4IG9mIGNvbXB1dGF0aW9uYWwgYmFzaXMgbXVzdCBiZSBzbWFsbGVyIHRoYW4gMl5xdWJpdF9jb3VudABFcnJvcjogRGVuc2l0eU1hdHJpeENwdTo6Z2V0X21hcmdpbmFsX3Byb2JhYmlsaXR5KHZlY3RvcjxVSU5UPik6IHRoZSBsZW5ndGggb2YgbWVhc3VyZWRfdmFsdWVzIG11c3QgYmUgZXF1YWwgdG8gcXViaXRfY291bnQARXJyb3I6IFF1YW50dW1TdGF0ZUNwdTo6Z2V0X21hcmdpbmFsX3Byb2JhYmlsaXR5KHZlY3RvcjxVSU5UPik6IHRoZSBsZW5ndGggb2YgbWVhc3VyZWRfdmFsdWVzIG11c3QgYmUgZXF1YWwgdG8gcXViaXRfY291bnQARXJyb3I6IFF1YXRudW1DaXJjdWl0OjphZGRfZ2F0ZShRdWFudHVtR2F0ZUJhc2UqLCBVSU5UKTogZ2F0ZSBtdXN0IGJlIGFwcGxpZWQgdG8gcXViaXRzIG9mIHdoaWNoIHRoZSBpbmRpY2VzIGFyZSBzbWFsbGVyIHRoYW4gcXViaXRfY291bnQARXJyb3I6IFF1YXRudW1DaXJjdWl0OjphZGRfZ2F0ZShRdWFudHVtR2F0ZUJhc2UqKTogZ2F0ZSBtdXN0IGJlIGFwcGxpZWQgdG8gcXViaXRzIG9mIHdoaWNoIHRoZSBpbmRpY2VzIGFyZSBzbWFsbGVyIHRoYW4gcXViaXRfY291bnQARXJyb3I6IERlbnNpdHlNYXRyaXhDcHU6OmdldF96ZXJvX3Byb2JhYmlsaXR5KFVJTlQpOiBpbmRleCBvZiB0YXJnZXQgcXViaXQgbXVzdCBiZSBzbWFsbGVyIHRoYW4gcXViaXRfY291bnQARXJyb3I6IFF1YW50dW1TdGF0ZUNwdTo6Z2V0X3plcm9fcHJvYmFiaWxpdHkoVUlOVCk6IGluZGV4IG9mIHRhcmdldCBxdWJpdCBtdXN0IGJlIHNtYWxsZXIgdGhhbiBxdWJpdF9jb3VudABFcnJvcjogR2VuZXJhbFF1YW50dW1PcGVyYXRvcjo6YWRkX29wZXJhdG9yKGRvdWJsZSxzdGQ6OnN0cmluZyk6IHBhdWxpX29wZXJhdG9yIGFwcGxpZXMgdGFyZ2V0IHF1Yml0IG9mIHdoaWNoIHRoZSBpbmRleCBpcyBsYXJnZXIgdGhhbiBxdWJpdF9jb3VudABFcnJvcjogR2VuZXJhbFF1YW50dW1PcGVyYXRvcjo6YWRkX29wZXJhdG9yKGNvbnN0IFBhdWxpT3BlcmF0b3IqKTogcGF1bGlfb3BlcmF0b3IgYXBwbGllcyB0YXJnZXQgcXViaXQgb2Ygd2hpY2ggdGhlIGluZGV4IGlzIGxhcmdlciB0aGFuIHF1Yml0X2NvdW50AGdldF9wYXJhbWV0ZXJfY291bnQAZ2V0X3Rlcm1fY291bnQAZ2V0X2dhdGVfY291bnQARXJyb3I6IFF1YW50dW1DaXJjdWl0OjphZGRfZ2F0ZShRdWFudHVtR2F0ZUJhc2UqLCBVSU5UKSA6IGluc2VydCBpbmRleCBtdXN0IGJlIHNtYWxsZXIgdGhhbiBvciBlcXVhbCB0byBnYXRlX2NvdW50AEVycm9yOiBRdWFudHVtQ2lyY3VpdDo6dXBkYXRlX3F1YW50dW1fc3RhdGUoUXVhbnR1bVN0YXRlQmFzZSxVSU5ULFVJTlQpIDogZW5kIG11c3QgYmUgc21hbGxlciB0aGFuIG9yIGVxdWFsIHRvIGdhdGVfY291bnQARXJyb3I6IFF1YW50dW1DaXJjdWl0OjpyZW1vdmVfZ2F0ZShVSU5UKSA6IGluZGV4IG11c3QgYmUgc21hbGxlciB0aGFuIGdhdGVfY291bnQARXJyb3I6IGRyb3BfcXViaXQoY29uc3QgUXVhbnR1bVN0YXRlKiwgc3RkOjp2ZWN0b3I8VUlOVD4pOiBpbnZhbGlkIHF1Yml0IGNvdW50AEVycm9yOiBwZXJtdXRhdGVfcXViaXQoY29uc3QgUXVhbnR1bVN0YXRlKiwgc3RkOjp2ZWN0b3I8VUlOVD4pOiBpbnZhbGlkIHF1Yml0IGNvdW50AEVycm9yOiBtYWtlX3N1cGVycG9zaXRpb24oQ1BQQ1RZUEUsIGNvbnN0IFF1YW50dW1TdGF0ZSosIENQUENUWVBFLCBjb25zdCBRdWFudHVtU3RhdGUqKTogaW52YWxpZCBxdWJpdCBjb3VudABFcnJvcjogaW5uZXJfcHJvZHVjdChjb25zdCBRdWFudHVtU3RhdGUqLCBjb25zdCBRdWFudHVtU3RhdGUqKTogaW52YWxpZCBxdWJpdCBjb3VudABFcnJvcjogR2VuZXJhbFF1YW50dW1PcGVyYXRvcjo6Z2V0X2V4cGVjdGF0aW9uX3ZhbHVlKGNvbnN0IFF1YW50dW1TdGF0ZUJhc2UqKTogaW52YWxpZCBxdWJpdCBjb3VudABFcnJvcjogRGVuc2l0eU1hdHJpeENwdTo6bG9hZChjb25zdCBRdWFudHVtU3RhdGVCYXNlKik6IGludmFsaWQgcXViaXQgY291bnQARXJyb3I6IFF1YW50dW1TdGF0ZUNwdTo6bG9hZChjb25zdCBRdWFudHVtU3RhdGVCYXNlKik6IGludmFsaWQgcXViaXQgY291bnQARXJyb3I6IG1ha2VfbWl4dHVyZShDUFBDVFlQRSwgY29uc3QgUXVhbnR1bVN0YXRlQmFzZSosIENQUENUWVBFLCBjb25zdCBRdWFudHVtU3RhdGVCYXNlKik6IGludmFsaWQgcXViaXQgY291bnQARXJyb3I6IEdlbmVyYWxRdWFudHVtT3BlcmF0b3I6OmdldF90cmFuc2l0aW9uX2FtcGxpdHVkZShjb25zdCBRdWFudHVtU3RhdGVCYXNlKiwgY29uc3QgUXVhbnR1bVN0YXRlQmFzZSopOiBpbnZhbGlkIHF1Yml0IGNvdW50AEVycm9yOiBRdWFudHVtQ2lyY3VpdDo6dXBkYXRlX3F1YW50dW1fc3RhdGUoUXVhbnR1bVN0YXRlQmFzZSkgOiBpbnZhbGlkIHF1Yml0IGNvdW50AEVycm9yOiBRdWFudHVtQ2lyY3VpdDo6dXBkYXRlX3F1YW50dW1fc3RhdGUoUXVhbnR1bVN0YXRlQmFzZSxVSU5ULFVJTlQpIDogaW52YWxpZCBxdWJpdCBjb3VudAB1bnNpZ25lZCBpbnQAbmVlZCBhdCBsZWFzdCBvbmUgZGlnaXQgaW4gZXhwb25lbnQAaXNfaW5zdHJ1bWVudABNZWFzdXJlbWVudAAgKiBEaWFnb25hbCBlbGVtZW50AFBhcmFtZXRyaWNRdWFudHVtQ2lyY3VpdABmcm9tX2pzb25fUXVhbnR1bUNpcmN1aXQAdGFyZ2V0X3F1Yml0AGRyb3BfcXViaXQAYWRkX2NvbnRyb2xfcXViaXQAb3B0aW1pemVfbGlnaHQAfmR5bmFtaWNfYml0c2V0AGR0AGJhY2twcm9wX2lubmVyX3Byb2R1Y3QAT2JqZWN0AE9jdABmbG9hdABwdHJlZSBjb250YWlucyBkYXRhIHRoYXQgY2Fubm90IGJlIHJlcHJlc2VudGVkIGluIEpTT04gZm9ybWF0AFNhdAB1aW50NjRfdABzZXRfZnJvbV90cmlwbGV0cwBjbGFzc2ljYWxfcmVnaXN0ZXJfYWRkcmVzcwBjX29wcwBzZXRfY29tcHV0YXRpb25hbF9iYXNpcwB5ZXMAY29sbGFwc2VEdXBsaWNhdGVzAENsc1N0YXRlUmVmbGVjdGlvbkdhdGU6OnVwZGF0ZV9xdWFudHVtc3RhdGUoUXVhbnR1bVN0YXRlQmFzZSopOiBxdWJpdCBjb3VudCBtdXN0IGJlIGVxdWFsIHRvIHJlZmxlY3Rpb25fc3RhdGUncwBBcHIAZ2V0X3ZlY3RvcgBzdGF0ZV92ZWN0b3IAbG9hZF9WZWN0b3IAYWRkX29wZXJhdG9yAGZyb21fanNvbl9IZXJtaXRpYW5RdWFudHVtT3BlcmF0b3IAZnJvbV9qc29uX0dlbmVyYWxRdWFudHVtT3BlcmF0b3IAU2luZ2xlUGF1bGlPcGVyYXRvcgBRdWFudHVtQ2lyY3VpdFNpbXVsYXRvcgBOb2lzZVNpbXVsYXRvcgBDYXVzYWxDb25lU2ltdWxhdG9yAEdyYWRDYWxjdWxhdG9yAHBhcnNlX2Vycm9yAHVuc3BlY2lmaWVkIGlvc3RyZWFtX2NhdGVnb3J5IGVycm9yAG1vbmV5X2dldCBlcnJvcgB3cml0ZSBlcnJvcgBRdWFudHVtQ2lyY3VpdE9wdGltaXplcgBjbGFzc2ljYWxfcmVnaXN0ZXIATm9pc3lFdm9sdXRpb25fZmFzdF9wb2ludGVyAEluc3RydW1lbnRfUXVhbnR1bUdhdGVfcG9pbnRlcgBDUFRQX1F1YW50dW1HYXRlX3BvaW50ZXIAQ1BfUXVhbnR1bUdhdGVfcG9pbnRlcgBtZXJnZV9RdWFudHVtR2F0ZUJhc2VfcG9pbnRlcgBhZGRfUXVhbnR1bUdhdGVCYXNlX3BvaW50ZXIAUHJvYmFiaWxpc3RpY19RdWFudHVtR2F0ZUJhc2VfcG9pbnRlcgBfZ2V0QWJzdHJhY3RHZW5lcmFsUXVhbnR1bU9wZXJhdG9yUG9pbnRlcgBfZ2V0QWJzdHJhY3RRdWFudHVtR2F0ZUJhc2VQb2ludGVyAHNldF9wYXJhbWV0ZXIAZ2V0X3BhcmFtZXRlcgBRdWFudHVtR2F0ZV9TaW5nbGVQYXJhbWV0ZXIAbXVsdGlwbHlfZWxlbWVudHdpc2VfZnVuY3Rpb25fd3JhcHBlcgBpbml0aWFsaXplX3N0YXRlX2l0eXBlX3dyYXBwZXIAaW5zZXJ0QmFja0J5T3V0ZXJJbm5lcgBjb3B5X3N0YXRlX3RvX2J1ZmZlcgBjb3B5X3N0YXRlX2Zyb21fYnVmZmVyAGFsbG9jYXRlX2J1ZmZlcgBzd2FwX3N0YXRlX2FuZF9idWZmZXIAT2N0b2JlcgBOb3ZlbWJlcgBTZXB0ZW1iZXIARGVjZW1iZXIAbXVsdGlwbHlfc2NhbGFyAHVuc2lnbmVkIGNoYXIAaW9zX2Jhc2U6OmNsZWFyAE1hcgAuL3N1Ym1vZHVsZXMvYm9vc3QvYm9vc3QvZHluYW1pY19iaXRzZXQvZHluYW1pY19iaXRzZXQuaHBwAC9tbnQvYy9Vc2Vycy9rYW1ha2lyaS9kZXYvcXVsYWNzLXY1LXdhc20vcXVsYWNzLXdhc20vc3VibW9kdWxlcy9xdWxhY3MvLi4vYm9vc3QvYm9vc3QvcHJvcGVydHlfdHJlZS9qc29uX3BhcnNlci9kZXRhaWwvcGFyc2VyLmhwcAAuL3N1Ym1vZHVsZXMvYm9vc3QvYm9vc3QvcHJvcGVydHlfdHJlZS9kZXRhaWwvcHRyZWVfaW1wbGVtZW50YXRpb24uaHBwAC9tbnQvYy9Vc2Vycy9rYW1ha2lyaS9kZXYvcXVsYWNzLXY1LXdhc20vcXVsYWNzLXdhc20vc3VibW9kdWxlcy9xdWxhY3MvLi4vYm9vc3QvYm9vc3QvcHJvcGVydHlfdHJlZS9kZXRhaWwvcHRyZWVfaW1wbGVtZW50YXRpb24uaHBwAC4vc3VibW9kdWxlcy9ib29zdC9ib29zdC9wcm9wZXJ0eV90cmVlL3N0cmluZ19wYXRoLmhwcAAvbW50L2MvVXNlcnMva2FtYWtpcmkvZGV2L3F1bGFjcy12NS13YXNtL3F1bGFjcy13YXNtL3N1Ym1vZHVsZXMvcXVsYWNzLy4uL2Jvb3N0L2Jvb3N0L3Byb3BlcnR5X3RyZWUvanNvbl9wYXJzZXIvZGV0YWlsL3dyaXRlLmhwcAAuL3N1Ym1vZHVsZXMvYm9vc3QvYm9vc3Qvb3B0aW9uYWwvZGV0YWlsL29wdGlvbmFsX3JlZmVyZW5jZV9zcGVjLmhwcABiYWNrcHJvcABCaXRGbGlwAFNlcABDd2lzZU51bGxhcnlPcAAlSTolTTolUyAlcABubwBTdW4ASnVuAHRvX2pzb24AQ2xzTm9pc3lFdm9sdXRpb24AZGlzdHJpYnV0aW9uAHN0ZDo6ZXhjZXB0aW9uAHRlcm1pbmF0ZV9oYW5kbGVyIHVuZXhwZWN0ZWRseSB0aHJldyBhbiBleGNlcHRpb24AbWFrZV9zdXBlcnBvc2l0aW9uAGdldF9wYXJhbWV0cmljX2dhdGVfcG9zaXRpb24AdGhpcyBnYXRlIGRvbid0IGhhdmUgZ2V0X2ludmVyc2UgZnVuY3Rpb24AU3RhdGVSZWZsZWN0aW9uAF9fY3hhX2d1YXJkX2FjcXVpcmUgZGV0ZWN0ZWQgcmVjdXJzaXZlIGluaXRpYWxpemF0aW9uAFBhdWxpLXJvdGF0aW9uAFotcm90YXRpb24AWS1yb3RhdGlvbgBYLXJvdGF0aW9uAFBhcmFtZXRyaWNQYXVsaVJvdGF0aW9uADogbm8gY29udmVyc2lvbgBNb24AbmFuAGlzX2hlcm1pdGlhbgBFcnJvcjogUXVhbnR1bUNpcmN1aXQ6OmFkZF9vYnNlcnZhYmxlX3JvdGF0aW9uX2dhdGUoY29uc3QgT2JzZXJ2YWJsZSYgb2JzZXJ2YWJsZSwgZG91YmxlIGFuZ2xlLCBVSU5UIG51bV9yZXBlYXRzKTogbm90IGltcGxlbWVudGVkIGZvciBub24gaGVybWl0aWFuAEVycm9yOiBRdWFudHVtQ2lyY3VpdDo6YWRkX211bHRpX1BhdWxpX3JvdGF0aW9uX2dhdGUoY29uc3QgUGF1bGlPcGVyYXRvciYgcGF1bGlfb3BlcmF0b3IpOiBub3QgaW1wbGVtZW50ZWQgZm9yIG5vbiBoZXJtaXRpYW4AaXNfR2F1c3NpYW4AaGFtaWx0b25pYW4AUmV2ZXJzaWJsZUJvb2xlYW4ASmFuAGdldF9zcXVhcmVkX25vcm0AZ2V0X3Rlcm0AL2Rldi91cmFuZG9tAHN5c3RlbQBpb3N0cmVhbQBKdWwAYm9vbABjb2wAc3RkOjpiYWRfZnVuY3Rpb25fY2FsbABtZXJnZV9hbGwAQXByaWwAZW1zY3JpcHRlbjo6dmFsAHdyaXRlX2pzb25faW50ZXJuYWwAaXNfZGlhZ29uYWwARVJST1I6IE9ic2VydmFibGUgaXMgbm90IGRpYWdvbmFsAHJlYWwAbV9oaWdoZXN0X2Jsb2NrAEZyaQBzdG9pAHBhdWxpAGlzX1BhdWxpAGFkZF9zaW5nbGVfUGF1bGkAY2FsY3VsYXRlX2RlcHRoAGJhZF9hcnJheV9uZXdfbGVuZ3RoAGZvcmNlX3BhdGgAcHVzaABNYXJjaAAuL3N1Ym1vZHVsZXMvcXVsYWNzL2luY2x1ZGUvRWlnZW4vc3JjL1NwYXJzZUNvcmUvU3BhcnNlTWF0cml4LmgALi9zdWJtb2R1bGVzL3F1bGFjcy9pbmNsdWRlL0VpZ2VuL3NyYy9Db3JlL0N3aXNlTnVsbGFyeU9wLmgALi9zdWJtb2R1bGVzL3F1bGFjcy9pbmNsdWRlL0VpZ2VuL3NyYy9Db3JlL1BsYWluT2JqZWN0QmFzZS5oAC4vc3VibW9kdWxlcy9xdWxhY3MvaW5jbHVkZS9FaWdlbi9zcmMvQ29yZS9EZW5zZUNvZWZmc0Jhc2UuaAAuL3N1Ym1vZHVsZXMvcXVsYWNzL2luY2x1ZGUvRWlnZW4vc3JjL0NvcmUvTWFwQmFzZS5oAEF1ZwB1bnNpZ25lZCBsb25nAERlcG9sYXJpemluZwBEZXBoYXNpbmcAc3RkOjp3c3RyaW5nAHRvX3N0cmluZwBnZXRfcGF1bGlfc3RyaW5nAGJhc2ljX3N0cmluZwBzdGQ6OnN0cmluZwBzdGQ6OnUxNnN0cmluZwBzdGQ6OnUzMnN0cmluZwBleHBlY3RlZCBrZXkgc3RyaW5nAHVudGVybWluYXRlZCBzdHJpbmcAQW1wbGl0dWRlRGFtcGluZwBzYW1wbGluZwBpbWFnAHNxcnRZZGFnAHNxcnRYZGFnAFRkYWcAU2RhZwBpbmYAbXVsdGlwbHlfY29lZgBnZXRfY29lZgBjaGFuZ2VfY29lZgAlLjBMZgAlTGYAJWYAcmVzaXplAG9wdGltaXplAHByb2JhYmlsaXR5X25vcm1hbGl6ZQBzdGF0ZV9ub3JtYWxpemUAcmVzZXJ2ZQBBZGFwdGl2ZQB0cnVlAHB1dF92YWx1ZQBnZXRfdmFsdWUAc2V0X3BhcmFtZXRlcl92YWx1ZQBnZXRfcGFyYW1ldGVyX3ZhbHVlAGdldF9leHBlY3RhdGlvbl92YWx1ZQBzZXRfY2xhc3NpY2FsX3ZhbHVlAGdldF9jbGFzc2ljYWxfdmFsdWUAZXhwZWN0ZWQgdmFsdWUAVHVlAGlzX2NvbW11dGUAZXhlY3V0ZQBhcHBseV90b19zdGF0ZQBzZXRfemVyb19zdGF0ZQByZWZsZWN0aW9uX3N0YXRlAHVwZGF0ZV9xdWFudHVtX3N0YXRlAHNldF9IYWFyX3JhbmRvbV9zdGF0ZQBpbml0aWFsaXplX3JhbmRvbV9zdGF0ZQBhZGRfc3RhdGUARXJyb3I6IERlbnNpdHlNYXRyaXhDcHU6OmxvYWQoQ29tcGxleE1hdHJpeCYpOiBpbnZhbGlkIGxlbmd0aCBvZiBzdGF0ZQBFcnJvcjogRGVuc2l0eU1hdHJpeENwdTo6bG9hZCh2ZWN0b3I8Q29tcGxleD4mKTogaW52YWxpZCBsZW5ndGggb2Ygc3RhdGUARXJyb3I6IFF1YW50dW1TdGF0ZUNwdTo6bG9hZCh2ZWN0b3I8Q29tcGxleD4mKTogaW52YWxpZCBsZW5ndGggb2Ygc3RhdGUAcGVybXV0YXRlX3F1Yml0X1F1YW50dW1TdGF0ZQB0ZW5zb3JfcHJvZHVjdF9RdWFudHVtU3RhdGUAZnJvbV9qc29uX1F1YW50dW1TdGF0ZQBwYXJ0aWFsX3RyYWNlX1F1YW50dW1TdGF0ZQBzaW11bGF0ZQBpbnZhbGlkIGNvZGVwb2ludCwgc3RyYXkgbG93IHN1cnJvZ2F0ZQBpbnZhbGlkIGNvZGVwb2ludCwgc3RyYXkgaGlnaCBzdXJyb2dhdGUAZXhwZWN0ZWQgbG93IHN1cnJvZ2F0ZSBhZnRlciBoaWdoIHN1cnJvZ2F0ZQBleHBlY3RlZCBjb2RlcG9pbnQgcmVmZXJlbmNlIGFmdGVyIGhpZ2ggc3Vycm9nYXRlAGFkZF9yYW5kb21fdW5pdGFyeV9nYXRlAHRvX21hdHJpeF9nYXRlAGFkZF9kZW5zZV9tYXRyaXhfZ2F0ZQBhZGRfbXVsdGlfUGF1bGlfcm90YXRpb25fZ2F0ZQBhZGRfcGFyYW1ldHJpY19tdWx0aV9QYXVsaV9yb3RhdGlvbl9nYXRlAGFkZF9kaWFnb25hbF9vYnNlcnZhYmxlX3JvdGF0aW9uX2dhdGUAYWRkX211bHRpX1BhdWxpX2dhdGUAYWRkX1RkYWdfZ2F0ZQBhZGRfU2RhZ19nYXRlAHJlbW92ZV9nYXRlAGFkZF9ub2lzZV9nYXRlAGFkZF9nYXRlAGFkZF9wYXJhbWV0cmljX2dhdGUAYWRkX1JvdEludlpfZ2F0ZQBhZGRfUm90Wl9nYXRlAGFkZF9aX2dhdGUAYWRkX1JaX2dhdGUAYWRkX3BhcmFtZXRyaWNfUlpfZ2F0ZQBhZGRfQ1pfZ2F0ZQBhZGRfUm90SW52WV9nYXRlAGFkZF9Sb3RZX2dhdGUAYWRkX1lfZ2F0ZQBhZGRfUllfZ2F0ZQBhZGRfcGFyYW1ldHJpY19SWV9nYXRlAGFkZF9Sb3RJbnZYX2dhdGUAYWRkX1JvdFhfZ2F0ZQBhZGRfWF9nYXRlAGFkZF9SWF9nYXRlAGFkZF9wYXJhbWV0cmljX1JYX2dhdGUAYWRkX1RfZ2F0ZQBhZGRfQ05PVF9nYXRlAGFkZF9TX2dhdGUAYWRkX1NXQVBfZ2F0ZQBhZGRfSF9nYXRlAGFkZF9VM19nYXRlAGFkZF9VMl9nYXRlAGFkZF9VMV9nYXRlAEVycm9yOiBhZGRfZGVuc2VfbWF0cml4X2dhdGUoVUlOVCwgY29uc3QgQ29tcGxleE1hdHJpeCYpIDogbWF0cml4IG11c3QgYmUgbWF0cml4LmNvbHMoKT09MiBhbmQgbWF0cml4LnJvd3MoKT09MiBmb3Igc2luZ2xlIHF1Yml0IGdhdGUAdG9vIG11Y2ggdXNlIGhhbWlsdG9uaWFuIHF1Yml0LiAgSWYgdGhlcmUgaXMgYW4gaW5kZXBlbmRlbnQgYml0LCBwbGVhc2Ugc2VwYXJhdGUgZ2F0ZQBQcm9qZWN0aW9uIGdhdGUgaGFzbid0IGludmVyc2UgZ2F0ZQBHZW5lcmljIGdhdGUARGlhZ29uYWxNYXRyaXhHYXRlAFNwYXJzZU1hdHJpeEdhdGUARGVuc2VNYXRyaXhHYXRlAE5vaXN5RXZvbHV0aW9uRmFzdEdhdGUAQ2xzVHdvUXViaXRHYXRlAENsc09uZVF1Yml0R2F0ZQBDbHNPbmVDb250cm9sT25lVGFyZ2V0R2F0ZQBDUFRQTWFwR2F0ZQBDUE1hcEdhdGUATm9pc3lFdm9sdXRpb25HYXRlAENsc1N0YXRlUmVmbGVjdGlvbkdhdGUAWi1yb3RhdGlvbkdhdGUAWS1yb3RhdGlvbkdhdGUAWC1yb3RhdGlvbkdhdGUAQ2xzT25lUXViaXRSb3RhdGlvbkdhdGUAQ2xzUGF1bGlSb3RhdGlvbkdhdGUAUGFyYW1ldHJpY1BhdWxpUm90YXRpb25HYXRlAENsc1JldmVyc2libGVCb29sZWFuR2F0ZQBDbHNQYXVsaUdhdGUAc3FydFlkYWdHYXRlAHNxcnRYZGFnR2F0ZQBUZGFnR2F0ZQBTZGFnR2F0ZQBQcm9iYWJpbGlzdGljR2F0ZQBQYXJhbWV0cmljUlpHYXRlAENaR2F0ZQBzcXJ0WUdhdGUAUGFyYW1ldHJpY1JZR2F0ZQBzcXJ0WEdhdGUAUGFyYW1ldHJpY1JYR2F0ZQBDTk9UR2F0ZQBTR2F0ZQBTV0FQR2F0ZQBJR2F0ZQBIR2F0ZQBQcm9qZWN0aW9uLTFHYXRlAFByb2plY3Rpb24tMEdhdGUAZmFsc2UAQml0RmxpcE5vaXNlAFR3b1F1Yml0RGVwb2xhcml6aW5nTm9pc2UARGVwaGFzaW5nTm9pc2UAQW1wbGl0dWRlRGFtcGluZ05vaXNlAEluZGVwZW5kZW50WFpOb2lzZQBNYXBCYXNlAGZyb21fanNvbl9RdWFudHVtU3RhdGVCYXNlAGxvYWRfUXVhbnR1bVN0YXRlQmFzZQBmcm9tX2pzb25fUXVhbnR1bUdhdGVCYXNlAG1ha2VfbWl4dHVyZQBwcm90b3R5cGUASnVuZQB0aW1lAFF1Yml0IGNvdW50IG9mIHN0YXRlX3RvX2JlX211bHRpcGxpZWQgYW5kIGRzdF9zdGF0ZSBtdXN0IGJlIHRoZSBzYW1lAGdldF9uYW1lAGdldF9kZXZpY2VfbmFtZQBhbmdsZQBkb3VibGUAbWVyZ2UAc2ltdWxhdGVfcmFuZ2UARXJyb3I6IEdlbmVyYWxRdWFudHVtT3BlcmF0b3I6OmdldF90ZXJtKFVJTlQpOiBpbmRleCBvdXQgb2YgcmFuZ2UARXJyb3I6IFBhcmFtZXRyaWNRdWFudHVtQ2lyY3VpdDo6c2V0X3BhcmFtZXRlcihVSU5ULGRvdWJsZSk6IHBhcmFtZXRlciBpbmRleCBpcyBvdXQgb2YgcmFuZ2UARXJyb3I6IFBhcmFtZXRyaWNRdWFudHVtQ2lyY3VpdDo6Z2V0X3BhcmFtZXRlcihVSU5UKTogcGFyYW1ldGVyIGluZGV4IGlzIG91dCBvZiByYW5nZQBFcnJvcjogUGFyYW1ldHJpY1F1YW50dW1DaXJjdWl0OjpnZXRfcGFyYW1ldHJpY19nYXRlX3Bvc2l0aW9uKFVJTlQpOiBwYXJhbWV0ZXIgaW5kZXggaXMgb3V0IG9mIHJhbmdlADogb3V0IG9mIHJhbmdlAGdldEV4Y2VwdGlvbk1lc3NhZ2UAZ2V0X2FtcGxpdHVkZQBnZXRfdHJhbnNpdGlvbl9hbXBsaXR1ZGUATm8gc3VjaCBub2RlAHJlZHVjZQBpbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZQBpbnZhbGlkIGNvZGUgc2VxdWVuY2UAaXNfQ2xpZmZvcmQARXJyb3I6IFF1YW50dW1DaXJjdWl0Ojp1cGRhdGVfcXVhbnR1bV9zdGF0ZShRdWFudHVtU3RhdGVCYXNlLFVJTlQsVUlOVCkgOiBzdGFydCBtdXN0IGJlIHNtYWxsZXIgdGhhbiBvciBlcXVhbCB0byBlbmQAYnVpbGQAZ2V0X2NoaWxkAHZvaWQAQ29udHJvbCBxdWJpdCBpbiBzcGFyc2UgbWF0cml4IGdhdGUgaXMgbm90IHN1cHBvcnRlZABsb2NhbGUgbm90IHN1cHBvcnRlZABSZWZsZWN0aW9uR2F0ZTo6c2V0X21hdHJpeCBpcyBub3QgaW1wbGVtZW50ZWQAbXVsdGlwbHlfZWxlbWVudHdpc2VfZnVuY3Rpb24gZm9yIGRlbnNpdHkgbWF0cml4IGlzIG5vdCBpbXBsZW1lbnRlZABRdWFudHVtR2F0ZURpYWdvbmFsTWF0cml4Ojp1cGRhdGVfcXVhbnR1bV9zdGF0ZSBmb3IgZGVuc2l0eSBtYXRyaXggaXMgbm90IGltcGxlbWVudGVkAFF1YW50dW1HYXRlU3BhcnNlTWF0cml4Ojp1cGRhdGVfcXVhbnR1bV9zdGF0ZSBmb3IgZGVuc2l0eSBtYXRyaXggaXMgbm90IGltcGxlbWVudGVkAGdldF90cmFuc2l0aW9uX2FtcGxpdHVkZSBmb3IgZGVuc2l0eSBtYXRyaXggaXMgbm90IGltcGxlbWVudGVkAGFkZCBzdGF0ZSBiZXR3ZWVuIGRlbnNpdHkgbWF0cml4IGFuZCBzdGF0ZSB2ZWN0b3IgaXMgbm90IGltcGxlbWVudGVkAHB0cmVlIGZvciB0aGlzIGdhdGUgaXMgbm90IGltcGxlbWVudGVkACBnYXRlIGlzIG5vdCBJbXBsZW1lbnRlZABpbnNlcnRCYWNrVW5jb21wcmVzc2VkAHRlcm1pbmF0ZV9oYW5kbGVyIHVuZXhwZWN0ZWRseSByZXR1cm5lZABFcnJvcjogUXVhbnR1bUdhdGVfU2luZ2xlUGFyYW1ldGVyT25lUXViaXRSb3RhdGlvbjo6dXBkYXRlX3F1YW50dW1fc3RhdGUoUXVhbnR1bVN0YXRlQmFzZSkgOiB1cGRhdGUgZnVuY3Rpb24gaXMgdW5kZWZpbmVkAEludmFsaWQgUGF1bGkgb3BlcmF0b3IgSUQgY2FsbGVkAHJhbmRvbV9kZXZpY2UgZ2V0ZW50cm9weSBmYWlsZWQAIiB0byBkYXRhIGZhaWxlZAAiIGZhaWxlZABhc3NpZ25femVyb19pZl9ub3RfbWF0Y2hlZABXZWQAYWRkAGNhbGN1bGF0ZV9ncmFkAFVua25vd24gZXJyb3IgJWQAc3RkOjpiYWRfYWxsb2MAUXVhbnR1bUdhdGVfUHJvYmFiaWxpc3RpYwBpc19wYXJhbWV0cmljACBkb2VzIG5vdCBzdXBwb3J0IGJhY2twcm9wIGluIHBhcmFtZXRyaWMAUGFyYW1ldHJpYwBnZW5lcmljAHN0YXJ0VmVjAERlYwBGZWIAZ2FyYmFnZSBhZnRlciBkYXRhAHB0cl8AJWxmIFslW15dXV0AJWxmJVtqXSBbJVteXV1dACglbGYtJWxmaikgWyVbXl1dXQAoJWxmKyVsZmopIFslW15dXV0Ab3BlcmF0b3JbXQBSb3RJbnZaAFJvdFoASW5kZXBlbmRlbnRYWgBQYXJhbWV0cmljUloAQ1oAUm90SW52WQBzcXJ0WQBSb3RZAFBhcmFtZXRyaWNSWQAlYSAlYiAlZCAlSDolTTolUyAlWQBSb3RJbnZYAHNxcnRYAFJvdFgAUGFyYW1ldHJpY1JYAFBPU0lYAFN0YXRlIHZlY3RvciBvbiBHUFUgY2Fubm90IGJlIGFkZGVkIHRvIHRoYXQgb24gQ1BVAENOT1QARGVuc2VNYXRyaXhfVUlOVABEZW5zZU1hdHJpeF92ZWN0b3JfVUlOVAAlSDolTTolUwBRdWFudHVtR2F0ZV9DUFRQAFNXQVAARlJFREtJTgBOQU4AUE0AQU0ATENfQUxMAFRPRkZPTEkASABMQU5HAElORgAwMTIzNDU2Nzg5QUJDREVGAEMAZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZmxvYXQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQzMl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQzMl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBjaGFyPgBzdGQ6OmJhc2ljX3N0cmluZzx1bnNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8bG9uZz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgbG9uZz4APHVuc3BlY2lmaWVkIGZpbGU+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGRvdWJsZT4AdW5rbm93biB2YWx1ZSBmb3IgcHJvcGVydHkgIm5hbWUiOgAwMTIzNDU2Nzg5AGNvbXBsZXgxMjgAQy5VVEYtOABVMwBFcnJvcjogU2luZ2xlUGF1bGlPcGVyYXRvcihVSU5ULCBVSU5UKTogaW5kZXggbXVzdCBiZSBlaXRoZXIgb2YgMCwxLDIsMwBVMgBVMQBQMQBQcm9qZWN0aW9uLTEARXJyb3I6IFF1YW50dW1HYXRlX1Byb2JhYmlsaXN0aWM6OmdldF9tYXJnaW5hbF9wcm9iYWJpbGl0eSh2ZWN0b3I8ZG91YmxlPiwgdmVjdG9yPFF1YW50dW1HYXRlQmFzZSo+KTogZ2F0ZV9saXN0LnNpemUoKSBtdXN0IGJlIGVxdWFsIHRvIGRpc3RyaWJ1dGlvbi5zaXplKCkgb3IgZGlzdHJpYnV0aW9uLnNpemUoKSsxAFAwAEkwACgoU2l6ZUF0Q29tcGlsZVRpbWUgPT0gRHluYW1pYyAmJiAoTWF4U2l6ZUF0Q29tcGlsZVRpbWU9PUR5bmFtaWMgfHwgc2l6ZTw9TWF4U2l6ZUF0Q29tcGlsZVRpbWUpKSB8fCBTaXplQXRDb21waWxlVGltZSA9PSBzaXplKSAmJiBzaXplPj0wAFByb2plY3Rpb24tMABzaXplKCkgPiAwICYmIG51bV9ibG9ja3MoKSA+IDAAdmVjU2l6ZSA+PSAwAEludmFsaWQgYXJndW1lbnQgcGFzc2VkIHRvIERlbnNlTWF0cml4LgBtYXRyaXggZGltcyBpcyBub3QgY29uc2lzdGVudC4ARmFpbGVkIHRvIGZpbmQgdGhlIGV4YWN0IGp1bXAgdGltZS4gVHJ5IHdpdGggc21hbGxlciBkdC4AIHF1Yml0cy4ARmFpbGVkIHRvIGZpbmQgdGhlIGV4YWN0IGp1bXAgdGltZS4gVHJ5IHdpdGggc21hbGxlciB0X3N0ZXAuAEVycm9yOiBnYXRlOjpQYXJhbWV0cmljUGF1bGlSb3RhdGlvbihzdGQ6OnZlY3RvcjxVSU5UPiwgc3RkOjp2ZWN0b3I8VUlOVD4sIGRvdWJsZSk6IHRhcmdldCBxdWJpdCBsaXN0IGNvbnRhaW5zIGR1cGxpY2F0ZWQgdmFsdWVzLgpJbmZvOiBOVUxMIHVzZWQgdG8gYmUgcmV0dXJuZWQsIGJ1dCBpdCBjaGFuZ2VkIHRvIHRocm93IGV4Y2VwdGlvbi4ARXJyb3I6IGdhdGU6OlNwYXJzZU1hdHJpeChzdGQ6OnZlY3RvcjxVSU5UPiB0YXJnZXRfbGlzdCwgU3BhcnNlQ29tcGxleE1hdHJpeCBtYXRyaXgpOiB0YXJnZXQgbGlzdCBjb250YWlucyBkdXBsaWNhdGVkIHZhbHVlcy4KSW5mbzogTlVMTCB1c2VkIHRvIGJlIHJldHVybmVkLCBidXQgaXQgY2hhbmdlZCB0byB0aHJvdyBleGNlcHRpb24uAEVycm9yOiBnYXRlOjpEZW5zZU1hdHJpeChzdGQ6OnZlY3RvcjxVSU5UPiB0YXJnZXRfbGlzdCwgQ29tcGxleE1hdHJpeCBtYXRyaXgpOiB0YXJnZXQgbGlzdCBjb250YWlucyBkdXBsaWNhdGVkIHZhbHVlcy4KSW5mbzogTlVMTCB1c2VkIHRvIGJlIHJldHVybmVkLCBidXQgaXQgY2hhbmdlZCB0byB0aHJvdyBleGNlcHRpb24uAEVycm9yOiBnYXRlOjpSYW5kb21Vbml0YXJ5KHN0ZDo6dmVjdG9yPFVJTlQ+IHRhcmdldF9saXN0KTogdGFyZ2V0IGxpc3QgY29udGFpbnMgZHVwbGljYXRlZCB2YWx1ZXMuCkluZm86IE5VTEwgdXNlZCB0byBiZSByZXR1cm5lZCwgYnV0IGl0IGNoYW5nZWQgdG8gdGhyb3cgZXhjZXB0aW9uLgBFcnJvcjogZ2F0ZTo6RGlhZ29uYWxNYXRyaXgoc3RkOjp2ZWN0b3I8VUlOVD4gdGFyZ2V0X2xpc3QsIENvbXBsZXhWZWN0b3IgZGlhZ29uYWxfZWxlbWVudCk6IHRhcmdldCBsaXN0IGNvbnRhaW5zIGR1cGxpY2F0ZWQgdmFsdWVzLgpJbmZvOiBOVUxMIHVzZWQgdG8gYmUgcmV0dXJuZWQsIGJ1dCBpdCBjaGFuZ2VkIHRvIHRocm93IGV4Y2VwdGlvbi4ARXJyb3I6IGdhdGU6OlJldmVyc2libGVCb29sZWFuKHN0ZDo6dmVjdG9yPFVJTlQ+IHRhcmdldF9xdWJpdF9pbmRleF9saXN0LCBzdGQ6OmZ1bmN0aW9uPElUWVBFKElUWVBFLElUWVBFKT4gZnVuY3Rpb25fcHRyKTogdGFyZ2V0IGxpc3QgY29udGFpbnMgZHVwbGljYXRlZCB2YWx1ZXMuCkluZm86IE5VTEwgdXNlZCB0byBiZSByZXR1cm5lZCwgYnV0IGl0IGNoYW5nZWQgdG8gdGhyb3cgZXhjZXB0aW9uLgBFcnJvcjogZ2F0ZTo6UGF1bGlSb3RhdGlvbihzdGQ6OnZlY3RvcjxVSU5UPiB0YXJnZXQsIHN0ZDo6dmVjdG9yPFVJTlQ+cGF1bGlfaWQsIGRvdWJsZSBhbmdsZSk6IHRhcmdldCBsaXN0IGNvbnRhaW5zIGR1cGxpY2F0ZWQgdmFsdWVzLgpJbmZvOiBOVUxMIHVzZWQgdG8gYmUgcmV0dXJuZWQsIGJ1dCBpdCBjaGFuZ2VkIHRvIHRocm93IGV4Y2VwdGlvbi4ARXJyb3I6IGdhdGU6OlR3b1F1Yml0RGVwb2xhcml6aW5nTm9pc2UoVUlOVCwgVUlOVCwgZG91YmxlKTogdGFyZ2V0IGxpc3QgY29udGFpbnMgZHVwbGljYXRlZCB2YWx1ZXMuCkluZm86IE5VTEwgdXNlZCB0byBiZSByZXR1cm5lZCwgYnV0IGl0IGNoYW5nZWQgdG8gdGhyb3cgZXhjZXB0aW9uLgBFcnJvcjogZ2F0ZTo6UGF1bGkoc3RkOjp2ZWN0b3I8VUlOVD4gdGFyZ2V0LCBzdGQ6OnZlY3RvcjxVSU5UPnBhdWxpX2lkKTogdGFyZ2V0IGxpc3QgY29udGFpbnMgZHVwbGljYXRlZCB2YWx1ZXMuCkluZm86IE5VTEwgdXNlZCB0byBiZSByZXR1cm5lZCwgYnV0IGl0IGNoYW5nZWQgdG8gdGhyb3cgZXhjZXB0aW9uLgBFcnJvcjogZ2F0ZTo6Q1ooVUlOVCwgVUlOVCk6IGNvbnRyb2xfcXViaXRfaW5kZXggYW5kIHRhcmdldF9xdWJpdF9pbmRleCBoYXMgdGhlIHNhbWUgdmFsdWUuCkluZm86IE5VTEwgdXNlZCB0byBiZSByZXR1cm5lZCwgYnV0IGl0IGNoYW5nZWQgdG8gdGhyb3cgZXhjZXB0aW9uLgBFcnJvcjogZ2F0ZTo6Q05PVChVSU5ULCBVSU5UKTogY29udHJvbF9xdWJpdF9pbmRleCBhbmQgdGFyZ2V0X3F1Yml0X2luZGV4IGhhcyB0aGUgc2FtZSB2YWx1ZS4KSW5mbzogTlVMTCB1c2VkIHRvIGJlIHJldHVybmVkLCBidXQgaXQgY2hhbmdlZCB0byB0aHJvdyBleGNlcHRpb24uAEVycm9yOiBnYXRlOjpTV0FQKFVJTlQsIFVJTlQpOiB0d28gaW5kaWNlcyBoYXZlIHRoZSBzYW1lIHZhbHVlLgpJbmZvOiBOVUxMIHVzZWQgdG8gYmUgcmV0dXJuZWQsIGJ1dCBpdCBjaGFuZ2VkIHRvIHRocm93IGV4Y2VwdGlvbi4ARXJyb3I6IEhlcm1pdGlhblF1YW50dW1PcGVyYXRvcjo6YWRkX29wZXJhdG9yKGNvbnN0IFBhdWxpT3BlcmF0b3IqIG1wdCk6IFBhdWxpT3BlcmF0b3IgbXVzdCBiZSBIZXJtaXRpYW4uAFNpemUgb2YgcXViaXQgbGlzdCBhbmQgcGF1bGkgbGlzdCBtdXN0IGJlIGVxdWFsLgBzb3JyeSwgVGhpcyBjb21wbGV4IGRvbid0IGhhdmUgZWlnZW52YWx1ZS4ARXJyb3I6IEdlbmVyYWxRdWFudHVtT3BlcmF0b3I6OnNvbHZlX2dyb3VuZF9zdGF0ZV9laWdlbnZhbHVlX2J5X3Bvd2VyX21ldGhvZChRdWFudHVtU3RhdGVCYXNlICogc3RhdGUsIGNvbnN0IFVJTlQgaXRlcl9jb3VudCwgY29uc3QgQ1BQQ1RZUEUgbXUpOiBBdCBsZWFzdCBvbmUgUGF1bGlPcGVyYXRvciBpcyByZXF1aXJlZC4ARXJyb3I6IEdlbmVyYWxRdWFudHVtT3BlcmF0b3I6OnNvbHZlX2dyb3VuZF9zdGF0ZV9laWdlbnZhbHVlX2J5X2Fybm9sZGlfbWV0aG9kKFF1YW50dW1TdGF0ZUJhc2UgKiBzdGF0ZSwgY29uc3QgVUlOVCBpdGVyX2NvdW50LCBjb25zdCBDUFBDVFlQRSBtdSk6IEF0IGxlYXN0IG9uZSBQYXVsaU9wZXJhdG9yIGlzIHJlcXVpcmVkLgAqIFdhcm5pbmcgOiBHYXRlLW1hdHJpeCBvZiBDUFRQLW1hcCBjYW5ub3QgYmUgb2J0YWluZWQuIElkZW50aXR5IG1hdHJpeCBpcyByZXR1cm5lZC4AKiBXYXJuaW5nIDogR2F0ZS1tYXRyaXggb2YgQ1AtbWFwIGNhbm5vdCBiZSBvYnRhaW5lZC4gSWRlbnRpdHkgbWF0cml4IGlzIHJldHVybmVkLgAqIFdhcm5pbmcgOiBHYXRlLW1hdHJpeCBvZiBBZGFwdGl2ZS1nYXRlIGNhbm5vdCBiZSBvYnRhaW5lZC4gSWRlbnRpdHkgbWF0cml4IGlzIHJldHVybmVkLgAqIFdhcm5pbmcgOiBHYXRlLW1hdHJpeCBvZiBwcm9iYWJpbGlzdGljIGdhdGUgY2Fubm90IGJlIG9idGFpbmVkLiBJZGVudGl0eSBtYXRyaXggaXMgcmV0dXJuZWQuAEVycm9yOiBDbHNOb2lzeUV2b2x1dGlvbjo6c2V0X21hdHJpeChDb21wbGV4TWF0cml4Jik6IEdhdGUtbWF0cml4IG9mIG5vaXN5IGV2b2x1dGlvbiBjYW5ub3QgYmUgZGVmaW5lZC4AKiBXYXJuaW5nIDogQ1BUUC1tYXAgd2FzIG5vdCB0cmFjZSBwcmVzZXJ2aW5nLiBJZGVudGl0eS1tYXAgaXMgYXBwbGllZC4ASW52YWxpZCBhcmd1bWVudCBwYXNzZWQgdG8gVE9GRk9MSS4AbWF0cml4IGRpbXMgaXMgbm90IDJ4Mi4AJy4AZXhwZWN0ZWQgZGlnaXRzIGFmdGVyIC0Ab3BlcmF0b3IqACAqKiogRGVuc2l0eSBNYXRyaXggKioqACoqKiBRdWFudHVtIENpcmN1aXQgSW5mbyAqKioAKioqIFBhcmFtZXRlciBJbmZvICoqKgAgKioqIFF1YW50dW0gU3RhdGUgKioqAEVycm9yOiBhZGRfZGVuc2VfbWF0cml4X2dhdGUodmVjdG9yPFVJTlQ+LCBjb25zdCBDb21wbGV4TWF0cml4JikgOiBtYXRyaXggbXVzdCBiZSBtYXRyaXguY29scygpPT0oMTw8dGFyZ2V0X2NvdW50KSBhbmQgbWF0cml4LnJvd3MoKT09KDE8PHRhcmdldF9jb3VudCkAcm93cyA+PSAwICYmIChSb3dzQXRDb21waWxlVGltZSA9PSBEeW5hbWljIHx8IFJvd3NBdENvbXBpbGVUaW1lID09IHJvd3MpICYmIGNvbHMgPj0gMCAmJiAoQ29sc0F0Q29tcGlsZVRpbWUgPT0gRHluYW1pYyB8fCBDb2xzQXRDb21waWxlVGltZSA9PSBjb2xzKQAobnVsbCkAbV9pbm5lck5vblplcm9zW291dGVyXTw9KG1fb3V0ZXJJbmRleFtvdXRlcisxXSAtIG1fb3V0ZXJJbmRleFtvdXRlcl0pAG1fY2hlY2tfaW52YXJpYW50cygpAGl0LT5yb3coKT49MCAmJiBpdC0+cm93KCk8bWF0LnJvd3MoKSAmJiBpdC0+Y29sKCk+PTAgJiYgaXQtPmNvbCgpPG1hdC5jb2xzKCkAcm93ID49IDAgJiYgcm93IDwgcm93cygpICYmIGNvbCA+PSAwICYmIGNvbCA8IGNvbHMoKQBvcGVyYXRvcigpAGluZGV4ID49IDAgJiYgaW5kZXggPCBzaXplKCkAIWlzQ29tcHJlc3NlZCgpACAoAGV4cGVjdGVkICdudWxsJwBleHBlY3RlZCAndHJ1ZScAZXhwZWN0ZWQgJ2ZhbHNlJwBleHBlY3RlZCAnOicAbmVlZCBhdCBsZWFzdCBvbmUgZGlnaXQgYWZ0ZXIgJy4nAGV4cGVjdGVkICd9JyBvciAnLCcAZXhwZWN0ZWQgJ10nIG9yICcsJwBFcnJvcjogUXVhbnR1bUNpcmN1aXQ6OmFkZF9ub2lzZV9nYXRlKFF1YW50dW1HYXRlQmFzZSosc3RyaW5nLGRvdWJsZSkgOiBub2lzZV90eXBlIGlzIHVuZGV0ZWN0YWJsZS4geW91ciBub2lzZV90eXBlID0gJwBtX291dGVySW5kZXhbb3V0ZXIrMV09PTAgJiYgIllvdSBtdXN0IGNhbGwgc3RhcnRWZWMgZm9yIGVhY2ggaW5uZXIgdmVjdG9yIHNlcXVlbnRpYWxseSIAbV9vdXRlckluZGV4W291dGVyXT09SW5kZXgobV9kYXRhLnNpemUoKSkgJiYgIllvdSBtdXN0IGNhbGwgc3RhcnRWZWMgZm9yIGVhY2ggaW5uZXIgdmVjdG9yIHNlcXVlbnRpYWxseSIAIWVtcHR5KCkgJiYgIlJlZHVjaW5nIGVtcHR5IHBhdGgiACghKFJvd3NBdENvbXBpbGVUaW1lIT1EeW5hbWljKSB8fCAocm93cz09Um93c0F0Q29tcGlsZVRpbWUpKSAmJiAoIShDb2xzQXRDb21waWxlVGltZSE9RHluYW1pYykgfHwgKGNvbHM9PUNvbHNBdENvbXBpbGVUaW1lKSkgJiYgKCEoUm93c0F0Q29tcGlsZVRpbWU9PUR5bmFtaWMgJiYgTWF4Um93c0F0Q29tcGlsZVRpbWUhPUR5bmFtaWMpIHx8IChyb3dzPD1NYXhSb3dzQXRDb21waWxlVGltZSkpICYmICghKENvbHNBdENvbXBpbGVUaW1lPT1EeW5hbWljICYmIE1heENvbHNBdENvbXBpbGVUaW1lIT1EeW5hbWljKSB8fCAoY29sczw9TWF4Q29sc0F0Q29tcGlsZVRpbWUpKSAmJiByb3dzPj0wICYmIGNvbHM+PTAgJiYgIkludmFsaWQgc2l6ZXMgd2hlbiByZXNpemluZyBhIG1hdHJpeCBvciBhcnJheS4iAGlzQ29tcHJlc3NlZCgpICYmICJUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IG1ha2Ugc2Vuc2UgaW4gbm9uIGNvbXByZXNzZWQgbW9kZS4iACFwLmVtcHR5KCkgJiYgIkVtcHR5IHBhdGggbm90IGFsbG93ZWQgZm9yIHB1dF9jaGlsZC4iAEluZGV4KG1fb3V0ZXJJbmRleFtvdXRlcisxXSkgPT0gbV9kYXRhLnNpemUoKSAmJiAiSW52YWxpZCBvcmRlcmVkIGluc2VydGlvbiAoaW52YWxpZCBvdXRlciBpbmRleCkiAChtX291dGVySW5kZXhbb3V0ZXIrMV0tbV9vdXRlckluZGV4W291dGVyXT09MCB8fCBtX2RhdGEuaW5kZXgobV9kYXRhLnNpemUoKS0xKTxpbm5lcikgJiYgIkludmFsaWQgb3JkZXJlZCBpbnNlcnRpb24gKGludmFsaWQgaW5uZXIgaW5kZXgpIgBjb252ZXJzaW9uIG9mIGRhdGEgdG8gdHlwZSAiAGNvbnZlcnNpb24gb2YgdHlwZSAiAFB1cmUgdmlydHVhbCBmdW5jdGlvbiBjYWxsZWQhAEVycm9yOiBRdWFudHVtR2F0ZV9Qcm9iYWJpbGlzdGljOjpnZXRfbWFyZ2luYWxfcHJvYmFiaWxpdHkodmVjdG9yPGRvdWJsZT4sIHZlY3RvcjxRdWFudHVtR2F0ZUJhc2UqPik6IHN1bSBvZiBwcm9iYWJpbGl0eSBkaXN0cmlidXRpb24gbXVzdCBiZSBlcXVhbCB0byBvciBsZXNzIHRoYW4gMS4wLCB3aGljaCBpcyAARXJyb3I6IFF1YW50dW1DaXJjdWl0OjphZGRfbm9pc2VfZ2F0ZShRdWFudHVtR2F0ZUJhc2UqLHN0cmluZyxkb3VibGUpIDogZGVwb2xhcml6aW5nIG5vaXNlIGNhbiBiZSB1c2VkIHVwIHRvIDIgcXViaXRzLCBidXQgdGhpcyBnYXRlIGhhcyAARXJyb3I6IFF1YW50dW1DaXJjdWl0OjphZGRfbm9pc2VfZ2F0ZShRdWFudHVtR2F0ZUJhc2UqLHN0cmluZyxkb3VibGUpIDogQml0RmxpcCBub2lzZSBjYW4gYmUgdXNlZCBieSAxIHF1Yml0cywgYnV0IHRoaXMgZ2F0ZSBoYXMgAEVycm9yOiBRdWFudHVtQ2lyY3VpdDo6YWRkX25vaXNlX2dhdGUoUXVhbnR1bUdhdGVCYXNlKixzdHJpbmcsZG91YmxlKSA6IERlcGhhc2luZyBub2lzZSBjYW4gYmUgdXNlZCBieSAxIHF1Yml0cywgYnV0IHRoaXMgZ2F0ZSBoYXMgAEVycm9yOiBRdWFudHVtQ2lyY3VpdDo6YWRkX25vaXNlX2dhdGUoUXVhbnR1bUdhdGVCYXNlKixzdHJpbmcsZG91YmxlKSA6IEFtcGxpdHVkZURhbXBpbmcgbm9pc2UgY2FuIGJlIHVzZWQgYnkgMSBxdWJpdHMsIGJ1dCB0aGlzIGdhdGUgaGFzIABFcnJvcjogUXVhbnR1bUNpcmN1aXQ6OmFkZF9ub2lzZV9nYXRlKFF1YW50dW1HYXRlQmFzZSosc3RyaW5nLGRvdWJsZSkgOiBJbmRlcGVuZGVudFhaIG5vaXNlIGNhbiBiZSB1c2VkIGJ5IDEgcXViaXRzLCBidXQgdGhpcyBnYXRlIGhhcyAASW52ZXJzZSBvZiAAIyBvZiAAIDogdmFsdWUgACA6IGNvbW11dGUgAHJhbmRvbSBkZXZpY2Ugbm90IHN1cHBvcnRlZCAASVhZWiAAIyBvZiBxdWJpdDogAEVycm9yOiBQYXVsaU9wZXJhdG9yOjpnZXRfZXhwZWN0YXRpb25fdmFsdWUoUXVhbnR1bVN0YXRlQmFzZSopOlRoZSBudW1iZXIgb2YgcXViaXQgaW4gUGF1bGlPcGVyYXRvciBpcyBncmVhdGVyIHRoYW4gUXVhbnR1bVN0YXRlLlBhdWxpT3BlcmF0b3I6IABFcnJvcjogACMgb2YgcGFyYW1ldGVyOiAARXJyb3I6IFBhdWxpT3BlcmF0b3I6OlBhdWxpT3BlcmF0b3Ioc3RkOjpzdHJpbmcsIENQUENUWVBFKTpEZXRlY3RlZCBwYXVsaV9zdHIgd2l0aG91dCBpbmRpY2VzLiBNYXliZSBtaXN0eXBlZD8gT3JpZ2luYWwgUGF1bGkgc3RyaW5nOiAAIFF1YW50dW1TdGF0ZTogACBxdWJpdCBnYXRlOiAAICogUGFyYW1ldHJpYzogACAqIFF1Yml0IENvdW50IDogACMgb2Ygc3RlcCA6IABpbnZhbGlkIFBhdWxpIHN0cmluZyBpcyBnaXZlbiA6IAAjIG9mIGdhdGUgOiAAICogZ2F0ZSBuYW1lIDogACAqIEdhdXNzaWFuICA6IAAgKiBEaWFnb25hbCAgOiAAICogQ2xpZmZvcmQgIDogACAqIERpbWVuc2lvbiAgIDogACAqIGNvbnRyb2wgICA6IAAgKiB0YXJnZXQgICAgOiAAICogUGF1bGkgICAgIDogADAgAG11c3QgYmUgcHJldl9zdGF0ZS5ub3JtKCkgPj0gdGFyZ2V0X25vcm0uIABtdXN0IGJlIG5vd19zdGF0ZS5ub3JtKCkgPD0gdGFyZ2V0X25vcm0uIAAgKyAAICoqKiBnYXRlIGluZm8gKioqIABPdXQgb2YgbWVtb3J5CgAgKiBEZW5zaXR5IG1hdHJpeCA6IAoAICogU3RhdGUgdmVjdG9yIDogCgAM6gAAZFQAAGRUAABOMTBlbXNjcmlwdGVuM3ZhbEUAALjqAABQVAAAtFQAAGzqAABOU3QzX18yMTJiYXNpY19zdHJpbmdJY05TXzExY2hhcl90cmFpdHNJY0VFTlNfOWFsbG9jYXRvckljRUVFRQAAuOoAAHRUAABpaWkATlN0M19fMjdjb21wbGV4SWRFRQC46gAAwFQAAFBOU3QzX18yN2NvbXBsZXhJZEVFAAAAAJjrAADcVAAAAAAAANRUAABQS05TdDNfXzI3Y29tcGxleElkRUUAAACY6wAABFUAAAEAAADUVAAAaWkAdgB2aQD0VAAAdmlpZABONUVpZ2VuNk1hdHJpeElOU3QzX18yN2NvbXBsZXhJZEVFTGluMUVMaW4xRUxpMUVMaW4xRUxpbjFFRUUATjVFaWdlbjE1UGxhaW5PYmplY3RCYXNlSU5TXzZNYXRyaXhJTlN0M19fMjdjb21wbGV4SWRFRUxpbjFFTGluMUVMaTFFTGluMUVMaW4xRUVFRUUATjVFaWdlbjEwTWF0cml4QmFzZUlOU182TWF0cml4SU5TdDNfXzI3Y29tcGxleElkRUVMaW4xRUxpbjFFTGkxRUxpbjFFTGluMUVFRUVFAE41RWlnZW45RGVuc2VCYXNlSU5TXzZNYXRyaXhJTlN0M19fMjdjb21wbGV4SWRFRUxpbjFFTGluMUVMaTFFTGluMUVMaW4xRUVFRUUATjVFaWdlbjE1RGVuc2VDb2VmZnNCYXNlSU5TXzZNYXRyaXhJTlN0M19fMjdjb21wbGV4SWRFRUxpbjFFTGluMUVMaTFFTGluMUVMaW4xRUVFTGkzRUVFAE41RWlnZW4xNURlbnNlQ29lZmZzQmFzZUlOU182TWF0cml4SU5TdDNfXzI3Y29tcGxleElkRUVMaW4xRUxpbjFFTGkxRUxpbjFFTGluMUVFRUxpMUVFRQBONUVpZ2VuMTVEZW5zZUNvZWZmc0Jhc2VJTlNfNk1hdHJpeElOU3QzX18yN2NvbXBsZXhJZEVFTGluMUVMaW4xRUxpMUVMaW4xRUxpbjFFRUVMaTBFRUUATjVFaWdlbjlFaWdlbkJhc2VJTlNfNk1hdHJpeElOU3QzX18yN2NvbXBsZXhJZEVFTGluMUVMaW4xRUxpMUVMaW4xRUxpbjFFRUVFRQAAuOoAAHJXAADg6gAAGlcAAMBXAADg6gAAwlYAAMhXAADg6gAAalYAANRXAADg6gAAHVYAAOBXAADg6gAAzlUAAOxXAADg6gAAelUAAPhXAADg6gAAPVUAAARYAABpADE2UXVhbnR1bVN0YXRlQmFzZQAAAAC46gAAHlgAAFAxNlF1YW50dW1TdGF0ZUJhc2UAmOsAADxYAAAAAAAANFgAAFBLMTZRdWFudHVtU3RhdGVCYXNlAAAAAJjrAABgWAAAAQAAADRYAAAxNVF1YW50dW1TdGF0ZUNwdQAAAODqAACIWAAANFgAAFAxNVF1YW50dW1TdGF0ZUNwdQAAmOsAAKhYAAAAAAAAnFgAAFBLMTVRdWFudHVtU3RhdGVDcHUAmOsAAMxYAAABAAAAnFgAALxYAABU6gAAAAAAAJxYAACnAgAAqAIAAKkCAACqAgAAqwIAAKwCAACtAgAArgIAAK8CAACwAgAAsQIAALICAACzAgAAtAIAALUCAAC2AgAAtwIAALgCAAC5AgAAugIAALsCAAC8AgAAvQIAAL4CAAC/AgAAwAIAAMECAADCAgAAwwIAAMQCAADFAgAAxgIAAMcCAADIAgAAyQIAAMoCAADLAgAAzAIAAM0CAAAAAAAANFgAAM4CAADPAgAAqQIAANACAADQAgAA0AIAANACAADQAgAA0AIAANACAADQAgAA0AIAANACAADQAgAA0AIAANACAADQAgAA0AIAANACAADQAgAA0AIAANACAADQAgAA0AIAANACAADQAgAA0AIAANACAADQAgAA0AIAANACAADGAgAAxwIAAMgCAADQAgAA0AIAANACAADMAgAAzQIAADMwTWF0cml4SW5kZXhPdXRPZlJhbmdlRXhjZXB0aW9uAAAAAODqAABAWgAAOO0AAAAAAABkWgAACQIAANECAADSAgAAMjlRdWJpdEluZGV4T3V0T2ZSYW5nZUV4Y2VwdGlvbgDg6gAAhFoAADjtAAAAAAAApFoAAAkCAADTAgAA0gIAADI2SW52YWxpZFF1Yml0Q291bnRFeGNlcHRpb24AAAAA4OoAAMRaAACM7AAAAAAAAORaAAAJAgAA1AIAANICAAAzMUludmFsaWRTdGF0ZVZlY3RvclNpemVFeGNlcHRpb24AAADg6gAABFsAAIzsAAAAAAAAKFsAAAkCAADVAgAA0gIAADMwUXVhbnR1bVN0YXRlUHJvY2Vzc29yRXhjZXB0aW9uAAAAAODqAABIWwAAjOwAAAAAAABsWwAACQIAANYCAADSAgAATjVib29zdDEwd3JhcGV4Y2VwdElOU18xM3Byb3BlcnR5X3RyZWUxNHB0cmVlX2JhZF9wYXRoRUVFAE41Ym9vc3QxNmV4Y2VwdGlvbl9kZXRhaWwxMGNsb25lX2Jhc2VFAAAAALjqAADGWwAATjVib29zdDEzcHJvcGVydHlfdHJlZTE0cHRyZWVfYmFkX3BhdGhFAE41Ym9vc3QxM3Byb3BlcnR5X3RyZWUxMXB0cmVlX2Vycm9yRQAAAADg6gAAIFwAAFjtAADg6gAA+FsAAEhcAABONWJvb3N0OWV4Y2VwdGlvbkUAALjqAABgXAAAPOsAAIxbAAAAAAAAAwAAAPBbAAACAAAAVFwAAAIEAAB0XAAAAhAAAAAAAAB8XAAA1wIAANgCAACDAgAA2QIAAPz///98XAAA2gIAANsCAADcAgAA8P///3xcAADdAgAA3gIAAAAAAADwWwAA0AIAANACAADfAgAA4AIAAAAAAABUXAAA4QIAAOICAADcAgAAAAAAAEhcAADjAgAA5AIAANwCAAAAAAAAdFwAANACAADQAgAAAAAAAPxdAADlAgAA5gIAAOcCAADoAgAATjVib29zdDNhbnk2aG9sZGVySU5TXzEzcHJvcGVydHlfdHJlZTExc3RyaW5nX3BhdGhJTlN0M19fMjEyYmFzaWNfc3RyaW5nSWNOUzRfMTFjaGFyX3RyYWl0c0ljRUVOUzRfOWFsbG9jYXRvckljRUVFRU5TMl8xM2lkX3RyYW5zbGF0b3JJU0FfRUVFRUVFAE41Ym9vc3QzYW55MTFwbGFjZWhvbGRlckUAALjqAADZXQAA4OoAAEhdAAD0XQAATjVib29zdDEzcHJvcGVydHlfdHJlZTExc3RyaW5nX3BhdGhJTlN0M19fMjEyYmFzaWNfc3RyaW5nSWNOUzJfMTFjaGFyX3RyYWl0c0ljRUVOUzJfOWFsbG9jYXRvckljRUVFRU5TMF8xM2lkX3RyYW5zbGF0b3JJUzhfRUVFRQC46gAACF4AAEExM19jAE41Ym9vc3QxMHdyYXBleGNlcHRJTlNfMTNwcm9wZXJ0eV90cmVlMTRwdHJlZV9iYWRfZGF0YUVFRQBONWJvb3N0MTNwcm9wZXJ0eV90cmVlMTRwdHJlZV9iYWRfZGF0YUUA4OoAANBeAABIXAAAPOsAAJZeAAAAAAAAAwAAAPBbAAACAAAA+F4AAAIEAAB0XAAAAhAAAAAAAAAEXwAA6QIAAOoCAACBAgAA6wIAAPz///8EXwAA7AIAAO0CAADcAgAA8P///wRfAADuAgAA7wIAAAAAAAD4XgAA8AIAAPECAADcAgAA9OkAALxYAAB2aWkA9OkAALxYAABg6gAAdmlpaQAAAAD06QAAnFgAAHjqAACo6gAA4FgAAGDqAABkaWlpAAAAAKjqAADgWAAAZFQAAKjqAADgWAAAZGlpAPTpAAC8WAAAqOoAALxYAADgWAAA9OkAAJxYAAA0WAAA9OkAAJxYAABkVAAAtFQAAOBYAAD06QAAvFgAAHhYAAD06QAAnFgAAGzqAAAAAAAABGEAAPICAADzAgAA9AIAAPUCAAD2AgAA9wIAAPgCAAD5AgAA+gIAAE5TdDNfXzIxMF9fZnVuY3Rpb242X19mdW5jSVpaTDIwZW1iaW5kX2luaXRfQmluZGluZ3N2RU5LMyRfNGNsRVIxNVF1YW50dW1TdGF0ZUNwdWxFVWx5RV9OU185YWxsb2NhdG9ySVM1X0VFRk5TXzdjb21wbGV4SWRFRXlFRUUATlN0M19fMjEwX19mdW5jdGlvbjZfX2Jhc2VJRk5TXzdjb21wbGV4SWRFRXlFRUUAuOoAAMxgAADg6gAATGAAAPxgAABaWkwyMGVtYmluZF9pbml0X0JpbmRpbmdzdkVOSzMkXzRjbEVSMTVRdWFudHVtU3RhdGVDcHVsRVVseUVfAAAAuOoAABBhAABg6gAAUFgAAGDqAABpaWlpAAAAAAAAAAD06QAAUFgAAGDqAABg6gAAdmlpaWkAAAC0VAAAeFgAAGRUAACcWAAAYOoAAGDqAABpaWlpaQAAAGRUAACcWAAAYOoAAGRUAACcWAAAtFQAAJxYAABg6gAAnFgAADE2RGVuc2l0eU1hdHJpeENwdQAA4OoAAMxhAAA0WAAAUDE2RGVuc2l0eU1hdHJpeENwdQCY6wAA7GEAAAAAAADgYQAAUEsxNkRlbnNpdHlNYXRyaXhDcHUAAAAAmOsAABBiAAABAAAA4GEAAABiAABU6gAAAAAAAOBhAAD7AgAA/AIAAKkCAAD9AgAA/gIAAP8CAAAAAwAAAQMAAAIDAAADAwAABAMAAAUDAAAGAwAABwMAAAgDAAAJAwAACgMAAAsDAAAMAwAADQMAAA4DAAAPAwAAEAMAABEDAAASAwAAEwMAABQDAAAVAwAAFgMAABcDAAAYAwAAxgIAAMcCAADIAgAAGQMAABoDAAAbAwAAHAMAAM0CAAAdAwAAHgMAADIzTm90SW1wbGVtZW50ZWRFeGNlcHRpb24AAADg6gAA7GIAAIzsAAAAAAAACGMAAAkCAAAfAwAA0gIAAEExNF9jAAAA9OkAAABiAAD06QAA4GEAAHjqAAD06QAAAGIAAGDqAACo6gAAKGIAAGDqAACo6gAA4GEAAGRUAABg6gAA4GEAAKjqAAAoYgAA9OkAAABiAACo6gAAAGIAAChiAAAAYgAA4GEAAPTpAADgYQAANFgAAPTpAADgYQAAZFQAALRUAAAoYgAA9OkAAABiAAB4WAAAtFQAAChiAAAAAAAAAAAAAGRUAADgYQAAYOoAAGDqAABkVAAA4GEAAGDqAABkVAAA4GEAALRUAADgYQAAUDE1UXVhbnR1bUdhdGVCYXNlAACY6wAA/GMAAAAAAABM8gAAUEsxNVF1YW50dW1HYXRlQmFzZQCY6wAAIGQAAAEAAABM8gAA9OkAABBkAABQWAAAEGQAADRkAAC0VAAANGQAAGRUAABM8gAA9OkAAGRUAABkVAAANGQAAAzqAAA0ZAAANGQAAAzqAAA0ZAAAtFQAAEzyAAAxMkNsc1BhdWxpR2F0ZQAA4OoAAJRkAABM8gAAUDEyQ2xzUGF1bGlHYXRlAJjrAACwZAAAAAAAAKRkAABQSzEyQ2xzUGF1bGlHYXRlAAAAAJjrAADQZAAAAQAAAKRkAABQMTVDbHNPbmVRdWJpdEdhdGUAAJjrAAD0ZAAAAAAAAPj1AABQSzE1Q2xzT25lUXViaXRHYXRlAJjrAAAYZQAAAQAAAPj1AAAyMENsc1BhdWxpUm90YXRpb25HYXRlAADg6gAAPGUAAEzyAABQMjBDbHNQYXVsaVJvdGF0aW9uR2F0ZQCY6wAAYGUAAAAAAABUZQAAUEsyMENsc1BhdWxpUm90YXRpb25HYXRlAAAAAJjrAACIZQAAAQAAAFRlAAAxNUNsc1R3b1F1Yml0R2F0ZQAAAODqAAC0ZQAATPIAAFAxNUNsc1R3b1F1Yml0R2F0ZQAAmOsAANRlAAAAAAAAyGUAAFBLMTVDbHNUd29RdWJpdEdhdGUAmOsAAPhlAAABAAAAyGUAAFAyM0Nsc09uZVF1Yml0Um90YXRpb25HYXRlAACY6wAAHGYAAAAAAAA49gAAUEsyM0Nsc09uZVF1Yml0Um90YXRpb25HYXRlAJjrAABIZgAAAQAAADj2AAAyNkNsc09uZUNvbnRyb2xPbmVUYXJnZXRHYXRlAAAAAODqAAB0ZgAATPIAAFAyNkNsc09uZUNvbnRyb2xPbmVUYXJnZXRHYXRlAAAAmOsAAKBmAAAAAAAAlGYAAFBLMjZDbHNPbmVDb250cm9sT25lVGFyZ2V0R2F0ZQAAmOsAANBmAAABAAAAlGYAADI3UXVhbnR1bUdhdGVfU2luZ2xlUGFyYW1ldGVyAAAA4OoAAABnAABM8gAAUDI3UXVhbnR1bUdhdGVfU2luZ2xlUGFyYW1ldGVyAACY6wAALGcAAAAAAAAgZwAAUEsyN1F1YW50dW1HYXRlX1NpbmdsZVBhcmFtZXRlcgCY6wAAXGcAAAEAAAAgZwAA9OkAAExnAACo6gAAqOoAAHxnAABQMTdRdWFudHVtR2F0ZU1hdHJpeAAAAACY6wAAoGcAAAAAAADg9AAAUEsxN1F1YW50dW1HYXRlTWF0cml4AAAAmOsAAMhnAAABAAAA4PQAALRUAADgZwAAuGcAAOBnAAD06QAA4PQAAGRUAAAAAAAA9OkAALhnAABg6gAAYOoAAFAyM1F1YW50dW1HYXRlU3BhcnNlTWF0cml4AACY6wAAIGgAAAAAAAB49QAAUEsyM1F1YW50dW1HYXRlU3BhcnNlTWF0cml4AJjrAABMaAAAAQAAAHj1AABQMjVRdWFudHVtR2F0ZURpYWdvbmFsTWF0cml4AAAAAJjrAAB4aAAAAAAAACz1AABQSzI1UXVhbnR1bUdhdGVEaWFnb25hbE1hdHJpeAAAAJjrAACoaAAAAQAAACz1AAAyNENsc1JldmVyc2libGVCb29sZWFuR2F0ZQAA4OoAANhoAABM8gAAUDI0Q2xzUmV2ZXJzaWJsZUJvb2xlYW5HYXRlAJjrAAAAaQAAAAAAAPRoAABQSzI0Q2xzUmV2ZXJzaWJsZUJvb2xlYW5HYXRlAAAAAJjrAAAsaQAAAQAAAPRoAAAyMkNsc1N0YXRlUmVmbGVjdGlvbkdhdGUAAAAA4OoAAFxpAABM8gAAUDIyQ2xzU3RhdGVSZWZsZWN0aW9uR2F0ZQAAAJjrAACEaQAAAAAAAHhpAABQSzIyQ2xzU3RhdGVSZWZsZWN0aW9uR2F0ZQAAmOsAALBpAAABAAAAeGkAADI1UXVhbnR1bUdhdGVfUHJvYmFiaWxpc3RpYwDg6gAA3GkAAEzyAABQMjVRdWFudHVtR2F0ZV9Qcm9iYWJpbGlzdGljAAAAAJjrAAAEagAAAAAAAPhpAABQSzI1UXVhbnR1bUdhdGVfUHJvYmFiaWxpc3RpYwAAAJjrAAA0agAAAQAAAPhpAAAxNlF1YW50dW1HYXRlX0NQVFAAAODqAABkagAATPIAAFAxNlF1YW50dW1HYXRlX0NQVFAAmOsAAIRqAAAAAAAAeGoAAFBLMTZRdWFudHVtR2F0ZV9DUFRQAAAAAJjrAACoagAAAQAAAHhqAABQMTdDbHNOb2lzeUV2b2x1dGlvbgAAAACY6wAA0GoAAAAAAADg9gAAUEsxN0Nsc05vaXN5RXZvbHV0aW9uAAAAmOsAAPhqAAABAAAA4PYAAFAyMkNsc05vaXN5RXZvbHV0aW9uX2Zhc3QAAACY6wAAIGsAAAAAAADU9gAAUEsyMkNsc05vaXN5RXZvbHV0aW9uX2Zhc3QAAJjrAABMawAAAQAAANT2AAAIZQAAYOoAALhnAABg6gAAqOoAAGlpaWQAAAAAAAAAAAAAAAAAAAAAuGcAAGDqAACo6gAAqOoAAGlpaWRkAAAAAAAAAAAAAAC4ZwAAYOoAAKjqAACo6gAAqOoAAGlpaWRkZAAAOGYAAGDqAACo6gAAwGYAAGDqAABg6gAA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KGIAAChiAAC8WAAA4FgAAGRUAAAAAAAAAAAAAAAAAAC8WAAA4FgAAGRUAABkVAAAvFgAAGRUAADgWAAAZFQAAOBYAAAAAAAAAAAAAAAAAAAAYgAAZFQAAHhYAABkVAAAeFgAALhnAAA0ZAAANGQAALhnAABkVAAAEGQAAGRUAABkVAAAEGQAAGRUAAAAAAAAEGQAAGRUAAAM6gAADOoAAAzqAAAQZAAAZFQAAGDqAAAQZAAAEGQAAGzqAAAAAAAAQHgAAC0DAAAuAwAALwMAADADAAAxAwAAMgMAADMDAAA0AwAANQMAAE5TdDNfXzIxMF9fZnVuY3Rpb242X19mdW5jSVpaTDIwZW1iaW5kX2luaXRfQmluZGluZ3N2RU5LNCRfODJjbEVQMTVRdWFudHVtR2F0ZUJhc2VsRVVsUktOU182dmVjdG9ySWpOU185YWxsb2NhdG9ySWpFRUVFRV9OUzZfSVNCX0VFRmJTQV9FRUUATlN0M19fMjEwX19mdW5jdGlvbjZfX2Jhc2VJRmJSS05TXzZ2ZWN0b3JJak5TXzlhbGxvY2F0b3JJakVFRUVFRUUAAAC46gAA9HcAAODqAABodwAAOHgAAFpaTDIwZW1iaW5kX2luaXRfQmluZGluZ3N2RU5LNCRfODJjbEVQMTVRdWFudHVtR2F0ZUJhc2VsRVVsUktOU3QzX18yNnZlY3RvcklqTlMyXzlhbGxvY2F0b3JJakVFRUVFXwC46gAATHgAAExnAABg6gAAqOoAABhxAAC0VAAAHG4AALRUAAC8WAAAtFQAAABiAAC0VAAAUFgAALRUAAAQZAAAtFQAAEBuAAC0VAAAHG4AALRUAABs6gAATPIAAGzqAABY9wAAMzNQYXJhbWV0ZXJJbmRleE91dE9mUmFuZ2VFeGNlcHRpb24AMzBDbHNQYXJhbWV0cmljUGF1bGlSb3RhdGlvbkdhdGUAMzRVbmtub3duUFRyZWVQcm9wZXJ0eVZhbHVlRXhjZXB0aW9uADI0UGFyYW1ldHJpY1F1YW50dW1DaXJjdWl0AEEyNV9jAE41Ym9vc3QzYW55NmhvbGRlcklOU3QzX18yMTJiYXNpY19zdHJpbmdJY05TMl8xMWNoYXJfdHJhaXRzSWNFRU5TMl85YWxsb2NhdG9ySWNFRUVFRUUAMjlEdXBsaWNhdGVkUXViaXRJbmRleEV4Y2VwdGlvbgAxOUNsc1BhcmFtZXRyaWNSWEdhdGUANDNRdWFudHVtR2F0ZV9TaW5nbGVQYXJhbWV0ZXJPbmVRdWJpdFJvdGF0aW9uADI4VW5kZWZpbmVkVXBkYXRlRnVuY0V4Y2VwdGlvbgBBMTdfYwAxOUNsc1BhcmFtZXRyaWNSWUdhdGUAMTlDbHNQYXJhbWV0cmljUlpHYXRlAEEyOF9jADI4R2F0ZUluZGV4T3V0T2ZSYW5nZUV4Y2VwdGlvbgAzNUludmFsaWROb2lzZVR5cGVJZGVudGlmaWVyRXhjZXB0aW9uADIxTm9uSGVybWl0aWFuRXhjZXB0aW9uADI2SW52YWxpZE9ic2VydmFibGVFeGNlcHRpb24AMzBJbnZhbGlkTWF0cml4R2F0ZVNpemVFeGNlcHRpb24AMTRRdWFudHVtQ2lyY3VpdABBMTVfYwAzMUludmFsaWRQYXVsaUlkZW50aWZpZXJFeGNlcHRpb24AMTVRdWFudHVtR2F0ZUJhc2UAMjhJbnZhbGlkQ29udHJvbFF1Yml0RXhjZXB0aW9uAEExMF9jAEExOF9jAEEyMF9jADM5SW52YWxpZFByb2JhYmlsaXR5RGlzdHJpYnV0aW9uRXhjZXB0aW9uAEExMl9jADE0UXVhbnR1bUdhdGVfQ1AAMTdRdWFudHVtR2F0ZU1hdHJpeABBMTZfYwAyNVF1YW50dW1HYXRlRGlhZ29uYWxNYXRyaXgAQTE5X2MAMjNRdWFudHVtR2F0ZVNwYXJzZU1hdHJpeAAyMFF1YW50dW1HYXRlX0FkYXB0aXZlADE1Q2xzT25lUXViaXRHYXRlADIzQ2xzT25lUXViaXRSb3RhdGlvbkdhdGUAMjJDbHNOb2lzeUV2b2x1dGlvbl9mYXN0ADE3Q2xzTm9pc3lFdm9sdXRpb24AQTIzX2MAMzFJbnZhbGlkUXVhbnR1bU9wZXJhdG9yRXhjZXB0aW9uADIyR2VuZXJhbFF1YW50dW1PcGVyYXRvcgAzMk9wZXJhdG9ySW5kZXhPdXRPZlJhbmdlRXhjZXB0aW9uADE0Tm9pc2VTaW11bGF0b3IAMjRIZXJtaXRpYW5RdWFudHVtT3BlcmF0b3IAMTNQYXVsaU9wZXJhdG9yADE2Q29udHJvbFF1Yml0SW5mbwAxNVRhcmdldFF1Yml0SW5mbwBONWJvb3N0MTB3cmFwZXhjZXB0SU5TXzEzcHJvcGVydHlfdHJlZTExanNvbl9wYXJzZXIxN2pzb25fcGFyc2VyX2Vycm9yRUVFAE41Ym9vc3QxM3Byb3BlcnR5X3RyZWUxMWpzb25fcGFyc2VyMTdqc29uX3BhcnNlcl9lcnJvckUATjVib29zdDEzcHJvcGVydHlfdHJlZTE3ZmlsZV9wYXJzZXJfZXJyb3JFAP//////////AQEBAQICA/8AAAAAAADwPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPA/AAAAAAAAAAAAAAAAAADwPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPA/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAAAAAAAAAAAAADwPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPA/zTt/Zp6g5j8AAAAAAAAAAM07f2aeoOY/AAAAAAAAAADNO39mnqDmPwAAAAAAAAAAzTt/Zp6g5r8AAAAAAAAAAAAAAAAAAPA/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwPwAAAAAAAAAATlN0M19fMjEyYmFzaWNfc3RyaW5nSWhOU18xMWNoYXJfdHJhaXRzSWhFRU5TXzlhbGxvY2F0b3JJaEVFRUUAALjqAAAQgAAATlN0M19fMjEyYmFzaWNfc3RyaW5nSXdOU18xMWNoYXJfdHJhaXRzSXdFRU5TXzlhbGxvY2F0b3JJd0VFRUUAALjqAABYgAAATlN0M19fMjEyYmFzaWNfc3RyaW5nSURzTlNfMTFjaGFyX3RyYWl0c0lEc0VFTlNfOWFsbG9jYXRvcklEc0VFRUUAAAC46gAAoIAAAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0lEaU5TXzExY2hhcl90cmFpdHNJRGlFRU5TXzlhbGxvY2F0b3JJRGlFRUVFAAAAuOoAAOyAAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ljRUUAALjqAAA4gQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJYUVFAAC46gAAYIEAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWhFRQAAuOoAAIiBAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lzRUUAALjqAACwgQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJdEVFAAC46gAA2IEAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWlFRQAAuOoAAACCAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lqRUUAALjqAAAoggAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbEVFAAC46gAAUIIAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SW1FRQAAuOoAAHiCAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lmRUUAALjqAACgggAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZEVFAAC46gAAyIIAAE+7YQVnrN0/GC1EVPsh6T+b9oHSC3PvPxgtRFT7Ifk/4mUvIn8rejwHXBQzJqaBPL3L8HqIB3A8B1wUMyamkTwYLURU+yHpPxgtRFT7Iem/0iEzf3zZAkDSITN/fNkCwAAAAAAAAAAAAAAAAAAAAIAYLURU+yEJQBgtRFT7IQnAAwAAAAQAAAAEAAAABgAAAIP5ogBETm4A/CkVANFXJwDdNPUAYtvAADyZlQBBkEMAY1H+ALveqwC3YcUAOm4kANJNQgBJBuAACeouAByS0QDrHf4AKbEcAOg+pwD1NYIARLsuAJzphAC0JnAAQX5fANaROQBTgzkAnPQ5AItfhAAo+b0A+B87AN7/lwAPmAUAES/vAApaiwBtH20Az342AAnLJwBGT7cAnmY/AC3qXwC6J3UA5evHAD178QD3OQcAklKKAPtr6gAfsV8ACF2NADADVgB7/EYA8KtrACC8zwA29JoA46kdAF5hkQAIG+YAhZllAKAUXwCNQGgAgNj/ACdzTQAGBjEAylYVAMmocwB74mAAa4zAABnERwDNZ8MACejcAFmDKgCLdsQAphyWAESv3QAZV9EApT4FAAUH/wAzfj8AwjLoAJhP3gC7fTIAJj3DAB5r7wCf+F4ANR86AH/yygDxhx0AfJAhAGokfADVbvoAMC13ABU7QwC1FMYAwxmdAK3EwgAsTUEADABdAIZ9RgDjcS0Am8aaADNiAAC00nwAtKeXADdV1QDXPvYAoxAYAE12/ABknSoAcNerAGN8+AB6sFcAFxXnAMBJVgA71tkAp4Q4ACQjywDWincAWlQjAAAfuQDxChsAGc7fAJ8x/wBmHmoAmVdhAKz7RwB+f9gAImW3ADLoiQDmv2AA78TNAGw2CQBdP9QAFt7XAFg73gDem5IA0iIoACiG6ADiWE0AxsoyAAjjFgDgfcsAF8BQAPMdpwAY4FsALhM0AIMSYgCDSAEA9Y5bAK2wfwAe6fIASEpDABBn0wCq3dgArl9CAGphzgAKKKQA05m0AAam8gBcd38Ao8KDAGE8iACKc3gAr4xaAG/XvQAtpmMA9L/LAI2B7wAmwWcAVcpFAMrZNgAoqNIAwmGNABLJdwAEJhQAEkabAMRZxADIxUQATbKRAAAX8wDUQ60AKUnlAP3VEAAAvvwAHpTMAHDO7gATPvUA7PGAALPnwwDH+CgAkwWUAMFxPgAuCbMAC0XzAIgSnACrIHsALrWfAEeSwgB7Mi8ADFVtAHKnkABr5x8AMcuWAHkWSgBBeeIA9N+JAOiUlwDi5oQAmTGXAIjtawBfXzYAu/0OAEiatABnpGwAcXJCAI1dMgCfFbgAvOUJAI0xJQD3dDkAMAUcAA0MAQBLCGgALO5YAEeqkAB05wIAvdYkAPd9pgBuSHIAnxbvAI6UpgC0kfYA0VNRAM8K8gAgmDMA9Ut+ALJjaADdPl8AQF0DAIWJfwBVUikAN2TAAG3YEAAySDIAW0x1AE5x1ABFVG4ACwnBACr1aQAUZtUAJwedAF0EUAC0O9sA6nbFAIf5FwBJa30AHSe6AJZpKQDGzKwArRRUAJDiagCI2YkALHJQAASkvgB3B5QA8zBwAAD8JwDqcagAZsJJAGTgPQCX3YMAoz+XAEOU/QANhowAMUHeAJI5nQDdcIwAF7fnAAjfOwAVNysAXICgAFqAkwAQEZIAD+jYAGyArwDb/0sAOJAPAFkYdgBipRUAYcu7AMeJuQAQQL0A0vIEAEl1JwDrtvYA2yK7AAoUqgCJJi8AZIN2AAk7MwAOlBoAUTqqAB2jwgCv7a4AXCYSAG3CTQAtepwAwFaXAAM/gwAJ8PYAK0CMAG0xmQA5tAcADCAVANjDWwD1ksQAxq1LAE7KpQCnN80A5qk2AKuSlADdQmgAGWPeAHaM7wBoi1IA/Ns3AK6hqwDfFTEAAK6hAAz72gBkTWYA7QW3ACllMABXVr8AR/86AGr5uQB1vvMAKJPfAKuAMABmjPYABMsVAPoiBgDZ5B0APbOkAFcbjwA2zQkATkLpABO+pAAzI7UA8KoaAE9lqADSwaUACz8PAFt4zQAj+XYAe4sEAIkXcgDGplMAb27iAO/rAACbSlgAxNq3AKpmugB2z88A0QIdALHxLQCMmcEAw613AIZI2gD3XaAAxoD0AKzwLwDd7JoAP1y8ANDebQCQxx8AKtu2AKMlOgAAr5oArVOTALZXBAApLbQAS4B+ANoHpwB2qg4Ae1mhABYSKgDcty0A+uX9AInb/gCJvv0A5HZsAAap/AA+gHAAhW4VAP2H/wAoPgcAYWczACoYhgBNveoAs+evAI9tbgCVZzkAMb9bAITXSAAw3xYAxy1DACVhNQDJcM4AMMu4AL9s/QCkAKIABWzkAFrdoAAhb0cAYhLSALlchABwYUkAa1bgAJlSAQBQVTcAHtW3ADPxxAATbl8AXTDkAIUuqQAdssMAoTI2AAi3pADqsdQAFvchAI9p5AAn/3cADAOAAI1ALQBPzaAAIKWZALOi0wAvXQoAtPlCABHaywB9vtAAm9vBAKsXvQDKooEACGpcAC5VFwAnAFUAfxTwAOEHhgAUC2QAlkGNAIe+3gDa/SoAayW2AHuJNAAF8/4Aub+eAGhqTwBKKqgAT8RaAC34vADXWpgA9MeVAA1NjQAgOqYApFdfABQ/sQCAOJUAzCABAHHdhgDJ3rYAv2D1AE1lEQABB2sAjLCsALLA0ABRVUgAHvsOAJVywwCjBjsAwEA1AAbcewDgRcwATin6ANbKyADo80EAfGTeAJtk2ADZvjEApJfDAHdY1ABp48UA8NoTALo6PABGGEYAVXVfANK99QBuksYArC5dAA5E7QAcPkIAYcSHACn96QDn1vMAInzKAG+RNQAI4MUA/9eNAG5q4gCw/cYAkwjBAHxddABrrbIAzW6dAD5yewDGEWoA98+pAClz3wC1yboAtwBRAOKyDQB0uiQA5X1gAHTYigANFSwAgRgMAH5mlAABKRYAn3p2AP39vgBWRe8A2X42AOzZEwCLurkAxJf8ADGoJwDxbsMAlMU2ANioVgC0qLUAz8wOABKJLQBvVzQALFaJAJnO4wDWILkAa16qAD4qnAARX8wA/QtKAOH0+wCOO20A4oYsAOnUhAD8tKkA7+7RAC41yQAvOWEAOCFEABvZyACB/AoA+0pqAC8c2ABTtIQATpmMAFQizAAqVdwAwMbWAAsZlgAacLgAaZVkACZaYAA/Uu4AfxEPAPS1EQD8y/UANLwtADS87gDoXcwA3V5gAGeOmwCSM+8AyRe4AGFYmwDhV7wAUYPGANg+EADdcUgALRzdAK8YoQAhLEYAWfPXANl6mACeVMAAT4b6AFYG/ADlea4AiSI2ADitIgBnk9wAVeiqAIImOADK55sAUQ2kAJkzsQCp1w4AaQVIAGWy8AB/iKcAiEyXAPnRNgAhkrMAe4JKAJjPIQBAn9wA3EdVAOF0OgBn60IA/p3fAF7UXwB7Z6QAuqx6AFX2ogAriCMAQbpVAFluCAAhKoYAOUeDAInj5gDlntQASftAAP9W6QAcD8oAxVmKAJT6KwDTwcUAD8XPANtargBHxYYAhUNiACGGOwAseZQAEGGHACpMewCALBoAQ78SAIgmkAB4PIkAqMTkAOXbewDEOsIAJvTqAPdnigANkr8AZaMrAD2TsQC9fAsApFHcACfdYwBp4d0AmpQZAKgplQBozigACe20AESfIABOmMoAcIJjAH58IwAPuTIAp/WOABRW5wAh8QgAtZ0qAG9+TQClGVEAtfmrAILf1gCW3WEAFjYCAMQ6nwCDoqEAcu1tADmNegCCuKkAazJcAEYnWwAANO0A0gB3APz0VQABWU0A4HGAAAAAAAAAAAAAAAAAQPsh+T8AAAAALUR0PgAAAICYRvg8AAAAYFHMeDsAAACAgxvwOQAAAEAgJXo4AAAAgCKC4zYAAAAAHfNpNf6CK2VHFWdAAAAAAAAAOEMAAPr+Qi52vzo7nrya9wy9vf3/////3z88VFVVVVXFP5ErF89VVaU/F9CkZxERgT8AAAAAAADIQu85+v5CLuY/JMSC/72/zj+19AzXCGusP8xQRtKrsoM/hDpOm+DXVT8AAAAAAAAAAAAAAAAAAPA/br+IGk87mzw1M/upPfbvP13c2JwTYHG8YYB3Pprs7z/RZocQel6QvIV/bugV4+8/E/ZnNVLSjDx0hRXTsNnvP/qO+SOAzou83vbdKWvQ7z9hyOZhTvdgPMibdRhFx+8/mdMzW+SjkDyD88bKPr7vP217g12mmpc8D4n5bFi17z/87/2SGrWOPPdHciuSrO8/0ZwvcD2+Pjyi0dMy7KPvPwtukIk0A2q8G9P+r2ab7z8OvS8qUlaVvFFbEtABk+8/VepOjO+AULzMMWzAvYrvPxb01bkjyZG84C2prpqC7z+vVVzp49OAPFGOpciYeu8/SJOl6hUbgLx7UX08uHLvPz0y3lXwH4+86o2MOPlq7z+/UxM/jImLPHXLb+tbY+8/JusRdpzZlrzUXASE4FvvP2AvOj737Jo8qrloMYdU7z+dOIbLguePvB3Z/CJQTe8/jcOmREFvijzWjGKIO0bvP30E5LAFeoA8ltx9kUk/7z+UqKjj/Y6WPDhidW56OO8/fUh08hhehzw/prJPzjHvP/LnH5grR4A83XziZUUr7z9eCHE/e7iWvIFj9eHfJO8/MasJbeH3gjzh3h/1nR7vP/q/bxqbIT28kNna0H8Y7z+0CgxygjeLPAsD5KaFEu8/j8vOiZIUbjxWLz6prwzvP7arsE11TYM8FbcxCv4G7z9MdKziAUKGPDHYTPxwAe8/SvjTXTndjzz/FmSyCPzuPwRbjjuAo4a88Z+SX8X27j9oUEvM7UqSvMupOjen8e4/ji1RG/gHmbxm2AVtruzuP9I2lD7o0XG895/lNNvn7j8VG86zGRmZvOWoE8Mt4+4/bUwqp0ifhTwiNBJMpt7uP4ppKHpgEpO8HICsBEXa7j9biRdIj6dYvCou9yEK1u4/G5pJZ5ssfLyXqFDZ9dHuPxGswmDtY0M8LYlhYAjO7j/vZAY7CWaWPFcAHe1Byu4/eQOh2uHMbjzQPMG1osbuPzASDz+O/5M83tPX8CrD7j+wr3q7zpB2PCcqNtXav+4/d+BU670dkzwN3f2ZsrzuP46jcQA0lI+8pyyddrK57j9Jo5PczN6HvEJmz6Latu4/XzgPvcbeeLyCT51WK7TuP/Zce+xGEoa8D5JdyqSx7j+O1/0YBTWTPNontTZHr+4/BZuKL7eYezz9x5fUEq3uPwlUHOLhY5A8KVRI3Qer7j/qxhlQhcc0PLdGWYomqe4/NcBkK+YylDxIIa0Vb6fuP592mWFK5Iy8Cdx2ueGl7j+oTe87xTOMvIVVOrB+pO4/rukriXhThLwgw8w0RqPuP1hYVnjdzpO8JSJVgjii7j9kGX6AqhBXPHOpTNRVoe4/KCJev++zk7zNO39mnqDuP4K5NIetEmq8v9oLdRKg7j/uqW2472djvC8aZTyyn+4/UYjgVD3cgLyElFH5fZ/uP88+Wn5kH3i8dF/s6HWf7j+wfYvASu6GvHSBpUian+4/iuZVHjIZhrzJZ0JW65/uP9PUCV7LnJA8P13eT2mg7j8dpU253DJ7vIcB63MUoe4/a8BnVP3slDwywTAB7aHuP1Vs1qvh62U8Yk7PNvOi7j9Cz7MvxaGIvBIaPlQnpO4/NDc78bZpk7wTzkyZiaXuPx7/GTqEXoC8rccjRhqn7j9uV3LYUNSUvO2SRJvZqO4/AIoOW2etkDyZZorZx6ruP7Tq8MEvt40826AqQuWs7j//58WcYLZlvIxEtRYyr+4/RF/zWYP2ezw2dxWZrrHuP4M9HqcfCZO8xv+RC1u07j8pHmyLuKldvOXFzbA3t+4/WbmQfPkjbLwPUsjLRLruP6r59CJDQ5K8UE7en4K97j9LjmbXbMqFvLoHynDxwO4/J86RK/yvcTyQ8KOCkcTuP7tzCuE10m08IyPjGWPI7j9jImIiBMWHvGXlXXtmzO4/1THi44YcizwzLUrsm9DuPxW7vNPRu5G8XSU+sgPV7j/SMe6cMcyQPFizMBOe2e4/s1pzboRphDy//XlVa97uP7SdjpfN34K8evPTv2vj7j+HM8uSdxqMPK3TWpmf6O4/+tnRSo97kLxmto0pB+7uP7qu3FbZw1W8+xVPuKLz7j9A9qY9DqSQvDpZ5Y1y+e4/NJOtOPTWaLxHXvvydv/uPzWKWGvi7pG8SgahMLAF7z/N3V8K1/90PNLBS5AeDO8/rJiS+vu9kbwJHtdbwhLvP7MMrzCubnM8nFKF3ZsZ7z+U/Z9cMuOOPHrQ/1+rIO8/rFkJ0Y/ghDxL0Vcu8SfvP2caTjivzWM8tecGlG0v7z9oGZJsLGtnPGmQ79wgN+8/0rXMgxiKgLz6w11VCz/vP2/6/z9drY+8fIkHSi1H7z9JqXU4rg2QvPKJDQiHT+8/pwc9poWjdDyHpPvcGFjvPw8iQCCekYK8mIPJFuNg7z+sksHVUFqOPIUy2wPmae8/S2sBrFk6hDxgtAHzIXPvPx8+tAch1YK8X5t7M5d87z/JDUc7uSqJvCmh9RRGhu8/04g6YAS2dDz2P4vnLpDvP3FynVHsxYM8g0zH+1Ga7z/wkdOPEvePvNqQpKKvpO8/fXQj4piujbzxZ44tSK/vPwggqkG8w448J1ph7hu67z8y66nDlCuEPJe6azcrxe8/7oXRMalkijxARW5bdtDvP+3jO+S6N468FL6crf3b7z+dzZFNO4l3PNiQnoHB5+8/icxgQcEFUzzxcY8rwvPvPwA4+v5CLuY/MGfHk1fzLj0BAAAAAADgv1swUVVVVdU/kEXr////z78RAfEks5nJP5/IBuV1VcW/AAAAAAAA4L93VVVVVVXVP8v9/////8+/DN2VmZmZyT+nRWdVVVXFvzDeRKMkScI/ZT1CpP//v7/K1ioohHG8P/9osEPrmbm/hdCv94KBtz/NRdF1E1K1v5/e4MPwNPc/AJDmeX/M178f6SxqeBP3PwAADcLub9e/oLX6CGDy9j8A4FET4xPXv32MEx+m0fY/AHgoOFu41r/RtMULSbH2PwB4gJBVXda/ugwvM0eR9j8AABh20ALWvyNCIhifcfY/AJCQhsqo1b/ZHqWZT1L2PwBQA1ZDT9W/xCSPqlYz9j8AQGvDN/bUvxTcnWuzFPY/AFCo/aed1L9MXMZSZPb1PwCoiTmSRdS/TyyRtWfY9T8AuLA59O3Tv96QW8u8uvU/AHCPRM6W0794GtnyYZ31PwCgvRceQNO/h1ZGElaA9T8AgEbv4unSv9Nr586XY/U/AOAwOBuU0r+Tf6fiJUf1PwCI2ozFPtK/g0UGQv8q9T8AkCcp4enRv9+9stsiD/U/APhIK22V0b/X3jRHj/P0PwD4uZpnQdG/QCjez0PY9D8AmO+U0O3Qv8ijeMA+vfQ/ABDbGKWa0L+KJeDDf6L0PwC4Y1LmR9C/NITUJAWI9D8A8IZFIuvPvwstGRvObfQ/ALAXdUpHz79UGDnT2VP0PwAwED1EpM6/WoS0RCc69D8AsOlEDQLOv/v4FUG1IPQ/APB3KaJgzb+x9D7aggf0PwCQlQQBwMy/j/5XXY/u8z8AEIlWKSDMv+lMC6DZ1fM/ABCBjReBy78rwRDAYL3zPwDQ08zJ4sq/uNp1KySl8z8AkBIuQEXKvwLQn80ijfM/APAdaHeoyb8ceoTFW3XzPwAwSGltDMm/4jatSc5d8z8AwEWmIHHIv0DUTZh5RvM/ADAUtI/Wx78ky//OXC/zPwBwYjy4PMe/SQ2hdXcY8z8AYDebmqPGv5A5PjfIAfM/AKC3VDELxr9B+JW7TuvyPwAwJHZ9c8W/0akZAgrV8j8AMMKPe9zEvyr9t6j5vvI/AADSUSxGxL+rGwx6HKnyPwAAg7yKsMO/MLUUYHKT8j8AAElrmRvDv/WhV1f6ffI/AECkkFSHwr+/Ox2bs2jyPwCgefi588G/vfWPg51T8j8AoCwlyGDBvzsIyaq3PvI/ACD3V3/OwL+2QKkrASryPwCg/kncPMC/MkHMlnkV8j8AgEu8vVe/v5v80h0gAfI/AEBAlgg3vr8LSE1J9OzxPwBA+T6YF72/aWWPUvXY8T8AoNhOZ/m7v3x+VxEjxfE/AGAvIHncur/pJst0fLHxPwCAKOfDwLm/thosDAGe8T8AwHKzRqa4v71wtnuwivE/AACsswGNt7+2vO8linfxPwAAOEXxdLa/2jFMNY1k8T8AgIdtDl61v91fJ5C5UfE/AOCh3lxItL9M0jKkDj/xPwCgak3ZM7O/2vkQcoss8T8AYMX4eSCyvzG17CgwGvE/ACBimEYOsb+vNITa+wfxPwAA0mps+q+/s2tOD+718D8AQHdKjdqtv86fKl0G5PA/AACF5Oy8q78hpSxjRNLwPwDAEkCJoam/GpjifKfA8D8AwAIzWIinv9E2xoMvr/A/AIDWZ15xpb85E6CY253wPwCAZUmKXKO/3+dSr6uM8D8AQBVk40mhv/soTi+fe/A/AIDrgsBynr8ZjzWMtWrwPwCAUlLxVZq/LPnspe5Z8D8AgIHPYj2Wv5As0c1JSfA/AACqjPsokr+prfDGxjjwPwAA+SB7MYy/qTJ5E2Uo8D8AAKpdNRmEv0hz6ickGPA/AADswgMSeL+VsRQGBAjwPwAAJHkJBGC/Gvom9x/g7z8AAJCE8+9vP3TqYcIcoe8/AAA9NUHchz8umYGwEGPvPwCAwsSjzpM/za3uPPYl7z8AAIkUwZ+bP+cTkQPI6e4/AAARztiwoT+rsct4gK7uPwDAAdBbiqU/mwydohp07j8AgNhAg1ypP7WZCoOROu4/AIBX72onrT9WmmAJ4AHuPwDAmOWYdbA/mLt35QHK7T8AIA3j9VOyPwORfAvyku0/AAA4i90utD/OXPtmrFztPwDAV4dZBrY/nd5eqiwn7T8AAGo1dtq3P80saz5u8uw/AGAcTkOruT8Ceaeibb7sPwBgDbvHeLs/bQg3bSaL7D8AIOcyE0O9PwRYXb2UWOw/AGDecTEKvz+Mn7sztSbsPwBAkSsVZ8A/P+fs7oP16z8AsJKChUfBP8GW23X9xOs/ADDKzW4mwj8oSoYMHpXrPwBQxabXA8M/LD7vxeJl6z8AEDM8w9/DP4uIyWdIN+s/AIB6aza6xD9KMB0hSwnrPwDw0Sg5k8U/fu/yhejb6j8A8BgkzWrGP6I9YDEdr+o/AJBm7PhAxz+nWNM/5oLqPwDwGvXAFcg/i3MJ70BX6j8AgPZUKenIPydLq5AqLOo/AED4Aja7yT/R8pMToAHqPwAALBzti8o/GzzbJJ/X6T8A0AFcUVvLP5CxxwUlruk/AMC8zGcpzD8vzpfyLoXpPwBgSNU19sw/dUuk7rpc6T8AwEY0vcHNPzhI553GNOk/AODPuAGMzj/mUmcvTw3pPwCQF8AJVc8/ndf/jlLm6D8AuB8SbA7QP3wAzJ/Ov+g/ANCTDrhx0D8Ow77awJnoPwBwhp5r1NA/+xcjqid06D8A0EszhzbRPwias6wAT+g/AEgjZw2Y0T9VPmXoSSroPwCAzOD/+NE/YAL0lQEG6D8AaGPXX1nSPymj4GMl4uc/AKgUCTC50j+ttdx3s77nPwBgQxByGNM/wiWXZ6qb5z8AGOxtJnfTP1cGF/IHeec/ADCv+0/V0z8ME9bbylbnPwDgL+PuMtQ/a7ZPAQAQ5j88W0KRbAJ+PJW0TQMAMOY/QV0ASOq/jTx41JQNAFDmP7el1oanf448rW9OBwBw5j9MJVRr6vxhPK4P3/7/j+Y//Q5ZTCd+fLy8xWMHALDmPwHa3EhowYq89sFcHgDQ5j8Rk0mdHD+DPD72Bev/7+Y/Uy3iGgSAfryAl4YOABDnP1J5CXFm/3s8Euln/P8v5z8kh70m4gCMPGoRgd//T+c/0gHxbpECbryQnGcPAHDnP3ScVM1x/Ge8Nch++v+P5z+DBPWewb6BPObCIP7/r+c/ZWTMKRd+cLwAyT/t/8/nPxyLewhygIC8dhom6f/v5z+u+Z1tKMCNPOijnAQAEOg/M0zlUdJ/iTyPLJMXADDoP4HzMLbp/oq8nHMzBgBQ6D+8NWVrv7+JPMaJQiAAcOg/dXsR82W/i7wEefXr/4/oP1fLPaJuAIm83wS8IgCw6D8KS+A43wB9vIobDOX/z+g/BZ//RnEAiLxDjpH8/+/oPzhwetB7gYM8x1/6HgAQ6T8DtN92kT6JPLl7RhMAMOk/dgKYS06AfzxvB+7m/0/pPy5i/9nwfo+80RI83v9v6T+6OCaWqoJwvA2KRfT/j+k/76hkkRuAh7w+Lpjd/6/pPzeTWorgQIe8ZvtJ7f/P6T8A4JvBCM4/PFGc8SAA8Ok/CluIJ6o/irwGsEURABDqP1baWJlI/3Q8+va7BwAw6j8YbSuKq76MPHkdlxAAUOo/MHl43cr+iDxILvUdAHDqP9ur2D12QY+8UjNZHACQ6j8SdsKEAr+OvEs+TyoAsOo/Xz//PAT9abzRHq7X/8/qP7RwkBLnPoK8eARR7v/v6j+j3g7gPgZqPFsNZdv/D+s/uQofOMgGWjxXyqr+/y/rPx08I3QeAXm83LqV2f9P6z+fKoZoEP95vJxlniQAcOs/Pk+G0EX/ijxAFof5/4/rP/nDwpZ3/nw8T8sE0v+v6z/EK/LuJ/9jvEVcQdL/z+s/Ieo77rf/bLzfCWP4/+/rP1wLLpcDQYG8U3a14f8P7D8ZareUZMGLPONX+vH/L+w/7cYwje/+ZLwk5L/c/0/sP3VH7LxoP4S897lU7f9v7D/s4FPwo36EPNWPmev/j+w/8ZL5jQaDczyaISUhALDsPwQOGGSO/Wi8nEaU3f/P7D9y6sccvn6OPHbE/er/7+w//oifrTm+jjwr+JoWABDtP3FauaiRfXU8HfcPDQAw7T/ax3BpkMGJPMQPeer/T+0/DP5YxTcOWLzlh9wuAHDtP0QPwU3WgH+8qoLcIQCQ7T9cXP2Uj3x0vIMCa9j/r+0/fmEhxR1/jDw5R2wpANDtP1Ox/7KeAYg89ZBE5f/v7T+JzFLG0gBuPJT2q83/D+4/0mktIECDf7zdyFLb/y/uP2QIG8rBAHs87xZC8v9P7j9Rq5SwqP9yPBFeiuj/b+4/Wb7vsXP2V7wN/54RAJDuPwHIC16NgIS8RBel3/+v7j+1IEPVBgB4PKF/EhoA0O4/klxWYPgCULzEvLoHAPDuPxHmNV1EQIW8Ao169f8P7z8Fke85MftPvMeK5R4AMO8/VRFz8qyBijyUNIL1/0/vP0PH19RBP4o8a0yp/P9v7z91eJgc9AJivEHE+eH/j+8/S+d39NF9dzx+4+DS/6/vPzGjfJoZAW+8nuR3HADQ7z+xrM5L7oFxPDHD4Pf/7+8/WodwATcFbrxuYGX0/w/wP9oKHEmtfoq8WHqG8/8v8D/gsvzDaX+XvBcN/P3/T/A/W5TLNP6/lzyCTc0DAHDwP8tW5MCDAII86Mvy+f+P8D8adTe+3/9tvGXaDAEAsPA/6ybmrn8/kbw406QBANDwP/efSHn6fYA8/f3a+v/v8D/Aa9ZwBQR3vJb9ugsAEPE/YgtthNSAjjxd9OX6/y/xP+82/WT6v5082ZrVDQBQ8T+uUBJwdwCaPJpVIQ8AcPE/7t7j4vn9jTwmVCf8/4/xP3NyO9wwAJE8WTw9EgCw8T+IAQOAeX+ZPLeeKfj/z/E/Z4yfqzL5ZbwA1Ir0/+/xP+tbp52/f5M8pIaLDAAQ8j8iW/2Ra4CfPANDhQMAMPI/M7+f68L/kzyE9rz//0/yP3IuLn7nAXY82SEp9f9v8j9hDH92u/x/PDw6kxQAkPI/K0ECPMoCcrwTY1UUALDyPwIf8jOCgJK8O1L+6//P8j/y3E84fv+IvJatuAsA8PI/xUEwUFH/hbyv4nr7/w/zP50oXohxAIG8f1+s/v8v8z8Vt7c/Xf+RvFZnpgwAUPM/vYKLIoJ/lTwh9/sRAHDzP8zVDcS6AIA8uS9Z+f+P8z9Rp7ItnT+UvELS3QQAsPM/4Th2cGt/hTxXybL1/8/zPzESvxA6Ano8GLSw6v/v8z+wUrFmbX+YPPSvMhUAEPQ/JIUZXzf4Zzwpi0cXADD0P0NR3HLmAYM8Y7SV5/9P9D9aibK4af+JPOB1BOj/b/Q/VPLCm7HAlbznwW/v/4/0P3IqOvIJQJs8BKe+5f+v9D9FfQ2/t/+UvN4nEBcA0PQ/PWrccWTAmbziPvAPAPD0PxxThQuJf5c80UvcEgAQ9T82pGZxZQRgPHonBRYAMPU/CTIjzs6/lrxMcNvs/0/1P9ehBQVyAom8qVRf7/9v9T8SZMkO5r+bPBIQ5hcAkPU/kO+vgcV+iDySPskDALD1P8AMvwoIQZ+8vBlJHQDQ9T8pRyX7KoGYvIl6uOf/7/U/BGntgLd+lLwAARcCHRgTAx4bGQsUCAQNHxYcEhoKBwwVEQkGEAUPDmD5AAAAAAAAAAAAAAAAAADRdJ4AV529KoBwUg///z4nCgAAAGQAAADoAwAAECcAAKCGAQBAQg8AgJaYAADh9QUYAAAANQAAAHEAAABr////zvv//5K///8AAAAAAAAAAP////////////////////////////////////////////////////////////////8AAQIDBAUGBwgJ/////////woLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIj////////CgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiP/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////AAECBAcDBgUAAAAAAAAAAgAAwAMAAMAEAADABQAAwAYAAMAHAADACAAAwAkAAMAKAADACwAAwAwAAMANAADADgAAwA8AAMAQAADAEQAAwBIAAMATAADAFAAAwBUAAMAWAADAFwAAwBgAAMAZAADAGgAAwBsAAMAcAADAHQAAwB4AAMAfAADAAAAAswEAAMMCAADDAwAAwwQAAMMFAADDBgAAwwcAAMMIAADDCQAAwwoAAMMLAADDDAAAww0AANMOAADDDwAAwwAADLsBAAzDAgAMwwMADMMEAAzbAAAAAByqAABbAgAAzwQAANAEAABOU3QzX18yMTdiYWRfZnVuY3Rpb25fY2FsbEUA4OoAAACqAAD46wAAAAAAAHysAADvBAAA8AQAAPEEAADyBAAA8wQAAPQEAAD1BAAA9gQAAPcEAAD4BAAA+QQAAPoEAAD7BAAA/AQAAAgAAAAAAAAAtKwAAP0EAAD+BAAA+P////j///+0rAAA/wQAAAAFAAB0qgAAiKoAAAQAAAAAAAAA/KwAAAEFAAACBQAA/P////z////8rAAAAwUAAAQFAACkqgAAuKoAAAwAAAAAAAAAlK0AAAUFAAAGBQAABAAAAPj///+UrQAABwUAAAgFAAD0////9P///5StAAAJBQAACgUAANSqAAAgrQAANK0AAEitAABcrQAA/KoAAOiqAAAAAAAAMK4AAAsFAAAMBQAADQUAAA4FAAAPBQAAEAUAABEFAAASBQAAEwUAABQFAAAVBQAAFgUAABcFAAAYBQAACAAAAAAAAABorgAAGQUAABoFAAD4////+P///2iuAAAbBQAAHAUAAGyrAACAqwAABAAAAAAAAACwrgAAHQUAAB4FAAD8/////P///7CuAAAfBQAAIAUAAJyrAACwqwAAAAAAAAyvAAAhBQAAIgUAAPEEAADyBAAAIwUAACQFAAD1BAAA9gQAAPcEAAAlBQAA+QQAACYFAAD7BAAAJwUAAAAAAAA8rAAAKAUAACkFAABOU3QzX18yOWJhc2ljX2lvc0ljTlNfMTFjaGFyX3RyYWl0c0ljRUVFRQAAAODqAAAQrAAAILIAAE5TdDNfXzIxNWJhc2ljX3N0cmVhbWJ1ZkljTlNfMTFjaGFyX3RyYWl0c0ljRUVFRQAAAAC46gAASKwAAE5TdDNfXzIxM2Jhc2ljX2lzdHJlYW1JY05TXzExY2hhcl90cmFpdHNJY0VFRUUAADzrAACErAAAAAAAAAEAAAA8rAAAA/T//05TdDNfXzIxM2Jhc2ljX29zdHJlYW1JY05TXzExY2hhcl90cmFpdHNJY0VFRUUAADzrAADMrAAAAAAAAAEAAAA8rAAAA/T//wwAAAAAAAAAtKwAAP0EAAD+BAAA9P////T///+0rAAA/wQAAAAFAAAEAAAAAAAAAPysAAABBQAAAgUAAPz////8/////KwAAAMFAAAEBQAATlN0M19fMjE0YmFzaWNfaW9zdHJlYW1JY05TXzExY2hhcl90cmFpdHNJY0VFRUUAPOsAAGStAAADAAAAAgAAALSsAAACAAAA/KwAAAIIAAAAAAAA8K0AACoFAAArBQAATlN0M19fMjliYXNpY19pb3NJd05TXzExY2hhcl90cmFpdHNJd0VFRUUAAADg6gAAxK0AACCyAABOU3QzX18yMTViYXNpY19zdHJlYW1idWZJd05TXzExY2hhcl90cmFpdHNJd0VFRUUAAAAAuOoAAPytAABOU3QzX18yMTNiYXNpY19pc3RyZWFtSXdOU18xMWNoYXJfdHJhaXRzSXdFRUVFAAA86wAAOK4AAAAAAAABAAAA8K0AAAP0//9OU3QzX18yMTNiYXNpY19vc3RyZWFtSXdOU18xMWNoYXJfdHJhaXRzSXdFRUVFAAA86wAAgK4AAAAAAAABAAAA8K0AAAP0//9OU3QzX18yMTViYXNpY19zdHJpbmdidWZJY05TXzExY2hhcl90cmFpdHNJY0VFTlNfOWFsbG9jYXRvckljRUVFRQAAAODqAADIrgAAfKwAAEAAAAAAAAAAULAAACwFAAAtBQAAOAAAAPj///9QsAAALgUAAC8FAADA////wP///1CwAAAwBQAAMQUAACSvAACIrwAAxK8AANivAADsrwAAALAAALCvAACcrwAATK8AADivAABAAAAAAAAAAJStAAAFBQAABgUAADgAAAD4////lK0AAAcFAAAIBQAAwP///8D///+UrQAACQUAAAoFAABAAAAAAAAAALSsAAD9BAAA/gQAAMD////A////tKwAAP8EAAAABQAAOAAAAAAAAAD8rAAAAQUAAAIFAADI////yP////ysAAADBQAABAUAAE5TdDNfXzIxOGJhc2ljX3N0cmluZ3N0cmVhbUljTlNfMTFjaGFyX3RyYWl0c0ljRUVOU185YWxsb2NhdG9ySWNFRUVFAAAAAODqAAAIsAAAlK0AADgAAAAAAAAABLEAADIFAAAzBQAAyP///8j///8EsQAANAUAADUFAABosAAAoLAAALSwAAB8sAAAOAAAAAAAAAD8rAAAAQUAAAIFAADI////yP////ysAAADBQAABAUAAE5TdDNfXzIxOWJhc2ljX29zdHJpbmdzdHJlYW1JY05TXzExY2hhcl90cmFpdHNJY0VFTlNfOWFsbG9jYXRvckljRUVFRQAAAODqAAC8sAAA/KwAADwAAAAAAAAAuLEAADYFAAA3BQAAxP///8T///+4sQAAOAUAADkFAAAcsQAAVLEAAGixAAAwsQAAPAAAAAAAAAC0rAAA/QQAAP4EAADE////xP///7SsAAD/BAAAAAUAAE5TdDNfXzIxOWJhc2ljX2lzdHJpbmdzdHJlYW1JY05TXzExY2hhcl90cmFpdHNJY0VFTlNfOWFsbG9jYXRvckljRUVFRQAAAODqAABwsQAAtKwAAAAAAABwsgAARAUAAEUFAABGBQAARwUAAEgFAABJBQAASgUAAAAAAABEsgAAPQUAAEsFAADcAgAAAAAAACCyAABMBQAATQUAAE5TdDNfXzI4aW9zX2Jhc2VFAAAAuOoAAAyyAABOU3QzX18yOGlvc19iYXNlN2ZhaWx1cmVFAAAA4OoAACiyAAC85wAATlN0M19fMjE5X19pb3N0cmVhbV9jYXRlZ29yeUUAAADg6gAAULIAAAToAAAA+gAAkPoAAAAAAADcsgAA7wQAAFgFAABZBQAA8gQAAPMEAAD0BAAA9QQAAPYEAAD3BAAAWgUAAFsFAABcBQAA+wQAAPwEAABOU3QzX18yMTBfX3N0ZGluYnVmSWNFRQDg6gAAxLIAAHysAAAAAAAARLMAAO8EAABdBQAAXgUAAPIEAADzBAAA9AQAAF8FAAD2BAAA9wQAAPgEAAD5BAAA+gQAAGAFAABhBQAATlN0M19fMjExX19zdGRvdXRidWZJY0VFAAAAAODqAAAoswAAfKwAAAAAAACoswAACwUAAGIFAABjBQAADgUAAA8FAAAQBQAAEQUAABIFAAATBQAAZAUAAGUFAABmBQAAFwUAABgFAABOU3QzX18yMTBfX3N0ZGluYnVmSXdFRQDg6gAAkLMAADCuAAAAAAAAELQAAAsFAABnBQAAaAUAAA4FAAAPBQAAEAUAAGkFAAASBQAAEwUAABQFAAAVBQAAFgUAAGoFAABrBQAATlN0M19fMjExX19zdGRvdXRidWZJd0VFAAAAAODqAAD0swAAMK4AAAAAAADeEgSVAAAAAP///////////////yC0AAAUAAAAQy5VVEYtOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADS0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATENfQ1RZUEUAAAAATENfTlVNRVJJQwAATENfVElNRQAAAAAATENfQ09MTEFURQAATENfTU9ORVRBUlkATENfTUVTU0FHRVMAAAAAAAAAAAAZAAoAGRkZAAAAAAUAAAAAAAAJAAAAAAsAAAAAAAAAABkAEQoZGRkDCgcAAQAJCxgAAAkGCwAACwAGGQAAABkZGQAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAZAAoNGRkZAA0AAAIACQ4AAAAJAA4AAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAEwAAAAATAAAAAAkMAAAAAAAMAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAA8AAAAEDwAAAAAJEAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASAAAAAAAAAAAAAAARAAAAABEAAAAACRIAAAAAABIAABIAABoAAAAaGhoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGgAAABoaGgAAAAAAAAkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAABcAAAAAFwAAAAAJFAAAAAAAFAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWAAAAAAAAAAAAAAAVAAAAABUAAAAACRYAAAAAABYAABYAADAxMjM0NTY3ODlBQkNERUbQuAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAA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FQYAABYGAAAXBgAAAAAAAITNAAAYBgAAGQYAABcGAAAaBgAAGwYAABwGAAAdBgAAHgYAAB8GAAAgBgAAIQYAAAAAAAAAAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABQIAAAUAAAAFAAAABQAAAAUAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAADAgAAggAAAIIAAACCAAAAggAAAIIAAACCAAAAggAAAIIAAACCAAAAggAAAIIAAACCAAAAggAAAIIAAACCAAAAQgEAAEIBAABCAQAAQgEAAEIBAABCAQAAQgEAAEIBAABCAQAAQgEAAIIAAACCAAAAggAAAIIAAACCAAAAggAAAIIAAAAqAQAAKgEAACoBAAAqAQAAKgEAACoBAAAqAAAAKgAAACoAAAAqAAAAKgAAACoAAAAqAAAAKgAAACoAAAAqAAAAKgAAACoAAAAqAAAAKgAAACoAAAAqAAAAKgAAACoAAAAqAAAAKgAAAIIAAACCAAAAggAAAIIAAACCAAAAggAAADIBAAAyAQAAMgEAADIBAAAyAQAAMgEAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAMgAAADIAAAAyAAAAggAAAIIAAACCAAAAggAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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cm9rZW4gcGlwZQBJL08gZXJyb3IATm8gc3VjaCBkZXZpY2Ugb3IgYWRkcmVzcwBCbG9jayBkZXZpY2UgcmVxdWlyZWQATm8gc3VjaCBkZXZpY2UATm90IGEgZGlyZWN0b3J5AElzIGEgZGlyZWN0b3J5AFRleHQgZmlsZSBidXN5AEV4ZWMgZm9ybWF0IGVycm9yAEludmFsaWQgYXJndW1lbnQAQXJndW1lbnQgbGlzdCB0b28gbG9uZwBTeW1ib2xpYyBsaW5rIGxvb3AARmlsZW5hbWUgdG9vIGxvbmcAVG9vIG1hbnkgb3BlbiBmaWxlcyBpbiBzeXN0ZW0ATm8gZmlsZSBkZXNjcmlwdG9ycyBhdmFpbGFibGUAQmFkIGZpbGUgZGVzY3JpcHRvcgBObyBjaGlsZCBwcm9jZXNzAEJhZCBhZGRyZXNzAEZpbGUgdG9vIGxhcmdlAFRvbyBtYW55IGxpbmtzAE5vIGxvY2tzIGF2YWlsYWJsZQBSZXNvdXJjZSBkZWFkbG9jayB3b3VsZCBvY2N1cgBTdGF0ZSBub3QgcmVjb3ZlcmFibGUAUHJldmlvdXMgb3duZXIgZGllZABPcGVyYXRpb24gY2FuY2VsZWQARnVuY3Rpb24gbm90IGltcGxlbWVudGVkAE5vIG1lc3NhZ2Ugb2YgZGVzaXJlZCB0eXBlAElkZW50aWZpZXIgcmVtb3ZlZABEZXZpY2Ugbm90IGEgc3RyZWFtAE5vIGRhdGEgYXZhaWxhYmxlAERldmljZSB0aW1lb3V0AE91dCBvZiBzdHJlYW1zIHJlc291cmNlcwBMaW5rIGhhcyBiZWVuIHNldmVyZWQAUHJvdG9jb2wgZXJyb3IAQmFkIG1lc3NhZ2UARmlsZSBkZXNjcmlwdG9yIGluIGJhZCBzdGF0ZQBOb3QgYSBzb2NrZXQARGVzdGluYXRpb24gYWRkcmVzcyByZXF1aXJlZABNZXNzYWdlIHRvbyBsYXJnZQBQcm90b2NvbCB3cm9uZyB0eXBlIGZvciBzb2NrZXQAUHJvdG9jb2wgbm90IGF2YWlsYWJsZQBQcm90b2NvbCBub3Qgc3VwcG9ydGVkAFNvY2tldCB0eXBlIG5vdCBzdXBwb3J0ZWQATm90IHN1cHBvcnRlZABQcm90b2NvbCBmYW1pbHkgbm90IHN1cHBvcnRlZABBZGRyZXNzIGZhbWlseSBub3Qgc3VwcG9ydGVkIGJ5IHByb3RvY29sAEFkZHJlc3Mgbm90IGF2YWlsYWJsZQBOZXR3b3JrIGlzIGRvd24ATmV0d29yayB1bnJlYWNoYWJsZQBDb25uZWN0aW9uIHJlc2V0IGJ5IG5ldHdvcmsAQ29ubmVjdGlvbiBhYm9ydGVkAE5vIGJ1ZmZlciBzcGFjZSBhdmFpbGFibGUAU29ja2V0IGlzIGNvbm5lY3RlZABTb2NrZXQgbm90IGNvbm5lY3RlZABDYW5ub3Qgc2VuZCBhZnRlciBzb2NrZXQgc2h1dGRvd24AT3BlcmF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3MAT3BlcmF0aW9uIGluIHByb2dyZXNzAFN0YWxlIGZpbGUgaGFuZGxlAFJlbW90ZSBJL08gZXJyb3IAUXVvdGEgZXhjZWVkZWQATm8gbWVkaXVtIGZvdW5kAFdyb25nIG1lZGl1bSB0eXBlAE11bHRpaG9wIGF0dGVtcHRlZAAAAAAAAAAAAAAAAAClAlsA8AG1BYwFJQGDBh0DlAT/AMcDMQMLBrwBjwF/A8oEKwDaBq8AQgNOA9wBDgQVAKEGDQGUAgsCOAZkArwC/wJdA+cECwfPAssF7wXbBeECHgZFAoUAggJsA28E8QDzAxgF2QDaA0wGVAJ7AZ0DvQQAAFEAFQK7ALMDbQD/AYUELwX5BDgAZQFGAZ8AtwaoAXMCUwEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAhBAAAAAAAAAAALwIAAAAAAAAAAAAAAAAAAAAAAAAAADUERwRWBAAAAAAAAAAAAAAAAAAAAACgBAAAAAAAAAAAAAAAAAAAAAAAAEYFYAVuBWEGAADPAQAAAAAAAAAAyQbpBvkGAAAAADAwMDEwMjAzMDQwNTA2MDcwODA5MTAxMTEyMTMxNDE1MTYxNzE4MTkyMDIxMjIyMzI0MjUyNjI3MjgyOTMwMzEzMjMzMzQzNTM2MzczODM5NDA0MTQyNDM0NDQ1NDY0NzQ4NDk1MDUxNTI1MzU0NTU1NjU3NTg1OTYwNjE2MjYzNjQ2NTY2Njc2ODY5NzA3MTcyNzM3NDc1NzY3Nzc4Nzk4MDgxODI4Mzg0ODU4Njg3ODg4OTkwOTE5MjkzOTQ5NTk2OTc5ODk5AAAAAAAAAAAAAAAACgAAAGQAAADoAwAAECcAAKCGAQBAQg8AgJaYAADh9QUAypo7AAAAADToAABEBQAAGwcAABwHAABHBQAASAUAAEkFAAAdBwAAAAAAAGToAABEBQAAHgcAAB8HAAAgBwAASAUAAEkFAAAhBwAAAAAAALznAAAaBwAAIgcAANwCAABOU3QzX18yMTJzeXN0ZW1fZXJyb3JFAADg6gAApOcAAFjtAABOU3QzX18yMTRlcnJvcl9jYXRlZ29yeUUAAAAAuOoAAMjnAABOU3QzX18yMTJfX2RvX21lc3NhZ2VFAADg6gAA7OcAAOTnAABOU3QzX18yMjRfX2dlbmVyaWNfZXJyb3JfY2F0ZWdvcnlFAADg6gAAEOgAAAToAABOU3QzX18yMjNfX3N5c3RlbV9lcnJvcl9jYXRlZ29yeUUAAADg6gAAQOgAAAToAABOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQAAAADg6gAAcOgAAIjtAABOMTBfX2N4eGFiaXYxMTdfX2NsYXNzX3R5cGVfaW5mb0UAAADg6gAAoOgAAJToAABOMTBfX2N4eGFiaXYxMTdfX3BiYXNlX3R5cGVfaW5mb0UAAADg6gAA0OgAAJToAABOMTBfX2N4eGFiaXYxMTlfX3BvaW50ZXJfdHlwZV9pbmZvRQDg6gAAAOkAAPToAABOMTBfX2N4eGFiaXYxMjBfX2Z1bmN0aW9uX3R5cGVfaW5mb0UAAAAA4OoAADDpAACU6AAATjEwX19jeHhhYml2MTI5X19wb2ludGVyX3RvX21lbWJlcl90eXBlX2luZm9FAAAA4OoAAGTpAAD06AAAAAAAAOTpAAAlBwAAJgcAACcHAAAoBwAAKQcAAE4xMF9fY3h4YWJpdjEyM19fZnVuZGFtZW50YWxfdHlwZV9pbmZvRQDg6gAAvOkAAJToAAB2AAAAqOkAAPDpAABEbgAAqOkAAPzpAABiAAAAqOkAAAjqAABjAAAAqOkAABTqAABoAAAAqOkAACDqAABhAAAAqOkAACzqAABzAAAAqOkAADjqAAB0AAAAqOkAAETqAABpAAAAqOkAAFDqAABqAAAAqOkAAFzqAABsAAAAqOkAAGjqAABtAAAAqOkAAHTqAAB4AAAAqOkAAIDqAAB5AAAAqOkAAIzqAABmAAAAqOkAAJjqAABkAAAAqOkAAKTqAAAAAAAAxOgAACUHAAAqBwAAJwcAACgHAAArBwAALAcAAC0HAAAuBwAAAAAAACjrAAAlBwAALwcAACcHAAAoBwAAKwcAADAHAAAxBwAAMgcAAE4xMF9fY3h4YWJpdjEyMF9fc2lfY2xhc3NfdHlwZV9pbmZvRQAAAADg6gAAAOsAAMToAAAAAAAAhOsAACUHAAAzBwAAJwcAACgHAAArBwAANAcAADUHAAA2BwAATjEwX19jeHhhYml2MTIxX192bWlfY2xhc3NfdHlwZV9pbmZvRQAAAODqAABc6wAAxOgAAAAAAAAk6QAAJQcAADcHAAAnBwAAKAcAADgHAAAAAAAAKOwAAA8AAAA5BwAAOgcAAAAAAAA07AAADwAAADsHAAA8BwAAAAAAAPjrAAAPAAAAPQcAAD4HAABTdDlleGNlcHRpb24AAAAAuOoAAOjrAABTdDIwYmFkX2FycmF5X25ld19sZW5ndGgAU3Q5YmFkX2FsbG9jAAAA4OoAABnsAAD46wAA4OoAAADsAAAo7AAAAAAAAIzsAAAJAgAAPwcAANICAAAAAAAAWO0AAOMCAABABwAA3AIAAFN0MTJkb21haW5fZXJyb3IAU3QxMWxvZ2ljX2Vycm9yAAAAAODqAAB57AAA+OsAAODqAABo7AAAjOwAAAAAAADQ7AAACQIAAEEHAADSAgAAU3QxNmludmFsaWRfYXJndW1lbnQAAAAA4OoAALjsAACM7AAAAAAAAATtAAAJAgAAQgcAANICAABTdDEybGVuZ3RoX2Vycm9yAAAAAODqAADw7AAAjOwAAAAAAAA47QAACQIAAEMHAADSAgAAU3QxMm91dF9vZl9yYW5nZQAAAADg6gAAJO0AAIzsAABTdDEzcnVudGltZV9lcnJvcgAAAODqAABE7QAA+OsAAAAAAACc7QAA7QQAAEQHAABFBwAAU3Q5dHlwZV9pbmZvAAAAALjqAAB47QAAU3Q4YmFkX2Nhc3QA4OoAAJDtAAD46wAAAEGo2wMLiBsAAAAA2O4AADYDAAA3AwAAOAMAADkDAAA6AwAAOwMAADwDAAA9AwAAPgMAAD8DAABAAwAAQQMAAEIDAABDAwAARAMAAEUDAABGAwAARwMAAEgDAABJAwAASgMAAEsDAABMAwAATQMAAE4DAABPAwAAUAMAAFEDAABSAwAAUwMAAFQDAABVAwAAVgMAAFcDAABYAwAAWQMAAFoDAABbAwAAXAMAAF0DAABeAwAAXwMAAGADAABhAwAAYgMAAGMDAABkAwAAZQMAAGYDAABnAwAAaAMAAGkDAABqAwAAawMAAGwDAABtAwAAbgMAAG8DAABwAwAAcQMAAHIDAABzAwAAdAMAAHUDAAB2AwAA4OoAABR5AAA47QAA4OoAADh5AAAgZwAA4OoAAFl5AACM7AAA4OoAAH55AACg8QAAAAAAALTuAAAJAgAAdwMAANICAAAAAAAAzO4AAAkCAAB4AwAA0gIAAAAAAAAk7wAAeQMAAHoDAAB7AwAAfAMAAODqAACfeQAA9F0AAODqAAD1eQAAjOwAAAAAAACE7wAAgwMAAIQDAACFAwAAhgMAAIcDAACIAwAAiQMAAIoDAACLAwAAjAMAAI0DAACOAwAAjwMAAODqAAAregAAIGcAAODqAAAVegAAeO8AAODqAABZegAAjOwAAAAAAACQ7wAACQIAAJADAADSAgAAAAAAAOzvAACDAwAAkQMAAIUDAACSAwAAkwMAAIgDAACJAwAAlAMAAIsDAACMAwAAlQMAAI4DAACPAwAA4OoAAH56AAB47wAAAAAAADTwAACDAwAAlgMAAIUDAACXAwAAmAMAAIgDAACJAwAAmQMAAIsDAACMAwAAmgMAAI4DAACPAwAA4OoAAJR6AAB47wAAAAAAADDvAAAJAgAAmwMAANICAAAAAAAAwO4AAJwDAACdAwAAngMAAJ8DAACgAwAAiAMAAIkDAAChAwAAiwMAAIwDAACiAwAAjgMAAI8DAACjAwAA4OoAALB6AAA47QAAAAAAAKDxAACkAwAApQMAAKYDAACnAwAAqAMAAKkDAAA8AwAAqgMAAKsDAAA/AwAAQAMAAEEDAABCAwAAQwMAAEQDAABFAwAARgMAAEcDAABIAwAASQMAAEoDAABLAwAATAMAAE0DAABOAwAATwMAAFADAABRAwAAUgMAAFMDAABUAwAAVQMAAFYDAABXAwAAWAMAAFkDAABaAwAAWwMAAFwDAABdAwAAXgMAAF8DAABgAwAAYQMAAGIDAABjAwAAZAMAAGUDAACsAwAAZwMAAODqAADPegAAmOwAAODqAAD1egAAjOwAAODqAAANewAAjOwAAODqAAAqewAAjOwAALjqAABLewAAAAAAAJTwAAAJAgAArQMAANICAAAAAAAAcPEAAAkCAACuAwAA0gIAAAAAAAB88QAACQIAAK8DAADSAgAAAAAAAIjxAAAJAgAAsAMAANICAAAAAAAAlPEAAAkCAACxAwAA0gIAAODqAABiewAAmOwAAAAAAABM8gAAgwMAALIDAADQAgAA0AIAANACAACIAwAAiQMAALMDAACLAwAAjAMAALQDAAC46gAAhHsAAAAAAAAM8gAACQIAALUDAADSAgAA4OoAAJZ7AACM7AAAAAAAAGjyAAAJAgAA2gMAANICAAAAAAAAlGYAANsDAADcAwAA3QMAAN4DAADfAwAAiAMAAIkDAADgAwAAiwMAAIwDAADhAwAAAAAAAMhlAADiAwAA4wMAAOQDAADlAwAA5gMAAIgDAACJAwAA5wMAAIsDAACMAwAA6AMAAAAAAACkZAAA6QMAAOoDAADrAwAA7AMAAO0DAACIAwAAiQMAAO4DAACLAwAAjAMAALQDAAAAAAAAVGUAAO8DAADwAwAA8QMAAPIDAADzAwAAiAMAAIkDAAD0AwAAiwMAAIwDAAD1AwAAAAAAAPRoAAD2AwAA9wMAAPgDAAD5AwAA+gMAAIgDAACJAwAAswMAAIsDAACMAwAAtAMAAAAAAAB4aQAA+wMAAPwDAAD9AwAA/gMAAP8DAACIAwAAiQMAAAAEAACLAwAAjAMAALQDAAAAAAAA+GkAAAEEAAACBAAAAwQAAAQEAAAFBAAAiAMAAIkDAAAGBAAABwQAAAgEAAC0AwAACQQAAAoEAAALBAAADAQAAODqAADHewAAjOwAAAAAAAAE9AAACQIAAA0EAADSAgAAAAAAAHhqAAAOBAAADwQAABAEAAARBAAAEgQAAIgDAACJAwAAEwQAAIsDAACMAwAAtAMAABQEAAAAAAAAlPQAABUEAAAWBAAAFwQAABgEAAAZBAAAiAMAAIkDAAAaBAAAiwMAAIwDAAC0AwAAGwQAAODqAAD3ewAATPIAAAAAAADg9AAAHAQAAB0EAAAeBAAAHwQAACAEAACIAwAAIQQAACIEAACLAwAAjAMAACMEAAAkBAAAJQQAACYEAADg6gAACHwAAEzyAAAAAAAALPUAACcEAAAoBAAAKQQAACoEAAArBAAAiAMAACwEAAAtBAAAiwMAAIwDAAAuBAAALwQAADAEAAAxBAAA4OoAACJ8AABM8gAAAAAAAHj1AAAyBAAAMwQAADQEAAA1BAAANgQAAIgDAAA3BAAAOAQAAIsDAACMAwAAtAMAADkEAAA6BAAAOwQAAODqAABEfAAATPIAAAAAAAC49QAAPAQAAD0EAAA+BAAAPwQAAEAEAACIAwAAiQMAALMDAACLAwAAjAMAALQDAADg6gAAXnwAAEzyAAAAAAAA+PUAAEEEAABCBAAAQwQAAEQEAABFBAAAiAMAAIkDAABGBAAAiwMAAIwDAABHBAAA4OoAAHV8AABM8gAAAAAAADj2AABIBAAASQQAAEoEAABLBAAATAQAAIgDAACJAwAATQQAAIsDAACMAwAATgQAAODqAACHfAAATPIAAAAAAADg9gAATwQAAFAEAABRBAAAUgQAAFMEAACIAwAAiQMAAFQEAACLAwAAVQQAALQDAABWBAAAVwQAAFgEAABZBAAAWgQAAAAAAADU9gAAWwQAAFwEAABdBAAAXgQAAF8EAACIAwAAiQMAAGAEAACLAwAAYQQAALQDAABiBAAAYwQAAGQEAABlBAAAZgQAAODqAAChfAAATPIAAODqAAC6fAAATPIAAAAAAABY9wAAZwQAAGgEAABpBAAAagQAAGsEAABsBAAAbQQAAG4EAABvBAAAcAQAAHEEAAByBAAAcwQAAHQEAAB1BAAAdgQAAHcEAAB4BAAAeQQAAHoEAAB7BAAAfAQAAODqAADUfAAAjOwAALjqAAD2fAAAAAAAAEz3AAAJAgAAfQQAANICAADg6gAAD30AADjtAAAAAAAAdPcAAAkCAAB+BAAA0gIAAAAAAACs9wAAfwQAAIAEAACBBAAAggQAALjqAAAyfQAAAAAAABT4AABnBAAAgwQAAGkEAACEBAAAhQQAAIYEAACHBAAAbgQAAG8EAABwBAAAcQQAAHIEAABzBAAAdAQAAIgEAACJBAAAdwQAAHgEAAB5BAAAegQAAIoEAAB8BAAA4OoAAEN9AABY9wAAAAAAAFz4AACLBAAAjAQAAI0EAACOBAAAjwQAAJAEAACRBAAAkgQAAJMEAACUBAAAlQQAAJYEAACXBAAAuOoAAF59AAAAAAAAfPgAACsDAACYBAAAmQQAAJoEAADg6gAAbn0AACR2AAAAAAAArPgAACsDAACbBAAAnAQAAJ0EAACeBAAAnwQAAKAEAADg6gAAgX0AACR2AADg6gAAFX4AAEhcAADg6gAA3X0AALj4AAA86wAAk30AAAAAAAADAAAA8FsAAAIAAADE+AAAAgQAAHRcAAACKAAAAAAAAND4AAC/BAAAwAQAAKEEAADBBAAA/P///9D4AADCBAAAwwQAANwCAADY////0PgAAMQEAADFBAAAAAAAAMT4AADGBAAAxwQAANwCAAAAAAAAuPgAAMYEAADIBAAA3AIAAAAAAAAFAAAAAAAAAAAAAADLBAAAAAAAAAAAAAAAAAAAAAAAAAAAAADMBAAAzQQAAJgDAQAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAA//////////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABg+QAAsBpRAMyxAAAAAAAACQAAAAAAAAAAAAAAywQAAAAAAAAAAAAAAAAAAAAAAABOBQAAAAAAAM0EAABIBgEAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAATwUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAzAQAAFAFAABYCgEAAAQAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAP////8KAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkPoAAFDnAAB05wAAIwcAAABBsPYDC8oJKGRvdWJsZSogYXJyLCBpbnQgdmVjU2l6ZSk8Ojo+eyB2YXIgcmVzdWx0ID0gW107IGNvbnN0IGJpdCA9IDg7IGZvciAobGV0IGkgPSAwOyBpIDwgdmVjU2l6ZTsgaSsrKSB7IHZhciByZWFsID0gZ2V0VmFsdWUoYXJyICsgaSoyICpiaXQsICJkb3VibGUiKTsgdmFyIGltYWcgPSBnZXRWYWx1ZShhcnIgKyBpKjIgKmJpdCArIGJpdCwgImRvdWJsZSIpOyByZXN1bHQucHVzaCh7IHJlYWwsIGltYWcgfSk7IH0gcmV0dXJuIEVtdmFsLnRvSGFuZGxlKHJlc3VsdCk7IH0AKGRvdWJsZSByZWFsLCBkb3VibGUgaW1hZyk8Ojo+eyB2YXIgcmVzdWx0ID0geyByZWFsOiByZWFsLCBpbWFnOiBpbWFnIH07IHJldHVybiBFbXZhbC50b0hhbmRsZShyZXN1bHQpOyB9AChkb3VibGUqIGFyciwgaW50IHZlY1NpemUpPDo6PnsgdmFyIHNpemUgPSBNYXRoLnNxcnQodmVjU2l6ZSk7IHZhciByZXN1bHQgPSBbXTsgY29uc3QgYml0ID0gODsgZm9yIChsZXQgeSA9IDA7IHkgPCBzaXplOyB5KyspIHsgcmVzdWx0W3ldID0gW107IGZvciAobGV0IHggPSAwOyB4IDwgc2l6ZTsgeCsrKSB7IHZhciBwID0geSpzaXplK3g7IHJlc3VsdFt5XS5wdXNoKHsgcmVhbDogZ2V0VmFsdWUoYXJyICsgcCoyICpiaXQsICJkb3VibGUiKSwgaW1hZzogZ2V0VmFsdWUoYXJyICsgcCoyICpiaXQgKyBiaXQsICJkb3VibGUiKSB9KTsgfSB9IHJldHVybiBFbXZhbC50b0hhbmRsZShyZXN1bHQpOyB9AChpbnQqIGFyciwgaW50IHZlY1NpemUpPDo6PnsgdmFyIHJlc3VsdCA9IFtdOyBjb25zdCBieXRlID0gNDsgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZWNTaXplOyBpKyspIHsgcmVzdWx0LnB1c2goZ2V0VmFsdWUoYXJyICsgaSAqYnl0ZSwgImkzMiIpKTsgfSByZXR1cm4gRW12YWwudG9IYW5kbGUocmVzdWx0KTsgfQAoaW50cHRyX3QgZnVuY1B0ciwgaW50IG4wLCBpbnQgbjEpPDo6PnsgdmFyIHJlID0gTW9kdWxlWydkeW5DYWxsJ10oJ2lpaScsIGZ1bmNQdHIsIFtuMCwgbjFdKTsgcmV0dXJuIHJlOyB9AChpbnRwdHJfdCBmdW5jUHRyLCBpbnQqIGFyciwgaW50IHNpemUpPDo6PnsgdmFyIHJlID0gTW9kdWxlWydkeW5DYWxsJ10oJ2lpaScsIGZ1bmNQdHIsIFthcnIsIHNpemVdKTsgcmV0dXJuIHJlOyB9AChpbnRwdHJfdCBmdW5jUHRyLCBpbnQgbnVtLCBkb3VibGUqIGNvbXBsZXhBcnJQdHIpPDo6PnsgTW9kdWxlWydkeW5DYWxsJ10oJ3ZpaScsIGZ1bmNQdHIsIFtudW0sIGNvbXBsZXhBcnJQdHJdKTsgfQA=';\n  if (!isDataURI(wasmBinaryFile)) {\n    wasmBinaryFile = locateFile(wasmBinaryFile);\n  }\n\nfunction getBinary(file) {\n  try {\n    if (file == wasmBinaryFile && wasmBinary) {\n      return new Uint8Array(wasmBinary);\n    }\n    var binary = tryParseAsDataURI(file);\n    if (binary) {\n      return binary;\n    }\n    if (readBinary) {\n      return readBinary(file);\n    }\n    throw \"both async and sync fetching of the wasm failed\";\n  }\n  catch (err) {\n    abort(err);\n  }\n}\n\nfunction getBinaryPromise() {\n  // If we don't have the binary yet, try to to load it asynchronously.\n  // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.\n  // See https://github.com/github/fetch/pull/92#issuecomment-140665932\n  // Cordova or Electron apps are typically loaded from a file:// url.\n  // So use fetch if it is available and the url is not a file, otherwise fall back to XHR.\n  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\n    if (typeof fetch == 'function'\n      && !isFileURI(wasmBinaryFile)\n    ) {\n      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {\n        if (!response['ok']) {\n          throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n        }\n        return response['arrayBuffer']();\n      }).catch(function () {\n          return getBinary(wasmBinaryFile);\n      });\n    }\n    else {\n      if (readAsync) {\n        // fetch is not available or url is file => try XHR (readAsync uses XHR internally)\n        return new Promise(function(resolve, reject) {\n          readAsync(wasmBinaryFile, function(response) { resolve(new Uint8Array(/** @type{!ArrayBuffer} */(response))) }, reject)\n        });\n      }\n    }\n  }\n\n  // Otherwise, getBinary should be able to get it synchronously\n  return Promise.resolve().then(function() { return getBinary(wasmBinaryFile); });\n}\n\n// Create the wasm instance.\n// Receives the wasm imports, returns the exports.\nfunction createWasm() {\n  // prepare imports\n  var info = {\n    'env': asmLibraryArg,\n    'wasi_snapshot_preview1': asmLibraryArg,\n  };\n  // Load the wasm module and create an instance of using native support in the JS engine.\n  // handle a generated wasm instance, receiving its exports and\n  // performing other necessary setup\n  /** @param {WebAssembly.Module=} module*/\n  function receiveInstance(instance, module) {\n    var exports = instance.exports;\n\n    Module['asm'] = exports;\n\n    wasmMemory = Module['asm']['memory'];\n    updateGlobalBufferAndViews(wasmMemory.buffer);\n\n    wasmTable = Module['asm']['__indirect_function_table'];\n\n    addOnInit(Module['asm']['__wasm_call_ctors']);\n\n    removeRunDependency('wasm-instantiate');\n\n  }\n  // we can't run yet (except in a pthread, where we have a custom sync instantiator)\n  addRunDependency('wasm-instantiate');\n\n  // Prefer streaming instantiation if available.\n  function receiveInstantiationResult(result) {\n    // 'result' is a ResultObject object which has both the module and instance.\n    // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\n    // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.\n    receiveInstance(result['instance']);\n  }\n\n  function instantiateArrayBuffer(receiver) {\n    return getBinaryPromise().then(function(binary) {\n      return WebAssembly.instantiate(binary, info);\n    }).then(function (instance) {\n      return instance;\n    }).then(receiver, function(reason) {\n      err('failed to asynchronously prepare wasm: ' + reason);\n\n      abort(reason);\n    });\n  }\n\n  function instantiateAsync() {\n    if (!wasmBinary &&\n        typeof WebAssembly.instantiateStreaming == 'function' &&\n        !isDataURI(wasmBinaryFile) &&\n        // Don't use streaming for file:// delivered objects in a webview, fetch them synchronously.\n        !isFileURI(wasmBinaryFile) &&\n        // Avoid instantiateStreaming() on Node.js environment for now, as while\n        // Node.js v18.1.0 implements it, it does not have a full fetch()\n        // implementation yet.\n        //\n        // Reference:\n        //   https://github.com/emscripten-core/emscripten/pull/16917\n        !ENVIRONMENT_IS_NODE &&\n        typeof fetch == 'function') {\n      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {\n        // Suppress closure warning here since the upstream definition for\n        // instantiateStreaming only allows Promise<Repsponse> rather than\n        // an actual Response.\n        // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure is fixed.\n        /** @suppress {checkTypes} */\n        var result = WebAssembly.instantiateStreaming(response, info);\n\n        return result.then(\n          receiveInstantiationResult,\n          function(reason) {\n            // We expect the most common failure cause to be a bad MIME type for the binary,\n            // in which case falling back to ArrayBuffer instantiation should work.\n            err('wasm streaming compile failed: ' + reason);\n            err('falling back to ArrayBuffer instantiation');\n            return instantiateArrayBuffer(receiveInstantiationResult);\n          });\n      });\n    } else {\n      return instantiateArrayBuffer(receiveInstantiationResult);\n    }\n  }\n\n  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel\n  // to any other async startup actions they are performing.\n  // Also pthreads and wasm workers initialize the wasm instance through this path.\n  if (Module['instantiateWasm']) {\n    try {\n      var exports = Module['instantiateWasm'](info, receiveInstance);\n      return exports;\n    } catch(e) {\n      err('Module.instantiateWasm callback failed with error: ' + e);\n        // If instantiation fails, reject the module ready promise.\n        readyPromiseReject(e);\n    }\n  }\n\n  // If instantiation fails, reject the module ready promise.\n  instantiateAsync().catch(readyPromiseReject);\n  return {}; // no exports yet; we'll fill them in later\n}\n\n// Globals used by JS i64 conversions (see makeSetValue)\nvar tempDouble;\nvar tempI64;\n\n// === Body ===\n\nvar ASM_CONSTS = {\n  \n};\nfunction convertDoubleArrayToJSComplexArray(arr,vecSize) { var result = []; const bit = 8; for (let i = 0; i < vecSize; i++) { var real = getValue(arr + i*2 *bit, \"double\"); var imag = getValue(arr + i*2 *bit + bit, \"double\"); result.push({ real, imag }); } return Emval.toHandle(result); }\nfunction convertCPPCTYPEToJSComplex(real,imag) { var result = { real: real, imag: imag }; return Emval.toHandle(result); }\nfunction convertMatrix(arr,vecSize) { var size = Math.sqrt(vecSize); var result = []; const bit = 8; for (let y = 0; y < size; y++) { result[y] = []; for (let x = 0; x < size; x++) { var p = y*size+x; result[y].push({ real: getValue(arr + p*2 *bit, \"double\"), imag: getValue(arr + p*2 *bit + bit, \"double\") }); } } return Emval.toHandle(result); }\nfunction convertIntArrayToJSArray(arr,vecSize) { var result = []; const byte = 4; for (let i = 0; i < vecSize; i++) { result.push(getValue(arr + i *byte, \"i32\")); } return Emval.toHandle(result); }\nfunction ReversibleBooleanWrapper(funcPtr,n0,n1) { var re = Module['dynCall']('iii', funcPtr, [n0, n1]); return re; }\nfunction AdaptiveWrapper(funcPtr,arr,size) { var re = Module['dynCall']('iii', funcPtr, [arr, size]); return re; }\nfunction QuantumStateMultiplyElementwiseFunctionWrapper(funcPtr,num,complexArrPtr) { Module['dynCall']('vii', funcPtr, [num, complexArrPtr]); }\n\n\n\n\n\n  /** @constructor */\n  function ExitStatus(status) {\n      this.name = 'ExitStatus';\n      this.message = 'Program terminated with exit(' + status + ')';\n      this.status = status;\n    }\n\n  function callRuntimeCallbacks(callbacks) {\n      while (callbacks.length > 0) {\n        // Pass the module as the first argument.\n        callbacks.shift()(Module);\n      }\n    }\n\n  function withStackSave(f) {\n      var stack = stackSave();\n      var ret = f();\n      stackRestore(stack);\n      return ret;\n    }\n  function demangle(func) {\n      return func;\n    }\n\n  function demangleAll(text) {\n      var regex =\n        /\\b_Z[\\w\\d_]+/g;\n      return text.replace(regex,\n        function(x) {\n          var y = demangle(x);\n          return x === y ? x : (y + ' [' + x + ']');\n        });\n    }\n\n  \n    /**\n     * @param {number} ptr\n     * @param {string} type\n     */\n  function getValue(ptr, type = 'i8') {\n      if (type.endsWith('*')) type = '*';\n      switch (type) {\n        case 'i1': return HEAP8[((ptr)>>0)];\n        case 'i8': return HEAP8[((ptr)>>0)];\n        case 'i16': return HEAP16[((ptr)>>1)];\n        case 'i32': return HEAP32[((ptr)>>2)];\n        case 'i64': return HEAP32[((ptr)>>2)];\n        case 'float': return HEAPF32[((ptr)>>2)];\n        case 'double': return HEAPF64[((ptr)>>3)];\n        case '*': return HEAPU32[((ptr)>>2)];\n        default: abort('invalid type for getValue: ' + type);\n      }\n      return null;\n    }\n\n  function handleException(e) {\n      // Certain exception types we do not treat as errors since they are used for\n      // internal control flow.\n      // 1. ExitStatus, which is thrown by exit()\n      // 2. \"unwind\", which is thrown by emscripten_unwind_to_js_event_loop() and others\n      //    that wish to return to JS event loop.\n      if (e instanceof ExitStatus || e == 'unwind') {\n        return EXITSTATUS;\n      }\n      quit_(1, e);\n    }\n\n  function intArrayToString(array) {\n    var ret = [];\n    for (var i = 0; i < array.length; i++) {\n      var chr = array[i];\n      if (chr > 0xFF) {\n        if (ASSERTIONS) {\n          assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');\n        }\n        chr &= 0xFF;\n      }\n      ret.push(String.fromCharCode(chr));\n    }\n    return ret.join('');\n  }\n\n  function jsStackTrace() {\n      var error = new Error();\n      if (!error.stack) {\n        // IE10+ special cases: It does have callstack info, but it is only\n        // populated if an Error object is thrown, so try that as a special-case.\n        try {\n          throw new Error();\n        } catch(e) {\n          error = e;\n        }\n        if (!error.stack) {\n          return '(no stack trace available)';\n        }\n      }\n      return error.stack.toString();\n    }\n\n  \n    /**\n     * @param {number} ptr\n     * @param {number} value\n     * @param {string} type\n     */\n  function setValue(ptr, value, type = 'i8') {\n      if (type.endsWith('*')) type = '*';\n      switch (type) {\n        case 'i1': HEAP8[((ptr)>>0)] = value; break;\n        case 'i8': HEAP8[((ptr)>>0)] = value; break;\n        case 'i16': HEAP16[((ptr)>>1)] = value; break;\n        case 'i32': HEAP32[((ptr)>>2)] = value; break;\n        case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)] = tempI64[0],HEAP32[(((ptr)+(4))>>2)] = tempI64[1]); break;\n        case 'float': HEAPF32[((ptr)>>2)] = value; break;\n        case 'double': HEAPF64[((ptr)>>3)] = value; break;\n        case '*': HEAPU32[((ptr)>>2)] = value; break;\n        default: abort('invalid type for setValue: ' + type);\n      }\n    }\n\n  function stackTrace() {\n      var js = jsStackTrace();\n      if (Module['extraStackTrace']) js += '\\n' + Module['extraStackTrace']();\n      return demangleAll(js);\n    }\n\n  function writeArrayToMemory(array, buffer) {\n      HEAP8.set(array, buffer);\n    }\n\n  function ___assert_fail(condition, filename, line, func) {\n      abort('Assertion failed: ' + UTF8ToString(condition) + ', at: ' + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']);\n    }\n\n  function ___cxa_allocate_exception(size) {\n      // Thrown object is prepended by exception metadata block\n      return _malloc(size + 24) + 24;\n    }\n\n  var exceptionCaught =  [];\n  \n  function exception_addRef(info) {\n      info.add_ref();\n    }\n  \n  var uncaughtExceptionCount = 0;\n  function ___cxa_begin_catch(ptr) {\n      var info = new ExceptionInfo(ptr);\n      if (!info.get_caught()) {\n        info.set_caught(true);\n        uncaughtExceptionCount--;\n      }\n      info.set_rethrown(false);\n      exceptionCaught.push(info);\n      exception_addRef(info);\n      return info.get_exception_ptr();\n    }\n\n  var exceptionLast = 0;\n  \n  /** @constructor */\n  function ExceptionInfo(excPtr) {\n      this.excPtr = excPtr;\n      this.ptr = excPtr - 24;\n  \n      this.set_type = function(type) {\n        HEAPU32[(((this.ptr)+(4))>>2)] = type;\n      };\n  \n      this.get_type = function() {\n        return HEAPU32[(((this.ptr)+(4))>>2)];\n      };\n  \n      this.set_destructor = function(destructor) {\n        HEAPU32[(((this.ptr)+(8))>>2)] = destructor;\n      };\n  \n      this.get_destructor = function() {\n        return HEAPU32[(((this.ptr)+(8))>>2)];\n      };\n  \n      this.set_refcount = function(refcount) {\n        HEAP32[((this.ptr)>>2)] = refcount;\n      };\n  \n      this.set_caught = function (caught) {\n        caught = caught ? 1 : 0;\n        HEAP8[(((this.ptr)+(12))>>0)] = caught;\n      };\n  \n      this.get_caught = function () {\n        return HEAP8[(((this.ptr)+(12))>>0)] != 0;\n      };\n  \n      this.set_rethrown = function (rethrown) {\n        rethrown = rethrown ? 1 : 0;\n        HEAP8[(((this.ptr)+(13))>>0)] = rethrown;\n      };\n  \n      this.get_rethrown = function () {\n        return HEAP8[(((this.ptr)+(13))>>0)] != 0;\n      };\n  \n      // Initialize native structure fields. Should be called once after allocated.\n      this.init = function(type, destructor) {\n        this.set_adjusted_ptr(0);\n        this.set_type(type);\n        this.set_destructor(destructor);\n        this.set_refcount(0);\n        this.set_caught(false);\n        this.set_rethrown(false);\n      }\n  \n      this.add_ref = function() {\n        var value = HEAP32[((this.ptr)>>2)];\n        HEAP32[((this.ptr)>>2)] = value + 1;\n      };\n  \n      // Returns true if last reference released.\n      this.release_ref = function() {\n        var prev = HEAP32[((this.ptr)>>2)];\n        HEAP32[((this.ptr)>>2)] = prev - 1;\n        return prev === 1;\n      };\n  \n      this.set_adjusted_ptr = function(adjustedPtr) {\n        HEAPU32[(((this.ptr)+(16))>>2)] = adjustedPtr;\n      };\n  \n      this.get_adjusted_ptr = function() {\n        return HEAPU32[(((this.ptr)+(16))>>2)];\n      };\n  \n      // Get pointer which is expected to be received by catch clause in C++ code. It may be adjusted\n      // when the pointer is casted to some of the exception object base classes (e.g. when virtual\n      // inheritance is used). When a pointer is thrown this method should return the thrown pointer\n      // itself.\n      this.get_exception_ptr = function() {\n        // Work around a fastcomp bug, this code is still included for some reason in a build without\n        // exceptions support.\n        var isPointer = ___cxa_is_pointer_type(this.get_type());\n        if (isPointer) {\n          return HEAPU32[((this.excPtr)>>2)];\n        }\n        var adjusted = this.get_adjusted_ptr();\n        if (adjusted !== 0) return adjusted;\n        return this.excPtr;\n      };\n    }\n  function ___cxa_free_exception(ptr) {\n        return _free(new ExceptionInfo(ptr).ptr);\n    }\n  \n  var wasmTableMirror = [];\n  function getWasmTableEntry(funcPtr) {\n      var func = wasmTableMirror[funcPtr];\n      if (!func) {\n        if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;\n        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\n      }\n      return func;\n    }\n  function exception_decRef(info) {\n      // A rethrown exception can reach refcount 0; it must not be discarded\n      // Its next handler will clear the rethrown flag and addRef it, prior to\n      // final decRef and destruction here\n      if (info.release_ref() && !info.get_rethrown()) {\n        var destructor = info.get_destructor();\n        if (destructor) {\n          // In Wasm, destructors return 'this' as in ARM\n          getWasmTableEntry(destructor)(info.excPtr);\n        }\n        ___cxa_free_exception(info.excPtr);\n      }\n    }\n  function ___cxa_end_catch() {\n      // Clear state flag.\n      _setThrew(0);\n      // Call destructor if one is registered then clear it.\n      var info = exceptionCaught.pop();\n  \n      exception_decRef(info);\n      exceptionLast = 0; // XXX in decRef?\n    }\n\n  function ___resumeException(ptr) {\n      if (!exceptionLast) { exceptionLast = ptr; }\n      throw ptr;\n    }\n  function ___cxa_find_matching_catch_2() {\n      var thrown = exceptionLast;\n      if (!thrown) {\n        // just pass through the null ptr\n        setTempRet0(0);\n        return 0;\n      }\n      var info = new ExceptionInfo(thrown);\n      info.set_adjusted_ptr(thrown);\n      var thrownType = info.get_type();\n      if (!thrownType) {\n        // just pass through the thrown ptr\n        setTempRet0(0);\n        return thrown;\n      }\n  \n      // can_catch receives a **, add indirection\n      // The different catch blocks are denoted by different types.\n      // Due to inheritance, those types may not precisely match the\n      // type of the thrown object. Find one which matches, and\n      // return the type of the catch block which should be called.\n      for (var i = 0; i < arguments.length; i++) {\n        var caughtType = arguments[i];\n        if (caughtType === 0 || caughtType === thrownType) {\n          // Catch all clause matched or exactly the same type is caught\n          break;\n        }\n        var adjusted_ptr_addr = info.ptr + 16;\n        if (___cxa_can_catch(caughtType, thrownType, adjusted_ptr_addr)) {\n          setTempRet0(caughtType);\n          return thrown;\n        }\n      }\n      setTempRet0(thrownType);\n      return thrown;\n    }\n\n  function ___cxa_find_matching_catch_3() {\n      var thrown = exceptionLast;\n      if (!thrown) {\n        // just pass through the null ptr\n        setTempRet0(0);\n        return 0;\n      }\n      var info = new ExceptionInfo(thrown);\n      info.set_adjusted_ptr(thrown);\n      var thrownType = info.get_type();\n      if (!thrownType) {\n        // just pass through the thrown ptr\n        setTempRet0(0);\n        return thrown;\n      }\n  \n      // can_catch receives a **, add indirection\n      // The different catch blocks are denoted by different types.\n      // Due to inheritance, those types may not precisely match the\n      // type of the thrown object. Find one which matches, and\n      // return the type of the catch block which should be called.\n      for (var i = 0; i < arguments.length; i++) {\n        var caughtType = arguments[i];\n        if (caughtType === 0 || caughtType === thrownType) {\n          // Catch all clause matched or exactly the same type is caught\n          break;\n        }\n        var adjusted_ptr_addr = info.ptr + 16;\n        if (___cxa_can_catch(caughtType, thrownType, adjusted_ptr_addr)) {\n          setTempRet0(caughtType);\n          return thrown;\n        }\n      }\n      setTempRet0(thrownType);\n      return thrown;\n    }\n\n\n  function ___cxa_rethrow() {\n      var info = exceptionCaught.pop();\n      if (!info) {\n        abort('no exception to throw');\n      }\n      var ptr = info.excPtr;\n      if (!info.get_rethrown()) {\n        // Only pop if the corresponding push was through rethrow_primary_exception\n        exceptionCaught.push(info);\n        info.set_rethrown(true);\n        info.set_caught(false);\n        uncaughtExceptionCount++;\n      }\n      exceptionLast = ptr;\n      throw ptr;\n    }\n\n  function ___cxa_throw(ptr, type, destructor) {\n      var info = new ExceptionInfo(ptr);\n      // Initialize ExceptionInfo content after it was allocated in __cxa_allocate_exception.\n      info.init(type, destructor);\n      exceptionLast = ptr;\n      uncaughtExceptionCount++;\n      throw ptr;\n    }\n\n  function ___cxa_uncaught_exceptions() {\n      return uncaughtExceptionCount;\n    }\n\n\n  var structRegistrations = {};\n  \n  function runDestructors(destructors) {\n      while (destructors.length) {\n        var ptr = destructors.pop();\n        var del = destructors.pop();\n        del(ptr);\n      }\n    }\n  \n  function simpleReadValueFromPointer(pointer) {\n      return this['fromWireType'](HEAP32[((pointer)>>2)]);\n    }\n  \n  var awaitingDependencies = {};\n  \n  var registeredTypes = {};\n  \n  var typeDependencies = {};\n  \n  var char_0 = 48;\n  \n  var char_9 = 57;\n  function makeLegalFunctionName(name) {\n      if (undefined === name) {\n        return '_unknown';\n      }\n      name = name.replace(/[^a-zA-Z0-9_]/g, '$');\n      var f = name.charCodeAt(0);\n      if (f >= char_0 && f <= char_9) {\n        return '_' + name;\n      }\n      return name;\n    }\n  function createNamedFunction(name, body) {\n      name = makeLegalFunctionName(name);\n      /*jshint evil:true*/\n      return new Function(\n          \"body\",\n          \"return function \" + name + \"() {\\n\" +\n          \"    \\\"use strict\\\";\" +\n          \"    return body.apply(this, arguments);\\n\" +\n          \"};\\n\"\n      )(body);\n    }\n  function extendError(baseErrorType, errorName) {\n      var errorClass = createNamedFunction(errorName, function(message) {\n        this.name = errorName;\n        this.message = message;\n  \n        var stack = (new Error(message)).stack;\n        if (stack !== undefined) {\n          this.stack = this.toString() + '\\n' +\n              stack.replace(/^Error(:[^\\n]*)?\\n/, '');\n        }\n      });\n      errorClass.prototype = Object.create(baseErrorType.prototype);\n      errorClass.prototype.constructor = errorClass;\n      errorClass.prototype.toString = function() {\n        if (this.message === undefined) {\n          return this.name;\n        } else {\n          return this.name + ': ' + this.message;\n        }\n      };\n  \n      return errorClass;\n    }\n  var InternalError = undefined;\n  function throwInternalError(message) {\n      throw new InternalError(message);\n    }\n  function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {\n      myTypes.forEach(function(type) {\n          typeDependencies[type] = dependentTypes;\n      });\n  \n      function onComplete(typeConverters) {\n          var myTypeConverters = getTypeConverters(typeConverters);\n          if (myTypeConverters.length !== myTypes.length) {\n              throwInternalError('Mismatched type converter count');\n          }\n          for (var i = 0; i < myTypes.length; ++i) {\n              registerType(myTypes[i], myTypeConverters[i]);\n          }\n      }\n  \n      var typeConverters = new Array(dependentTypes.length);\n      var unregisteredTypes = [];\n      var registered = 0;\n      dependentTypes.forEach((dt, i) => {\n        if (registeredTypes.hasOwnProperty(dt)) {\n          typeConverters[i] = registeredTypes[dt];\n        } else {\n          unregisteredTypes.push(dt);\n          if (!awaitingDependencies.hasOwnProperty(dt)) {\n            awaitingDependencies[dt] = [];\n          }\n          awaitingDependencies[dt].push(() => {\n            typeConverters[i] = registeredTypes[dt];\n            ++registered;\n            if (registered === unregisteredTypes.length) {\n              onComplete(typeConverters);\n            }\n          });\n        }\n      });\n      if (0 === unregisteredTypes.length) {\n        onComplete(typeConverters);\n      }\n    }\n  function __embind_finalize_value_object(structType) {\n      var reg = structRegistrations[structType];\n      delete structRegistrations[structType];\n  \n      var rawConstructor = reg.rawConstructor;\n      var rawDestructor = reg.rawDestructor;\n      var fieldRecords = reg.fields;\n      var fieldTypes = fieldRecords.map((field) => field.getterReturnType).\n                concat(fieldRecords.map((field) => field.setterArgumentType));\n      whenDependentTypesAreResolved([structType], fieldTypes, (fieldTypes) => {\n        var fields = {};\n        fieldRecords.forEach((field, i) => {\n          var fieldName = field.fieldName;\n          var getterReturnType = fieldTypes[i];\n          var getter = field.getter;\n          var getterContext = field.getterContext;\n          var setterArgumentType = fieldTypes[i + fieldRecords.length];\n          var setter = field.setter;\n          var setterContext = field.setterContext;\n          fields[fieldName] = {\n            read: (ptr) => {\n              return getterReturnType['fromWireType'](\n                  getter(getterContext, ptr));\n            },\n            write: (ptr, o) => {\n              var destructors = [];\n              setter(setterContext, ptr, setterArgumentType['toWireType'](destructors, o));\n              runDestructors(destructors);\n            }\n          };\n        });\n  \n        return [{\n          name: reg.name,\n          'fromWireType': function(ptr) {\n            var rv = {};\n            for (var i in fields) {\n              rv[i] = fields[i].read(ptr);\n            }\n            rawDestructor(ptr);\n            return rv;\n          },\n          'toWireType': function(destructors, o) {\n            // todo: Here we have an opportunity for -O3 level \"unsafe\" optimizations:\n            // assume all fields are present without checking.\n            for (var fieldName in fields) {\n              if (!(fieldName in o)) {\n                throw new TypeError('Missing field:  \"' + fieldName + '\"');\n              }\n            }\n            var ptr = rawConstructor();\n            for (fieldName in fields) {\n              fields[fieldName].write(ptr, o[fieldName]);\n            }\n            if (destructors !== null) {\n              destructors.push(rawDestructor, ptr);\n            }\n            return ptr;\n          },\n          'argPackAdvance': 8,\n          'readValueFromPointer': simpleReadValueFromPointer,\n          destructorFunction: rawDestructor,\n        }];\n      });\n    }\n\n  function __embind_register_bigint(primitiveType, name, size, minRange, maxRange) {}\n\n  function getShiftFromSize(size) {\n      switch (size) {\n          case 1: return 0;\n          case 2: return 1;\n          case 4: return 2;\n          case 8: return 3;\n          default:\n              throw new TypeError('Unknown type size: ' + size);\n      }\n    }\n  \n  function embind_init_charCodes() {\n      var codes = new Array(256);\n      for (var i = 0; i < 256; ++i) {\n          codes[i] = String.fromCharCode(i);\n      }\n      embind_charCodes = codes;\n    }\n  var embind_charCodes = undefined;\n  function readLatin1String(ptr) {\n      var ret = \"\";\n      var c = ptr;\n      while (HEAPU8[c]) {\n          ret += embind_charCodes[HEAPU8[c++]];\n      }\n      return ret;\n    }\n  \n  var BindingError = undefined;\n  function throwBindingError(message) {\n      throw new BindingError(message);\n    }\n  /** @param {Object=} options */\n  function registerType(rawType, registeredInstance, options = {}) {\n      if (!('argPackAdvance' in registeredInstance)) {\n          throw new TypeError('registerType registeredInstance requires argPackAdvance');\n      }\n  \n      var name = registeredInstance.name;\n      if (!rawType) {\n          throwBindingError('type \"' + name + '\" must have a positive integer typeid pointer');\n      }\n      if (registeredTypes.hasOwnProperty(rawType)) {\n          if (options.ignoreDuplicateRegistrations) {\n              return;\n          } else {\n              throwBindingError(\"Cannot register type '\" + name + \"' twice\");\n          }\n      }\n  \n      registeredTypes[rawType] = registeredInstance;\n      delete typeDependencies[rawType];\n  \n      if (awaitingDependencies.hasOwnProperty(rawType)) {\n        var callbacks = awaitingDependencies[rawType];\n        delete awaitingDependencies[rawType];\n        callbacks.forEach((cb) => cb());\n      }\n    }\n  function __embind_register_bool(rawType, name, size, trueValue, falseValue) {\n      var shift = getShiftFromSize(size);\n  \n      name = readLatin1String(name);\n      registerType(rawType, {\n          name: name,\n          'fromWireType': function(wt) {\n              // ambiguous emscripten ABI: sometimes return values are\n              // true or false, and sometimes integers (0 or 1)\n              return !!wt;\n          },\n          'toWireType': function(destructors, o) {\n              return o ? trueValue : falseValue;\n          },\n          'argPackAdvance': 8,\n          'readValueFromPointer': function(pointer) {\n              // TODO: if heap is fixed (like in asm.js) this could be executed outside\n              var heap;\n              if (size === 1) {\n                  heap = HEAP8;\n              } else if (size === 2) {\n                  heap = HEAP16;\n              } else if (size === 4) {\n                  heap = HEAP32;\n              } else {\n                  throw new TypeError(\"Unknown boolean type size: \" + name);\n              }\n              return this['fromWireType'](heap[pointer >> shift]);\n          },\n          destructorFunction: null, // This type does not need a destructor\n      });\n    }\n\n  function ClassHandle_isAliasOf(other) {\n      if (!(this instanceof ClassHandle)) {\n        return false;\n      }\n      if (!(other instanceof ClassHandle)) {\n        return false;\n      }\n  \n      var leftClass = this.$$.ptrType.registeredClass;\n      var left = this.$$.ptr;\n      var rightClass = other.$$.ptrType.registeredClass;\n      var right = other.$$.ptr;\n  \n      while (leftClass.baseClass) {\n        left = leftClass.upcast(left);\n        leftClass = leftClass.baseClass;\n      }\n  \n      while (rightClass.baseClass) {\n        right = rightClass.upcast(right);\n        rightClass = rightClass.baseClass;\n      }\n  \n      return leftClass === rightClass && left === right;\n    }\n  \n  function shallowCopyInternalPointer(o) {\n      return {\n        count: o.count,\n        deleteScheduled: o.deleteScheduled,\n        preservePointerOnDelete: o.preservePointerOnDelete,\n        ptr: o.ptr,\n        ptrType: o.ptrType,\n        smartPtr: o.smartPtr,\n        smartPtrType: o.smartPtrType,\n      };\n    }\n  \n  function throwInstanceAlreadyDeleted(obj) {\n      function getInstanceTypeName(handle) {\n        return handle.$$.ptrType.registeredClass.name;\n      }\n      throwBindingError(getInstanceTypeName(obj) + ' instance already deleted');\n    }\n  \n  var finalizationRegistry = false;\n  \n  function detachFinalizer(handle) {}\n  \n  function runDestructor($$) {\n      if ($$.smartPtr) {\n        $$.smartPtrType.rawDestructor($$.smartPtr);\n      } else {\n        $$.ptrType.registeredClass.rawDestructor($$.ptr);\n      }\n    }\n  function releaseClassHandle($$) {\n      $$.count.value -= 1;\n      var toDelete = 0 === $$.count.value;\n      if (toDelete) {\n        runDestructor($$);\n      }\n    }\n  \n  function downcastPointer(ptr, ptrClass, desiredClass) {\n      if (ptrClass === desiredClass) {\n        return ptr;\n      }\n      if (undefined === desiredClass.baseClass) {\n        return null; // no conversion\n      }\n  \n      var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\n      if (rv === null) {\n        return null;\n      }\n      return desiredClass.downcast(rv);\n    }\n  \n  var registeredPointers = {};\n  \n  function getInheritedInstanceCount() {\n      return Object.keys(registeredInstances).length;\n    }\n  \n  function getLiveInheritedInstances() {\n      var rv = [];\n      for (var k in registeredInstances) {\n        if (registeredInstances.hasOwnProperty(k)) {\n          rv.push(registeredInstances[k]);\n        }\n      }\n      return rv;\n    }\n  \n  var deletionQueue = [];\n  function flushPendingDeletes() {\n      while (deletionQueue.length) {\n        var obj = deletionQueue.pop();\n        obj.$$.deleteScheduled = false;\n        obj['delete']();\n      }\n    }\n  \n  var delayFunction = undefined;\n  function setDelayFunction(fn) {\n      delayFunction = fn;\n      if (deletionQueue.length && delayFunction) {\n        delayFunction(flushPendingDeletes);\n      }\n    }\n  function init_embind() {\n      Module['getInheritedInstanceCount'] = getInheritedInstanceCount;\n      Module['getLiveInheritedInstances'] = getLiveInheritedInstances;\n      Module['flushPendingDeletes'] = flushPendingDeletes;\n      Module['setDelayFunction'] = setDelayFunction;\n    }\n  var registeredInstances = {};\n  \n  function getBasestPointer(class_, ptr) {\n      if (ptr === undefined) {\n          throwBindingError('ptr should not be undefined');\n      }\n      while (class_.baseClass) {\n          ptr = class_.upcast(ptr);\n          class_ = class_.baseClass;\n      }\n      return ptr;\n    }\n  function getInheritedInstance(class_, ptr) {\n      ptr = getBasestPointer(class_, ptr);\n      return registeredInstances[ptr];\n    }\n  \n  function makeClassHandle(prototype, record) {\n      if (!record.ptrType || !record.ptr) {\n        throwInternalError('makeClassHandle requires ptr and ptrType');\n      }\n      var hasSmartPtrType = !!record.smartPtrType;\n      var hasSmartPtr = !!record.smartPtr;\n      if (hasSmartPtrType !== hasSmartPtr) {\n        throwInternalError('Both smartPtrType and smartPtr must be specified');\n      }\n      record.count = { value: 1 };\n      return attachFinalizer(Object.create(prototype, {\n        $$: {\n            value: record,\n        },\n      }));\n    }\n  function RegisteredPointer_fromWireType(ptr) {\n      // ptr is a raw pointer (or a raw smartpointer)\n  \n      // rawPointer is a maybe-null raw pointer\n      var rawPointer = this.getPointee(ptr);\n      if (!rawPointer) {\n        this.destructor(ptr);\n        return null;\n      }\n  \n      var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);\n      if (undefined !== registeredInstance) {\n        // JS object has been neutered, time to repopulate it\n        if (0 === registeredInstance.$$.count.value) {\n          registeredInstance.$$.ptr = rawPointer;\n          registeredInstance.$$.smartPtr = ptr;\n          return registeredInstance['clone']();\n        } else {\n          // else, just increment reference count on existing object\n          // it already has a reference to the smart pointer\n          var rv = registeredInstance['clone']();\n          this.destructor(ptr);\n          return rv;\n        }\n      }\n  \n      function makeDefaultHandle() {\n        if (this.isSmartPointer) {\n          return makeClassHandle(this.registeredClass.instancePrototype, {\n            ptrType: this.pointeeType,\n            ptr: rawPointer,\n            smartPtrType: this,\n            smartPtr: ptr,\n          });\n        } else {\n          return makeClassHandle(this.registeredClass.instancePrototype, {\n            ptrType: this,\n            ptr: ptr,\n          });\n        }\n      }\n  \n      var actualType = this.registeredClass.getActualType(rawPointer);\n      var registeredPointerRecord = registeredPointers[actualType];\n      if (!registeredPointerRecord) {\n        return makeDefaultHandle.call(this);\n      }\n  \n      var toType;\n      if (this.isConst) {\n        toType = registeredPointerRecord.constPointerType;\n      } else {\n        toType = registeredPointerRecord.pointerType;\n      }\n      var dp = downcastPointer(\n          rawPointer,\n          this.registeredClass,\n          toType.registeredClass);\n      if (dp === null) {\n        return makeDefaultHandle.call(this);\n      }\n      if (this.isSmartPointer) {\n        return makeClassHandle(toType.registeredClass.instancePrototype, {\n          ptrType: toType,\n          ptr: dp,\n          smartPtrType: this,\n          smartPtr: ptr,\n        });\n      } else {\n        return makeClassHandle(toType.registeredClass.instancePrototype, {\n          ptrType: toType,\n          ptr: dp,\n        });\n      }\n    }\n  function attachFinalizer(handle) {\n      if ('undefined' === typeof FinalizationRegistry) {\n        attachFinalizer = (handle) => handle;\n        return handle;\n      }\n      // If the running environment has a FinalizationRegistry (see\n      // https://github.com/tc39/proposal-weakrefs), then attach finalizers\n      // for class handles.  We check for the presence of FinalizationRegistry\n      // at run-time, not build-time.\n      finalizationRegistry = new FinalizationRegistry((info) => {\n        releaseClassHandle(info.$$);\n      });\n      attachFinalizer = (handle) => {\n        var $$ = handle.$$;\n        var hasSmartPtr = !!$$.smartPtr;\n        if (hasSmartPtr) {\n          // We should not call the destructor on raw pointers in case other code expects the pointee to live\n          var info = { $$: $$ };\n          finalizationRegistry.register(handle, info, handle);\n        }\n        return handle;\n      };\n      detachFinalizer = (handle) => finalizationRegistry.unregister(handle);\n      return attachFinalizer(handle);\n    }\n  function ClassHandle_clone() {\n      if (!this.$$.ptr) {\n        throwInstanceAlreadyDeleted(this);\n      }\n  \n      if (this.$$.preservePointerOnDelete) {\n        this.$$.count.value += 1;\n        return this;\n      } else {\n        var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {\n          $$: {\n            value: shallowCopyInternalPointer(this.$$),\n          }\n        }));\n  \n        clone.$$.count.value += 1;\n        clone.$$.deleteScheduled = false;\n        return clone;\n      }\n    }\n  \n  function ClassHandle_delete() {\n      if (!this.$$.ptr) {\n        throwInstanceAlreadyDeleted(this);\n      }\n  \n      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n        throwBindingError('Object already scheduled for deletion');\n      }\n  \n      detachFinalizer(this);\n      releaseClassHandle(this.$$);\n  \n      if (!this.$$.preservePointerOnDelete) {\n        this.$$.smartPtr = undefined;\n        this.$$.ptr = undefined;\n      }\n    }\n  \n  function ClassHandle_isDeleted() {\n      return !this.$$.ptr;\n    }\n  \n  function ClassHandle_deleteLater() {\n      if (!this.$$.ptr) {\n        throwInstanceAlreadyDeleted(this);\n      }\n      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n        throwBindingError('Object already scheduled for deletion');\n      }\n      deletionQueue.push(this);\n      if (deletionQueue.length === 1 && delayFunction) {\n        delayFunction(flushPendingDeletes);\n      }\n      this.$$.deleteScheduled = true;\n      return this;\n    }\n  function init_ClassHandle() {\n      ClassHandle.prototype['isAliasOf'] = ClassHandle_isAliasOf;\n      ClassHandle.prototype['clone'] = ClassHandle_clone;\n      ClassHandle.prototype['delete'] = ClassHandle_delete;\n      ClassHandle.prototype['isDeleted'] = ClassHandle_isDeleted;\n      ClassHandle.prototype['deleteLater'] = ClassHandle_deleteLater;\n    }\n  function ClassHandle() {\n    }\n  \n  function ensureOverloadTable(proto, methodName, humanName) {\n      if (undefined === proto[methodName].overloadTable) {\n        var prevFunc = proto[methodName];\n        // Inject an overload resolver function that routes to the appropriate overload based on the number of arguments.\n        proto[methodName] = function() {\n          // TODO This check can be removed in -O3 level \"unsafe\" optimizations.\n          if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {\n              throwBindingError(\"Function '\" + humanName + \"' called with an invalid number of arguments (\" + arguments.length + \") - expects one of (\" + proto[methodName].overloadTable + \")!\");\n          }\n          return proto[methodName].overloadTable[arguments.length].apply(this, arguments);\n        };\n        // Move the previous function into the overload table.\n        proto[methodName].overloadTable = [];\n        proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n      }\n    }\n  /** @param {number=} numArguments */\n  function exposePublicSymbol(name, value, numArguments) {\n      if (Module.hasOwnProperty(name)) {\n        if (undefined === numArguments || (undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments])) {\n          throwBindingError(\"Cannot register public name '\" + name + \"' twice\");\n        }\n  \n        // We are exposing a function with the same name as an existing function. Create an overload table and a function selector\n        // that routes between the two.\n        ensureOverloadTable(Module, name, name);\n        if (Module.hasOwnProperty(numArguments)) {\n            throwBindingError(\"Cannot register multiple overloads of a function with the same number of arguments (\" + numArguments + \")!\");\n        }\n        // Add the new function into the overload table.\n        Module[name].overloadTable[numArguments] = value;\n      }\n      else {\n        Module[name] = value;\n        if (undefined !== numArguments) {\n          Module[name].numArguments = numArguments;\n        }\n      }\n    }\n  \n  /** @constructor */\n  function RegisteredClass(name,\n                               constructor,\n                               instancePrototype,\n                               rawDestructor,\n                               baseClass,\n                               getActualType,\n                               upcast,\n                               downcast) {\n      this.name = name;\n      this.constructor = constructor;\n      this.instancePrototype = instancePrototype;\n      this.rawDestructor = rawDestructor;\n      this.baseClass = baseClass;\n      this.getActualType = getActualType;\n      this.upcast = upcast;\n      this.downcast = downcast;\n      this.pureVirtualFunctions = [];\n    }\n  \n  function upcastPointer(ptr, ptrClass, desiredClass) {\n      while (ptrClass !== desiredClass) {\n        if (!ptrClass.upcast) {\n          throwBindingError(\"Expected null or instance of \" + desiredClass.name + \", got an instance of \" + ptrClass.name);\n        }\n        ptr = ptrClass.upcast(ptr);\n        ptrClass = ptrClass.baseClass;\n      }\n      return ptr;\n    }\n  function constNoSmartPtrRawPointerToWireType(destructors, handle) {\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError('null is not a valid ' + this.name);\n        }\n        return 0;\n      }\n  \n      if (!handle.$$) {\n        throwBindingError('Cannot pass \"' + embindRepr(handle) + '\" as a ' + this.name);\n      }\n      if (!handle.$$.ptr) {\n        throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      return ptr;\n    }\n  \n  function genericPointerToWireType(destructors, handle) {\n      var ptr;\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError('null is not a valid ' + this.name);\n        }\n  \n        if (this.isSmartPointer) {\n          ptr = this.rawConstructor();\n          if (destructors !== null) {\n            destructors.push(this.rawDestructor, ptr);\n          }\n          return ptr;\n        } else {\n          return 0;\n        }\n      }\n  \n      if (!handle.$$) {\n        throwBindingError('Cannot pass \"' + embindRepr(handle) + '\" as a ' + this.name);\n      }\n      if (!handle.$$.ptr) {\n        throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);\n      }\n      if (!this.isConst && handle.$$.ptrType.isConst) {\n        throwBindingError('Cannot convert argument of type ' + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + ' to parameter type ' + this.name);\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n  \n      if (this.isSmartPointer) {\n        // TODO: this is not strictly true\n        // We could support BY_EMVAL conversions from raw pointers to smart pointers\n        // because the smart pointer can hold a reference to the handle\n        if (undefined === handle.$$.smartPtr) {\n          throwBindingError('Passing raw pointer to smart pointer is illegal');\n        }\n  \n        switch (this.sharingPolicy) {\n          case 0: // NONE\n            // no upcasting\n            if (handle.$$.smartPtrType === this) {\n              ptr = handle.$$.smartPtr;\n            } else {\n              throwBindingError('Cannot convert argument of type ' + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + ' to parameter type ' + this.name);\n            }\n            break;\n  \n          case 1: // INTRUSIVE\n            ptr = handle.$$.smartPtr;\n            break;\n  \n          case 2: // BY_EMVAL\n            if (handle.$$.smartPtrType === this) {\n              ptr = handle.$$.smartPtr;\n            } else {\n              var clonedHandle = handle['clone']();\n              ptr = this.rawShare(\n                ptr,\n                Emval.toHandle(function() {\n                  clonedHandle['delete']();\n                })\n              );\n              if (destructors !== null) {\n                destructors.push(this.rawDestructor, ptr);\n              }\n            }\n            break;\n  \n          default:\n            throwBindingError('Unsupporting sharing policy');\n        }\n      }\n      return ptr;\n    }\n  \n  function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError('null is not a valid ' + this.name);\n        }\n        return 0;\n      }\n  \n      if (!handle.$$) {\n        throwBindingError('Cannot pass \"' + embindRepr(handle) + '\" as a ' + this.name);\n      }\n      if (!handle.$$.ptr) {\n        throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);\n      }\n      if (handle.$$.ptrType.isConst) {\n          throwBindingError('Cannot convert argument of type ' + handle.$$.ptrType.name + ' to parameter type ' + this.name);\n      }\n      var handleClass = handle.$$.ptrType.registeredClass;\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      return ptr;\n    }\n  \n  function RegisteredPointer_getPointee(ptr) {\n      if (this.rawGetPointee) {\n        ptr = this.rawGetPointee(ptr);\n      }\n      return ptr;\n    }\n  \n  function RegisteredPointer_destructor(ptr) {\n      if (this.rawDestructor) {\n        this.rawDestructor(ptr);\n      }\n    }\n  \n  function RegisteredPointer_deleteObject(handle) {\n      if (handle !== null) {\n        handle['delete']();\n      }\n    }\n  function init_RegisteredPointer() {\n      RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;\n      RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;\n      RegisteredPointer.prototype['argPackAdvance'] = 8;\n      RegisteredPointer.prototype['readValueFromPointer'] = simpleReadValueFromPointer;\n      RegisteredPointer.prototype['deleteObject'] = RegisteredPointer_deleteObject;\n      RegisteredPointer.prototype['fromWireType'] = RegisteredPointer_fromWireType;\n    }\n  /** @constructor\n      @param {*=} pointeeType,\n      @param {*=} sharingPolicy,\n      @param {*=} rawGetPointee,\n      @param {*=} rawConstructor,\n      @param {*=} rawShare,\n      @param {*=} rawDestructor,\n       */\n  function RegisteredPointer(\n      name,\n      registeredClass,\n      isReference,\n      isConst,\n  \n      // smart pointer properties\n      isSmartPointer,\n      pointeeType,\n      sharingPolicy,\n      rawGetPointee,\n      rawConstructor,\n      rawShare,\n      rawDestructor\n    ) {\n      this.name = name;\n      this.registeredClass = registeredClass;\n      this.isReference = isReference;\n      this.isConst = isConst;\n  \n      // smart pointer properties\n      this.isSmartPointer = isSmartPointer;\n      this.pointeeType = pointeeType;\n      this.sharingPolicy = sharingPolicy;\n      this.rawGetPointee = rawGetPointee;\n      this.rawConstructor = rawConstructor;\n      this.rawShare = rawShare;\n      this.rawDestructor = rawDestructor;\n  \n      if (!isSmartPointer && registeredClass.baseClass === undefined) {\n        if (isConst) {\n          this['toWireType'] = constNoSmartPtrRawPointerToWireType;\n          this.destructorFunction = null;\n        } else {\n          this['toWireType'] = nonConstNoSmartPtrRawPointerToWireType;\n          this.destructorFunction = null;\n        }\n      } else {\n        this['toWireType'] = genericPointerToWireType;\n        // Here we must leave this.destructorFunction undefined, since whether genericPointerToWireType returns\n        // a pointer that needs to be freed up is runtime-dependent, and cannot be evaluated at registration time.\n        // TODO: Create an alternative mechanism that allows removing the use of var destructors = []; array in\n        //       craftInvokerFunction altogether.\n      }\n    }\n  \n  /** @param {number=} numArguments */\n  function replacePublicSymbol(name, value, numArguments) {\n      if (!Module.hasOwnProperty(name)) {\n        throwInternalError('Replacing nonexistant public symbol');\n      }\n      // If there's an overload table for this symbol, replace the symbol in the overload table instead.\n      if (undefined !== Module[name].overloadTable && undefined !== numArguments) {\n        Module[name].overloadTable[numArguments] = value;\n      }\n      else {\n        Module[name] = value;\n        Module[name].argCount = numArguments;\n      }\n    }\n  \n  function dynCallLegacy(sig, ptr, args) {\n      var f = Module['dynCall_' + sig];\n      return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);\n    }\n  /** @param {Object=} args */\n  function dynCall(sig, ptr, args) {\n      // Without WASM_BIGINT support we cannot directly call function with i64 as\n      // part of thier signature, so we rely the dynCall functions generated by\n      // wasm-emscripten-finalize\n      if (sig.includes('j')) {\n        return dynCallLegacy(sig, ptr, args);\n      }\n      var rtn = getWasmTableEntry(ptr).apply(null, args);\n      return rtn;\n    }\n  function getDynCaller(sig, ptr) {\n      var argCache = [];\n      return function() {\n        argCache.length = 0;\n        Object.assign(argCache, arguments);\n        return dynCall(sig, ptr, argCache);\n      };\n    }\n  function embind__requireFunction(signature, rawFunction) {\n      signature = readLatin1String(signature);\n  \n      function makeDynCaller() {\n        if (signature.includes('j')) {\n          return getDynCaller(signature, rawFunction);\n        }\n        return getWasmTableEntry(rawFunction);\n      }\n  \n      var fp = makeDynCaller();\n      if (typeof fp != \"function\") {\n          throwBindingError(\"unknown function pointer with signature \" + signature + \": \" + rawFunction);\n      }\n      return fp;\n    }\n  \n  var UnboundTypeError = undefined;\n  \n  function getTypeName(type) {\n      var ptr = ___getTypeName(type);\n      var rv = readLatin1String(ptr);\n      _free(ptr);\n      return rv;\n    }\n  function throwUnboundTypeError(message, types) {\n      var unboundTypes = [];\n      var seen = {};\n      function visit(type) {\n        if (seen[type]) {\n          return;\n        }\n        if (registeredTypes[type]) {\n          return;\n        }\n        if (typeDependencies[type]) {\n          typeDependencies[type].forEach(visit);\n          return;\n        }\n        unboundTypes.push(type);\n        seen[type] = true;\n      }\n      types.forEach(visit);\n  \n      throw new UnboundTypeError(message + ': ' + unboundTypes.map(getTypeName).join([', ']));\n    }\n  function __embind_register_class(rawType,\n                                     rawPointerType,\n                                     rawConstPointerType,\n                                     baseClassRawType,\n                                     getActualTypeSignature,\n                                     getActualType,\n                                     upcastSignature,\n                                     upcast,\n                                     downcastSignature,\n                                     downcast,\n                                     name,\n                                     destructorSignature,\n                                     rawDestructor) {\n      name = readLatin1String(name);\n      getActualType = embind__requireFunction(getActualTypeSignature, getActualType);\n      if (upcast) {\n        upcast = embind__requireFunction(upcastSignature, upcast);\n      }\n      if (downcast) {\n        downcast = embind__requireFunction(downcastSignature, downcast);\n      }\n      rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\n      var legalFunctionName = makeLegalFunctionName(name);\n  \n      exposePublicSymbol(legalFunctionName, function() {\n        // this code cannot run if baseClassRawType is zero\n        throwUnboundTypeError('Cannot construct ' + name + ' due to unbound types', [baseClassRawType]);\n      });\n  \n      whenDependentTypesAreResolved(\n        [rawType, rawPointerType, rawConstPointerType],\n        baseClassRawType ? [baseClassRawType] : [],\n        function(base) {\n          base = base[0];\n  \n          var baseClass;\n          var basePrototype;\n          if (baseClassRawType) {\n            baseClass = base.registeredClass;\n            basePrototype = baseClass.instancePrototype;\n          } else {\n            basePrototype = ClassHandle.prototype;\n          }\n  \n          var constructor = createNamedFunction(legalFunctionName, function() {\n            if (Object.getPrototypeOf(this) !== instancePrototype) {\n              throw new BindingError(\"Use 'new' to construct \" + name);\n            }\n            if (undefined === registeredClass.constructor_body) {\n              throw new BindingError(name + \" has no accessible constructor\");\n            }\n            var body = registeredClass.constructor_body[arguments.length];\n            if (undefined === body) {\n              throw new BindingError(\"Tried to invoke ctor of \" + name + \" with invalid number of parameters (\" + arguments.length + \") - expected (\" + Object.keys(registeredClass.constructor_body).toString() + \") parameters instead!\");\n            }\n            return body.apply(this, arguments);\n          });\n  \n          var instancePrototype = Object.create(basePrototype, {\n            constructor: { value: constructor },\n          });\n  \n          constructor.prototype = instancePrototype;\n  \n          var registeredClass = new RegisteredClass(name,\n                                                    constructor,\n                                                    instancePrototype,\n                                                    rawDestructor,\n                                                    baseClass,\n                                                    getActualType,\n                                                    upcast,\n                                                    downcast);\n  \n          var referenceConverter = new RegisteredPointer(name,\n                                                         registeredClass,\n                                                         true,\n                                                         false,\n                                                         false);\n  \n          var pointerConverter = new RegisteredPointer(name + '*',\n                                                       registeredClass,\n                                                       false,\n                                                       false,\n                                                       false);\n  \n          var constPointerConverter = new RegisteredPointer(name + ' const*',\n                                                            registeredClass,\n                                                            false,\n                                                            true,\n                                                            false);\n  \n          registeredPointers[rawType] = {\n            pointerType: pointerConverter,\n            constPointerType: constPointerConverter\n          };\n  \n          replacePublicSymbol(legalFunctionName, constructor);\n  \n          return [referenceConverter, pointerConverter, constPointerConverter];\n        }\n      );\n    }\n\n  function heap32VectorToArray(count, firstElement) {\n      var array = [];\n      for (var i = 0; i < count; i++) {\n          // TODO(https://github.com/emscripten-core/emscripten/issues/17310):\n          // Find a way to hoist the `>> 2` or `>> 3` out of this loop.\n          array.push(HEAPU32[(((firstElement)+(i * 4))>>2)]);\n      }\n      return array;\n    }\n  \n  function new_(constructor, argumentList) {\n      if (!(constructor instanceof Function)) {\n        throw new TypeError('new_ called with constructor type ' + typeof(constructor) + \" which is not a function\");\n      }\n      /*\n       * Previously, the following line was just:\n       *   function dummy() {};\n       * Unfortunately, Chrome was preserving 'dummy' as the object's name, even\n       * though at creation, the 'dummy' has the correct constructor name.  Thus,\n       * objects created with IMVU.new would show up in the debugger as 'dummy',\n       * which isn't very helpful.  Using IMVU.createNamedFunction addresses the\n       * issue.  Doublely-unfortunately, there's no way to write a test for this\n       * behavior.  -NRD 2013.02.22\n       */\n      var dummy = createNamedFunction(constructor.name || 'unknownFunctionName', function(){});\n      dummy.prototype = constructor.prototype;\n      var obj = new dummy;\n  \n      var r = constructor.apply(obj, argumentList);\n      return (r instanceof Object) ? r : obj;\n    }\n  function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {\n      // humanName: a human-readable string name for the function to be generated.\n      // argTypes: An array that contains the embind type objects for all types in the function signature.\n      //    argTypes[0] is the type object for the function return value.\n      //    argTypes[1] is the type object for function this object/class type, or null if not crafting an invoker for a class method.\n      //    argTypes[2...] are the actual function parameters.\n      // classType: The embind type object for the class to be bound, or null if this is not a method of a class.\n      // cppInvokerFunc: JS Function object to the C++-side function that interops into C++ code.\n      // cppTargetFunc: Function pointer (an integer to FUNCTION_TABLE) to the target C++ function the cppInvokerFunc will end up calling.\n      var argCount = argTypes.length;\n  \n      if (argCount < 2) {\n        throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n      }\n  \n      var isClassMethodFunc = (argTypes[1] !== null && classType !== null);\n  \n      // Free functions with signature \"void function()\" do not need an invoker that marshalls between wire types.\n  // TODO: This omits argument count check - enable only at -O3 or similar.\n  //    if (ENABLE_UNSAFE_OPTS && argCount == 2 && argTypes[0].name == \"void\" && !isClassMethodFunc) {\n  //       return FUNCTION_TABLE[fn];\n  //    }\n  \n      // Determine if we need to use a dynamic stack to store the destructors for the function parameters.\n      // TODO: Remove this completely once all function invokers are being dynamically generated.\n      var needsDestructorStack = false;\n  \n      for (var i = 1; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here.\n        if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) { // The type does not define a destructor function - must use dynamic stack\n          needsDestructorStack = true;\n          break;\n        }\n      }\n  \n      var returns = (argTypes[0].name !== \"void\");\n  \n      var argsList = \"\";\n      var argsListWired = \"\";\n      for (var i = 0; i < argCount - 2; ++i) {\n        argsList += (i!==0?\", \":\"\")+\"arg\"+i;\n        argsListWired += (i!==0?\", \":\"\")+\"arg\"+i+\"Wired\";\n      }\n  \n      var invokerFnBody =\n          \"return function \"+makeLegalFunctionName(humanName)+\"(\"+argsList+\") {\\n\" +\n          \"if (arguments.length !== \"+(argCount - 2)+\") {\\n\" +\n              \"throwBindingError('function \"+humanName+\" called with ' + arguments.length + ' arguments, expected \"+(argCount - 2)+\" args!');\\n\" +\n          \"}\\n\";\n  \n      if (needsDestructorStack) {\n        invokerFnBody += \"var destructors = [];\\n\";\n      }\n  \n      var dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\n      var args1 = [\"throwBindingError\", \"invoker\", \"fn\", \"runDestructors\", \"retType\", \"classParam\"];\n      var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];\n  \n      if (isClassMethodFunc) {\n        invokerFnBody += \"var thisWired = classParam.toWireType(\"+dtorStack+\", this);\\n\";\n      }\n  \n      for (var i = 0; i < argCount - 2; ++i) {\n        invokerFnBody += \"var arg\"+i+\"Wired = argType\"+i+\".toWireType(\"+dtorStack+\", arg\"+i+\"); // \"+argTypes[i+2].name+\"\\n\";\n        args1.push(\"argType\"+i);\n        args2.push(argTypes[i+2]);\n      }\n  \n      if (isClassMethodFunc) {\n        argsListWired = \"thisWired\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired;\n      }\n  \n      invokerFnBody +=\n          (returns?\"var rv = \":\"\") + \"invoker(fn\"+(argsListWired.length>0?\", \":\"\")+argsListWired+\");\\n\";\n  \n      if (needsDestructorStack) {\n        invokerFnBody += \"runDestructors(destructors);\\n\";\n      } else {\n        for (var i = isClassMethodFunc?1:2; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here. Also skip class type if not a method.\n          var paramName = (i === 1 ? \"thisWired\" : (\"arg\"+(i - 2)+\"Wired\"));\n          if (argTypes[i].destructorFunction !== null) {\n            invokerFnBody += paramName+\"_dtor(\"+paramName+\"); // \"+argTypes[i].name+\"\\n\";\n            args1.push(paramName+\"_dtor\");\n            args2.push(argTypes[i].destructorFunction);\n          }\n        }\n      }\n  \n      if (returns) {\n        invokerFnBody += \"var ret = retType.fromWireType(rv);\\n\" +\n                         \"return ret;\\n\";\n      } else {\n      }\n  \n      invokerFnBody += \"}\\n\";\n  \n      args1.push(invokerFnBody);\n  \n      var invokerFunction = new_(Function, args1).apply(null, args2);\n      return invokerFunction;\n    }\n  function __embind_register_class_constructor(\n      rawClassType,\n      argCount,\n      rawArgTypesAddr,\n      invokerSignature,\n      invoker,\n      rawConstructor\n    ) {\n      assert(argCount > 0);\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      invoker = embind__requireFunction(invokerSignature, invoker);\n      var args = [rawConstructor];\n      var destructors = [];\n  \n      whenDependentTypesAreResolved([], [rawClassType], function(classType) {\n        classType = classType[0];\n        var humanName = 'constructor ' + classType.name;\n  \n        if (undefined === classType.registeredClass.constructor_body) {\n          classType.registeredClass.constructor_body = [];\n        }\n        if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {\n          throw new BindingError(\"Cannot register multiple constructors with identical number of parameters (\" + (argCount-1) + \") for class '\" + classType.name + \"'! Overload resolution is currently only performed using the parameter count, not actual type info!\");\n        }\n        classType.registeredClass.constructor_body[argCount - 1] = () => {\n          throwUnboundTypeError('Cannot construct ' + classType.name + ' due to unbound types', rawArgTypes);\n        };\n  \n        whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {\n          // Insert empty slot for context type (argTypes[1]).\n          argTypes.splice(1, 0, null);\n          classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);\n          return [];\n        });\n        return [];\n      });\n    }\n\n  function __embind_register_class_function(rawClassType,\n                                              methodName,\n                                              argCount,\n                                              rawArgTypesAddr, // [ReturnType, ThisType, Args...]\n                                              invokerSignature,\n                                              rawInvoker,\n                                              context,\n                                              isPureVirtual) {\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      methodName = readLatin1String(methodName);\n      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\n  \n      whenDependentTypesAreResolved([], [rawClassType], function(classType) {\n        classType = classType[0];\n        var humanName = classType.name + '.' + methodName;\n  \n        if (methodName.startsWith(\"@@\")) {\n          methodName = Symbol[methodName.substring(2)];\n        }\n  \n        if (isPureVirtual) {\n          classType.registeredClass.pureVirtualFunctions.push(methodName);\n        }\n  \n        function unboundTypesHandler() {\n          throwUnboundTypeError('Cannot call ' + humanName + ' due to unbound types', rawArgTypes);\n        }\n  \n        var proto = classType.registeredClass.instancePrototype;\n        var method = proto[methodName];\n        if (undefined === method || (undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2)) {\n          // This is the first overload to be registered, OR we are replacing a\n          // function in the base class with a function in the derived class.\n          unboundTypesHandler.argCount = argCount - 2;\n          unboundTypesHandler.className = classType.name;\n          proto[methodName] = unboundTypesHandler;\n        } else {\n          // There was an existing function with the same name registered. Set up\n          // a function overload routing table.\n          ensureOverloadTable(proto, methodName, humanName);\n          proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\n        }\n  \n        whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {\n          var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);\n  \n          // Replace the initial unbound-handler-stub function with the appropriate member function, now that all types\n          // are resolved. If multiple overloads are registered for this function, the function goes into an overload table.\n          if (undefined === proto[methodName].overloadTable) {\n            // Set argCount in case an overload is registered later\n            memberFunction.argCount = argCount - 2;\n            proto[methodName] = memberFunction;\n          } else {\n            proto[methodName].overloadTable[argCount - 2] = memberFunction;\n          }\n  \n          return [];\n        });\n        return [];\n      });\n    }\n\n  function validateThis(this_, classType, humanName) {\n      if (!(this_ instanceof Object)) {\n        throwBindingError(humanName + ' with invalid \"this\": ' + this_);\n      }\n      if (!(this_ instanceof classType.registeredClass.constructor)) {\n        throwBindingError(humanName + ' incompatible with \"this\" of type ' + this_.constructor.name);\n      }\n      if (!this_.$$.ptr) {\n        throwBindingError('cannot call emscripten binding method ' + humanName + ' on deleted object');\n      }\n  \n      // todo: kill this\n      return upcastPointer(this_.$$.ptr,\n                           this_.$$.ptrType.registeredClass,\n                           classType.registeredClass);\n    }\n  function __embind_register_class_property(classType,\n                                              fieldName,\n                                              getterReturnType,\n                                              getterSignature,\n                                              getter,\n                                              getterContext,\n                                              setterArgumentType,\n                                              setterSignature,\n                                              setter,\n                                              setterContext) {\n      fieldName = readLatin1String(fieldName);\n      getter = embind__requireFunction(getterSignature, getter);\n  \n      whenDependentTypesAreResolved([], [classType], function(classType) {\n        classType = classType[0];\n        var humanName = classType.name + '.' + fieldName;\n        var desc = {\n          get: function() {\n            throwUnboundTypeError('Cannot access ' + humanName + ' due to unbound types', [getterReturnType, setterArgumentType]);\n          },\n          enumerable: true,\n          configurable: true\n        };\n        if (setter) {\n          desc.set = () => {\n            throwUnboundTypeError('Cannot access ' + humanName + ' due to unbound types', [getterReturnType, setterArgumentType]);\n          };\n        } else {\n          desc.set = (v) => {\n            throwBindingError(humanName + ' is a read-only property');\n          };\n        }\n  \n        Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);\n  \n        whenDependentTypesAreResolved(\n          [],\n          (setter ? [getterReturnType, setterArgumentType] : [getterReturnType]),\n      function(types) {\n          var getterReturnType = types[0];\n          var desc = {\n            get: function() {\n              var ptr = validateThis(this, classType, humanName + ' getter');\n              return getterReturnType['fromWireType'](getter(getterContext, ptr));\n            },\n            enumerable: true\n          };\n  \n          if (setter) {\n            setter = embind__requireFunction(setterSignature, setter);\n            var setterArgumentType = types[1];\n            desc.set = function(v) {\n              var ptr = validateThis(this, classType, humanName + ' setter');\n              var destructors = [];\n              setter(setterContext, ptr, setterArgumentType['toWireType'](destructors, v));\n              runDestructors(destructors);\n            };\n          }\n  \n          Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);\n          return [];\n        });\n  \n        return [];\n      });\n    }\n\n  var emval_free_list = [];\n  \n  var emval_handle_array = [{},{value:undefined},{value:null},{value:true},{value:false}];\n  function __emval_decref(handle) {\n      if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {\n        emval_handle_array[handle] = undefined;\n        emval_free_list.push(handle);\n      }\n    }\n  \n  function count_emval_handles() {\n      var count = 0;\n      for (var i = 5; i < emval_handle_array.length; ++i) {\n        if (emval_handle_array[i] !== undefined) {\n          ++count;\n        }\n      }\n      return count;\n    }\n  \n  function get_first_emval() {\n      for (var i = 5; i < emval_handle_array.length; ++i) {\n        if (emval_handle_array[i] !== undefined) {\n          return emval_handle_array[i];\n        }\n      }\n      return null;\n    }\n  function init_emval() {\n      Module['count_emval_handles'] = count_emval_handles;\n      Module['get_first_emval'] = get_first_emval;\n    }\n  var Emval = {toValue:(handle) => {\n        if (!handle) {\n            throwBindingError('Cannot use deleted val. handle = ' + handle);\n        }\n        return emval_handle_array[handle].value;\n      },toHandle:(value) => {\n        switch (value) {\n          case undefined: return 1;\n          case null: return 2;\n          case true: return 3;\n          case false: return 4;\n          default:{\n            var handle = emval_free_list.length ?\n                emval_free_list.pop() :\n                emval_handle_array.length;\n  \n            emval_handle_array[handle] = {refcount: 1, value: value};\n            return handle;\n          }\n        }\n      }};\n  function __embind_register_emval(rawType, name) {\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        'fromWireType': function(handle) {\n          var rv = Emval.toValue(handle);\n          __emval_decref(handle);\n          return rv;\n        },\n        'toWireType': function(destructors, value) {\n          return Emval.toHandle(value);\n        },\n        'argPackAdvance': 8,\n        'readValueFromPointer': simpleReadValueFromPointer,\n        destructorFunction: null, // This type does not need a destructor\n  \n        // TODO: do we need a deleteObject here?  write a test where\n        // emval is passed into JS via an interface\n      });\n    }\n\n  function embindRepr(v) {\n      if (v === null) {\n          return 'null';\n      }\n      var t = typeof v;\n      if (t === 'object' || t === 'array' || t === 'function') {\n          return v.toString();\n      } else {\n          return '' + v;\n      }\n    }\n  \n  function floatReadValueFromPointer(name, shift) {\n      switch (shift) {\n          case 2: return function(pointer) {\n              return this['fromWireType'](HEAPF32[pointer >> 2]);\n          };\n          case 3: return function(pointer) {\n              return this['fromWireType'](HEAPF64[pointer >> 3]);\n          };\n          default:\n              throw new TypeError(\"Unknown float type: \" + name);\n      }\n    }\n  function __embind_register_float(rawType, name, size) {\n      var shift = getShiftFromSize(size);\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        'fromWireType': function(value) {\n           return value;\n        },\n        'toWireType': function(destructors, value) {\n          // The VM will perform JS to Wasm value conversion, according to the spec:\n          // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue\n          return value;\n        },\n        'argPackAdvance': 8,\n        'readValueFromPointer': floatReadValueFromPointer(name, shift),\n        destructorFunction: null, // This type does not need a destructor\n      });\n    }\n\n  function __embind_register_function(name, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {\n      var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      name = readLatin1String(name);\n  \n      rawInvoker = embind__requireFunction(signature, rawInvoker);\n  \n      exposePublicSymbol(name, function() {\n        throwUnboundTypeError('Cannot call ' + name + ' due to unbound types', argTypes);\n      }, argCount - 1);\n  \n      whenDependentTypesAreResolved([], argTypes, function(argTypes) {\n        var invokerArgsArray = [argTypes[0] /* return value */, null /* no class 'this'*/].concat(argTypes.slice(1) /* actual params */);\n        replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null /* no class 'this'*/, rawInvoker, fn), argCount - 1);\n        return [];\n      });\n    }\n\n  function integerReadValueFromPointer(name, shift, signed) {\n      // integers are quite common, so generate very specialized functions\n      switch (shift) {\n          case 0: return signed ?\n              function readS8FromPointer(pointer) { return HEAP8[pointer]; } :\n              function readU8FromPointer(pointer) { return HEAPU8[pointer]; };\n          case 1: return signed ?\n              function readS16FromPointer(pointer) { return HEAP16[pointer >> 1]; } :\n              function readU16FromPointer(pointer) { return HEAPU16[pointer >> 1]; };\n          case 2: return signed ?\n              function readS32FromPointer(pointer) { return HEAP32[pointer >> 2]; } :\n              function readU32FromPointer(pointer) { return HEAPU32[pointer >> 2]; };\n          default:\n              throw new TypeError(\"Unknown integer type: \" + name);\n      }\n    }\n  function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {\n      name = readLatin1String(name);\n      // LLVM doesn't have signed and unsigned 32-bit types, so u32 literals come\n      // out as 'i32 -1'. Always treat those as max u32.\n      if (maxRange === -1) {\n          maxRange = 4294967295;\n      }\n  \n      var shift = getShiftFromSize(size);\n  \n      var fromWireType = (value) => value;\n  \n      if (minRange === 0) {\n          var bitshift = 32 - 8*size;\n          fromWireType = (value) => (value << bitshift) >>> bitshift;\n      }\n  \n      var isUnsignedType = (name.includes('unsigned'));\n      var checkAssertions = (value, toTypeName) => {\n      }\n      var toWireType;\n      if (isUnsignedType) {\n        toWireType = function(destructors, value) {\n          checkAssertions(value, this.name);\n          return value >>> 0;\n        }\n      } else {\n        toWireType = function(destructors, value) {\n          checkAssertions(value, this.name);\n          // The VM will perform JS to Wasm value conversion, according to the spec:\n          // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue\n          return value;\n        }\n      }\n      registerType(primitiveType, {\n        name: name,\n        'fromWireType': fromWireType,\n        'toWireType': toWireType,\n        'argPackAdvance': 8,\n        'readValueFromPointer': integerReadValueFromPointer(name, shift, minRange !== 0),\n        destructorFunction: null, // This type does not need a destructor\n      });\n    }\n\n  function __embind_register_memory_view(rawType, dataTypeIndex, name) {\n      var typeMapping = [\n        Int8Array,\n        Uint8Array,\n        Int16Array,\n        Uint16Array,\n        Int32Array,\n        Uint32Array,\n        Float32Array,\n        Float64Array,\n      ];\n  \n      var TA = typeMapping[dataTypeIndex];\n  \n      function decodeMemoryView(handle) {\n        handle = handle >> 2;\n        var heap = HEAPU32;\n        var size = heap[handle]; // in elements\n        var data = heap[handle + 1]; // byte offset into emscripten heap\n        return new TA(buffer, data, size);\n      }\n  \n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        'fromWireType': decodeMemoryView,\n        'argPackAdvance': 8,\n        'readValueFromPointer': decodeMemoryView,\n      }, {\n        ignoreDuplicateRegistrations: true,\n      });\n    }\n\n  function __embind_register_std_string(rawType, name) {\n      name = readLatin1String(name);\n      var stdStringIsUTF8\n      //process only std::string bindings with UTF8 support, in contrast to e.g. std::basic_string<unsigned char>\n      = (name === \"std::string\");\n  \n      registerType(rawType, {\n        name: name,\n        'fromWireType': function(value) {\n          var length = HEAPU32[((value)>>2)];\n          var payload = value + 4;\n  \n          var str;\n          if (stdStringIsUTF8) {\n            var decodeStartPtr = payload;\n            // Looping here to support possible embedded '0' bytes\n            for (var i = 0; i <= length; ++i) {\n              var currentBytePtr = payload + i;\n              if (i == length || HEAPU8[currentBytePtr] == 0) {\n                var maxRead = currentBytePtr - decodeStartPtr;\n                var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\n                if (str === undefined) {\n                  str = stringSegment;\n                } else {\n                  str += String.fromCharCode(0);\n                  str += stringSegment;\n                }\n                decodeStartPtr = currentBytePtr + 1;\n              }\n            }\n          } else {\n            var a = new Array(length);\n            for (var i = 0; i < length; ++i) {\n              a[i] = String.fromCharCode(HEAPU8[payload + i]);\n            }\n            str = a.join('');\n          }\n  \n          _free(value);\n  \n          return str;\n        },\n        'toWireType': function(destructors, value) {\n          if (value instanceof ArrayBuffer) {\n            value = new Uint8Array(value);\n          }\n  \n          var length;\n          var valueIsOfTypeString = (typeof value == 'string');\n  \n          if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {\n            throwBindingError('Cannot pass non-string to std::string');\n          }\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\n            length = lengthBytesUTF8(value);\n          } else {\n            length = value.length;\n          }\n  \n          // assumes 4-byte alignment\n          var base = _malloc(4 + length + 1);\n          var ptr = base + 4;\n          HEAPU32[((base)>>2)] = length;\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\n            stringToUTF8(value, ptr, length + 1);\n          } else {\n            if (valueIsOfTypeString) {\n              for (var i = 0; i < length; ++i) {\n                var charCode = value.charCodeAt(i);\n                if (charCode > 255) {\n                  _free(ptr);\n                  throwBindingError('String has UTF-16 code units that do not fit in 8 bits');\n                }\n                HEAPU8[ptr + i] = charCode;\n              }\n            } else {\n              for (var i = 0; i < length; ++i) {\n                HEAPU8[ptr + i] = value[i];\n              }\n            }\n          }\n  \n          if (destructors !== null) {\n            destructors.push(_free, base);\n          }\n          return base;\n        },\n        'argPackAdvance': 8,\n        'readValueFromPointer': simpleReadValueFromPointer,\n        destructorFunction: function(ptr) { _free(ptr); },\n      });\n    }\n\n  var UTF16Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf-16le') : undefined;;\n  function UTF16ToString(ptr, maxBytesToRead) {\n      var endPtr = ptr;\n      // TextDecoder needs to know the byte length in advance, it doesn't stop on\n      // null terminator by itself.\n      // Also, use the length info to avoid running tiny strings through\n      // TextDecoder, since .subarray() allocates garbage.\n      var idx = endPtr >> 1;\n      var maxIdx = idx + maxBytesToRead / 2;\n      // If maxBytesToRead is not passed explicitly, it will be undefined, and this\n      // will always evaluate to true. This saves on code size.\n      while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;\n      endPtr = idx << 1;\n  \n      if (endPtr - ptr > 32 && UTF16Decoder)\n        return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n  \n      // Fallback: decode without UTF16Decoder\n      var str = '';\n  \n      // If maxBytesToRead is not passed explicitly, it will be undefined, and the\n      // for-loop's condition will always evaluate to true. The loop is then\n      // terminated on the first null char.\n      for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\n        var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];\n        if (codeUnit == 0) break;\n        // fromCharCode constructs a character from a UTF-16 code unit, so we can\n        // pass the UTF16 string right through.\n        str += String.fromCharCode(codeUnit);\n      }\n  \n      return str;\n    }\n  \n  function stringToUTF16(str, outPtr, maxBytesToWrite) {\n      // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n      if (maxBytesToWrite === undefined) {\n        maxBytesToWrite = 0x7FFFFFFF;\n      }\n      if (maxBytesToWrite < 2) return 0;\n      maxBytesToWrite -= 2; // Null terminator.\n      var startPtr = outPtr;\n      var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;\n      for (var i = 0; i < numCharsToWrite; ++i) {\n        // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\n        var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n        HEAP16[((outPtr)>>1)] = codeUnit;\n        outPtr += 2;\n      }\n      // Null-terminate the pointer to the HEAP.\n      HEAP16[((outPtr)>>1)] = 0;\n      return outPtr - startPtr;\n    }\n  \n  function lengthBytesUTF16(str) {\n      return str.length*2;\n    }\n  \n  function UTF32ToString(ptr, maxBytesToRead) {\n      var i = 0;\n  \n      var str = '';\n      // If maxBytesToRead is not passed explicitly, it will be undefined, and this\n      // will always evaluate to true. This saves on code size.\n      while (!(i >= maxBytesToRead / 4)) {\n        var utf32 = HEAP32[(((ptr)+(i*4))>>2)];\n        if (utf32 == 0) break;\n        ++i;\n        // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        if (utf32 >= 0x10000) {\n          var ch = utf32 - 0x10000;\n          str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n        } else {\n          str += String.fromCharCode(utf32);\n        }\n      }\n      return str;\n    }\n  \n  function stringToUTF32(str, outPtr, maxBytesToWrite) {\n      // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n      if (maxBytesToWrite === undefined) {\n        maxBytesToWrite = 0x7FFFFFFF;\n      }\n      if (maxBytesToWrite < 4) return 0;\n      var startPtr = outPtr;\n      var endPtr = startPtr + maxBytesToWrite - 4;\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n        if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\n          var trailSurrogate = str.charCodeAt(++i);\n          codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);\n        }\n        HEAP32[((outPtr)>>2)] = codeUnit;\n        outPtr += 4;\n        if (outPtr + 4 > endPtr) break;\n      }\n      // Null-terminate the pointer to the HEAP.\n      HEAP32[((outPtr)>>2)] = 0;\n      return outPtr - startPtr;\n    }\n  \n  function lengthBytesUTF32(str) {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        var codeUnit = str.charCodeAt(i);\n        if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\n        len += 4;\n      }\n  \n      return len;\n    }\n  function __embind_register_std_wstring(rawType, charSize, name) {\n      name = readLatin1String(name);\n      var decodeString, encodeString, getHeap, lengthBytesUTF, shift;\n      if (charSize === 2) {\n        decodeString = UTF16ToString;\n        encodeString = stringToUTF16;\n        lengthBytesUTF = lengthBytesUTF16;\n        getHeap = () => HEAPU16;\n        shift = 1;\n      } else if (charSize === 4) {\n        decodeString = UTF32ToString;\n        encodeString = stringToUTF32;\n        lengthBytesUTF = lengthBytesUTF32;\n        getHeap = () => HEAPU32;\n        shift = 2;\n      }\n      registerType(rawType, {\n        name: name,\n        'fromWireType': function(value) {\n          // Code mostly taken from _embind_register_std_string fromWireType\n          var length = HEAPU32[value >> 2];\n          var HEAP = getHeap();\n          var str;\n  \n          var decodeStartPtr = value + 4;\n          // Looping here to support possible embedded '0' bytes\n          for (var i = 0; i <= length; ++i) {\n            var currentBytePtr = value + 4 + i * charSize;\n            if (i == length || HEAP[currentBytePtr >> shift] == 0) {\n              var maxReadBytes = currentBytePtr - decodeStartPtr;\n              var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\n              if (str === undefined) {\n                str = stringSegment;\n              } else {\n                str += String.fromCharCode(0);\n                str += stringSegment;\n              }\n              decodeStartPtr = currentBytePtr + charSize;\n            }\n          }\n  \n          _free(value);\n  \n          return str;\n        },\n        'toWireType': function(destructors, value) {\n          if (!(typeof value == 'string')) {\n            throwBindingError('Cannot pass non-string to C++ string type ' + name);\n          }\n  \n          // assumes 4-byte alignment\n          var length = lengthBytesUTF(value);\n          var ptr = _malloc(4 + length + charSize);\n          HEAPU32[ptr >> 2] = length >> shift;\n  \n          encodeString(value, ptr + 4, length + charSize);\n  \n          if (destructors !== null) {\n            destructors.push(_free, ptr);\n          }\n          return ptr;\n        },\n        'argPackAdvance': 8,\n        'readValueFromPointer': simpleReadValueFromPointer,\n        destructorFunction: function(ptr) { _free(ptr); },\n      });\n    }\n\n  function __embind_register_value_object(\n      rawType,\n      name,\n      constructorSignature,\n      rawConstructor,\n      destructorSignature,\n      rawDestructor\n    ) {\n      structRegistrations[rawType] = {\n        name: readLatin1String(name),\n        rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),\n        rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),\n        fields: [],\n      };\n    }\n\n  function __embind_register_void(rawType, name) {\n      name = readLatin1String(name);\n      registerType(rawType, {\n          isVoid: true, // void return values can be optimized out sometimes\n          name: name,\n          'argPackAdvance': 0,\n          'fromWireType': function() {\n              return undefined;\n          },\n          'toWireType': function(destructors, o) {\n              // TODO: assert if anything else is given?\n              return undefined;\n          },\n      });\n    }\n\n  function requireRegisteredType(rawType, humanName) {\n      var impl = registeredTypes[rawType];\n      if (undefined === impl) {\n          throwBindingError(humanName + \" has unknown type \" + getTypeName(rawType));\n      }\n      return impl;\n    }\n  function __emval_as(handle, returnType, destructorsRef) {\n      handle = Emval.toValue(handle);\n      returnType = requireRegisteredType(returnType, 'emval::as');\n      var destructors = [];\n      var rd = Emval.toHandle(destructors);\n      HEAPU32[((destructorsRef)>>2)] = rd;\n      return returnType['toWireType'](destructors, handle);\n    }\n\n  function emval_allocateDestructors(destructorsRef) {\n      var destructors = [];\n      HEAPU32[((destructorsRef)>>2)] = Emval.toHandle(destructors);\n      return destructors;\n    }\n  \n  var emval_symbols = {};\n  function getStringOrSymbol(address) {\n      var symbol = emval_symbols[address];\n      if (symbol === undefined) {\n        return readLatin1String(address);\n      }\n      return symbol;\n    }\n  \n  var emval_methodCallers = [];\n  function __emval_call_method(caller, handle, methodName, destructorsRef, args) {\n      caller = emval_methodCallers[caller];\n      handle = Emval.toValue(handle);\n      methodName = getStringOrSymbol(methodName);\n      return caller(handle, methodName, emval_allocateDestructors(destructorsRef), args);\n    }\n\n  function __emval_call_void_method(caller, handle, methodName, args) {\n      caller = emval_methodCallers[caller];\n      handle = Emval.toValue(handle);\n      methodName = getStringOrSymbol(methodName);\n      caller(handle, methodName, null, args);\n    }\n\n\n  function emval_get_global() {\n      if (typeof globalThis == 'object') {\n        return globalThis;\n      }\n      return (function(){\n        return Function;\n      })()('return this')();\n    }\n  function __emval_get_global(name) {\n      if (name===0) {\n        return Emval.toHandle(emval_get_global());\n      } else {\n        name = getStringOrSymbol(name);\n        return Emval.toHandle(emval_get_global()[name]);\n      }\n    }\n\n  function emval_addMethodCaller(caller) {\n      var id = emval_methodCallers.length;\n      emval_methodCallers.push(caller);\n      return id;\n    }\n  \n  function emval_lookupTypes(argCount, argTypes) {\n      var a = new Array(argCount);\n      for (var i = 0; i < argCount; ++i) {\n        a[i] = requireRegisteredType(HEAPU32[(((argTypes)+(i * POINTER_SIZE))>>2)],\n                                     \"parameter \" + i);\n      }\n      return a;\n    }\n  \n  var emval_registeredMethods = [];\n  function __emval_get_method_caller(argCount, argTypes) {\n      var types = emval_lookupTypes(argCount, argTypes);\n      var retType = types[0];\n      var signatureName = retType.name + \"_$\" + types.slice(1).map(function (t) { return t.name; }).join(\"_\") + \"$\";\n      var returnId = emval_registeredMethods[signatureName];\n      if (returnId !== undefined) {\n        return returnId;\n      }\n  \n      var params = [\"retType\"];\n      var args = [retType];\n  \n      var argsList = \"\"; // 'arg0, arg1, arg2, ... , argN'\n      for (var i = 0; i < argCount - 1; ++i) {\n        argsList += (i !== 0 ? \", \" : \"\") + \"arg\" + i;\n        params.push(\"argType\" + i);\n        args.push(types[1 + i]);\n      }\n  \n      var functionName = makeLegalFunctionName(\"methodCaller_\" + signatureName);\n      var functionBody =\n          \"return function \" + functionName + \"(handle, name, destructors, args) {\\n\";\n  \n      var offset = 0;\n      for (var i = 0; i < argCount - 1; ++i) {\n          functionBody +=\n          \"    var arg\" + i + \" = argType\" + i + \".readValueFromPointer(args\" + (offset ? (\"+\"+offset) : \"\") + \");\\n\";\n          offset += types[i + 1]['argPackAdvance'];\n      }\n      functionBody +=\n          \"    var rv = handle[name](\" + argsList + \");\\n\";\n      for (var i = 0; i < argCount - 1; ++i) {\n          if (types[i + 1]['deleteObject']) {\n              functionBody +=\n              \"    argType\" + i + \".deleteObject(arg\" + i + \");\\n\";\n          }\n      }\n      if (!retType.isVoid) {\n          functionBody +=\n          \"    return retType.toWireType(destructors, rv);\\n\";\n      }\n      functionBody +=\n          \"};\\n\";\n  \n      params.push(functionBody);\n      var invokerFunction = new_(Function, params).apply(null, args);\n      returnId = emval_addMethodCaller(invokerFunction);\n      emval_registeredMethods[signatureName] = returnId;\n      return returnId;\n    }\n\n  function __emval_get_property(handle, key) {\n      handle = Emval.toValue(handle);\n      key = Emval.toValue(key);\n      return Emval.toHandle(handle[key]);\n    }\n\n  function __emval_incref(handle) {\n      if (handle > 4) {\n        emval_handle_array[handle].refcount += 1;\n      }\n    }\n\n  function __emval_new_array() {\n      return Emval.toHandle([]);\n    }\n\n  function __emval_new_cstring(v) {\n      return Emval.toHandle(getStringOrSymbol(v));\n    }\n\n  function __emval_run_destructors(handle) {\n      var destructors = Emval.toValue(handle);\n      runDestructors(destructors);\n      __emval_decref(handle);\n    }\n\n  function __emval_take_value(type, arg) {\n      type = requireRegisteredType(type, '_emval_take_value');\n      var v = type['readValueFromPointer'](arg);\n      return Emval.toHandle(v);\n    }\n\n  function _abort() {\n      abort('');\n    }\n\n  function _emscripten_memcpy_big(dest, src, num) {\n      HEAPU8.copyWithin(dest, src, src + num);\n    }\n\n  function getHeapMax() {\n      // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate\n      // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side\n      // for any code that deals with heap sizes, which would require special\n      // casing all heap size related code to treat 0 specially.\n      return 2147483648;\n    }\n  \n  function emscripten_realloc_buffer(size) {\n      try {\n        // round size grow request up to wasm page size (fixed 64KB per spec)\n        wasmMemory.grow((size - buffer.byteLength + 65535) >>> 16); // .grow() takes a delta compared to the previous size\n        updateGlobalBufferAndViews(wasmMemory.buffer);\n        return 1 /*success*/;\n      } catch(e) {\n      }\n      // implicit 0 return to save code size (caller will cast \"undefined\" into 0\n      // anyhow)\n    }\n  function _emscripten_resize_heap(requestedSize) {\n      var oldSize = HEAPU8.length;\n      requestedSize = requestedSize >>> 0;\n      // With multithreaded builds, races can happen (another thread might increase the size\n      // in between), so return a failure, and let the caller retry.\n  \n      // Memory resize rules:\n      // 1.  Always increase heap size to at least the requested size, rounded up\n      //     to next page multiple.\n      // 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap\n      //     geometrically: increase the heap size according to\n      //     MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%), At most\n      //     overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).\n      // 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap\n      //     linearly: increase the heap size by at least\n      //     MEMORY_GROWTH_LINEAR_STEP bytes.\n      // 3.  Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by\n      //     MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest\n      // 4.  If we were unable to allocate as much memory, it may be due to\n      //     over-eager decision to excessively reserve due to (3) above.\n      //     Hence if an allocation fails, cut down on the amount of excess\n      //     growth, in an attempt to succeed to perform a smaller allocation.\n  \n      // A limit is set for how much we can grow. We should not exceed that\n      // (the wasm binary specifies it, so if we tried, we'd fail anyhow).\n      var maxHeapSize = getHeapMax();\n      if (requestedSize > maxHeapSize) {\n        return false;\n      }\n  \n      let alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;\n  \n      // Loop through potential heap size increases. If we attempt a too eager\n      // reservation that fails, cut down on the attempted size and reserve a\n      // smaller bump instead. (max 3 times, chosen somewhat arbitrarily)\n      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth\n        // but limit overreserving (default to capping at +96MB overgrowth at most)\n        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296 );\n  \n        var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\n  \n        var replacement = emscripten_realloc_buffer(newSize);\n        if (replacement) {\n  \n          return true;\n        }\n      }\n      return false;\n    }\n\n  var ENV = {};\n  \n  function getExecutableName() {\n      return thisProgram || './this.program';\n    }\n  function getEnvStrings() {\n      if (!getEnvStrings.strings) {\n        // Default values.\n        // Browser language detection #8751\n        var lang = ((typeof navigator == 'object' && navigator.languages && navigator.languages[0]) || 'C').replace('-', '_') + '.UTF-8';\n        var env = {\n          'USER': 'web_user',\n          'LOGNAME': 'web_user',\n          'PATH': '/',\n          'PWD': '/',\n          'HOME': '/home/web_user',\n          'LANG': lang,\n          '_': getExecutableName()\n        };\n        // Apply the user-provided values, if any.\n        for (var x in ENV) {\n          // x is a key in ENV; if ENV[x] is undefined, that means it was\n          // explicitly set to be so. We allow user code to do that to\n          // force variables with default values to remain unset.\n          if (ENV[x] === undefined) delete env[x];\n          else env[x] = ENV[x];\n        }\n        var strings = [];\n        for (var x in env) {\n          strings.push(x + '=' + env[x]);\n        }\n        getEnvStrings.strings = strings;\n      }\n      return getEnvStrings.strings;\n    }\n  \n  /** @param {boolean=} dontAddNull */\n  function writeAsciiToMemory(str, buffer, dontAddNull) {\n      for (var i = 0; i < str.length; ++i) {\n        HEAP8[((buffer++)>>0)] = str.charCodeAt(i);\n      }\n      // Null-terminate the pointer to the HEAP.\n      if (!dontAddNull) HEAP8[((buffer)>>0)] = 0;\n    }\n  \n  var PATH = {isAbs:(path) => path.charAt(0) === '/',splitPath:(filename) => {\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n        return splitPathRe.exec(filename).slice(1);\n      },normalizeArray:(parts, allowAboveRoot) => {\n        // if the path tries to go above the root, `up` ends up > 0\n        var up = 0;\n        for (var i = parts.length - 1; i >= 0; i--) {\n          var last = parts[i];\n          if (last === '.') {\n            parts.splice(i, 1);\n          } else if (last === '..') {\n            parts.splice(i, 1);\n            up++;\n          } else if (up) {\n            parts.splice(i, 1);\n            up--;\n          }\n        }\n        // if the path is allowed to go above the root, restore leading ..s\n        if (allowAboveRoot) {\n          for (; up; up--) {\n            parts.unshift('..');\n          }\n        }\n        return parts;\n      },normalize:(path) => {\n        var isAbsolute = PATH.isAbs(path),\n            trailingSlash = path.substr(-1) === '/';\n        // Normalize the path\n        path = PATH.normalizeArray(path.split('/').filter((p) => !!p), !isAbsolute).join('/');\n        if (!path && !isAbsolute) {\n          path = '.';\n        }\n        if (path && trailingSlash) {\n          path += '/';\n        }\n        return (isAbsolute ? '/' : '') + path;\n      },dirname:(path) => {\n        var result = PATH.splitPath(path),\n            root = result[0],\n            dir = result[1];\n        if (!root && !dir) {\n          // No dirname whatsoever\n          return '.';\n        }\n        if (dir) {\n          // It has a dirname, strip trailing slash\n          dir = dir.substr(0, dir.length - 1);\n        }\n        return root + dir;\n      },basename:(path) => {\n        // EMSCRIPTEN return '/'' for '/', not an empty string\n        if (path === '/') return '/';\n        path = PATH.normalize(path);\n        path = path.replace(/\\/$/, \"\");\n        var lastSlash = path.lastIndexOf('/');\n        if (lastSlash === -1) return path;\n        return path.substr(lastSlash+1);\n      },join:function() {\n        var paths = Array.prototype.slice.call(arguments);\n        return PATH.normalize(paths.join('/'));\n      },join2:(l, r) => {\n        return PATH.normalize(l + '/' + r);\n      }};\n  \n  function getRandomDevice() {\n      if (typeof crypto == 'object' && typeof crypto['getRandomValues'] == 'function') {\n        // for modern web browsers\n        var randomBuffer = new Uint8Array(1);\n        return () => { crypto.getRandomValues(randomBuffer); return randomBuffer[0]; };\n      } else\n      if (ENVIRONMENT_IS_NODE) {\n        // for nodejs with or without crypto support included\n        try {\n          var crypto_module = __webpack_require__(/*! crypto */ \"?13b2\");\n          // nodejs has crypto support\n          return () => crypto_module['randomBytes'](1)[0];\n        } catch (e) {\n          // nodejs doesn't have crypto support\n        }\n      }\n      // we couldn't find a proper implementation, as Math.random() is not suitable for /dev/random, see emscripten-core/emscripten/pull/7096\n      return () => abort(\"randomDevice\");\n    }\n  \n  var PATH_FS = {resolve:function() {\n        var resolvedPath = '',\n          resolvedAbsolute = false;\n        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n          var path = (i >= 0) ? arguments[i] : FS.cwd();\n          // Skip empty and invalid entries\n          if (typeof path != 'string') {\n            throw new TypeError('Arguments to path.resolve must be strings');\n          } else if (!path) {\n            return ''; // an invalid portion invalidates the whole thing\n          }\n          resolvedPath = path + '/' + resolvedPath;\n          resolvedAbsolute = PATH.isAbs(path);\n        }\n        // At this point the path should be resolved to a full absolute path, but\n        // handle relative paths to be safe (might happen when process.cwd() fails)\n        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter((p) => !!p), !resolvedAbsolute).join('/');\n        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n      },relative:(from, to) => {\n        from = PATH_FS.resolve(from).substr(1);\n        to = PATH_FS.resolve(to).substr(1);\n        function trim(arr) {\n          var start = 0;\n          for (; start < arr.length; start++) {\n            if (arr[start] !== '') break;\n          }\n          var end = arr.length - 1;\n          for (; end >= 0; end--) {\n            if (arr[end] !== '') break;\n          }\n          if (start > end) return [];\n          return arr.slice(start, end - start + 1);\n        }\n        var fromParts = trim(from.split('/'));\n        var toParts = trim(to.split('/'));\n        var length = Math.min(fromParts.length, toParts.length);\n        var samePartsLength = length;\n        for (var i = 0; i < length; i++) {\n          if (fromParts[i] !== toParts[i]) {\n            samePartsLength = i;\n            break;\n          }\n        }\n        var outputParts = [];\n        for (var i = samePartsLength; i < fromParts.length; i++) {\n          outputParts.push('..');\n        }\n        outputParts = outputParts.concat(toParts.slice(samePartsLength));\n        return outputParts.join('/');\n      }};\n  \n  /** @type {function(string, boolean=, number=)} */\n  function intArrayFromString(stringy, dontAddNull, length) {\n    var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;\n    var u8array = new Array(len);\n    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n    if (dontAddNull) u8array.length = numBytesWritten;\n    return u8array;\n  }\n  var TTY = {ttys:[],init:function () {\n        // https://github.com/emscripten-core/emscripten/pull/1555\n        // if (ENVIRONMENT_IS_NODE) {\n        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY\n        //   // device, it always assumes it's a TTY device. because of this, we're forcing\n        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible\n        //   // with text files until FS.init can be refactored.\n        //   process['stdin']['setEncoding']('utf8');\n        // }\n      },shutdown:function() {\n        // https://github.com/emscripten-core/emscripten/pull/1555\n        // if (ENVIRONMENT_IS_NODE) {\n        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?\n        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation\n        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?\n        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle\n        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call\n        //   process['stdin']['pause']();\n        // }\n      },register:function(dev, ops) {\n        TTY.ttys[dev] = { input: [], output: [], ops: ops };\n        FS.registerDevice(dev, TTY.stream_ops);\n      },stream_ops:{open:function(stream) {\n          var tty = TTY.ttys[stream.node.rdev];\n          if (!tty) {\n            throw new FS.ErrnoError(43);\n          }\n          stream.tty = tty;\n          stream.seekable = false;\n        },close:function(stream) {\n          // flush any pending line data\n          stream.tty.ops.fsync(stream.tty);\n        },fsync:function(stream) {\n          stream.tty.ops.fsync(stream.tty);\n        },read:function(stream, buffer, offset, length, pos /* ignored */) {\n          if (!stream.tty || !stream.tty.ops.get_char) {\n            throw new FS.ErrnoError(60);\n          }\n          var bytesRead = 0;\n          for (var i = 0; i < length; i++) {\n            var result;\n            try {\n              result = stream.tty.ops.get_char(stream.tty);\n            } catch (e) {\n              throw new FS.ErrnoError(29);\n            }\n            if (result === undefined && bytesRead === 0) {\n              throw new FS.ErrnoError(6);\n            }\n            if (result === null || result === undefined) break;\n            bytesRead++;\n            buffer[offset+i] = result;\n          }\n          if (bytesRead) {\n            stream.node.timestamp = Date.now();\n          }\n          return bytesRead;\n        },write:function(stream, buffer, offset, length, pos) {\n          if (!stream.tty || !stream.tty.ops.put_char) {\n            throw new FS.ErrnoError(60);\n          }\n          try {\n            for (var i = 0; i < length; i++) {\n              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);\n            }\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n          if (length) {\n            stream.node.timestamp = Date.now();\n          }\n          return i;\n        }},default_tty_ops:{get_char:function(tty) {\n          if (!tty.input.length) {\n            var result = null;\n            if (ENVIRONMENT_IS_NODE) {\n              // we will read data by chunks of BUFSIZE\n              var BUFSIZE = 256;\n              var buf = Buffer.alloc(BUFSIZE);\n              var bytesRead = 0;\n  \n              try {\n                bytesRead = fs.readSync(process.stdin.fd, buf, 0, BUFSIZE, -1);\n              } catch(e) {\n                // Cross-platform differences: on Windows, reading EOF throws an exception, but on other OSes,\n                // reading EOF returns 0. Uniformize behavior by treating the EOF exception to return 0.\n                if (e.toString().includes('EOF')) bytesRead = 0;\n                else throw e;\n              }\n  \n              if (bytesRead > 0) {\n                result = buf.slice(0, bytesRead).toString('utf-8');\n              } else {\n                result = null;\n              }\n            } else\n            if (typeof window != 'undefined' &&\n              typeof window.prompt == 'function') {\n              // Browser.\n              result = window.prompt('Input: ');  // returns null on cancel\n              if (result !== null) {\n                result += '\\n';\n              }\n            } else if (typeof readline == 'function') {\n              // Command line.\n              result = readline();\n              if (result !== null) {\n                result += '\\n';\n              }\n            }\n            if (!result) {\n              return null;\n            }\n            tty.input = intArrayFromString(result, true);\n          }\n          return tty.input.shift();\n        },put_char:function(tty, val) {\n          if (val === null || val === 10) {\n            out(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.\n          }\n        },fsync:function(tty) {\n          if (tty.output && tty.output.length > 0) {\n            out(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          }\n        }},default_tty1_ops:{put_char:function(tty, val) {\n          if (val === null || val === 10) {\n            err(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val);\n          }\n        },fsync:function(tty) {\n          if (tty.output && tty.output.length > 0) {\n            err(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          }\n        }}};\n  \n  function zeroMemory(address, size) {\n      HEAPU8.fill(0, address, address + size);\n      return address;\n    }\n  \n  function alignMemory(size, alignment) {\n      return Math.ceil(size / alignment) * alignment;\n    }\n  function mmapAlloc(size) {\n      abort();\n    }\n  var MEMFS = {ops_table:null,mount:function(mount) {\n        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);\n      },createNode:function(parent, name, mode, dev) {\n        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n          // no supported\n          throw new FS.ErrnoError(63);\n        }\n        if (!MEMFS.ops_table) {\n          MEMFS.ops_table = {\n            dir: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr,\n                lookup: MEMFS.node_ops.lookup,\n                mknod: MEMFS.node_ops.mknod,\n                rename: MEMFS.node_ops.rename,\n                unlink: MEMFS.node_ops.unlink,\n                rmdir: MEMFS.node_ops.rmdir,\n                readdir: MEMFS.node_ops.readdir,\n                symlink: MEMFS.node_ops.symlink\n              },\n              stream: {\n                llseek: MEMFS.stream_ops.llseek\n              }\n            },\n            file: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr\n              },\n              stream: {\n                llseek: MEMFS.stream_ops.llseek,\n                read: MEMFS.stream_ops.read,\n                write: MEMFS.stream_ops.write,\n                allocate: MEMFS.stream_ops.allocate,\n                mmap: MEMFS.stream_ops.mmap,\n                msync: MEMFS.stream_ops.msync\n              }\n            },\n            link: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr,\n                readlink: MEMFS.node_ops.readlink\n              },\n              stream: {}\n            },\n            chrdev: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr\n              },\n              stream: FS.chrdev_stream_ops\n            }\n          };\n        }\n        var node = FS.createNode(parent, name, mode, dev);\n        if (FS.isDir(node.mode)) {\n          node.node_ops = MEMFS.ops_table.dir.node;\n          node.stream_ops = MEMFS.ops_table.dir.stream;\n          node.contents = {};\n        } else if (FS.isFile(node.mode)) {\n          node.node_ops = MEMFS.ops_table.file.node;\n          node.stream_ops = MEMFS.ops_table.file.stream;\n          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.\n          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred\n          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size\n          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.\n          node.contents = null; \n        } else if (FS.isLink(node.mode)) {\n          node.node_ops = MEMFS.ops_table.link.node;\n          node.stream_ops = MEMFS.ops_table.link.stream;\n        } else if (FS.isChrdev(node.mode)) {\n          node.node_ops = MEMFS.ops_table.chrdev.node;\n          node.stream_ops = MEMFS.ops_table.chrdev.stream;\n        }\n        node.timestamp = Date.now();\n        // add the new node to the parent\n        if (parent) {\n          parent.contents[name] = node;\n          parent.timestamp = node.timestamp;\n        }\n        return node;\n      },getFileDataAsTypedArray:function(node) {\n        if (!node.contents) return new Uint8Array(0);\n        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.\n        return new Uint8Array(node.contents);\n      },expandFileStorage:function(node, newCapacity) {\n        var prevCapacity = node.contents ? node.contents.length : 0;\n        if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.\n        // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.\n        // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to\n        // avoid overshooting the allocation cap by a very large margin.\n        var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n        newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0);\n        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.\n        var oldContents = node.contents;\n        node.contents = new Uint8Array(newCapacity); // Allocate new storage.\n        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.\n      },resizeFileStorage:function(node, newSize) {\n        if (node.usedBytes == newSize) return;\n        if (newSize == 0) {\n          node.contents = null; // Fully decommit when requesting a resize to zero.\n          node.usedBytes = 0;\n        } else {\n          var oldContents = node.contents;\n          node.contents = new Uint8Array(newSize); // Allocate new storage.\n          if (oldContents) {\n            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.\n          }\n          node.usedBytes = newSize;\n        }\n      },node_ops:{getattr:function(node) {\n          var attr = {};\n          // device numbers reuse inode numbers.\n          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n          attr.ino = node.id;\n          attr.mode = node.mode;\n          attr.nlink = 1;\n          attr.uid = 0;\n          attr.gid = 0;\n          attr.rdev = node.rdev;\n          if (FS.isDir(node.mode)) {\n            attr.size = 4096;\n          } else if (FS.isFile(node.mode)) {\n            attr.size = node.usedBytes;\n          } else if (FS.isLink(node.mode)) {\n            attr.size = node.link.length;\n          } else {\n            attr.size = 0;\n          }\n          attr.atime = new Date(node.timestamp);\n          attr.mtime = new Date(node.timestamp);\n          attr.ctime = new Date(node.timestamp);\n          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),\n          //       but this is not required by the standard.\n          attr.blksize = 4096;\n          attr.blocks = Math.ceil(attr.size / attr.blksize);\n          return attr;\n        },setattr:function(node, attr) {\n          if (attr.mode !== undefined) {\n            node.mode = attr.mode;\n          }\n          if (attr.timestamp !== undefined) {\n            node.timestamp = attr.timestamp;\n          }\n          if (attr.size !== undefined) {\n            MEMFS.resizeFileStorage(node, attr.size);\n          }\n        },lookup:function(parent, name) {\n          throw FS.genericErrors[44];\n        },mknod:function(parent, name, mode, dev) {\n          return MEMFS.createNode(parent, name, mode, dev);\n        },rename:function(old_node, new_dir, new_name) {\n          // if we're overwriting a directory at new_name, make sure it's empty.\n          if (FS.isDir(old_node.mode)) {\n            var new_node;\n            try {\n              new_node = FS.lookupNode(new_dir, new_name);\n            } catch (e) {\n            }\n            if (new_node) {\n              for (var i in new_node.contents) {\n                throw new FS.ErrnoError(55);\n              }\n            }\n          }\n          // do the internal rewiring\n          delete old_node.parent.contents[old_node.name];\n          old_node.parent.timestamp = Date.now()\n          old_node.name = new_name;\n          new_dir.contents[new_name] = old_node;\n          new_dir.timestamp = old_node.parent.timestamp;\n          old_node.parent = new_dir;\n        },unlink:function(parent, name) {\n          delete parent.contents[name];\n          parent.timestamp = Date.now();\n        },rmdir:function(parent, name) {\n          var node = FS.lookupNode(parent, name);\n          for (var i in node.contents) {\n            throw new FS.ErrnoError(55);\n          }\n          delete parent.contents[name];\n          parent.timestamp = Date.now();\n        },readdir:function(node) {\n          var entries = ['.', '..'];\n          for (var key in node.contents) {\n            if (!node.contents.hasOwnProperty(key)) {\n              continue;\n            }\n            entries.push(key);\n          }\n          return entries;\n        },symlink:function(parent, newname, oldpath) {\n          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);\n          node.link = oldpath;\n          return node;\n        },readlink:function(node) {\n          if (!FS.isLink(node.mode)) {\n            throw new FS.ErrnoError(28);\n          }\n          return node.link;\n        }},stream_ops:{read:function(stream, buffer, offset, length, position) {\n          var contents = stream.node.contents;\n          if (position >= stream.node.usedBytes) return 0;\n          var size = Math.min(stream.node.usedBytes - position, length);\n          if (size > 8 && contents.subarray) { // non-trivial, and typed array\n            buffer.set(contents.subarray(position, position + size), offset);\n          } else {\n            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];\n          }\n          return size;\n        },write:function(stream, buffer, offset, length, position, canOwn) {\n          // If the buffer is located in main memory (HEAP), and if\n          // memory can grow, we can't hold on to references of the\n          // memory buffer, as they may get invalidated. That means we\n          // need to do copy its contents.\n          if (buffer.buffer === HEAP8.buffer) {\n            canOwn = false;\n          }\n  \n          if (!length) return 0;\n          var node = stream.node;\n          node.timestamp = Date.now();\n  \n          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?\n            if (canOwn) {\n              node.contents = buffer.subarray(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.\n              node.contents = buffer.slice(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?\n              node.contents.set(buffer.subarray(offset, offset + length), position);\n              return length;\n            }\n          }\n  \n          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.\n          MEMFS.expandFileStorage(node, position+length);\n          if (node.contents.subarray && buffer.subarray) {\n            // Use typed array write which is available.\n            node.contents.set(buffer.subarray(offset, offset + length), position);\n          } else {\n            for (var i = 0; i < length; i++) {\n             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.\n            }\n          }\n          node.usedBytes = Math.max(node.usedBytes, position + length);\n          return length;\n        },llseek:function(stream, offset, whence) {\n          var position = offset;\n          if (whence === 1) {\n            position += stream.position;\n          } else if (whence === 2) {\n            if (FS.isFile(stream.node.mode)) {\n              position += stream.node.usedBytes;\n            }\n          }\n          if (position < 0) {\n            throw new FS.ErrnoError(28);\n          }\n          return position;\n        },allocate:function(stream, offset, length) {\n          MEMFS.expandFileStorage(stream.node, offset + length);\n          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\n        },mmap:function(stream, length, position, prot, flags) {\n          if (!FS.isFile(stream.node.mode)) {\n            throw new FS.ErrnoError(43);\n          }\n          var ptr;\n          var allocated;\n          var contents = stream.node.contents;\n          // Only make a new copy when MAP_PRIVATE is specified.\n          if (!(flags & 2) && contents.buffer === buffer) {\n            // We can't emulate MAP_SHARED when the file is not backed by the buffer\n            // we're mapping to (e.g. the HEAP buffer).\n            allocated = false;\n            ptr = contents.byteOffset;\n          } else {\n            // Try to avoid unnecessary slices.\n            if (position > 0 || position + length < contents.length) {\n              if (contents.subarray) {\n                contents = contents.subarray(position, position + length);\n              } else {\n                contents = Array.prototype.slice.call(contents, position, position + length);\n              }\n            }\n            allocated = true;\n            ptr = mmapAlloc(length);\n            if (!ptr) {\n              throw new FS.ErrnoError(48);\n            }\n            HEAP8.set(contents, ptr);\n          }\n          return { ptr: ptr, allocated: allocated };\n        },msync:function(stream, buffer, offset, length, mmapFlags) {\n          MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n          // should we check if bytesWritten and length are the same?\n          return 0;\n        }}};\n  \n  /** @param {boolean=} noRunDep */\n  function asyncLoad(url, onload, onerror, noRunDep) {\n      var dep = !noRunDep ? getUniqueRunDependency('al ' + url) : '';\n      readAsync(url, (arrayBuffer) => {\n        assert(arrayBuffer, 'Loading data file \"' + url + '\" failed (no arrayBuffer).');\n        onload(new Uint8Array(arrayBuffer));\n        if (dep) removeRunDependency(dep);\n      }, (event) => {\n        if (onerror) {\n          onerror();\n        } else {\n          throw 'Loading data file \"' + url + '\" failed.';\n        }\n      });\n      if (dep) addRunDependency(dep);\n    }\n  var FS = {root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:\"/\",initialized:false,ignorePermissions:true,ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,lookupPath:(path, opts = {}) => {\n        path = PATH_FS.resolve(FS.cwd(), path);\n  \n        if (!path) return { path: '', node: null };\n  \n        var defaults = {\n          follow_mount: true,\n          recurse_count: 0\n        };\n        opts = Object.assign(defaults, opts)\n  \n        if (opts.recurse_count > 8) {  // max recursive lookup of 8\n          throw new FS.ErrnoError(32);\n        }\n  \n        // split the path\n        var parts = PATH.normalizeArray(path.split('/').filter((p) => !!p), false);\n  \n        // start at the root\n        var current = FS.root;\n        var current_path = '/';\n  \n        for (var i = 0; i < parts.length; i++) {\n          var islast = (i === parts.length-1);\n          if (islast && opts.parent) {\n            // stop resolving\n            break;\n          }\n  \n          current = FS.lookupNode(current, parts[i]);\n          current_path = PATH.join2(current_path, parts[i]);\n  \n          // jump to the mount's root node if this is a mountpoint\n          if (FS.isMountpoint(current)) {\n            if (!islast || (islast && opts.follow_mount)) {\n              current = current.mounted.root;\n            }\n          }\n  \n          // by default, lookupPath will not follow a symlink if it is the final path component.\n          // setting opts.follow = true will override this behavior.\n          if (!islast || opts.follow) {\n            var count = 0;\n            while (FS.isLink(current.mode)) {\n              var link = FS.readlink(current_path);\n              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\n  \n              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 });\n              current = lookup.node;\n  \n              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).\n                throw new FS.ErrnoError(32);\n              }\n            }\n          }\n        }\n  \n        return { path: current_path, node: current };\n      },getPath:(node) => {\n        var path;\n        while (true) {\n          if (FS.isRoot(node)) {\n            var mount = node.mount.mountpoint;\n            if (!path) return mount;\n            return mount[mount.length-1] !== '/' ? mount + '/' + path : mount + path;\n          }\n          path = path ? node.name + '/' + path : node.name;\n          node = node.parent;\n        }\n      },hashName:(parentid, name) => {\n        var hash = 0;\n  \n        for (var i = 0; i < name.length; i++) {\n          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;\n        }\n        return ((parentid + hash) >>> 0) % FS.nameTable.length;\n      },hashAddNode:(node) => {\n        var hash = FS.hashName(node.parent.id, node.name);\n        node.name_next = FS.nameTable[hash];\n        FS.nameTable[hash] = node;\n      },hashRemoveNode:(node) => {\n        var hash = FS.hashName(node.parent.id, node.name);\n        if (FS.nameTable[hash] === node) {\n          FS.nameTable[hash] = node.name_next;\n        } else {\n          var current = FS.nameTable[hash];\n          while (current) {\n            if (current.name_next === node) {\n              current.name_next = node.name_next;\n              break;\n            }\n            current = current.name_next;\n          }\n        }\n      },lookupNode:(parent, name) => {\n        var errCode = FS.mayLookup(parent);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode, parent);\n        }\n        var hash = FS.hashName(parent.id, name);\n        for (var node = FS.nameTable[hash]; node; node = node.name_next) {\n          var nodeName = node.name;\n          if (node.parent.id === parent.id && nodeName === name) {\n            return node;\n          }\n        }\n        // if we failed to find it in the cache, call into the VFS\n        return FS.lookup(parent, name);\n      },createNode:(parent, name, mode, rdev) => {\n        var node = new FS.FSNode(parent, name, mode, rdev);\n  \n        FS.hashAddNode(node);\n  \n        return node;\n      },destroyNode:(node) => {\n        FS.hashRemoveNode(node);\n      },isRoot:(node) => {\n        return node === node.parent;\n      },isMountpoint:(node) => {\n        return !!node.mounted;\n      },isFile:(mode) => {\n        return (mode & 61440) === 32768;\n      },isDir:(mode) => {\n        return (mode & 61440) === 16384;\n      },isLink:(mode) => {\n        return (mode & 61440) === 40960;\n      },isChrdev:(mode) => {\n        return (mode & 61440) === 8192;\n      },isBlkdev:(mode) => {\n        return (mode & 61440) === 24576;\n      },isFIFO:(mode) => {\n        return (mode & 61440) === 4096;\n      },isSocket:(mode) => {\n        return (mode & 49152) === 49152;\n      },flagModes:{\"r\":0,\"r+\":2,\"w\":577,\"w+\":578,\"a\":1089,\"a+\":1090},modeStringToFlags:(str) => {\n        var flags = FS.flagModes[str];\n        if (typeof flags == 'undefined') {\n          throw new Error('Unknown file open mode: ' + str);\n        }\n        return flags;\n      },flagsToPermissionString:(flag) => {\n        var perms = ['r', 'w', 'rw'][flag & 3];\n        if ((flag & 512)) {\n          perms += 'w';\n        }\n        return perms;\n      },nodePermissions:(node, perms) => {\n        if (FS.ignorePermissions) {\n          return 0;\n        }\n        // return 0 if any user, group or owner bits are set.\n        if (perms.includes('r') && !(node.mode & 292)) {\n          return 2;\n        } else if (perms.includes('w') && !(node.mode & 146)) {\n          return 2;\n        } else if (perms.includes('x') && !(node.mode & 73)) {\n          return 2;\n        }\n        return 0;\n      },mayLookup:(dir) => {\n        var errCode = FS.nodePermissions(dir, 'x');\n        if (errCode) return errCode;\n        if (!dir.node_ops.lookup) return 2;\n        return 0;\n      },mayCreate:(dir, name) => {\n        try {\n          var node = FS.lookupNode(dir, name);\n          return 20;\n        } catch (e) {\n        }\n        return FS.nodePermissions(dir, 'wx');\n      },mayDelete:(dir, name, isdir) => {\n        var node;\n        try {\n          node = FS.lookupNode(dir, name);\n        } catch (e) {\n          return e.errno;\n        }\n        var errCode = FS.nodePermissions(dir, 'wx');\n        if (errCode) {\n          return errCode;\n        }\n        if (isdir) {\n          if (!FS.isDir(node.mode)) {\n            return 54;\n          }\n          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n            return 10;\n          }\n        } else {\n          if (FS.isDir(node.mode)) {\n            return 31;\n          }\n        }\n        return 0;\n      },mayOpen:(node, flags) => {\n        if (!node) {\n          return 44;\n        }\n        if (FS.isLink(node.mode)) {\n          return 32;\n        } else if (FS.isDir(node.mode)) {\n          if (FS.flagsToPermissionString(flags) !== 'r' || // opening for write\n              (flags & 512)) { // TODO: check for O_SEARCH? (== search for dir only)\n            return 31;\n          }\n        }\n        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n      },MAX_OPEN_FDS:4096,nextfd:(fd_start = 0, fd_end = FS.MAX_OPEN_FDS) => {\n        for (var fd = fd_start; fd <= fd_end; fd++) {\n          if (!FS.streams[fd]) {\n            return fd;\n          }\n        }\n        throw new FS.ErrnoError(33);\n      },getStream:(fd) => FS.streams[fd],createStream:(stream, fd_start, fd_end) => {\n        if (!FS.FSStream) {\n          FS.FSStream = /** @constructor */ function() {\n            this.shared = { };\n          };\n          FS.FSStream.prototype = {};\n          Object.defineProperties(FS.FSStream.prototype, {\n            object: {\n              /** @this {FS.FSStream} */\n              get: function() { return this.node; },\n              /** @this {FS.FSStream} */\n              set: function(val) { this.node = val; }\n            },\n            isRead: {\n              /** @this {FS.FSStream} */\n              get: function() { return (this.flags & 2097155) !== 1; }\n            },\n            isWrite: {\n              /** @this {FS.FSStream} */\n              get: function() { return (this.flags & 2097155) !== 0; }\n            },\n            isAppend: {\n              /** @this {FS.FSStream} */\n              get: function() { return (this.flags & 1024); }\n            },\n            flags: {\n              /** @this {FS.FSStream} */\n              get: function() { return this.shared.flags; },\n              /** @this {FS.FSStream} */\n              set: function(val) { this.shared.flags = val; },\n            },\n            position : {\n              /** @this {FS.FSStream} */\n              get: function() { return this.shared.position; },\n              /** @this {FS.FSStream} */\n              set: function(val) { this.shared.position = val; },\n            },\n          });\n        }\n        // clone it, so we can return an instance of FSStream\n        stream = Object.assign(new FS.FSStream(), stream);\n        var fd = FS.nextfd(fd_start, fd_end);\n        stream.fd = fd;\n        FS.streams[fd] = stream;\n        return stream;\n      },closeStream:(fd) => {\n        FS.streams[fd] = null;\n      },chrdev_stream_ops:{open:(stream) => {\n          var device = FS.getDevice(stream.node.rdev);\n          // override node's stream ops with the device's\n          stream.stream_ops = device.stream_ops;\n          // forward the open call\n          if (stream.stream_ops.open) {\n            stream.stream_ops.open(stream);\n          }\n        },llseek:() => {\n          throw new FS.ErrnoError(70);\n        }},major:(dev) => ((dev) >> 8),minor:(dev) => ((dev) & 0xff),makedev:(ma, mi) => ((ma) << 8 | (mi)),registerDevice:(dev, ops) => {\n        FS.devices[dev] = { stream_ops: ops };\n      },getDevice:(dev) => FS.devices[dev],getMounts:(mount) => {\n        var mounts = [];\n        var check = [mount];\n  \n        while (check.length) {\n          var m = check.pop();\n  \n          mounts.push(m);\n  \n          check.push.apply(check, m.mounts);\n        }\n  \n        return mounts;\n      },syncfs:(populate, callback) => {\n        if (typeof populate == 'function') {\n          callback = populate;\n          populate = false;\n        }\n  \n        FS.syncFSRequests++;\n  \n        if (FS.syncFSRequests > 1) {\n          err('warning: ' + FS.syncFSRequests + ' FS.syncfs operations in flight at once, probably just doing extra work');\n        }\n  \n        var mounts = FS.getMounts(FS.root.mount);\n        var completed = 0;\n  \n        function doCallback(errCode) {\n          FS.syncFSRequests--;\n          return callback(errCode);\n        }\n  \n        function done(errCode) {\n          if (errCode) {\n            if (!done.errored) {\n              done.errored = true;\n              return doCallback(errCode);\n            }\n            return;\n          }\n          if (++completed >= mounts.length) {\n            doCallback(null);\n          }\n        };\n  \n        // sync all mounts\n        mounts.forEach((mount) => {\n          if (!mount.type.syncfs) {\n            return done(null);\n          }\n          mount.type.syncfs(mount, populate, done);\n        });\n      },mount:(type, opts, mountpoint) => {\n        var root = mountpoint === '/';\n        var pseudo = !mountpoint;\n        var node;\n  \n        if (root && FS.root) {\n          throw new FS.ErrnoError(10);\n        } else if (!root && !pseudo) {\n          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\n  \n          mountpoint = lookup.path;  // use the absolute path\n          node = lookup.node;\n  \n          if (FS.isMountpoint(node)) {\n            throw new FS.ErrnoError(10);\n          }\n  \n          if (!FS.isDir(node.mode)) {\n            throw new FS.ErrnoError(54);\n          }\n        }\n  \n        var mount = {\n          type: type,\n          opts: opts,\n          mountpoint: mountpoint,\n          mounts: []\n        };\n  \n        // create a root node for the fs\n        var mountRoot = type.mount(mount);\n        mountRoot.mount = mount;\n        mount.root = mountRoot;\n  \n        if (root) {\n          FS.root = mountRoot;\n        } else if (node) {\n          // set as a mountpoint\n          node.mounted = mount;\n  \n          // add the new mount to the current mount's children\n          if (node.mount) {\n            node.mount.mounts.push(mount);\n          }\n        }\n  \n        return mountRoot;\n      },unmount:(mountpoint) => {\n        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\n  \n        if (!FS.isMountpoint(lookup.node)) {\n          throw new FS.ErrnoError(28);\n        }\n  \n        // destroy the nodes for this mount, and all its child mounts\n        var node = lookup.node;\n        var mount = node.mounted;\n        var mounts = FS.getMounts(mount);\n  \n        Object.keys(FS.nameTable).forEach((hash) => {\n          var current = FS.nameTable[hash];\n  \n          while (current) {\n            var next = current.name_next;\n  \n            if (mounts.includes(current.mount)) {\n              FS.destroyNode(current);\n            }\n  \n            current = next;\n          }\n        });\n  \n        // no longer a mountpoint\n        node.mounted = null;\n  \n        // remove this mount from the child mounts\n        var idx = node.mount.mounts.indexOf(mount);\n        node.mount.mounts.splice(idx, 1);\n      },lookup:(parent, name) => {\n        return parent.node_ops.lookup(parent, name);\n      },mknod:(path, mode, dev) => {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        if (!name || name === '.' || name === '..') {\n          throw new FS.ErrnoError(28);\n        }\n        var errCode = FS.mayCreate(parent, name);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.mknod) {\n          throw new FS.ErrnoError(63);\n        }\n        return parent.node_ops.mknod(parent, name, mode, dev);\n      },create:(path, mode) => {\n        mode = mode !== undefined ? mode : 438 /* 0666 */;\n        mode &= 4095;\n        mode |= 32768;\n        return FS.mknod(path, mode, 0);\n      },mkdir:(path, mode) => {\n        mode = mode !== undefined ? mode : 511 /* 0777 */;\n        mode &= 511 | 512;\n        mode |= 16384;\n        return FS.mknod(path, mode, 0);\n      },mkdirTree:(path, mode) => {\n        var dirs = path.split('/');\n        var d = '';\n        for (var i = 0; i < dirs.length; ++i) {\n          if (!dirs[i]) continue;\n          d += '/' + dirs[i];\n          try {\n            FS.mkdir(d, mode);\n          } catch(e) {\n            if (e.errno != 20) throw e;\n          }\n        }\n      },mkdev:(path, mode, dev) => {\n        if (typeof dev == 'undefined') {\n          dev = mode;\n          mode = 438 /* 0666 */;\n        }\n        mode |= 8192;\n        return FS.mknod(path, mode, dev);\n      },symlink:(oldpath, newpath) => {\n        if (!PATH_FS.resolve(oldpath)) {\n          throw new FS.ErrnoError(44);\n        }\n        var lookup = FS.lookupPath(newpath, { parent: true });\n        var parent = lookup.node;\n        if (!parent) {\n          throw new FS.ErrnoError(44);\n        }\n        var newname = PATH.basename(newpath);\n        var errCode = FS.mayCreate(parent, newname);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.symlink) {\n          throw new FS.ErrnoError(63);\n        }\n        return parent.node_ops.symlink(parent, newname, oldpath);\n      },rename:(old_path, new_path) => {\n        var old_dirname = PATH.dirname(old_path);\n        var new_dirname = PATH.dirname(new_path);\n        var old_name = PATH.basename(old_path);\n        var new_name = PATH.basename(new_path);\n        // parents must exist\n        var lookup, old_dir, new_dir;\n  \n        // let the errors from non existant directories percolate up\n        lookup = FS.lookupPath(old_path, { parent: true });\n        old_dir = lookup.node;\n        lookup = FS.lookupPath(new_path, { parent: true });\n        new_dir = lookup.node;\n  \n        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\n        // need to be part of the same mount\n        if (old_dir.mount !== new_dir.mount) {\n          throw new FS.ErrnoError(75);\n        }\n        // source must exist\n        var old_node = FS.lookupNode(old_dir, old_name);\n        // old path should not be an ancestor of the new path\n        var relative = PATH_FS.relative(old_path, new_dirname);\n        if (relative.charAt(0) !== '.') {\n          throw new FS.ErrnoError(28);\n        }\n        // new path should not be an ancestor of the old path\n        relative = PATH_FS.relative(new_path, old_dirname);\n        if (relative.charAt(0) !== '.') {\n          throw new FS.ErrnoError(55);\n        }\n        // see if the new path already exists\n        var new_node;\n        try {\n          new_node = FS.lookupNode(new_dir, new_name);\n        } catch (e) {\n          // not fatal\n        }\n        // early out if nothing needs to change\n        if (old_node === new_node) {\n          return;\n        }\n        // we'll need to delete the old entry\n        var isdir = FS.isDir(old_node.mode);\n        var errCode = FS.mayDelete(old_dir, old_name, isdir);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        // need delete permissions if we'll be overwriting.\n        // need create permissions if new doesn't already exist.\n        errCode = new_node ?\n          FS.mayDelete(new_dir, new_name, isdir) :\n          FS.mayCreate(new_dir, new_name);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!old_dir.node_ops.rename) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {\n          throw new FS.ErrnoError(10);\n        }\n        // if we are going to change the parent, check write permissions\n        if (new_dir !== old_dir) {\n          errCode = FS.nodePermissions(old_dir, 'w');\n          if (errCode) {\n            throw new FS.ErrnoError(errCode);\n          }\n        }\n        // remove the node from the lookup hash\n        FS.hashRemoveNode(old_node);\n        // do the underlying fs rename\n        try {\n          old_dir.node_ops.rename(old_node, new_dir, new_name);\n        } catch (e) {\n          throw e;\n        } finally {\n          // add the node back to the hash (in case node_ops.rename\n          // changed its name)\n          FS.hashAddNode(old_node);\n        }\n      },rmdir:(path) => {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var errCode = FS.mayDelete(parent, name, true);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.rmdir) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10);\n        }\n        parent.node_ops.rmdir(parent, name);\n        FS.destroyNode(node);\n      },readdir:(path) => {\n        var lookup = FS.lookupPath(path, { follow: true });\n        var node = lookup.node;\n        if (!node.node_ops.readdir) {\n          throw new FS.ErrnoError(54);\n        }\n        return node.node_ops.readdir(node);\n      },unlink:(path) => {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        if (!parent) {\n          throw new FS.ErrnoError(44);\n        }\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var errCode = FS.mayDelete(parent, name, false);\n        if (errCode) {\n          // According to POSIX, we should map EISDIR to EPERM, but\n          // we instead do what Linux does (and we must, as we use\n          // the musl linux libc).\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.unlink) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10);\n        }\n        parent.node_ops.unlink(parent, name);\n        FS.destroyNode(node);\n      },readlink:(path) => {\n        var lookup = FS.lookupPath(path);\n        var link = lookup.node;\n        if (!link) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!link.node_ops.readlink) {\n          throw new FS.ErrnoError(28);\n        }\n        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\n      },stat:(path, dontFollow) => {\n        var lookup = FS.lookupPath(path, { follow: !dontFollow });\n        var node = lookup.node;\n        if (!node) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!node.node_ops.getattr) {\n          throw new FS.ErrnoError(63);\n        }\n        return node.node_ops.getattr(node);\n      },lstat:(path) => {\n        return FS.stat(path, true);\n      },chmod:(path, mode, dontFollow) => {\n        var node;\n        if (typeof path == 'string') {\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        node.node_ops.setattr(node, {\n          mode: (mode & 4095) | (node.mode & ~4095),\n          timestamp: Date.now()\n        });\n      },lchmod:(path, mode) => {\n        FS.chmod(path, mode, true);\n      },fchmod:(fd, mode) => {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n          throw new FS.ErrnoError(8);\n        }\n        FS.chmod(stream.node, mode);\n      },chown:(path, uid, gid, dontFollow) => {\n        var node;\n        if (typeof path == 'string') {\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        node.node_ops.setattr(node, {\n          timestamp: Date.now()\n          // we ignore the uid / gid for now\n        });\n      },lchown:(path, uid, gid) => {\n        FS.chown(path, uid, gid, true);\n      },fchown:(fd, uid, gid) => {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n          throw new FS.ErrnoError(8);\n        }\n        FS.chown(stream.node, uid, gid);\n      },truncate:(path, len) => {\n        if (len < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        var node;\n        if (typeof path == 'string') {\n          var lookup = FS.lookupPath(path, { follow: true });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!FS.isFile(node.mode)) {\n          throw new FS.ErrnoError(28);\n        }\n        var errCode = FS.nodePermissions(node, 'w');\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        node.node_ops.setattr(node, {\n          size: len,\n          timestamp: Date.now()\n        });\n      },ftruncate:(fd, len) => {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(28);\n        }\n        FS.truncate(stream.node, len);\n      },utime:(path, atime, mtime) => {\n        var lookup = FS.lookupPath(path, { follow: true });\n        var node = lookup.node;\n        node.node_ops.setattr(node, {\n          timestamp: Math.max(atime, mtime)\n        });\n      },open:(path, flags, mode) => {\n        if (path === \"\") {\n          throw new FS.ErrnoError(44);\n        }\n        flags = typeof flags == 'string' ? FS.modeStringToFlags(flags) : flags;\n        mode = typeof mode == 'undefined' ? 438 /* 0666 */ : mode;\n        if ((flags & 64)) {\n          mode = (mode & 4095) | 32768;\n        } else {\n          mode = 0;\n        }\n        var node;\n        if (typeof path == 'object') {\n          node = path;\n        } else {\n          path = PATH.normalize(path);\n          try {\n            var lookup = FS.lookupPath(path, {\n              follow: !(flags & 131072)\n            });\n            node = lookup.node;\n          } catch (e) {\n            // ignore\n          }\n        }\n        // perhaps we need to create the node\n        var created = false;\n        if ((flags & 64)) {\n          if (node) {\n            // if O_CREAT and O_EXCL are set, error out if the node already exists\n            if ((flags & 128)) {\n              throw new FS.ErrnoError(20);\n            }\n          } else {\n            // node doesn't exist, try to create it\n            node = FS.mknod(path, mode, 0);\n            created = true;\n          }\n        }\n        if (!node) {\n          throw new FS.ErrnoError(44);\n        }\n        // can't truncate a device\n        if (FS.isChrdev(node.mode)) {\n          flags &= ~512;\n        }\n        // if asked only for a directory, then this must be one\n        if ((flags & 65536) && !FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(54);\n        }\n        // check permissions, if this is not a file we just created now (it is ok to\n        // create and write to a file with read-only permissions; it is read-only\n        // for later use)\n        if (!created) {\n          var errCode = FS.mayOpen(node, flags);\n          if (errCode) {\n            throw new FS.ErrnoError(errCode);\n          }\n        }\n        // do truncation if necessary\n        if ((flags & 512) && !created) {\n          FS.truncate(node, 0);\n        }\n        // we've already handled these, don't pass down to the underlying vfs\n        flags &= ~(128 | 512 | 131072);\n  \n        // register the stream with the filesystem\n        var stream = FS.createStream({\n          node: node,\n          path: FS.getPath(node),  // we want the absolute path to the node\n          flags: flags,\n          seekable: true,\n          position: 0,\n          stream_ops: node.stream_ops,\n          // used by the file family libc calls (fopen, fwrite, ferror, etc.)\n          ungotten: [],\n          error: false\n        });\n        // call the new stream's open function\n        if (stream.stream_ops.open) {\n          stream.stream_ops.open(stream);\n        }\n        if (Module['logReadFiles'] && !(flags & 1)) {\n          if (!FS.readFiles) FS.readFiles = {};\n          if (!(path in FS.readFiles)) {\n            FS.readFiles[path] = 1;\n          }\n        }\n        return stream;\n      },close:(stream) => {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (stream.getdents) stream.getdents = null; // free readdir state\n        try {\n          if (stream.stream_ops.close) {\n            stream.stream_ops.close(stream);\n          }\n        } catch (e) {\n          throw e;\n        } finally {\n          FS.closeStream(stream.fd);\n        }\n        stream.fd = null;\n      },isClosed:(stream) => {\n        return stream.fd === null;\n      },llseek:(stream, offset, whence) => {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (!stream.seekable || !stream.stream_ops.llseek) {\n          throw new FS.ErrnoError(70);\n        }\n        if (whence != 0 && whence != 1 && whence != 2) {\n          throw new FS.ErrnoError(28);\n        }\n        stream.position = stream.stream_ops.llseek(stream, offset, whence);\n        stream.ungotten = [];\n        return stream.position;\n      },read:(stream, buffer, offset, length, position) => {\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(8);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!stream.stream_ops.read) {\n          throw new FS.ErrnoError(28);\n        }\n        var seeking = typeof position != 'undefined';\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(70);\n        }\n        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\n        if (!seeking) stream.position += bytesRead;\n        return bytesRead;\n      },write:(stream, buffer, offset, length, position, canOwn) => {\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(8);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!stream.stream_ops.write) {\n          throw new FS.ErrnoError(28);\n        }\n        if (stream.seekable && stream.flags & 1024) {\n          // seek to the end before writing in append mode\n          FS.llseek(stream, 0, 2);\n        }\n        var seeking = typeof position != 'undefined';\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(70);\n        }\n        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\n        if (!seeking) stream.position += bytesWritten;\n        return bytesWritten;\n      },allocate:(stream, offset, length) => {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (offset < 0 || length <= 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(8);\n        }\n        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(43);\n        }\n        if (!stream.stream_ops.allocate) {\n          throw new FS.ErrnoError(138);\n        }\n        stream.stream_ops.allocate(stream, offset, length);\n      },mmap:(stream, length, position, prot, flags) => {\n        // User requests writing to file (prot & PROT_WRITE != 0).\n        // Checking if we have permissions to write to the file unless\n        // MAP_PRIVATE flag is set. According to POSIX spec it is possible\n        // to write to file opened in read-only mode with MAP_PRIVATE flag,\n        // as all modifications will be visible only in the memory of\n        // the current process.\n        if ((prot & 2) !== 0\n            && (flags & 2) === 0\n            && (stream.flags & 2097155) !== 2) {\n          throw new FS.ErrnoError(2);\n        }\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(2);\n        }\n        if (!stream.stream_ops.mmap) {\n          throw new FS.ErrnoError(43);\n        }\n        return stream.stream_ops.mmap(stream, length, position, prot, flags);\n      },msync:(stream, buffer, offset, length, mmapFlags) => {\n        if (!stream.stream_ops.msync) {\n          return 0;\n        }\n        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\n      },munmap:(stream) => 0,ioctl:(stream, cmd, arg) => {\n        if (!stream.stream_ops.ioctl) {\n          throw new FS.ErrnoError(59);\n        }\n        return stream.stream_ops.ioctl(stream, cmd, arg);\n      },readFile:(path, opts = {}) => {\n        opts.flags = opts.flags || 0;\n        opts.encoding = opts.encoding || 'binary';\n        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {\n          throw new Error('Invalid encoding type \"' + opts.encoding + '\"');\n        }\n        var ret;\n        var stream = FS.open(path, opts.flags);\n        var stat = FS.stat(path);\n        var length = stat.size;\n        var buf = new Uint8Array(length);\n        FS.read(stream, buf, 0, length, 0);\n        if (opts.encoding === 'utf8') {\n          ret = UTF8ArrayToString(buf, 0);\n        } else if (opts.encoding === 'binary') {\n          ret = buf;\n        }\n        FS.close(stream);\n        return ret;\n      },writeFile:(path, data, opts = {}) => {\n        opts.flags = opts.flags || 577;\n        var stream = FS.open(path, opts.flags, opts.mode);\n        if (typeof data == 'string') {\n          var buf = new Uint8Array(lengthBytesUTF8(data)+1);\n          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\n        } else if (ArrayBuffer.isView(data)) {\n          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\n        } else {\n          throw new Error('Unsupported data type');\n        }\n        FS.close(stream);\n      },cwd:() => FS.currentPath,chdir:(path) => {\n        var lookup = FS.lookupPath(path, { follow: true });\n        if (lookup.node === null) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!FS.isDir(lookup.node.mode)) {\n          throw new FS.ErrnoError(54);\n        }\n        var errCode = FS.nodePermissions(lookup.node, 'x');\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        FS.currentPath = lookup.path;\n      },createDefaultDirectories:() => {\n        FS.mkdir('/tmp');\n        FS.mkdir('/home');\n        FS.mkdir('/home/web_user');\n      },createDefaultDevices:() => {\n        // create /dev\n        FS.mkdir('/dev');\n        // setup /dev/null\n        FS.registerDevice(FS.makedev(1, 3), {\n          read: () => 0,\n          write: (stream, buffer, offset, length, pos) => length,\n        });\n        FS.mkdev('/dev/null', FS.makedev(1, 3));\n        // setup /dev/tty and /dev/tty1\n        // stderr needs to print output using err() rather than out()\n        // so we register a second tty just for it.\n        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n        FS.mkdev('/dev/tty', FS.makedev(5, 0));\n        FS.mkdev('/dev/tty1', FS.makedev(6, 0));\n        // setup /dev/[u]random\n        var random_device = getRandomDevice();\n        FS.createDevice('/dev', 'random', random_device);\n        FS.createDevice('/dev', 'urandom', random_device);\n        // we're not going to emulate the actual shm device,\n        // just create the tmp dirs that reside in it commonly\n        FS.mkdir('/dev/shm');\n        FS.mkdir('/dev/shm/tmp');\n      },createSpecialDirectories:() => {\n        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the\n        // name of the stream for fd 6 (see test_unistd_ttyname)\n        FS.mkdir('/proc');\n        var proc_self = FS.mkdir('/proc/self');\n        FS.mkdir('/proc/self/fd');\n        FS.mount({\n          mount: () => {\n            var node = FS.createNode(proc_self, 'fd', 16384 | 511 /* 0777 */, 73);\n            node.node_ops = {\n              lookup: (parent, name) => {\n                var fd = +name;\n                var stream = FS.getStream(fd);\n                if (!stream) throw new FS.ErrnoError(8);\n                var ret = {\n                  parent: null,\n                  mount: { mountpoint: 'fake' },\n                  node_ops: { readlink: () => stream.path },\n                };\n                ret.parent = ret; // make it look like a simple root node\n                return ret;\n              }\n            };\n            return node;\n          }\n        }, {}, '/proc/self/fd');\n      },createStandardStreams:() => {\n        // TODO deprecate the old functionality of a single\n        // input / output callback and that utilizes FS.createDevice\n        // and instead require a unique set of stream ops\n  \n        // by default, we symlink the standard streams to the\n        // default tty devices. however, if the standard streams\n        // have been overwritten we create a unique device for\n        // them instead.\n        if (Module['stdin']) {\n          FS.createDevice('/dev', 'stdin', Module['stdin']);\n        } else {\n          FS.symlink('/dev/tty', '/dev/stdin');\n        }\n        if (Module['stdout']) {\n          FS.createDevice('/dev', 'stdout', null, Module['stdout']);\n        } else {\n          FS.symlink('/dev/tty', '/dev/stdout');\n        }\n        if (Module['stderr']) {\n          FS.createDevice('/dev', 'stderr', null, Module['stderr']);\n        } else {\n          FS.symlink('/dev/tty1', '/dev/stderr');\n        }\n  \n        // open default streams for the stdin, stdout and stderr devices\n        var stdin = FS.open('/dev/stdin', 0);\n        var stdout = FS.open('/dev/stdout', 1);\n        var stderr = FS.open('/dev/stderr', 1);\n      },ensureErrnoError:() => {\n        if (FS.ErrnoError) return;\n        FS.ErrnoError = /** @this{Object} */ function ErrnoError(errno, node) {\n          this.node = node;\n          this.setErrno = /** @this{Object} */ function(errno) {\n            this.errno = errno;\n          };\n          this.setErrno(errno);\n          this.message = 'FS error';\n  \n        };\n        FS.ErrnoError.prototype = new Error();\n        FS.ErrnoError.prototype.constructor = FS.ErrnoError;\n        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)\n        [44].forEach((code) => {\n          FS.genericErrors[code] = new FS.ErrnoError(code);\n          FS.genericErrors[code].stack = '<generic error, no stack>';\n        });\n      },staticInit:() => {\n        FS.ensureErrnoError();\n  \n        FS.nameTable = new Array(4096);\n  \n        FS.mount(MEMFS, {}, '/');\n  \n        FS.createDefaultDirectories();\n        FS.createDefaultDevices();\n        FS.createSpecialDirectories();\n  \n        FS.filesystems = {\n          'MEMFS': MEMFS,\n        };\n      },init:(input, output, error) => {\n        FS.init.initialized = true;\n  \n        FS.ensureErrnoError();\n  \n        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here\n        Module['stdin'] = input || Module['stdin'];\n        Module['stdout'] = output || Module['stdout'];\n        Module['stderr'] = error || Module['stderr'];\n  \n        FS.createStandardStreams();\n      },quit:() => {\n        FS.init.initialized = false;\n        // force-flush all streams, so we get musl std streams printed out\n        // close all of our streams\n        for (var i = 0; i < FS.streams.length; i++) {\n          var stream = FS.streams[i];\n          if (!stream) {\n            continue;\n          }\n          FS.close(stream);\n        }\n      },getMode:(canRead, canWrite) => {\n        var mode = 0;\n        if (canRead) mode |= 292 | 73;\n        if (canWrite) mode |= 146;\n        return mode;\n      },findObject:(path, dontResolveLastLink) => {\n        var ret = FS.analyzePath(path, dontResolveLastLink);\n        if (!ret.exists) {\n          return null;\n        }\n        return ret.object;\n      },analyzePath:(path, dontResolveLastLink) => {\n        // operate from within the context of the symlink's target\n        try {\n          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n          path = lookup.path;\n        } catch (e) {\n        }\n        var ret = {\n          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,\n          parentExists: false, parentPath: null, parentObject: null\n        };\n        try {\n          var lookup = FS.lookupPath(path, { parent: true });\n          ret.parentExists = true;\n          ret.parentPath = lookup.path;\n          ret.parentObject = lookup.node;\n          ret.name = PATH.basename(path);\n          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n          ret.exists = true;\n          ret.path = lookup.path;\n          ret.object = lookup.node;\n          ret.name = lookup.node.name;\n          ret.isRoot = lookup.path === '/';\n        } catch (e) {\n          ret.error = e.errno;\n        };\n        return ret;\n      },createPath:(parent, path, canRead, canWrite) => {\n        parent = typeof parent == 'string' ? parent : FS.getPath(parent);\n        var parts = path.split('/').reverse();\n        while (parts.length) {\n          var part = parts.pop();\n          if (!part) continue;\n          var current = PATH.join2(parent, part);\n          try {\n            FS.mkdir(current);\n          } catch (e) {\n            // ignore EEXIST\n          }\n          parent = current;\n        }\n        return current;\n      },createFile:(parent, name, properties, canRead, canWrite) => {\n        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);\n        var mode = FS.getMode(canRead, canWrite);\n        return FS.create(path, mode);\n      },createDataFile:(parent, name, data, canRead, canWrite, canOwn) => {\n        var path = name;\n        if (parent) {\n          parent = typeof parent == 'string' ? parent : FS.getPath(parent);\n          path = name ? PATH.join2(parent, name) : parent;\n        }\n        var mode = FS.getMode(canRead, canWrite);\n        var node = FS.create(path, mode);\n        if (data) {\n          if (typeof data == 'string') {\n            var arr = new Array(data.length);\n            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);\n            data = arr;\n          }\n          // make sure we can write to the file\n          FS.chmod(node, mode | 146);\n          var stream = FS.open(node, 577);\n          FS.write(stream, data, 0, data.length, 0, canOwn);\n          FS.close(stream);\n          FS.chmod(node, mode);\n        }\n        return node;\n      },createDevice:(parent, name, input, output) => {\n        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);\n        var mode = FS.getMode(!!input, !!output);\n        if (!FS.createDevice.major) FS.createDevice.major = 64;\n        var dev = FS.makedev(FS.createDevice.major++, 0);\n        // Create a fake device that a set of stream ops to emulate\n        // the old behavior.\n        FS.registerDevice(dev, {\n          open: (stream) => {\n            stream.seekable = false;\n          },\n          close: (stream) => {\n            // flush any pending line data\n            if (output && output.buffer && output.buffer.length) {\n              output(10);\n            }\n          },\n          read: (stream, buffer, offset, length, pos /* ignored */) => {\n            var bytesRead = 0;\n            for (var i = 0; i < length; i++) {\n              var result;\n              try {\n                result = input();\n              } catch (e) {\n                throw new FS.ErrnoError(29);\n              }\n              if (result === undefined && bytesRead === 0) {\n                throw new FS.ErrnoError(6);\n              }\n              if (result === null || result === undefined) break;\n              bytesRead++;\n              buffer[offset+i] = result;\n            }\n            if (bytesRead) {\n              stream.node.timestamp = Date.now();\n            }\n            return bytesRead;\n          },\n          write: (stream, buffer, offset, length, pos) => {\n            for (var i = 0; i < length; i++) {\n              try {\n                output(buffer[offset+i]);\n              } catch (e) {\n                throw new FS.ErrnoError(29);\n              }\n            }\n            if (length) {\n              stream.node.timestamp = Date.now();\n            }\n            return i;\n          }\n        });\n        return FS.mkdev(path, mode, dev);\n      },forceLoadFile:(obj) => {\n        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\n        if (typeof XMLHttpRequest != 'undefined') {\n          throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\n        } else if (read_) {\n          // Command-line.\n          try {\n            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as\n            //          read() will try to parse UTF8.\n            obj.contents = intArrayFromString(read_(obj.url), true);\n            obj.usedBytes = obj.contents.length;\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n        } else {\n          throw new Error('Cannot load without read() or XMLHttpRequest.');\n        }\n      },createLazyFile:(parent, name, url, canRead, canWrite) => {\n        // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.\n        /** @constructor */\n        function LazyUint8Array() {\n          this.lengthKnown = false;\n          this.chunks = []; // Loaded chunks. Index is the chunk number\n        }\n        LazyUint8Array.prototype.get = /** @this{Object} */ function LazyUint8Array_get(idx) {\n          if (idx > this.length-1 || idx < 0) {\n            return undefined;\n          }\n          var chunkOffset = idx % this.chunkSize;\n          var chunkNum = (idx / this.chunkSize)|0;\n          return this.getter(chunkNum)[chunkOffset];\n        };\n        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\n          this.getter = getter;\n        };\n        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\n          // Find length\n          var xhr = new XMLHttpRequest();\n          xhr.open('HEAD', url, false);\n          xhr.send(null);\n          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n          var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\n          var header;\n          var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\n          var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\n  \n          var chunkSize = 1024*1024; // Chunk size in bytes\n  \n          if (!hasByteServing) chunkSize = datalength;\n  \n          // Function to get a range from the remote URL.\n          var doXHR = (from, to) => {\n            if (from > to) throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\n            if (to > datalength-1) throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\n  \n            // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.\n            var xhr = new XMLHttpRequest();\n            xhr.open('GET', url, false);\n            if (datalength !== chunkSize) xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\n  \n            // Some hints to the browser that we want binary data.\n            xhr.responseType = 'arraybuffer';\n            if (xhr.overrideMimeType) {\n              xhr.overrideMimeType('text/plain; charset=x-user-defined');\n            }\n  \n            xhr.send(null);\n            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n            if (xhr.response !== undefined) {\n              return new Uint8Array(/** @type{Array<number>} */(xhr.response || []));\n            }\n            return intArrayFromString(xhr.responseText || '', true);\n          };\n          var lazyArray = this;\n          lazyArray.setDataGetter((chunkNum) => {\n            var start = chunkNum * chunkSize;\n            var end = (chunkNum+1) * chunkSize - 1; // including this byte\n            end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block\n            if (typeof lazyArray.chunks[chunkNum] == 'undefined') {\n              lazyArray.chunks[chunkNum] = doXHR(start, end);\n            }\n            if (typeof lazyArray.chunks[chunkNum] == 'undefined') throw new Error('doXHR failed!');\n            return lazyArray.chunks[chunkNum];\n          });\n  \n          if (usesGzip || !datalength) {\n            // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length\n            chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file\n            datalength = this.getter(0).length;\n            chunkSize = datalength;\n            out(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\n          }\n  \n          this._length = datalength;\n          this._chunkSize = chunkSize;\n          this.lengthKnown = true;\n        };\n        if (typeof XMLHttpRequest != 'undefined') {\n          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';\n          var lazyArray = new LazyUint8Array();\n          Object.defineProperties(lazyArray, {\n            length: {\n              get: /** @this{Object} */ function() {\n                if (!this.lengthKnown) {\n                  this.cacheLength();\n                }\n                return this._length;\n              }\n            },\n            chunkSize: {\n              get: /** @this{Object} */ function() {\n                if (!this.lengthKnown) {\n                  this.cacheLength();\n                }\n                return this._chunkSize;\n              }\n            }\n          });\n  \n          var properties = { isDevice: false, contents: lazyArray };\n        } else {\n          var properties = { isDevice: false, url: url };\n        }\n  \n        var node = FS.createFile(parent, name, properties, canRead, canWrite);\n        // This is a total hack, but I want to get this lazy file code out of the\n        // core of MEMFS. If we want to keep this lazy file concept I feel it should\n        // be its own thin LAZYFS proxying calls to MEMFS.\n        if (properties.contents) {\n          node.contents = properties.contents;\n        } else if (properties.url) {\n          node.contents = null;\n          node.url = properties.url;\n        }\n        // Add a function that defers querying the file size until it is asked the first time.\n        Object.defineProperties(node, {\n          usedBytes: {\n            get: /** @this {FSNode} */ function() { return this.contents.length; }\n          }\n        });\n        // override each stream op with one that tries to force load the lazy file first\n        var stream_ops = {};\n        var keys = Object.keys(node.stream_ops);\n        keys.forEach((key) => {\n          var fn = node.stream_ops[key];\n          stream_ops[key] = function forceLoadLazyFile() {\n            FS.forceLoadFile(node);\n            return fn.apply(null, arguments);\n          };\n        });\n        function writeChunks(stream, buffer, offset, length, position) {\n          var contents = stream.node.contents;\n          if (position >= contents.length)\n            return 0;\n          var size = Math.min(contents.length - position, length);\n          if (contents.slice) { // normal array\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents[position + i];\n            }\n          } else {\n            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR\n              buffer[offset + i] = contents.get(position + i);\n            }\n          }\n          return size;\n        }\n        // use a custom read function\n        stream_ops.read = (stream, buffer, offset, length, position) => {\n          FS.forceLoadFile(node);\n          return writeChunks(stream, buffer, offset, length, position)\n        };\n        // use a custom mmap function\n        stream_ops.mmap = (stream, length, position, prot, flags) => {\n          FS.forceLoadFile(node);\n          var ptr = mmapAlloc(length);\n          if (!ptr) {\n            throw new FS.ErrnoError(48);\n          }\n          writeChunks(stream, HEAP8, ptr, length, position);\n          return { ptr: ptr, allocated: true };\n        };\n        node.stream_ops = stream_ops;\n        return node;\n      },createPreloadedFile:(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {\n        // TODO we should allow people to just pass in a complete filename instead\n        // of parent and name being that we just join them anyways\n        var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\n        var dep = getUniqueRunDependency('cp ' + fullname); // might have several active requests for the same fullname\n        function processData(byteArray) {\n          function finish(byteArray) {\n            if (preFinish) preFinish();\n            if (!dontCreateFile) {\n              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\n            }\n            if (onload) onload();\n            removeRunDependency(dep);\n          }\n          if (Browser.handledByPreloadPlugin(byteArray, fullname, finish, () => {\n            if (onerror) onerror();\n            removeRunDependency(dep);\n          })) {\n            return;\n          }\n          finish(byteArray);\n        }\n        addRunDependency(dep);\n        if (typeof url == 'string') {\n          asyncLoad(url, (byteArray) => processData(byteArray), onerror);\n        } else {\n          processData(url);\n        }\n      },indexedDB:() => {\n        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n      },DB_NAME:() => {\n        return 'EM_FS_' + window.location.pathname;\n      },DB_VERSION:20,DB_STORE_NAME:\"FILE_DATA\",saveFilesToDB:(paths, onload, onerror) => {\n        onload = onload || (() => {});\n        onerror = onerror || (() => {});\n        var indexedDB = FS.indexedDB();\n        try {\n          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\n        } catch (e) {\n          return onerror(e);\n        }\n        openRequest.onupgradeneeded = () => {\n          out('creating db');\n          var db = openRequest.result;\n          db.createObjectStore(FS.DB_STORE_NAME);\n        };\n        openRequest.onsuccess = () => {\n          var db = openRequest.result;\n          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');\n          var files = transaction.objectStore(FS.DB_STORE_NAME);\n          var ok = 0, fail = 0, total = paths.length;\n          function finish() {\n            if (fail == 0) onload(); else onerror();\n          }\n          paths.forEach((path) => {\n            var putRequest = files.put(FS.analyzePath(path).object.contents, path);\n            putRequest.onsuccess = () => { ok++; if (ok + fail == total) finish() };\n            putRequest.onerror = () => { fail++; if (ok + fail == total) finish() };\n          });\n          transaction.onerror = onerror;\n        };\n        openRequest.onerror = onerror;\n      },loadFilesFromDB:(paths, onload, onerror) => {\n        onload = onload || (() => {});\n        onerror = onerror || (() => {});\n        var indexedDB = FS.indexedDB();\n        try {\n          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\n        } catch (e) {\n          return onerror(e);\n        }\n        openRequest.onupgradeneeded = onerror; // no database to load from\n        openRequest.onsuccess = () => {\n          var db = openRequest.result;\n          try {\n            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');\n          } catch(e) {\n            onerror(e);\n            return;\n          }\n          var files = transaction.objectStore(FS.DB_STORE_NAME);\n          var ok = 0, fail = 0, total = paths.length;\n          function finish() {\n            if (fail == 0) onload(); else onerror();\n          }\n          paths.forEach((path) => {\n            var getRequest = files.get(path);\n            getRequest.onsuccess = () => {\n              if (FS.analyzePath(path).exists) {\n                FS.unlink(path);\n              }\n              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);\n              ok++;\n              if (ok + fail == total) finish();\n            };\n            getRequest.onerror = () => { fail++; if (ok + fail == total) finish() };\n          });\n          transaction.onerror = onerror;\n        };\n        openRequest.onerror = onerror;\n      }};\n  var SYSCALLS = {DEFAULT_POLLMASK:5,calculateAt:function(dirfd, path, allowEmpty) {\n        if (PATH.isAbs(path)) {\n          return path;\n        }\n        // relative path\n        var dir;\n        if (dirfd === -100) {\n          dir = FS.cwd();\n        } else {\n          var dirstream = SYSCALLS.getStreamFromFD(dirfd);\n          dir = dirstream.path;\n        }\n        if (path.length == 0) {\n          if (!allowEmpty) {\n            throw new FS.ErrnoError(44);// removed by dead control flow\n\n          }\n          return dir;\n        }\n        return PATH.join2(dir, path);\n      },doStat:function(func, path, buf) {\n        try {\n          var stat = func(path);\n        } catch (e) {\n          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\n            // an error occurred while trying to look up the path; we should just report ENOTDIR\n            return -54;\n          }\n          throw e;\n        }\n        HEAP32[((buf)>>2)] = stat.dev;\n        HEAP32[(((buf)+(8))>>2)] = stat.ino;\n        HEAP32[(((buf)+(12))>>2)] = stat.mode;\n        HEAPU32[(((buf)+(16))>>2)] = stat.nlink;\n        HEAP32[(((buf)+(20))>>2)] = stat.uid;\n        HEAP32[(((buf)+(24))>>2)] = stat.gid;\n        HEAP32[(((buf)+(28))>>2)] = stat.rdev;\n        (tempI64 = [stat.size>>>0,(tempDouble=stat.size,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(40))>>2)] = tempI64[0],HEAP32[(((buf)+(44))>>2)] = tempI64[1]);\n        HEAP32[(((buf)+(48))>>2)] = 4096;\n        HEAP32[(((buf)+(52))>>2)] = stat.blocks;\n        (tempI64 = [Math.floor(stat.atime.getTime() / 1000)>>>0,(tempDouble=Math.floor(stat.atime.getTime() / 1000),(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(56))>>2)] = tempI64[0],HEAP32[(((buf)+(60))>>2)] = tempI64[1]);\n        HEAPU32[(((buf)+(64))>>2)] = 0;\n        (tempI64 = [Math.floor(stat.mtime.getTime() / 1000)>>>0,(tempDouble=Math.floor(stat.mtime.getTime() / 1000),(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(72))>>2)] = tempI64[0],HEAP32[(((buf)+(76))>>2)] = tempI64[1]);\n        HEAPU32[(((buf)+(80))>>2)] = 0;\n        (tempI64 = [Math.floor(stat.ctime.getTime() / 1000)>>>0,(tempDouble=Math.floor(stat.ctime.getTime() / 1000),(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(88))>>2)] = tempI64[0],HEAP32[(((buf)+(92))>>2)] = tempI64[1]);\n        HEAPU32[(((buf)+(96))>>2)] = 0;\n        (tempI64 = [stat.ino>>>0,(tempDouble=stat.ino,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(104))>>2)] = tempI64[0],HEAP32[(((buf)+(108))>>2)] = tempI64[1]);\n        return 0;\n      },doMsync:function(addr, stream, len, flags, offset) {\n        if (!FS.isFile(stream.node.mode)) {\n          throw new FS.ErrnoError(43);\n        }\n        if (flags & 2) {\n          // MAP_PRIVATE calls need not to be synced back to underlying fs\n          return 0;\n        }\n        var buffer = HEAPU8.slice(addr, addr + len);\n        FS.msync(stream, buffer, offset, len, flags);\n      },varargs:undefined,get:function() {\n        SYSCALLS.varargs += 4;\n        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];\n        return ret;\n      },getStr:function(ptr) {\n        var ret = UTF8ToString(ptr);\n        return ret;\n      },getStreamFromFD:function(fd) {\n        var stream = FS.getStream(fd);\n        if (!stream) throw new FS.ErrnoError(8);\n        return stream;\n      }};\n  function _environ_get(__environ, environ_buf) {\n      var bufSize = 0;\n      getEnvStrings().forEach(function(string, i) {\n        var ptr = environ_buf + bufSize;\n        HEAPU32[(((__environ)+(i*4))>>2)] = ptr;\n        writeAsciiToMemory(string, ptr);\n        bufSize += string.length + 1;\n      });\n      return 0;\n    }\n\n  function _environ_sizes_get(penviron_count, penviron_buf_size) {\n      var strings = getEnvStrings();\n      HEAPU32[((penviron_count)>>2)] = strings.length;\n      var bufSize = 0;\n      strings.forEach(function(string) {\n        bufSize += string.length + 1;\n      });\n      HEAPU32[((penviron_buf_size)>>2)] = bufSize;\n      return 0;\n    }\n\n  function _proc_exit(code) {\n      EXITSTATUS = code;\n      if (!keepRuntimeAlive()) {\n        if (Module['onExit']) Module['onExit'](code);\n        ABORT = true;\n      }\n      quit_(code, new ExitStatus(code));\n    }\n  /** @param {boolean|number=} implicit */\n  function exitJS(status, implicit) {\n      EXITSTATUS = status;\n  \n      _proc_exit(status);\n    }\n  var _exit = exitJS;\n\n  function _fd_close(fd) {\n  try {\n  \n      var stream = SYSCALLS.getStreamFromFD(fd);\n      FS.close(stream);\n      return 0;\n    } catch (e) {\n    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;\n    return e.errno;\n  }\n  }\n\n  /** @param {number=} offset */\n  function doReadv(stream, iov, iovcnt, offset) {\n      var ret = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAPU32[((iov)>>2)];\n        var len = HEAPU32[(((iov)+(4))>>2)];\n        iov += 8;\n        var curr = FS.read(stream, HEAP8,ptr, len, offset);\n        if (curr < 0) return -1;\n        ret += curr;\n        if (curr < len) break; // nothing more to read\n      }\n      return ret;\n    }\n  function _fd_read(fd, iov, iovcnt, pnum) {\n  try {\n  \n      var stream = SYSCALLS.getStreamFromFD(fd);\n      var num = doReadv(stream, iov, iovcnt);\n      HEAPU32[((pnum)>>2)] = num;\n      return 0;\n    } catch (e) {\n    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;\n    return e.errno;\n  }\n  }\n\n  function convertI32PairToI53Checked(lo, hi) {\n      return ((hi + 0x200000) >>> 0 < 0x400001 - !!lo) ? (lo >>> 0) + hi * 4294967296 : NaN;\n    }\n  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\n  try {\n  \n      var offset = convertI32PairToI53Checked(offset_low, offset_high); if (isNaN(offset)) return 61;\n      var stream = SYSCALLS.getStreamFromFD(fd);\n      FS.llseek(stream, offset, whence);\n      (tempI64 = [stream.position>>>0,(tempDouble=stream.position,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((newOffset)>>2)] = tempI64[0],HEAP32[(((newOffset)+(4))>>2)] = tempI64[1]);\n      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state\n      return 0;\n    } catch (e) {\n    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;\n    return e.errno;\n  }\n  }\n\n  /** @param {number=} offset */\n  function doWritev(stream, iov, iovcnt, offset) {\n      var ret = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAPU32[((iov)>>2)];\n        var len = HEAPU32[(((iov)+(4))>>2)];\n        iov += 8;\n        var curr = FS.write(stream, HEAP8,ptr, len, offset);\n        if (curr < 0) return -1;\n        ret += curr;\n      }\n      return ret;\n    }\n  function _fd_write(fd, iov, iovcnt, pnum) {\n  try {\n  \n      var stream = SYSCALLS.getStreamFromFD(fd);\n      var num = doWritev(stream, iov, iovcnt);\n      HEAPU32[((pnum)>>2)] = num;\n      return 0;\n    } catch (e) {\n    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;\n    return e.errno;\n  }\n  }\n\n  function _getentropy(buffer, size) {\n      if (!_getentropy.randomDevice) {\n        _getentropy.randomDevice = getRandomDevice();\n      }\n      for (var i = 0; i < size; i++) {\n        HEAP8[(((buffer)+(i))>>0)] = _getentropy.randomDevice();\n      }\n      return 0;\n    }\n\n  function __isLeapYear(year) {\n        return year%4 === 0 && (year%100 !== 0 || year%400 === 0);\n    }\n  \n  function __arraySum(array, index) {\n      var sum = 0;\n      for (var i = 0; i <= index; sum += array[i++]) {\n        // no-op\n      }\n      return sum;\n    }\n  \n  var __MONTH_DAYS_LEAP = [31,29,31,30,31,30,31,31,30,31,30,31];\n  \n  var __MONTH_DAYS_REGULAR = [31,28,31,30,31,30,31,31,30,31,30,31];\n  function __addDays(date, days) {\n      var newDate = new Date(date.getTime());\n      while (days > 0) {\n        var leap = __isLeapYear(newDate.getFullYear());\n        var currentMonth = newDate.getMonth();\n        var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];\n  \n        if (days > daysInCurrentMonth-newDate.getDate()) {\n          // we spill over to next month\n          days -= (daysInCurrentMonth-newDate.getDate()+1);\n          newDate.setDate(1);\n          if (currentMonth < 11) {\n            newDate.setMonth(currentMonth+1)\n          } else {\n            newDate.setMonth(0);\n            newDate.setFullYear(newDate.getFullYear()+1);\n          }\n        } else {\n          // we stay in current month\n          newDate.setDate(newDate.getDate()+days);\n          return newDate;\n        }\n      }\n  \n      return newDate;\n    }\n  function _strftime(s, maxsize, format, tm) {\n      // size_t strftime(char *restrict s, size_t maxsize, const char *restrict format, const struct tm *restrict timeptr);\n      // http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html\n  \n      var tm_zone = HEAP32[(((tm)+(40))>>2)];\n  \n      var date = {\n        tm_sec: HEAP32[((tm)>>2)],\n        tm_min: HEAP32[(((tm)+(4))>>2)],\n        tm_hour: HEAP32[(((tm)+(8))>>2)],\n        tm_mday: HEAP32[(((tm)+(12))>>2)],\n        tm_mon: HEAP32[(((tm)+(16))>>2)],\n        tm_year: HEAP32[(((tm)+(20))>>2)],\n        tm_wday: HEAP32[(((tm)+(24))>>2)],\n        tm_yday: HEAP32[(((tm)+(28))>>2)],\n        tm_isdst: HEAP32[(((tm)+(32))>>2)],\n        tm_gmtoff: HEAP32[(((tm)+(36))>>2)],\n        tm_zone: tm_zone ? UTF8ToString(tm_zone) : ''\n      };\n  \n      var pattern = UTF8ToString(format);\n  \n      // expand format\n      var EXPANSION_RULES_1 = {\n        '%c': '%a %b %d %H:%M:%S %Y',     // Replaced by the locale's appropriate date and time representation - e.g., Mon Aug  3 14:02:01 2013\n        '%D': '%m/%d/%y',                 // Equivalent to %m / %d / %y\n        '%F': '%Y-%m-%d',                 // Equivalent to %Y - %m - %d\n        '%h': '%b',                       // Equivalent to %b\n        '%r': '%I:%M:%S %p',              // Replaced by the time in a.m. and p.m. notation\n        '%R': '%H:%M',                    // Replaced by the time in 24-hour notation\n        '%T': '%H:%M:%S',                 // Replaced by the time\n        '%x': '%m/%d/%y',                 // Replaced by the locale's appropriate date representation\n        '%X': '%H:%M:%S',                 // Replaced by the locale's appropriate time representation\n        // Modified Conversion Specifiers\n        '%Ec': '%c',                      // Replaced by the locale's alternative appropriate date and time representation.\n        '%EC': '%C',                      // Replaced by the name of the base year (period) in the locale's alternative representation.\n        '%Ex': '%m/%d/%y',                // Replaced by the locale's alternative date representation.\n        '%EX': '%H:%M:%S',                // Replaced by the locale's alternative time representation.\n        '%Ey': '%y',                      // Replaced by the offset from %EC (year only) in the locale's alternative representation.\n        '%EY': '%Y',                      // Replaced by the full alternative year representation.\n        '%Od': '%d',                      // Replaced by the day of the month, using the locale's alternative numeric symbols, filled as needed with leading zeros if there is any alternative symbol for zero; otherwise, with leading <space> characters.\n        '%Oe': '%e',                      // Replaced by the day of the month, using the locale's alternative numeric symbols, filled as needed with leading <space> characters.\n        '%OH': '%H',                      // Replaced by the hour (24-hour clock) using the locale's alternative numeric symbols.\n        '%OI': '%I',                      // Replaced by the hour (12-hour clock) using the locale's alternative numeric symbols.\n        '%Om': '%m',                      // Replaced by the month using the locale's alternative numeric symbols.\n        '%OM': '%M',                      // Replaced by the minutes using the locale's alternative numeric symbols.\n        '%OS': '%S',                      // Replaced by the seconds using the locale's alternative numeric symbols.\n        '%Ou': '%u',                      // Replaced by the weekday as a number in the locale's alternative representation (Monday=1).\n        '%OU': '%U',                      // Replaced by the week number of the year (Sunday as the first day of the week, rules corresponding to %U ) using the locale's alternative numeric symbols.\n        '%OV': '%V',                      // Replaced by the week number of the year (Monday as the first day of the week, rules corresponding to %V ) using the locale's alternative numeric symbols.\n        '%Ow': '%w',                      // Replaced by the number of the weekday (Sunday=0) using the locale's alternative numeric symbols.\n        '%OW': '%W',                      // Replaced by the week number of the year (Monday as the first day of the week) using the locale's alternative numeric symbols.\n        '%Oy': '%y',                      // Replaced by the year (offset from %C ) using the locale's alternative numeric symbols.\n      };\n      for (var rule in EXPANSION_RULES_1) {\n        pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_1[rule]);\n      }\n  \n      var WEEKDAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n      var MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\n  \n      function leadingSomething(value, digits, character) {\n        var str = typeof value == 'number' ? value.toString() : (value || '');\n        while (str.length < digits) {\n          str = character[0]+str;\n        }\n        return str;\n      }\n  \n      function leadingNulls(value, digits) {\n        return leadingSomething(value, digits, '0');\n      }\n  \n      function compareByDay(date1, date2) {\n        function sgn(value) {\n          return value < 0 ? -1 : (value > 0 ? 1 : 0);\n        }\n  \n        var compare;\n        if ((compare = sgn(date1.getFullYear()-date2.getFullYear())) === 0) {\n          if ((compare = sgn(date1.getMonth()-date2.getMonth())) === 0) {\n            compare = sgn(date1.getDate()-date2.getDate());\n          }\n        }\n        return compare;\n      }\n  \n      function getFirstWeekStartDate(janFourth) {\n          switch (janFourth.getDay()) {\n            case 0: // Sunday\n              return new Date(janFourth.getFullYear()-1, 11, 29);\n            case 1: // Monday\n              return janFourth;\n            case 2: // Tuesday\n              return new Date(janFourth.getFullYear(), 0, 3);\n            case 3: // Wednesday\n              return new Date(janFourth.getFullYear(), 0, 2);\n            case 4: // Thursday\n              return new Date(janFourth.getFullYear(), 0, 1);\n            case 5: // Friday\n              return new Date(janFourth.getFullYear()-1, 11, 31);\n            case 6: // Saturday\n              return new Date(janFourth.getFullYear()-1, 11, 30);\n          }\n      }\n  \n      function getWeekBasedYear(date) {\n          var thisDate = __addDays(new Date(date.tm_year+1900, 0, 1), date.tm_yday);\n  \n          var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);\n          var janFourthNextYear = new Date(thisDate.getFullYear()+1, 0, 4);\n  \n          var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\n          var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\n  \n          if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {\n            // this date is after the start of the first week of this year\n            if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {\n              return thisDate.getFullYear()+1;\n            }\n            return thisDate.getFullYear();\n          }\n          return thisDate.getFullYear()-1;\n      }\n  \n      var EXPANSION_RULES_2 = {\n        '%a': function(date) {\n          return WEEKDAYS[date.tm_wday].substring(0,3);\n        },\n        '%A': function(date) {\n          return WEEKDAYS[date.tm_wday];\n        },\n        '%b': function(date) {\n          return MONTHS[date.tm_mon].substring(0,3);\n        },\n        '%B': function(date) {\n          return MONTHS[date.tm_mon];\n        },\n        '%C': function(date) {\n          var year = date.tm_year+1900;\n          return leadingNulls((year/100)|0,2);\n        },\n        '%d': function(date) {\n          return leadingNulls(date.tm_mday, 2);\n        },\n        '%e': function(date) {\n          return leadingSomething(date.tm_mday, 2, ' ');\n        },\n        '%g': function(date) {\n          // %g, %G, and %V give values according to the ISO 8601:2000 standard week-based year.\n          // In this system, weeks begin on a Monday and week 1 of the year is the week that includes\n          // January 4th, which is also the week that includes the first Thursday of the year, and\n          // is also the first week that contains at least four days in the year.\n          // If the first Monday of January is the 2nd, 3rd, or 4th, the preceding days are part of\n          // the last week of the preceding year; thus, for Saturday 2nd January 1999,\n          // %G is replaced by 1998 and %V is replaced by 53. If December 29th, 30th,\n          // or 31st is a Monday, it and any following days are part of week 1 of the following year.\n          // Thus, for Tuesday 30th December 1997, %G is replaced by 1998 and %V is replaced by 01.\n  \n          return getWeekBasedYear(date).toString().substring(2);\n        },\n        '%G': function(date) {\n          return getWeekBasedYear(date);\n        },\n        '%H': function(date) {\n          return leadingNulls(date.tm_hour, 2);\n        },\n        '%I': function(date) {\n          var twelveHour = date.tm_hour;\n          if (twelveHour == 0) twelveHour = 12;\n          else if (twelveHour > 12) twelveHour -= 12;\n          return leadingNulls(twelveHour, 2);\n        },\n        '%j': function(date) {\n          // Day of the year (001-366)\n          return leadingNulls(date.tm_mday+__arraySum(__isLeapYear(date.tm_year+1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date.tm_mon-1), 3);\n        },\n        '%m': function(date) {\n          return leadingNulls(date.tm_mon+1, 2);\n        },\n        '%M': function(date) {\n          return leadingNulls(date.tm_min, 2);\n        },\n        '%n': function() {\n          return '\\n';\n        },\n        '%p': function(date) {\n          if (date.tm_hour >= 0 && date.tm_hour < 12) {\n            return 'AM';\n          }\n          return 'PM';\n        },\n        '%S': function(date) {\n          return leadingNulls(date.tm_sec, 2);\n        },\n        '%t': function() {\n          return '\\t';\n        },\n        '%u': function(date) {\n          return date.tm_wday || 7;\n        },\n        '%U': function(date) {\n          var days = date.tm_yday + 7 - date.tm_wday;\n          return leadingNulls(Math.floor(days / 7), 2);\n        },\n        '%V': function(date) {\n          // Replaced by the week number of the year (Monday as the first day of the week)\n          // as a decimal number [01,53]. If the week containing 1 January has four\n          // or more days in the new year, then it is considered week 1.\n          // Otherwise, it is the last week of the previous year, and the next week is week 1.\n          // Both January 4th and the first Thursday of January are always in week 1. [ tm_year, tm_wday, tm_yday]\n          var val = Math.floor((date.tm_yday + 7 - (date.tm_wday + 6) % 7 ) / 7);\n          // If 1 Jan is just 1-3 days past Monday, the previous week\n          // is also in this year.\n          if ((date.tm_wday + 371 - date.tm_yday - 2) % 7 <= 2) {\n            val++;\n          }\n          if (!val) {\n            val = 52;\n            // If 31 December of prev year a Thursday, or Friday of a\n            // leap year, then the prev year has 53 weeks.\n            var dec31 = (date.tm_wday + 7 - date.tm_yday - 1) % 7;\n            if (dec31 == 4 || (dec31 == 5 && __isLeapYear(date.tm_year%400-1))) {\n              val++;\n            }\n          } else if (val == 53) {\n            // If 1 January is not a Thursday, and not a Wednesday of a\n            // leap year, then this year has only 52 weeks.\n            var jan1 = (date.tm_wday + 371 - date.tm_yday) % 7;\n            if (jan1 != 4 && (jan1 != 3 || !__isLeapYear(date.tm_year)))\n              val = 1;\n          }\n          return leadingNulls(val, 2);\n        },\n        '%w': function(date) {\n          return date.tm_wday;\n        },\n        '%W': function(date) {\n          var days = date.tm_yday + 7 - ((date.tm_wday + 6) % 7);\n          return leadingNulls(Math.floor(days / 7), 2);\n        },\n        '%y': function(date) {\n          // Replaced by the last two digits of the year as a decimal number [00,99]. [ tm_year]\n          return (date.tm_year+1900).toString().substring(2);\n        },\n        '%Y': function(date) {\n          // Replaced by the year as a decimal number (for example, 1997). [ tm_year]\n          return date.tm_year+1900;\n        },\n        '%z': function(date) {\n          // Replaced by the offset from UTC in the ISO 8601:2000 standard format ( +hhmm or -hhmm ).\n          // For example, \"-0430\" means 4 hours 30 minutes behind UTC (west of Greenwich).\n          var off = date.tm_gmtoff;\n          var ahead = off >= 0;\n          off = Math.abs(off) / 60;\n          // convert from minutes into hhmm format (which means 60 minutes = 100 units)\n          off = (off / 60)*100 + (off % 60);\n          return (ahead ? '+' : '-') + String(\"0000\" + off).slice(-4);\n        },\n        '%Z': function(date) {\n          return date.tm_zone;\n        },\n        '%%': function() {\n          return '%';\n        }\n      };\n  \n      // Replace %% with a pair of NULLs (which cannot occur in a C string), then\n      // re-inject them after processing.\n      pattern = pattern.replace(/%%/g, '\\0\\0')\n      for (var rule in EXPANSION_RULES_2) {\n        if (pattern.includes(rule)) {\n          pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_2[rule](date));\n        }\n      }\n      pattern = pattern.replace(/\\0\\0/g, '%')\n  \n      var bytes = intArrayFromString(pattern, false);\n      if (bytes.length > maxsize) {\n        return 0;\n      }\n  \n      writeArrayToMemory(bytes, s);\n      return bytes.length-1;\n    }\n  function _strftime_l(s, maxsize, format, tm) {\n      return _strftime(s, maxsize, format, tm); // no locale support yet\n    }\n\n\n  function uleb128Encode(n, target) {\n      if (n < 128) {\n        target.push(n);\n      } else {\n        target.push((n % 128) | 128, n >> 7);\n      }\n    }\n  \n  function sigToWasmTypes(sig) {\n      var typeNames = {\n        'i': 'i32',\n        'j': 'i64',\n        'f': 'f32',\n        'd': 'f64',\n        'p': 'i32',\n      };\n      var type = {\n        parameters: [],\n        results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]\n      };\n      for (var i = 1; i < sig.length; ++i) {\n        type.parameters.push(typeNames[sig[i]]);\n      }\n      return type;\n    }\n  \n  function generateFuncType(sig, target){\n      var sigRet = sig.slice(0, 1);\n      var sigParam = sig.slice(1);\n      var typeCodes = {\n        'i': 0x7f, // i32\n        'p': 0x7f, // i32\n        'j': 0x7e, // i64\n        'f': 0x7d, // f32\n        'd': 0x7c, // f64\n      };\n    \n      // Parameters, length + signatures\n      target.push(0x60 /* form: func */);\n      uleb128Encode(sigParam.length, target);\n      for (var i = 0; i < sigParam.length; ++i) {\n    target.push(typeCodes[sigParam[i]]);\n      }\n    \n      // Return values, length + signatures\n      // With no multi-return in MVP, either 0 (void) or 1 (anything else)\n      if (sigRet == 'v') {\n        target.push(0x00);\n      } else {\n        target.push(0x01, typeCodes[sigRet]);\n      }\n    }\n  function convertJsFunctionToWasm(func, sig) {\n  \n      // If the type reflection proposal is available, use the new\n      // \"WebAssembly.Function\" constructor.\n      // Otherwise, construct a minimal wasm module importing the JS function and\n      // re-exporting it.\n      if (typeof WebAssembly.Function == \"function\") {\n        return new WebAssembly.Function(sigToWasmTypes(sig), func);\n      }\n  \n      // The module is static, with the exception of the type section, which is\n      // generated based on the signature passed in.\n      var typeSectionBody = [\n        0x01, // count: 1\n      ];\n      generateFuncType(sig, typeSectionBody);\n  \n      // Rest of the module is static\n      var bytes = [\n        0x00, 0x61, 0x73, 0x6d, // magic (\"\\0asm\")\n        0x01, 0x00, 0x00, 0x00, // version: 1\n        0x01, // Type section code\n      ];\n      // Write the overall length of the type section followed by the body\n      uleb128Encode(typeSectionBody.length, bytes);\n      bytes.push.apply(bytes, typeSectionBody);\n  \n      // The rest of the module is static\n      bytes.push(\n        0x02, 0x07, // import section\n          // (import \"e\" \"f\" (func 0 (type 0)))\n          0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,\n        0x07, 0x05, // export section\n          // (export \"f\" (func 0 (type 0)))\n          0x01, 0x01, 0x66, 0x00, 0x00,\n      );\n  \n      // We can compile this wasm module synchronously because it is very small.\n      // This accepts an import (at \"e.f\"), that it reroutes to an export (at \"f\")\n      var module = new WebAssembly.Module(new Uint8Array(bytes));\n      var instance = new WebAssembly.Instance(module, { 'e': { 'f': func } });\n      var wrappedFunc = instance.exports['f'];\n      return wrappedFunc;\n    }\n  \n  function updateTableMap(offset, count) {\n      if (functionsInTableMap) {\n        for (var i = offset; i < offset + count; i++) {\n          var item = getWasmTableEntry(i);\n          // Ignore null values.\n          if (item) {\n            functionsInTableMap.set(item, i);\n          }\n        }\n      }\n    }\n  \n  var functionsInTableMap = undefined;\n  \n  var freeTableIndexes = [];\n  function getEmptyTableSlot() {\n      // Reuse a free index if there is one, otherwise grow.\n      if (freeTableIndexes.length) {\n        return freeTableIndexes.pop();\n      }\n      // Grow the table\n      try {\n        wasmTable.grow(1);\n      } catch (err) {\n        if (!(err instanceof RangeError)) {\n          throw err;\n        }\n        throw 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.';\n      }\n      return wasmTable.length - 1;\n    }\n  \n  function setWasmTableEntry(idx, func) {\n      wasmTable.set(idx, func);\n      // With ABORT_ON_WASM_EXCEPTIONS wasmTable.get is overriden to return wrapped\n      // functions so we need to call it here to retrieve the potential wrapper correctly\n      // instead of just storing 'func' directly into wasmTableMirror\n      wasmTableMirror[idx] = wasmTable.get(idx);\n    }\n  /** @param {string=} sig */\n  function addFunction(func, sig) {\n  \n      // Check if the function is already in the table, to ensure each function\n      // gets a unique index. First, create the map if this is the first use.\n      if (!functionsInTableMap) {\n        functionsInTableMap = new WeakMap();\n        updateTableMap(0, wasmTable.length);\n      }\n      if (functionsInTableMap.has(func)) {\n        return functionsInTableMap.get(func);\n      }\n  \n      // It's not in the table, add it now.\n  \n      var ret = getEmptyTableSlot();\n  \n      // Set the new value.\n      try {\n        // Attempting to call this with JS function will cause of table.set() to fail\n        setWasmTableEntry(ret, func);\n      } catch (err) {\n        if (!(err instanceof TypeError)) {\n          throw err;\n        }\n        var wrapped = convertJsFunctionToWasm(func, sig);\n        setWasmTableEntry(ret, wrapped);\n      }\n  \n      functionsInTableMap.set(func, ret);\n  \n      return ret;\n    }\n\n  function removeFunction(index) {\n      functionsInTableMap.delete(getWasmTableEntry(index));\n      freeTableIndexes.push(index);\n    }\n\n  function getCFunc(ident) {\n      var func = Module['_' + ident]; // closure exported function\n      return func;\n    }\n  \n    /**\n     * @param {string|null=} returnType\n     * @param {Array=} argTypes\n     * @param {Arguments|Array=} args\n     * @param {Object=} opts\n     */\n  function ccall(ident, returnType, argTypes, args, opts) {\n      // For fast lookup of conversion functions\n      var toC = {\n        'string': (str) => {\n          var ret = 0;\n          if (str !== null && str !== undefined && str !== 0) { // null string\n            // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\n            var len = (str.length << 2) + 1;\n            ret = stackAlloc(len);\n            stringToUTF8(str, ret, len);\n          }\n          return ret;\n        },\n        'array': (arr) => {\n          var ret = stackAlloc(arr.length);\n          writeArrayToMemory(arr, ret);\n          return ret;\n        }\n      };\n  \n      function convertReturnValue(ret) {\n        if (returnType === 'string') {\n          \n          return UTF8ToString(ret);\n        }\n        if (returnType === 'boolean') return Boolean(ret);\n        return ret;\n      }\n  \n      var func = getCFunc(ident);\n      var cArgs = [];\n      var stack = 0;\n      if (args) {\n        for (var i = 0; i < args.length; i++) {\n          var converter = toC[argTypes[i]];\n          if (converter) {\n            if (stack === 0) stack = stackSave();\n            cArgs[i] = converter(args[i]);\n          } else {\n            cArgs[i] = args[i];\n          }\n        }\n      }\n      var ret = func.apply(null, cArgs);\n      function onDone(ret) {\n        if (stack !== 0) stackRestore(stack);\n        return convertReturnValue(ret);\n      }\n  \n      ret = onDone(ret);\n      return ret;\n    }\n\n  \n    /**\n     * @param {string=} returnType\n     * @param {Array=} argTypes\n     * @param {Object=} opts\n     */\n  function cwrap(ident, returnType, argTypes, opts) {\n      argTypes = argTypes || [];\n      // When the function takes numbers and returns a number, we can just return\n      // the original function\n      var numericArgs = argTypes.every((type) => type === 'number' || type === 'boolean');\n      var numericRet = returnType !== 'string';\n      if (numericRet && numericArgs && !opts) {\n        return getCFunc(ident);\n      }\n      return function() {\n        return ccall(ident, returnType, argTypes, arguments, opts);\n      }\n    }\n\n\n\nInternalError = Module['InternalError'] = extendError(Error, 'InternalError');;\nembind_init_charCodes();\nBindingError = Module['BindingError'] = extendError(Error, 'BindingError');;\ninit_ClassHandle();\ninit_embind();;\ninit_RegisteredPointer();\nUnboundTypeError = Module['UnboundTypeError'] = extendError(Error, 'UnboundTypeError');;\ninit_emval();;\n\n  var FSNode = /** @constructor */ function(parent, name, mode, rdev) {\n    if (!parent) {\n      parent = this;  // root node sets parent to itself\n    }\n    this.parent = parent;\n    this.mount = parent.mount;\n    this.mounted = null;\n    this.id = FS.nextInode++;\n    this.name = name;\n    this.mode = mode;\n    this.node_ops = {};\n    this.stream_ops = {};\n    this.rdev = rdev;\n  };\n  var readMode = 292/*292*/ | 73/*73*/;\n  var writeMode = 146/*146*/;\n  Object.defineProperties(FSNode.prototype, {\n   read: {\n    get: /** @this{FSNode} */function() {\n     return (this.mode & readMode) === readMode;\n    },\n    set: /** @this{FSNode} */function(val) {\n     val ? this.mode |= readMode : this.mode &= ~readMode;\n    }\n   },\n   write: {\n    get: /** @this{FSNode} */function() {\n     return (this.mode & writeMode) === writeMode;\n    },\n    set: /** @this{FSNode} */function(val) {\n     val ? this.mode |= writeMode : this.mode &= ~writeMode;\n    }\n   },\n   isFolder: {\n    get: /** @this{FSNode} */function() {\n     return FS.isDir(this.mode);\n    }\n   },\n   isDevice: {\n    get: /** @this{FSNode} */function() {\n     return FS.isChrdev(this.mode);\n    }\n   }\n  });\n  FS.FSNode = FSNode;\n  FS.staticInit();;\nvar ASSERTIONS = false;\n\n// Copied from https://github.com/strophe/strophejs/blob/e06d027/src/polyfills.js#L149\n\n// This code was written by Tyler Akins and has been placed in the\n// public domain.  It would be nice if you left this header intact.\n// Base64 code from Tyler Akins -- http://rumkin.com\n\n/**\n * Decodes a base64 string.\n * @param {string} input The string to decode.\n */\nvar decodeBase64 = typeof atob == 'function' ? atob : function (input) {\n  var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n  var output = '';\n  var chr1, chr2, chr3;\n  var enc1, enc2, enc3, enc4;\n  var i = 0;\n  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\n  input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\n  do {\n    enc1 = keyStr.indexOf(input.charAt(i++));\n    enc2 = keyStr.indexOf(input.charAt(i++));\n    enc3 = keyStr.indexOf(input.charAt(i++));\n    enc4 = keyStr.indexOf(input.charAt(i++));\n\n    chr1 = (enc1 << 2) | (enc2 >> 4);\n    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n    chr3 = ((enc3 & 3) << 6) | enc4;\n\n    output = output + String.fromCharCode(chr1);\n\n    if (enc3 !== 64) {\n      output = output + String.fromCharCode(chr2);\n    }\n    if (enc4 !== 64) {\n      output = output + String.fromCharCode(chr3);\n    }\n  } while (i < input.length);\n  return output;\n};\n\n// Converts a string of base64 into a byte array.\n// Throws error on invalid input.\nfunction intArrayFromBase64(s) {\n  if (typeof ENVIRONMENT_IS_NODE == 'boolean' && ENVIRONMENT_IS_NODE) {\n    var buf = Buffer.from(s, 'base64');\n    return new Uint8Array(buf['buffer'], buf['byteOffset'], buf['byteLength']);\n  }\n\n  try {\n    var decoded = decodeBase64(s);\n    var bytes = new Uint8Array(decoded.length);\n    for (var i = 0 ; i < decoded.length ; ++i) {\n      bytes[i] = decoded.charCodeAt(i);\n    }\n    return bytes;\n  } catch (_) {\n    throw new Error('Converting base64 string to bytes failed.');\n  }\n}\n\n// If filename is a base64 data URI, parses and returns data (Buffer on node,\n// Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.\nfunction tryParseAsDataURI(filename) {\n  if (!isDataURI(filename)) {\n    return;\n  }\n\n  return intArrayFromBase64(filename.slice(dataURIPrefix.length));\n}\n\n\nvar asmLibraryArg = {\n  \"AdaptiveWrapper\": AdaptiveWrapper,\n  \"QuantumStateMultiplyElementwiseFunctionWrapper\": QuantumStateMultiplyElementwiseFunctionWrapper,\n  \"ReversibleBooleanWrapper\": ReversibleBooleanWrapper,\n  \"__assert_fail\": ___assert_fail,\n  \"__cxa_allocate_exception\": ___cxa_allocate_exception,\n  \"__cxa_begin_catch\": ___cxa_begin_catch,\n  \"__cxa_end_catch\": ___cxa_end_catch,\n  \"__cxa_find_matching_catch_2\": ___cxa_find_matching_catch_2,\n  \"__cxa_find_matching_catch_3\": ___cxa_find_matching_catch_3,\n  \"__cxa_free_exception\": ___cxa_free_exception,\n  \"__cxa_rethrow\": ___cxa_rethrow,\n  \"__cxa_throw\": ___cxa_throw,\n  \"__cxa_uncaught_exceptions\": ___cxa_uncaught_exceptions,\n  \"__resumeException\": ___resumeException,\n  \"_embind_finalize_value_object\": __embind_finalize_value_object,\n  \"_embind_register_bigint\": __embind_register_bigint,\n  \"_embind_register_bool\": __embind_register_bool,\n  \"_embind_register_class\": __embind_register_class,\n  \"_embind_register_class_constructor\": __embind_register_class_constructor,\n  \"_embind_register_class_function\": __embind_register_class_function,\n  \"_embind_register_class_property\": __embind_register_class_property,\n  \"_embind_register_emval\": __embind_register_emval,\n  \"_embind_register_float\": __embind_register_float,\n  \"_embind_register_function\": __embind_register_function,\n  \"_embind_register_integer\": __embind_register_integer,\n  \"_embind_register_memory_view\": __embind_register_memory_view,\n  \"_embind_register_std_string\": __embind_register_std_string,\n  \"_embind_register_std_wstring\": __embind_register_std_wstring,\n  \"_embind_register_value_object\": __embind_register_value_object,\n  \"_embind_register_void\": __embind_register_void,\n  \"_emval_as\": __emval_as,\n  \"_emval_call_method\": __emval_call_method,\n  \"_emval_call_void_method\": __emval_call_void_method,\n  \"_emval_decref\": __emval_decref,\n  \"_emval_get_global\": __emval_get_global,\n  \"_emval_get_method_caller\": __emval_get_method_caller,\n  \"_emval_get_property\": __emval_get_property,\n  \"_emval_incref\": __emval_incref,\n  \"_emval_new_array\": __emval_new_array,\n  \"_emval_new_cstring\": __emval_new_cstring,\n  \"_emval_run_destructors\": __emval_run_destructors,\n  \"_emval_take_value\": __emval_take_value,\n  \"abort\": _abort,\n  \"convertCPPCTYPEToJSComplex\": convertCPPCTYPEToJSComplex,\n  \"convertDoubleArrayToJSComplexArray\": convertDoubleArrayToJSComplexArray,\n  \"convertIntArrayToJSArray\": convertIntArrayToJSArray,\n  \"convertMatrix\": convertMatrix,\n  \"emscripten_memcpy_big\": _emscripten_memcpy_big,\n  \"emscripten_resize_heap\": _emscripten_resize_heap,\n  \"environ_get\": _environ_get,\n  \"environ_sizes_get\": _environ_sizes_get,\n  \"exit\": _exit,\n  \"fd_close\": _fd_close,\n  \"fd_read\": _fd_read,\n  \"fd_seek\": _fd_seek,\n  \"fd_write\": _fd_write,\n  \"getentropy\": _getentropy,\n  \"invoke_dii\": invoke_dii,\n  \"invoke_diii\": invoke_diii,\n  \"invoke_diiiij\": invoke_diiiij,\n  \"invoke_fiii\": invoke_fiii,\n  \"invoke_i\": invoke_i,\n  \"invoke_ii\": invoke_ii,\n  \"invoke_iid\": invoke_iid,\n  \"invoke_iii\": invoke_iii,\n  \"invoke_iiid\": invoke_iiid,\n  \"invoke_iiii\": invoke_iiii,\n  \"invoke_iiiii\": invoke_iiiii,\n  \"invoke_iiiiid\": invoke_iiiiid,\n  \"invoke_iiiiii\": invoke_iiiiii,\n  \"invoke_iiiiiii\": invoke_iiiiiii,\n  \"invoke_iiiiiiii\": invoke_iiiiiiii,\n  \"invoke_iiiiiiiiii\": invoke_iiiiiiiiii,\n  \"invoke_iiiiiiiiiii\": invoke_iiiiiiiiiii,\n  \"invoke_iiiiiiiiiiii\": invoke_iiiiiiiiiiii,\n  \"invoke_iiiiiiiiiiiii\": invoke_iiiiiiiiiiiii,\n  \"invoke_iiiiij\": invoke_iiiiij,\n  \"invoke_iij\": invoke_iij,\n  \"invoke_ij\": invoke_ij,\n  \"invoke_jiiii\": invoke_jiiii,\n  \"invoke_v\": invoke_v,\n  \"invoke_vi\": invoke_vi,\n  \"invoke_vii\": invoke_vii,\n  \"invoke_viid\": invoke_viid,\n  \"invoke_viii\": invoke_viii,\n  \"invoke_viiid\": invoke_viiid,\n  \"invoke_viiii\": invoke_viiii,\n  \"invoke_viiiii\": invoke_viiiii,\n  \"invoke_viiiiiii\": invoke_viiiiiii,\n  \"invoke_viiiiiiiiii\": invoke_viiiiiiiiii,\n  \"invoke_viiiiiiiiiiiiiii\": invoke_viiiiiiiiiiiiiii,\n  \"invoke_vij\": invoke_vij,\n  \"strftime_l\": _strftime_l\n};\nvar asm = createWasm();\n/** @type {function(...*):?} */\nvar ___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = function() {\n  return (___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = Module[\"asm\"][\"__wasm_call_ctors\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar getTempRet0 = Module[\"getTempRet0\"] = function() {\n  return (getTempRet0 = Module[\"getTempRet0\"] = Module[\"asm\"][\"getTempRet0\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar _free = Module[\"_free\"] = function() {\n  return (_free = Module[\"_free\"] = Module[\"asm\"][\"free\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar _malloc = Module[\"_malloc\"] = function() {\n  return (_malloc = Module[\"_malloc\"] = Module[\"asm\"][\"malloc\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar ___getTypeName = Module[\"___getTypeName\"] = function() {\n  return (___getTypeName = Module[\"___getTypeName\"] = Module[\"asm\"][\"__getTypeName\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar __embind_initialize_bindings = Module[\"__embind_initialize_bindings\"] = function() {\n  return (__embind_initialize_bindings = Module[\"__embind_initialize_bindings\"] = Module[\"asm\"][\"_embind_initialize_bindings\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar ___errno_location = Module[\"___errno_location\"] = function() {\n  return (___errno_location = Module[\"___errno_location\"] = Module[\"asm\"][\"__errno_location\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar _setThrew = Module[\"_setThrew\"] = function() {\n  return (_setThrew = Module[\"_setThrew\"] = Module[\"asm\"][\"setThrew\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar setTempRet0 = Module[\"setTempRet0\"] = function() {\n  return (setTempRet0 = Module[\"setTempRet0\"] = Module[\"asm\"][\"setTempRet0\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar stackSave = Module[\"stackSave\"] = function() {\n  return (stackSave = Module[\"stackSave\"] = Module[\"asm\"][\"stackSave\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar stackRestore = Module[\"stackRestore\"] = function() {\n  return (stackRestore = Module[\"stackRestore\"] = Module[\"asm\"][\"stackRestore\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar stackAlloc = Module[\"stackAlloc\"] = function() {\n  return (stackAlloc = Module[\"stackAlloc\"] = Module[\"asm\"][\"stackAlloc\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar ___cxa_can_catch = Module[\"___cxa_can_catch\"] = function() {\n  return (___cxa_can_catch = Module[\"___cxa_can_catch\"] = Module[\"asm\"][\"__cxa_can_catch\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar ___cxa_is_pointer_type = Module[\"___cxa_is_pointer_type\"] = function() {\n  return (___cxa_is_pointer_type = Module[\"___cxa_is_pointer_type\"] = Module[\"asm\"][\"__cxa_is_pointer_type\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar dynCall_ij = Module[\"dynCall_ij\"] = function() {\n  return (dynCall_ij = Module[\"dynCall_ij\"] = Module[\"asm\"][\"dynCall_ij\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar dynCall_vij = Module[\"dynCall_vij\"] = function() {\n  return (dynCall_vij = Module[\"dynCall_vij\"] = Module[\"asm\"][\"dynCall_vij\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar dynCall_diiiij = Module[\"dynCall_diiiij\"] = function() {\n  return (dynCall_diiiij = Module[\"dynCall_diiiij\"] = Module[\"asm\"][\"dynCall_diiiij\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar dynCall_iij = Module[\"dynCall_iij\"] = function() {\n  return (dynCall_iij = Module[\"dynCall_iij\"] = Module[\"asm\"][\"dynCall_iij\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar dynCall_jiii = Module[\"dynCall_jiii\"] = function() {\n  return (dynCall_jiii = Module[\"dynCall_jiii\"] = Module[\"asm\"][\"dynCall_jiii\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar dynCall_vidij = Module[\"dynCall_vidij\"] = function() {\n  return (dynCall_vidij = Module[\"dynCall_vidij\"] = Module[\"asm\"][\"dynCall_vidij\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar dynCall_viijii = Module[\"dynCall_viijii\"] = function() {\n  return (dynCall_viijii = Module[\"dynCall_viijii\"] = Module[\"asm\"][\"dynCall_viijii\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar dynCall_viij = Module[\"dynCall_viij\"] = function() {\n  return (dynCall_viij = Module[\"dynCall_viij\"] = Module[\"asm\"][\"dynCall_viij\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar dynCall_viiij = Module[\"dynCall_viiij\"] = function() {\n  return (dynCall_viiij = Module[\"dynCall_viiij\"] = Module[\"asm\"][\"dynCall_viiij\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar dynCall_ji = Module[\"dynCall_ji\"] = function() {\n  return (dynCall_ji = Module[\"dynCall_ji\"] = Module[\"asm\"][\"dynCall_ji\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar dynCall_jiji = Module[\"dynCall_jiji\"] = function() {\n  return (dynCall_jiji = Module[\"dynCall_jiji\"] = Module[\"asm\"][\"dynCall_jiji\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar dynCall_iiiiij = Module[\"dynCall_iiiiij\"] = function() {\n  return (dynCall_iiiiij = Module[\"dynCall_iiiiij\"] = Module[\"asm\"][\"dynCall_iiiiij\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar dynCall_jiiii = Module[\"dynCall_jiiii\"] = function() {\n  return (dynCall_jiiii = Module[\"dynCall_jiiii\"] = Module[\"asm\"][\"dynCall_jiiii\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar dynCall_iiiiijj = Module[\"dynCall_iiiiijj\"] = function() {\n  return (dynCall_iiiiijj = Module[\"dynCall_iiiiijj\"] = Module[\"asm\"][\"dynCall_iiiiijj\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar dynCall_iiiiiijj = Module[\"dynCall_iiiiiijj\"] = function() {\n  return (dynCall_iiiiiijj = Module[\"dynCall_iiiiiijj\"] = Module[\"asm\"][\"dynCall_iiiiiijj\"]).apply(null, arguments);\n};\n\nvar ___start_em_js = Module['___start_em_js'] = 64304;\nvar ___stop_em_js = Module['___stop_em_js'] = 65530;\nfunction invoke_iii(index,a1,a2) {\n  var sp = stackSave();\n  try {\n    return getWasmTableEntry(index)(a1,a2);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_vi(index,a1) {\n  var sp = stackSave();\n  try {\n    getWasmTableEntry(index)(a1);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_diii(index,a1,a2,a3) {\n  var sp = stackSave();\n  try {\n    return getWasmTableEntry(index)(a1,a2,a3);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_ii(index,a1) {\n  var sp = stackSave();\n  try {\n    return getWasmTableEntry(index)(a1);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_iiiii(index,a1,a2,a3,a4) {\n  var sp = stackSave();\n  try {\n    return getWasmTableEntry(index)(a1,a2,a3,a4);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_vii(index,a1,a2) {\n  var sp = stackSave();\n  try {\n    getWasmTableEntry(index)(a1,a2);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_v(index) {\n  var sp = stackSave();\n  try {\n    getWasmTableEntry(index)();\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_viiii(index,a1,a2,a3,a4) {\n  var sp = stackSave();\n  try {\n    getWasmTableEntry(index)(a1,a2,a3,a4);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_viii(index,a1,a2,a3) {\n  var sp = stackSave();\n  try {\n    getWasmTableEntry(index)(a1,a2,a3);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_iiiiii(index,a1,a2,a3,a4,a5) {\n  var sp = stackSave();\n  try {\n    return getWasmTableEntry(index)(a1,a2,a3,a4,a5);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_iiii(index,a1,a2,a3) {\n  var sp = stackSave();\n  try {\n    return getWasmTableEntry(index)(a1,a2,a3);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_iiiiiii(index,a1,a2,a3,a4,a5,a6) {\n  var sp = stackSave();\n  try {\n    return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_iiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9) {\n  var sp = stackSave();\n  try {\n    return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_iid(index,a1,a2) {\n  var sp = stackSave();\n  try {\n    return getWasmTableEntry(index)(a1,a2);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_dii(index,a1,a2) {\n  var sp = stackSave();\n  try {\n    return getWasmTableEntry(index)(a1,a2);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_iiid(index,a1,a2,a3) {\n  var sp = stackSave();\n  try {\n    return getWasmTableEntry(index)(a1,a2,a3);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_viid(index,a1,a2,a3) {\n  var sp = stackSave();\n  try {\n    getWasmTableEntry(index)(a1,a2,a3);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_viiid(index,a1,a2,a3,a4) {\n  var sp = stackSave();\n  try {\n    getWasmTableEntry(index)(a1,a2,a3,a4);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_viiiii(index,a1,a2,a3,a4,a5) {\n  var sp = stackSave();\n  try {\n    getWasmTableEntry(index)(a1,a2,a3,a4,a5);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_iiiiid(index,a1,a2,a3,a4,a5) {\n  var sp = stackSave();\n  try {\n    return getWasmTableEntry(index)(a1,a2,a3,a4,a5);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_iiiiiiii(index,a1,a2,a3,a4,a5,a6,a7) {\n  var sp = stackSave();\n  try {\n    return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_iiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) {\n  var sp = stackSave();\n  try {\n    return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_iiiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12) {\n  var sp = stackSave();\n  try {\n    return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_fiii(index,a1,a2,a3) {\n  var sp = stackSave();\n  try {\n    return getWasmTableEntry(index)(a1,a2,a3);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_i(index) {\n  var sp = stackSave();\n  try {\n    return getWasmTableEntry(index)();\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_viiiiiii(index,a1,a2,a3,a4,a5,a6,a7) {\n  var sp = stackSave();\n  try {\n    getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_iiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) {\n  var sp = stackSave();\n  try {\n    return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_viiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) {\n  var sp = stackSave();\n  try {\n    getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_viiiiiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15) {\n  var sp = stackSave();\n  try {\n    getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_ij(index,a1,a2) {\n  var sp = stackSave();\n  try {\n    return dynCall_ij(index,a1,a2);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_vij(index,a1,a2,a3) {\n  var sp = stackSave();\n  try {\n    dynCall_vij(index,a1,a2,a3);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_diiiij(index,a1,a2,a3,a4,a5,a6) {\n  var sp = stackSave();\n  try {\n    return dynCall_diiiij(index,a1,a2,a3,a4,a5,a6);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_iij(index,a1,a2,a3) {\n  var sp = stackSave();\n  try {\n    return dynCall_iij(index,a1,a2,a3);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_iiiiij(index,a1,a2,a3,a4,a5,a6) {\n  var sp = stackSave();\n  try {\n    return dynCall_iiiiij(index,a1,a2,a3,a4,a5,a6);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\nfunction invoke_jiiii(index,a1,a2,a3,a4) {\n  var sp = stackSave();\n  try {\n    return dynCall_jiiii(index,a1,a2,a3,a4);\n  } catch(e) {\n    stackRestore(sp);\n    if (e !== e+0) throw e;\n    _setThrew(1, 0);\n  }\n}\n\n\n\n\n// === Auto-generated postamble setup entry stuff ===\n\nModule[\"dynCall\"] = dynCall;\nModule[\"ccall\"] = ccall;\nModule[\"cwrap\"] = cwrap;\nModule[\"addFunction\"] = addFunction;\nModule[\"removeFunction\"] = removeFunction;\nModule[\"setValue\"] = setValue;\nModule[\"getValue\"] = getValue;\n\n\nvar calledRun;\n\ndependenciesFulfilled = function runCaller() {\n  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n  if (!calledRun) run();\n  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n};\n\n/** @type {function(Array=)} */\nfunction run(args) {\n  args = args || arguments_;\n\n  if (runDependencies > 0) {\n    return;\n  }\n\n  preRun();\n\n  // a preRun added a dependency, run will be called later\n  if (runDependencies > 0) {\n    return;\n  }\n\n  function doRun() {\n    // run may have just been called through dependencies being fulfilled just in this very frame,\n    // or while the async setStatus time below was happening\n    if (calledRun) return;\n    calledRun = true;\n    Module['calledRun'] = true;\n\n    if (ABORT) return;\n\n    initRuntime();\n\n    readyPromiseResolve(Module);\n    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\n\n    postRun();\n  }\n\n  if (Module['setStatus']) {\n    Module['setStatus']('Running...');\n    setTimeout(function() {\n      setTimeout(function() {\n        Module['setStatus']('');\n      }, 1);\n      doRun();\n    }, 1);\n  } else\n  {\n    doRun();\n  }\n}\n\nif (Module['preInit']) {\n  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\n  while (Module['preInit'].length > 0) {\n    Module['preInit'].pop()();\n  }\n}\n\nrun();\n\n\n\n\n\n\n\n  return ModuleQulacsWasm.ready\n}\n);\n})();\nif (true)\n  module.exports = ModuleQulacsWasm;\nelse // removed by dead control flow\n{}\n\n\n//# sourceURL=webpack://qasm-quantum-simulator/./node_modules/qulacs-wasm/lib/bundle/wasm/module.js?\n}");

/***/ }),

/***/ "./node_modules/util/node_modules/inherits/inherits_browser.js":
/*!*********************************************************************!*\
  !*** ./node_modules/util/node_modules/inherits/inherits_browser.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("{if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n//# sourceURL=webpack://qasm-quantum-simulator/./node_modules/util/node_modules/inherits/inherits_browser.js?\n}");

/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/***/ ((module) => {

eval("{module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n//# sourceURL=webpack://qasm-quantum-simulator/./node_modules/util/support/isBufferBrowser.js?\n}");

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("{// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(__webpack_require__.g.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"./node_modules/util/support/isBufferBrowser.js\");\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(/*! inherits */ \"./node_modules/util/node_modules/inherits/inherits_browser.js\");\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n\n//# sourceURL=webpack://qasm-quantum-simulator/./node_modules/util/util.js?\n}");

/***/ }),

/***/ "?13b2":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

eval("{/* (ignored) */\n\n//# sourceURL=webpack://qasm-quantum-simulator/crypto_(ignored)?\n}");

/***/ }),

/***/ "?253a":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

eval("{/* (ignored) */\n\n//# sourceURL=webpack://qasm-quantum-simulator/fs_(ignored)?\n}");

/***/ }),

/***/ "?2e5e":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

eval("{/* (ignored) */\n\n//# sourceURL=webpack://qasm-quantum-simulator/fs_(ignored)?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./lib/app.js");
/******/ 	
/******/ })()
;